
9.1  数据驱动编程
    进行数据驱动编程时，需要把代码和代码作用的数据结构划分清楚，这样，在改变
程序的逻辑时，就只要编辑数据结构而不是代码。
    数据驱动编程有时会跟面向对象混淆起来，后者是另一种以数据组织为中心的风格。
它们之间至少有两点不同。第一，在数据驱动编程中，数据不仅仅是某个对象的状态，
实际上还定义了程序的控制流；第二，00首先考虑的是封装，而数据驱动编程看重的
是编写尽可能少的固定代码。Unix中数据驱动编程的传统比00更深厚。
www.pdf365.com
9.1  数据驱动编程
217
    数据驱动编程有时也会和状态机编写相混淆。把状态机逻辑表达成表格或数据结构
事实上是可能的，但手工编码的状态机通常是固定的代码块，远比表格更难修改。
    进行任何类型的代码生成或数据驱动编程的重要原则是：始终把问题层次往上推。
不要手工修改生成的代码或中间形式——相反，应找到一种方式来改进或代替转换工具。
否则，很可能发现手工修补应该由机器王E确生成的代码会耗费无穷的时间。
    数据驱动编程，最复杂的情形是为p-code或我们在第8章讨论过的那些简单微型语
言编写解释器。对于其它情形，它类似于代码生成器和状态机编程。区别其实并非那样
重要，重要的是把程序逻辑从硬编定的控制结构转移到数据中。
9.1，1实例分析：ascii
    我维护着一个口L{ ascii OtJ程序，它非常简单，把命令行参数按ASCII（ American Standard
Code for Information Interchange，美国信息交换标准编码）字符的名称解释，并报告其它
所有等价形式的名称。这个工具的代码和文档可以在项目主页<http：／/www - catb．
org/-esr/ascii>处获得。以下是直观的屏幕截图：

    表明这是个好程序的标志之～是该程序具有意想不到的用法——作为快速的CLI辅
助工具，在字节的十进制、十六进制、八进制和二进制表示法中进行转换。
    这个裎序的主要逻辑原本可以编成有128个分支的选择语句。然而，这肯定会使代
码庞大、难以维护。变化相对较快的部分（如字符的别名清单）和变化较慢或根本不变
www.pdf365.com
218
第9章生成：提升规格说明的层次
化的部分（如正式名称）原本也可纠缠在一起，都放在同一个示意字符串中。当然，这
样出现编辑错误时，更有可能改变实际上本该稳定的数据。
    相反，我们采用了数据驱动编程。所有字符名的字符串都放在一个表结构中，这个
表结构比代码中任何函数都大（事实上，按行数算的话，它比程序任意三个函数都大）。
代码仅仅查表并完成数制转换等底层任务。初始化代码实际上存放在文件nametable.h中，
我们会在本章稍后部分说明这个文件的生成方法。
    这种结构使得增加新字符名、改变现有字符名或删除旧字符名都非常容易，只要简
单编辑数据表就行，不需要改动代码。

（这个程序编制方法具有很好的Unix风格，但是输出格式有问题。很难看出输出能
有效作为其它程序的输入，所以这个程序不能很好地和其它程序合作。）
9.1.2实例分析：统计学的垃圾邮件统计
    数据驱动编程的有趣例子是探测垃圾邮件（不请自来的大批电子邮件）的统计学习
算法。整个一大类邮件过滤程序（网络搜索很容易找到的程序包括popfile、spambayes
和bogofilter等）都使用单词相关性的数据库来代替复杂的模式匹配逻辑条件。
    2002年，随着Paul Graham友表里程碑式的论文《反垃圾邮件计划》（A Planfor Spam）
[Graham]，这样的程序迅速在互联网上普及。虽然这种爆炸式发展由模式匹配竞赛中不
断上升的成本而引发，但最早而且最快采用这种统计学过滤思路的却是Unix阵营。部分
原因当然是因为几乎所有的互联网服务提供商（他们承受垃圾邮件的负担最重，因此采
用有效新技术的动机最强烈）都在Unix阵营——但这种方法与Unix软件设计的一些传
统主题相吻合无疑也起了很大作用。
    传统的垃圾邮件过滤器要求系统管理员或其它责任方维护在垃圾邮件中发现的文本
模式信息——除了垃圾邮件，站点名、色情网站或网络诈骗常用的诱人词组以及类似内
容，别的什么也不发。在论文里，Graham精确指出，计算机程序员喜欢模式匹配过滤器，
因为这种方法给了他们很多展现聪明的机会，所以有时很难打破藩篱。
www.pdf365.com
9.1  数据驱动编程
219
    另一方面，垃圾邮件统计过滤器通过收集用户对垃圾邮件的判断反馈来工作。反馈
经过处理后，将用户区分垃圾／非垃圾邮件的词组和词语与统计相关系数或权重相关联，
存放到数据库中。最流行的算法使用了贝叶斯定律（Bayes's Theorem）的小变种，但也应用
其它技术（包括不同类型的多项式散列法）。
    在所有这些程序中，相关性检查是个相对微不足道的数学公式。代入公式的权重和
被检查的消息一起，组成过滤算法的隐式控制结构。
    传统模式匹配垃圾邮件过滤器存在的问题是它们非常脆弱。垃圾邮件发送者不断同
过滤规则的数据库进行博弈，迫使过滤器的维护者不断重编过滤器以便在这场竞赛中保
持领先。而统计学垃圾邮件过滤器却根据用户的反馈生成自己的过滤规则。
    事实上，使用统计学过滤器的经验似乎表明，所采用的具体学习算法远没有学习算
法用来计算权重的垃圾／j#垃圾邮件数据集的质量重要。因此，统计过滤器的结果与其说
由算法驱动，不如说由数据形态驱动。
    《反垃圾由仁件计划>（A Planfor Spam）仿佛是一颗炸弹，原因是作者令人信服地证
明，一个简单甚至粗糙的统计方法把非垃圾邮件归为垃圾邮件的出错率，比复杂的模式
匹配方法或入眼所能处理的出错率都要低。对Unix程序员来说，看透聪明模式匹配的诱
惑，远比其它编程文化来得容易，因为那些编程文化没有对“Keep It Simple，Stupid!，，的
强烈依恋。
9.1.3实例分析：fetchmailcon厂中的元类改动
    随fetchmail（1）-起发布的fetchmailconf（1）点文件配置器包含-个启发性例子，
演示在非常高层的、面向对象语言中实现高级数据驱动编程。
    1997年10月，在fetchmail-friends邮件列表上出现的一系列问题清楚表明，最终用
户在生成fetchmail的配置文件时越来越困难。文件使用简单而经典的Unix式自由格式
语法，但如果用户在多个站点上有POP3和IMAP帐户，则会变得非常可怕复杂。例9.1
是fetchmail作者经过稍微简化的配置文件。
UNIX编腥艺．术
  www.pdf365.com
220
第9章生成：提升规格说明的层次
例9.1  fetchmailrc语法示例
set postmaster  ”esr“
set daemon 300
poll imapccil.org with pro七o IMAP and opLions no dns
     aka  snark .七hyrsus _ com  locke _ ccil . org  ccil . org
          user esr七here is esr here
              options fetchall dropstatus warnings 3600
poll  imap . netaxs _ com  with  proto  IMAP
         user "esr" there is esr here options dropstatus warnings 3600
    fetchmailconf的设计旨在把控制文件的语法完全隐藏在时髦、符合人体工程学、到
处是选择按钮、滑动条和待填表单的GUI之后。但是beta设计存在一个问题：它可以很
容易地从用户的GUI操作生成配置文件，但却不能读取和编辑已有的配置文件。
    针对fetchmail配置文件语法的分析程序相当复杂，实际是用yacc和lex编写的，而
vacc和lex是两个经典Unix工具，用来生成语言的C分析程序。为了让fetchmailconf熊
够编辑已有配置文件，最初，似乎用fetchmailconf的实现语言-Python来重复编写复
杂的语法分析程序是必须的。
    这个策略似乎注定要失败。即使不考虑隐含的重复工作，要确保两个用不同语言编
写的语法分析程序接受同一种语法也出了名地难。随着配置语言的发展，要保持两者同
步真有可能成为维护噩梦，完全违反了我们在第4章讨论过的SPOT原则。
    这个问题一度困扰了我。打破这个羁绊的顿悟是fetchmailconf可以使用fetchmait本
身的语法分析程序作为过滤器！我给fetchmail增加了一个- - conf igdump选项，可以分
析．fet chmailrc，并把结果以Python初始化器格式转储到标准输出。对以上文件，结
果看上去大致就像例9.2（为节省空间，省略了一些与示例无关的数据）。
www.pdf365.com
9.1数据驱动编程
221
例9.2fetchmail配置的Python结构转储

222
第9章生成：提升规格说明的层次


    主要障碍跃过了。接下来Python解释器就可以评估fetchmail -configdump的输
出，并将fetchmailconf可用的配置信息作为变量“fetchmail”的值读取。
    但这并不是比赛中的最后一个障碍。真正需要的并不仅仅是让fetchmailconf拥有现
成的配置信息，而是要把它转变为活动对象的链接树。这棵树上有三类对象：
Configuration（代表整个配置的顶层对象）、Site（代表待查询的的服务器之一）
和User（代表站点附有的用户数据）。示例文件描述了三个站点对象，每个站点对象都
附有一伞用户对象。
    这三个对象类已经存在于fetchmailconf中。每个对象类都有一个方法使它可以弹出
GUI编辑面板来修改其实例信息。剩下的最后一个问题是如何把Python初始化器的静态
数据转换成活动对象。
    我曾考虑编写胶合层，它能够明确知道这三类的结构，并以此迎合初始化器创建匹
配的对象，但是我放弃了这个想法，因为随着时间的推移，配置语言会增加新的特性，
则也可能增加新的类成员。如果对象的创建代码用显式的方法编写而成，那么它会再次
www.pdf365.com
9.1数据驱动编程
223
变得非常脆弱，当类定义或- - configdump报表生成程序转储的初始化器结构变化时，
它往往不能同步。这又是一个带来无穷bug的方法。
更好的方法应该是数据驱动编程——可以分析初始化器形态和成员、自查询类定义
自身成员，然后阻抗匹配这两个集合的代码。
Lisp和Java程序员称之为内省；其它一些面向对象的语言称之为“元类修改（metaclass
hacking）”，通常视其为非常可怕的深奥邪招。绝大多数面向对象语言根本不支持：在那
些提供支持的语言（包括Perl和Java）中，它往往是一项复杂而脆弱的工作。但是Python
对内省和元类修改的功能却异乎寻常地容易用。
解决方法的代码可参考例9.3，从1.43版本第1895行附近开始。
例9.3  copy_instance的元类代码

检查
的核
def
这份代码的绝大部分是对类成员和- - configdump报表生成不同步可能性的错误
。它
心是
确保如果代碣失败，失败会尽早得到发现——此即补救原则的实现。这个函数
最后两行，根据字典中的相应成员设置类中的属性，它们等价于：
copy_instance （ toclass ，   fromdict ） :
    for x in  fromdict.keys （） :
               setat七r （toclass，  x，  fromdict [x]
www.pdf365.com
224
第9章生成：提升规格说明的层次
如果代码这样简单，当然更可能正确。调用该函数的代码参见例9.4。
例 9.4   copy_instance的调用环境

    以这段代码中提取的关键点在于，它遍历了初始化器的三个层次（配置／服务器／用
户），实例化了各层的正确对象并放进更高一层对象所包含的链表中。因为
copy_instance是数据驱动的而且完全通用，所以它可用于所有三个层次中三个不同
的对象类型。
    这是一个新派的例子；Python直到1990年才发明出来，但是它反映了可追溯到1969
年的Unix传统主题。  如果对上一代人身体力行的Unix编程进行的思考没有教会我建
设性的懒惰——坚持复用、遵循SPOT原则拒绝编写重复的胶合代码——我可能会匆忙
编写一个Python分析程序。fetchmail本身就可编写进fetchmailconf配置分析程序的第一
个领悟就可能永远不会产生。
    第二个领悟（copy_instance可以是通用的）来自于Unix孜孜不倦地寻找避免手
工编码的方法这一传统。但更特殊的是，Unix程序员非常习惯于编写解析器规格说明来
生成分析程序，用于处理类似语言的标记；这样一来，它就是个捷径，可以认为所剩工
作由配置结构某种通用的树遍历就可以完成。这就需要数据驱动编程有两个独立阶段，
～个构建在另外一个之上，以干净地觯决设计问题。
    像这样的领悟可能特别强大有效。我们刚才分析的代码大概在90分钟内完成，首次
运行的时候就成功了，而且从那以后一直都很稳定（唯一的一次崩溃是发生真正版本不
兼容时抛出了异常）。它少于40行，非常漂亮得简单。没有哪种通过完整构建另一个分
www.pdf365.com
9.2专用代码的生成
225
析程序的天真方法能够产生这样的可维护性、可靠性或紧凑性。重用、简化、归纳、正
交：这就是在运转的Unix之禅。
    我们将在第10章分析fetchmail的运行控制语法，这是一例标准的运行控制文件的
类shell标准元格式。在第14章，我们会以fetchmailconf为例，说明Python快速构建GUI
的优势。
9.2专用代码的生成
    Unix有一些强大的专用代码生成器，用于建造词法分析器（记号化器）和语法分析
器等目的，我们将在第15章予以分析。但是还有～些简单而且轻巧得多的代码生成方式，
我们无需了解任何编译理论或编写（容易出错的）程序逻辑就可以使生活更轻松。
    以下几个简单的分析实例可以证明这一点：
9.2.1  实例分析：生成ascii显示的代码
    如果不带参数调用，ascif生成如例9.5所示的用法屏幕（usage screen）。
    这个屏幕仔细地设计成23行79列，这样可以放进24x80的终端窗口。
    这张表也可在运行时现场生成。做出十进制和十六进制两栏内容十分简单。但是，
丛表格如何分行，到何时打印NUL之类的助记符而不是原样照印，存在很多奇奇怪怪的
边角情况，使代码明显变得别扭不舒服。仳外，表格的列间隔必须是不均匀的才能适应
79列。但任何Unix程序员在明白这些前，都会条件反射般地把它表示成一个数据块。
    生成这个用法屏幕最原始的方法就是在asc11．c源码中把每一行都放到一个C初
始化器中，然后代码通过初始化器写出所有行。这种方法的问题是C初始化器格式中中
的额外数据（换行、串引号和逗号）可能会使一行超过79个字符，折行使得让代码的显
示和输出的显示要对应起来困难重重。这反过来也会使显示难以编辑，我在对其修改以
适合24×80的屏幕时可真是伤透了脑筋。
    更加复杂的方法是使用ANSIC预处理器的字符串粘合行为，但也会产生类似问题。
本质上，任何内嵌用法屏幕的方法显然都会陷入行首或行尾没有足够空间容纳标点的困
UNIX编程艺：术
  www.pdf365.com
226
第9章生成：提升规格说明的层次
例9.5 ascu用法屏幕

境2。而在运行时把表格从文件拷贝到屏幕上似乎是个糟糕脆弱的权宜之计；毕竟，文件
有可能丢失。
    以下是解决方案。发布的源码包含一个文件，这个文件包括完全同上面一致并命名
为splashscreen的使用屏幕。C源码包含以下函数：

2脚本语言对这个问题的解决通常比c更优雅。请研究一下shell的here document和Python的三引
号（字符串）构造来探个究竟。
www.pdf365.com
9.2专用代码的生成
227
而splashsrceen．h由makefile生成：


    因此，程序编译时，splashscreen文件自动被揉制成一系列输出函数调用，然后
由C预处理器包含到正确的函数中。
    通过从数据产生代码，我们能够使可编辑的用法屏幕和它的显示一致。这提高了透
明性。而且，我们根本无需改动C代码就能随意修改用法屏幕，而该做的事情会在下一
次编译时自动完成。下～版建构就可以自动完成正确的操作。
    出于同样的原因，掌控同名字符串的初始化器也由makefile中的sed脚本产生，
makefile来自ascl源码中nametable文件。绝大多数nametable都只是简单地拷贝
进C初始化器。但生成过程使这个工具很容易适应其他8位字符集，如IS0-8859系列
（Latin-I及其友集）。
    这几乎是一个微不足道的例子，但是它仍然证明了即使非常简单专用的代码生成所
具有的优点。类似技术可以应用到吏大的程序中，相应地获得更大的好处。
9.2.2实例分析：为列表生成HTML代码
    假设要在网页上生成一页表格状数据，我们希望开头几行像例9.6 -样。

例9.6明星列表要求的输出格式

    笨重的处理方法是手工编写HTML表格代码以获得预期的显示效果。之盾，每需要
增加一个名字时，我们就得为新条目手写另外一套<tr>和<td>标签。这项工作很快就
会变得异常乏味。更糟的是，要改变列表的格式需要手工修改每一条记录。
UNI×4iria~Yae
    www.pdf365.com
228
第9章生成：提升规格说明的层次
    一种看上去聪明的处理方法是把这些数据做成三栏关系放在数据库中，然后使用一
些流行的CGI3技术或PHP等具有数据库能力的模版引擎来现场生成页面。但假设我们
知道列表不会经常改变，既不想仅仅为能显示这个列表而运行数据库服务器，也不想给
服务器带来不必要的CGI流量负担，情况又会怎样？3
    还有更好的解决方案，我们可以把数据放入类似例9.7的列表式平面文件格式中。
例9.7  明星表的主表


我们可以使用没有冒号字段分隔符酌格式，而使用两个或更多空格作为分隔的特征
符，但是显式分隔符可以防止我们编辑某个字段值时键入两个空格而没有发觉。
    然后我们用shell、Perl、Python或Tcl编写脚本，可以把这个文件揉制成HTML表
格，每次增加新记录时就运行一次。旧派Unix的方法是以如下几乎不可读的sed（1）调
用为核心。


    或者是下面这个也许稍微易读一点的awk （l）程序：
awk   -F:    l {print f （ "<tr><td>%s</td><td>%s</td><td>%s</td></tr>\n" ，    \
    （这两个例子很有趣，但如果对任何一个有所迷惑，请阅读sed （1）或awk （1）的
文档。我们在第8章说过后者现在已经不太用了。前者仍然是重要的Unix工具，我们没
3这里的CGI不是指计算机图形成像，而是指实时显示网页内容所用的公共网关接口（Common
Gateway Interface）。
www.pdf365.com
9.2专用代码的生成
229
有仔细分析的原因是：  （l） Unix程序员已经很了解这个工具；  （2） -旦非Unix程序
员掌握了管道和重定向等基本概念，就很容易从手册中掌握相关知识）。
    新学派的解决方案可能集中在以下这个Python代码或等价的Perl代码：
for  row  in  map （lambda  x:x. rstrip （ } . split （ l : I ） ， sys . stdin. readlines （》
    print   "<七r>    d）"   +   " </七d><td>iT _ j oin （ row）   +   "</td></七r> "
    这些脚本程序每个只花五分钟左右就可以编写和调试完成，当然比手工修改初始的
HTML或创建及验证数据库所需要的时间短。维护这种表格加代码的方式，比起设计差
劲的手工修改HTML方式或过度设计的数据库方式来说，要简单得多。
    这种解决问题方法的深层优点在于主文件很容易用普通的文本编辑器搜索和修改。
另外一个优点是我们可以通过改动生成脚本，不断尝试表格到HTML的不同转换方式，
或者在此之前放置grep （1）过滤器就可以很方便地生成报告子集。
    我确实使用这种技法来维护列出fetchmail测试站点的网页。以上所举例子的数据是
虚构的，原因无外乎友布真正的数据可能会泄漏帐号的用户名和口令。
    与前面一个例子相比，这个例子就不是那么微不足道了。我们在这儿的设计实际
上是把内容和格式分开，把生成脚本用作样式表（这也是另外一种机制和策略的分
离）。
    所有这些例子的借鉴之处都是一样的：尽可能少干活；让数据塑造代码；依靠工具；
把机制从策略中分离。专家级Unix程序员要学会迅速自动地看出这些可能性。建设性的
懒惰是大师级程序员的基本美德之一。


配置：迈出正否的§一步
Configuration: Starting on the
Right Foot
Let us watch well our beginnings， and results will manage themselves.
    积跬步，致千里。
    -Alexander Clark
    Unix的程序和周边环境交流的方式多种多样。可以很方便地把这些方式分成（a）
启动环境查询和（b）交互通道。本章我们主要讨论启动环境查询。下一章将讨论交互通
道。
10.1  什么应是可配置的
的？
在具体讨论不同种类的程序配置之前，我们先问一个高层面问题：什么应是可配置
    无畏的Unix回答是“一切’’。我们在第1章讨论的分离原则鼓励Unix程序员：只
要可能，就建立机制而把策略决定权交给用户。这种方式产生的程序往往功能强大，专
家用户用起来会非常顺手；但它所产生的接口往往选项过多，并且配置文件像杂草一样
疯长，从而彻底打击了新手和一般用户。
www.pdf365.com
232
第10章配置：迈出正确的第一步
    Unix程序员并不打算修改这种为同行和最老练用户设计的倾向（我们将在第20章
讨论这样的改变是否真的值得）。所以，也许把问题反过来，问问“什么不应该可配置？”
更加有用。Unix实践的确在这方面提供了一些指导。
    首先，对于能够可靠地进行自动检测的东西，就不要提供配置开关。这是个常犯的
错误。相反，尽量用自动检测来减少配置开关的数量，或者在运行时不断尝试其它方法
直到成功。如果觉得这个方法不够优雅或太昂贵，问问自己是不是掉进了过早优化的陷
阱。
    我所经历的最好的自动检测例子之一，发生在Dennis Ritchie和我把Unix移
植到Interdata 8/32时。这是一台高位优先的机器，我们盛须在PDP-II上为这台
机器生成数据，写入磁带，然后在Interdata上载入这个磁带。普遍的一个错误是
忘记转换字节顺序；一旦出现校验和错误我们就必须卸载，然后重新装配在PDP
- 11机器上、重新生成数据、卸载然后再重装。后来，有一天，Dennis修改了
Interdata读取磁带的程序，这样，一旦它收到一个校验和错误，就倒带、启用“字
节交换”并重新读取。第二次遇到校验和错误时停止装栽，但是99%的情况下它
都正好能读取磁带并正确完成任务。生产率迅速上升，从那时起我们几乎忽略了
磁带字节顺序的问题。
-Steve Johnson
    ～个很好的经验法则是：提高适应能力，除非这样做会产生超过0.7秒的延迟。0.7
秒是～个魔数，因为，正如Jef Raskin设计Canon Cat计算机时的发现，人们几乎觉察不
到少于0.7秒的启动延时；人们还没有来得及转移注意力，它就消失了。
    其次，用户不应该看到优化开关。让程序经济运行是设计者的任务，不是用户的任
务。与提高界面复杂度成本相比，让用户从优化开关来获取的那点儿性能收益，换来界
面复杂度的提升，往往得不偿失。
    Unix幸运地避开了文件格式的废料（记录长度、块因子等），但是同样性质
的东西在过度配置中又叫嚣着回来了。KISS原则变成了MICAHI原则：make it
complicated and hide ic（搞复杂后藏起来）。
    -Doug Mclfroy
    最后，能用脚本包装器或简单管道实现的任务，就不要用配置开关实现。能简单利
用其它程序来完成的任务，就不要增加本程序的复杂度。  （回想一下我们在第7章有关
Is （1）为什么不内建一个分页程序或是增加一个调用选项的讨论），
www.pdf365.com
10.2配置在哪里
233
无论何时想增加配置选项，请考虑以下这些较普遍的问题：
    ●  能省掉这个功能吗？为什么在加厚手册之外还要加重用户负担？
    ●  能否用某种无伤大雅的方式改变程序的常规行为从而无需这个选项？
    ●  这个选项是否花哨没用？是否应该少考虑用户界面的可配置性而多考虑正确
    性？
    ●  这个选项附加的行为是否应该用一个独立的程序来代替？
    增加不必要的选项会产生诸多不良后果。其中最不易察觉但最严重的后果是对测试
覆盖率的影响。
    除非做得非常仔细，否则增加一个开／关配置选项就会使测试量加倍。既然
  在实践中从来没有人完成双倍测试量，那么实际影响就是减少了特定配置获得
  的测试量。增加十个选项会产生1024倍测试量，所以不要多久就要讨论可靠性
  问题了。
10.2配置在哪里
-Steve Johnson
传统上，一个Unix程序可以在启动环境的五个地方寻找控制信息：
●  ／etc下的运行控制文件（或者系统中其它固有位置）。
●  由系统设置的环境变量。
●  用户主目录中的运行控制文件（或“点文件”）。  （如果不熟悉，请参考第3
    章对这个重要概念的讨论。）
●  由用户设置的环境变量。
●  启动程序的命令行所传递的开关和参数。
www.pdf365.com
第1 0章配置：迈出正确的第一步
    查询通常按以上所列的顺序进行。这样，后面（较局部）的设置会覆盖前面（较全
局）的设置。前面找到的设置可以帮助程序计算出配置数据的后续检索位置。
    当考虑使用何种机制向程序传递配置数据时，要牢记：好的Unix实践要求使用同参
数选项预期寿命虽匹配的机制。因此，对调用时可能发生变化的选项，使用命令行开关。
对改动很少但确实应该由各个用户控制的选项，使用用户主目录的运行控制文件。对需
要由系统管理员设置而不是由用户改变的整个系统级选项数据，使用整个系统里的运行
控制文件。
    我们会逐一详细讨论以上设置所在，然后再分析～些实例。
10.3运行控制文件
    运行控制文件存放与程序相关的声明或命令，在程序启动时解析。如果所有用户都
在一处共享程序的系统级配置，则通常在／etc目录下有一个运行控制文件。（有些Unix
用/etc/conf子目录来集中存放此类数据。）
    用户专有的配置信息通常存放在用户主目录下一个隐藏的运行控制文件中。此类文
件通常叫做“点文件’’，这是因为它们利用了Unix目录列表工具通常不显示点开头文件
名的约定。1
    程序也可以拥有运行控制目录或点目录。每个目录包含了数个与程序相关的配置丈
件，但最好还是将这些配置文件分别对待（也许是因为它们与程序不同的子系统相关，
或者是语法各有不同）。
    文件或者目录约定俗成的命名方式是：运行控制文件信息的位置和与读取该信息的
可执行文件的基本文件名一致。某些系统程序中仍然通行较老的约定：使用可执行文件
名后加“rc"后缀代表“运行摔制’’2。这样，如果编写一个既有系统级配置又有用户级
配置，名为“seekstuff”的程序，有经验的Unix用户就会试图在／etc／seekstuf f找
到前者，在用户主目录下的．seekstuff找到后者；当然，如果此两者位于
1要显示点文件，使用Is （l）的-a选项。
2“rc’’后缀可追溯到Unix的祖父CTSS. CTSS有一个叫做“runcom”的命令脚本功能。早期的Unix
使用“rc”作为操作系统引导脚本名字，以此纪念CTSS的runcom。
www.pdf365.com
10.3运行控制文件
235
/etc/seekstuffrc和．seekstuffrc也并不稀奇，特别是当seekstuff是一个系统
实用程序时。
    我们在第5章描述了稍有区别的一套针对文本化数据文件格式的设计准则，并讨论
了如何根据互用性、透明性和处理经济性进行不同的取舍以臻最优。运行控制文件通常
只在程序启动时读取一次而且不需要写入；因此经济性通常不是主要考虑的问题。互用
性和透明性两者都要求我们采用文本格式设计，以便能够让人阅读并且可以用常规的文
本编辑器修改。
    尽管运行控制文件的语意是完全独立于程序的，但是人们仍然广泛遵循一些有关运
行控制语法的设计规定。我们会在下文说明；但首先我们要描述一个非常重要的例外。
    如果程序是某种语言的解释器，那么人们就期望运行控制文件只是以该语言语法写
成的并在启动时执行的命令文件。这是一条重要原则，因为Unix传统强烈提倡各种类型
的程序都作为专门语言和微型语言来设计。此种类型点文件的著名例子包括各种Unix命
令的shell和Emacs可编程编辑器。
    （采用这条设计原则的理由之一是对“特殊情况是坏消息”的坚信——这样，任何
改变语言行为的转换开关都应该从语言内部进行设置。知果作为语言的设计者发现不能
用语言本身表达所有的启动设置，Unix程序员就会认定存在设计问题——应该修改，而
不是设计一个特殊的运行控制语法）。
    抛开这种例外，这里给出针对运行控制语法的～些通用的风格规定。从历史角度来
看，它们都效法Unix shell的语法：
    1．支持说明性注释，并以“样”开始。语法也应该忽略“样”前的空白符，这样注释
和配置命令才可以写在同一行。
    2．不要区别隐匿的空白符。也就是说，在语法上把一连串的空格和制表符都视为一
个单独的空格。如果命令格式面向行，忽略跨行的空格和制表符就是一个很好的做法。
总的规则就是，文件的解释不应该被人眼不能分辨的区别所干扰。
    3．把多个空行和注释行视为单个空行。如果输入格式使用空行作为记录的分隔符，
可能必须确保注释行不会结束当前记录。
UNI×编程艺：术
  www.pdf365.com
236
第1 0章配置：迈出正确的第一步
    4．词法上把文件视作简单的用空白分隔的标记序列，或多行标记。复杂的词法规则
不仅难以学习、记忆而且难以分析。应该避免如此。
    5．但是，支持以字符串语法对待内嵌空白符的标记。使用单引号或是双引号作为对
称的分隔符。如果两者都支持，如果它们语意不同（如在shell中），务必留心；众所周知，
这是混淆之源。
    6．支持反斜杠语法以在字符串中嵌入不可打印字符和特殊字符。标准做法是C编译
器支持的反斜杠转义语法。这样～来，举例来说，如果字符串“a\tb”不被解析成字符
“a"接制表符再接字符“b"，就很别扭了。
    另一方面，shell语法的某些部分不应该被运行控制语法所效仿——至少没有充分、
具体的理由，就不能这样做。shell中怪异复杂的引用和括号规定，以及通配符和变量替
换的特殊元字符均在此列。
    要重申这些约定的关键是，对于用户从未见过的程序，要减少阅读和编辑运行控制
文件所必须应对的新鲜事物。因此，如果必须打破这些约定，首先确切地告知你已经这
么做了，特别留心地做好语法文档，然后（最重要的是）设计语法，人们可以通过例子
很容易地掌握语法。
    这些标准风格规定仅仅描述了记号化（tokenizing）祁注释的约定。运行控制文件的命
名、高级语法和语法的语义解释通常和应用程序有关。当然，也存在少数几个例外：其
中之一就是点文件，从点文件通常都包含一整类应用程序使用的信息这个意义上讲，点
文件已经变得“众所周知”了。用这种方式共享运行控制格式文件减少了用户必须应付
的新鲜事物量。
    其中可能最好的应用就是．netrc文件。如果．netrc文件存在的话，必须为用户
记录主机／口令（hosUpassword）对的互联网客户端程序通常就可以从中获得该信息。
10.3.1  实例分析：．netrc文件
    在实际使用的各种标准规定中，．netrc文件是一个很好的例子。使用变化口令保
护无辜者，见例10.1。
www.pdf365.com
10.3运行控制文件
237
例10.1  ．netrc例子

注意，臣口使此前从未见过这份文件的用户也能够读懂这个格式。它是一组主tru登录
／口令的三元组，每个三元组都描述了远程主机上的一个帐户。这种透明性非常重要
事实上比快速解析的时间经济性或更紧凑、更秘密文件格式的空间经济性重要得多。无
需阅读乎册，只需使用惯常的老式编辑器就能够阅读和修改，它节约了极具价值资源
人的时间。
同时注意，这个格式用于为多个服务提供信息——这是个优势，因为它意味着敏感
的口令信息只需存储在～个地方。．netrc文件是为最初Unix的FrP客户端程序设计
的。所有的FTP客户端都使用它，能理解它的还有部分telnet客户端、smbclient（1）命
令行工具和fetchmait程序。如果正在编写一个必须通过远程登录进行口令验证的互联网
客户端，最小立异原则就要求默认使用．netrc的内容。
www.pdf365.com
238
第1 0章配置：迈出正确的第一步
10.3.2到其它操作系统的可移植性
    系统范围的运行控制文件是一种设计策略，几乎可用于任何操作系统，但是点文件
却很难映射到非Unix环境中。大多数非Unix操作系统所缺少的关键内容是真正的多用
户能力和用户级主目录这些概念。举例来说，DOS和Windows ME以下的版本（包括
Windows 95和Windows 98）都完全没有这种概念；所有的配置信息都必须存放在固定位
置的系统级运行控制文件，即Windows注册表中，或存放在和程序运行目录一致的配置
文件中。Windows NT已经有了一些用户级主目录的概念（这概念也带入了Windows 2000
和Windows XP），但是没有很好地得到系统工具的支持。
10.4环境变量
    当Unix程序启动时，它可访问的环境包括一组名字和值的关联（名字和值都是字符
串）。有些由用户手动设置，有些由系统在登录时设置，或由shell和终端仿真器（如果
正在运行‘个终端仿真器的话）设嚣。在Unix下，环境变量往往携带文件搜索路径、系
统默认值、当前用户ID和进程号等信息，以及其它有关程序运行时环境的关键信息。在
shell提示符下，键入“set"后回车将列出所有当前定义的shell变量。
    在C和C++中，这些值都可以由库函数getenv （3）查询。Perl和Python在启动时
会初始化环境变量字典对象。其它语言通常都采用以上两种方式之一。
10.4.1  系统环境变量
    有些环境变量众所周知，可以期望在程序从Unix shell下启动时就能够找到定义。这
些环境变量（特别是HOME）经常需要在读取本地点文件前就已被赋值。
    USER
当前对话登录的帐号名（BSD约定）。
当前对话登录的帐号名（System V约定）。
www.pdf365.com
10.4环境变量
239
HOME
用户运行当前对话的主目录。
COLUMNS
控制终端和终端仿真器窗口以字符为单元的列数。
L工NES
控制终端和终端仿真器窗口的以字符为单元的行数。
SHELL
用户命令shell的名字（通常由shellout命令使用）。
    PATH
    shell寻找匹配名字的可执行命令时搜索的目录列表。
    TERM
    对话控制台或终端仿真器窗口的终端类型名称（背景知识参阅第6章terminfo的实
例分析）。TERM之所以特别，是因为通过网络创建远程对话的程序（如telnet和ssh）
期望能够经过它，并在远程对话中进行设置。
    （以上所列只是代表性的环境变量，难免挂一漏万。）
    HOME变量特别重要，是因为许多程序用它来寻找调用者用户的点文件（其它程序
调用C运行库的一些函数来获取调用用户的主目录）。
    注意，当程序用shell生成以外的方法启动时，这些系统环境变量的一部分或全部都
还未设置。特别是监听TCP/IP套接字的守护进程，这些变量通常都未设置——即使设置
了，那些值也常常无意义。
    最后，注意，当一个环境变量必须包含多个值城，尤其是值域可作为某种搜索路径
解释时，使用冒号作为分隔符（以PATH变量为证）是个传统，注意，一些shell（特别
是bash和ksh）总是把环境变量中冒号分隔的字段解释为文件名，这就特别意味着这
些shell把字段中的一扩展成用户主目录。
UNIXS譬艺术
  www.pdf365.com
240
第1 0章配置：迈出正确的第一步
10.4.2用户环境变量
    尽管应用程序可以在系统定义的范围外自由解释环境变量，但是这样做在今天实际
上已颇为少见。环境变量值并不真正适合把结构化信息传递到程序中（虽然原则上可通
过解析变量值达到目的）。相反，现代的Unix应用程序倾向于使用运行控制文件和点文
件。
然而，在一些设计模式中，用户定义环境变量仍有用武之地：
    必须由大量不同程序共享、独立于应用程序的优先选项。这套“标准”集的变化非
常缓慢，因为很多不同的程序在这些选项真正有用之前都必须逐个进行识别3。以下是一
些标准变量：
ED工TOR
用户首选的编辑器名称（通常由shellout命令使用）。4
MA工LER
用户首选的邮件用户代理的名称（通常由shellout命令使用）。
日疆西羽
用户浏览纯文本的首选程序名称。
田哥配乐耵碉
    用户浏览网页URL的首选程序名称。直到2003年，这个变量还很新，没有得到广
泛的实现。
10.4.3何时使用环境变量
    用户和系统环境变量的共同点是，在必须复制大量应用程序运行控制文件所包含的
信息时特别麻烦，而且尤其令人讨厌的是，只要优先选项改变就必须到处去改变信息。
3没有人知道真正优雅的方法来表示遮类分散的优先设置的选项数据；环境变量可能并不是最优解，
但所有已知解都有同样棘手的问题。
4事实上，大多数Unix程序首先检查环境变量VISUAL，只有在这个值没有设置时才参考EDITOR。
这是人们可以选择面向行或可视化编辑器那个时代的历史遗留痕迹。
www.pdf365.com
10.4环境变量
241
通常，用户在其shell对话启动文件里设置这些变量。
    变量值根据共享点文件或父进程需要向多个子进程传递信息的上下文环境的不同而
变化。有些启动信息希望能根据调用用户共享运行控制文件和点文件的不同上下文环境
而不同。举一个系统级的例子来说，考虑一下通过X桌面终端仿真器窗口而开启的几个
shell对话。它们都会查询同样的点文件，但可能有不同的COLUMNS、LINES和TERM
变量值。  （旧派的shell编程广泛使用这个方法；makefile至今仍然使用这种机制。）
    变量值随点文件不同而频繁改变，但每次启动都不变化。一个用户定义的环境变量
可能（举例来讲）会用于传递文件系统或Intemet位置，以作为程序将操作的文件树的根
节点。例如，CVS版本控制系统就是这样解析CVSROOT的。又如，从使用NNTP协议
的服务器中获取新闻的阅读客户端程序把NNTPSERVER环境变量解释为待查询的服务
器位置。
    进程唯一的覆盖必须以不要求改变命令行调用的方式来表述。不管出于何种理由，
如果不便于改动应用程序的点文件或提供命令行选项（也许希望这个应用程序正常地在
shell包装器或makefile中使用）．在这种情形下，用户定义的环境变量可能非常有用。
这类使用特别重要的应用环境是调试。例如，在Linux下，使用变量与ld （1）链接加载
器关联的LD—LIBRARY_PATH可以改变库加载的位置——也许为了挑选能进行缓冲区
溢出检查或性能评定（profiling）的版本。
    总的来说，当变量值经常改变，以至于每次编辑点文件很不方便，但又未必每次都
会改变（如果这样的话，总是用命令行选项设置位置也不方便），则用户定义的环境变
量是～种有效的设计方案。此类变量通常在本地的点文件之后求值，并允许覆盖已有的
设置。
    还有一个传统的Unix设计模式，我们并不建议在新程序使用。有时，用户设置的环
境变量可以作为在运行控制文件中表达程序优先选项的轻量级替代方案。例如，历史悠
久的nethaclc（1）地下城探险游戏就读取NETHACKOPTIONS环境变量作为用户优先权。
这是一个老式技巧；现代的实践通常偏向去解析．nethack或．nethackrc控制文件。
    这种老式风格的问题在于，同知道程序在用户主目录下有一个运行控制文件相比，以
这种方式来追踪优先选项信息存放的地方更加困难。环境变量可以设置在数个不同shell
运行控制支件中的任一位置-Linux中可能至少包括.profile、bash_profile
www.pdf365.com
242
第1 0章配置：迈出正确的第一步
和．bashrc。这些文件杂乱不堪，而且很不稳定，因此，随着拥有选项解析器的代码开
销越来越少，选项信息往往从环境变量中挪出到点文件中。
10.4.4到其它操作系统的可移植性
    环境变量在Unix之外的可移植性非常有限。Microsoft操作系统有一个以Unix为模
型的环境变量特性，并且和Unix -样使用PATH变量设置二进制文件查找路径，但不
支持Unix shell程序员认为理所当然应有的大多数其它类型的变量（如进程ID或当前工
作路径）。其它操作系统（包括传统的MacOS）通常都没有环境变量的对应物。
1．  命令行选项
    Unix传统提倡使用命令行开关来控制程序，这样选项可由脚本指定。这对作为管道
或过滤器的程序尤其重要。有三种约定可以区分命令行选项和普通的参数：原始的Unix
风格、GNU风格和X toolkit风格。
    在原始的Unix传统中，命令行选项是以连字符“一”开头的单个字符。后面不带参
数的模式标志选项可以组合在一起使用；例如，如果-a和-b是模式选项，-ab或-ba都
正确而且启用了两个选项。如果选项有参数的话，这些参数紧接着选项后面（是否以空
白分隔可选）。这种凤格的选项偏爱小写字符而不是大写字符。如果使用大写字符，把
它们作为小写字符的选项的特殊变种是一种很好的做法。
    原始的Unix风格从速度缓慢、以精练为美的ASR-33电传打字机上发展起来：所以
形成了这样的单字符选项。按住“shift”键也需要额外的精力，所以优先选择了小写字
符和“一”（而不是可能更合逻辑的“+"号）来启用选项。
    GNU风格使用前面有两个连字符的选项关键字（而不是关键字母）。这是在一些相
当复杂的GNU程序用完单字母选项后的几年内发展起来的（这只是一种治标不治本的方
法）o这种风格仍然非常流行，是因为GNU选项比老式的字母滥觞（alphabet soup）更
容易理解o GNU风格的选项不用空白分隔就不能组合使用。选项参数（如果有的话）既
可以用空白分隔也可以用单个“="（等号）来分隔。
www.pdf365.com
10.5命令行选项
243
    之所以GNU选择双连字符选项引导符，是因为传统的单字母选项和GNU风格的关
键字选项可以在同一命令行内混和使用而不会混淆。这样，如果原始设计的选项不多而
且很简单，就可以使用Unix风格，而不用担心以后必须转移到GNU风格时产生进退维
谷的矛盾局面（flag day）。另一方面，如果使用GUN风格，良好实践是，至少对最常
用的选项添加单字母等效选项。
    令人困惑的是，X toolkit风格使用了单连字符和关键字选项并由X toolkit进行解析。
它首先过滤并处理某些选项（如-geometry和-display）然后再把过滤后的命令行
传递给应用程序逻辑进行解析。这种风格既不能和古典的Unix风格又不能和GNU风格
很好地兼容，所以不应该在新程序中使用，除非遵循老式的X约定看起来价值很高。
    许多工具都接受一个不带任何选项字母的单个连字符，作为伪文件名，指示应用程
序从标准输入中读取数据。也习惯上把双连字符视为单连字符，作为停止解析选项的标
志，并把后面的参数都按照字面意义处理。
    大多数Unix编程语言都提供命令行程序库，以解析古典的Unix风格或GNU风格（也
解析双连字符约定）。
10.5.1  以一a到一z的命令行选项
    随着时间的推移，在一些众所周知的Unix程序中频繁使用的选项已经建立了一种松
散的语义标准，以其期望含义。以下列出一些选项及其含义，一个经验丰富的Unix用户
决不会对此感到惊讶：
-a
    所有项（all）（不带参数）。如果是GNU风格，则为-all选项，如果-a选项不是
-all选项的一个同名项的话，真的很出乎意外。示例：fuse，（1）和fetchmail（1）。
    添加（append），同在tar（1）中一样。这个命令选项和表示删除的-d选项是一对儿。
    -b
    缓冲区（buffer）大小或块（block）大小（带参数）。设置～个临界缓冲区大小，或（在
和存档或处理存储介质有关的程序中）设置块大小。示例：du （1）、df （l）和tar（1）。
    批处理（batch）。如果程序是自然交互的，-b选项可用于禁用提示或设置有其它适当
选项来接受文件的输入而不是操作员的操作。示例：flex（1）。
www.pdf365.com
244
第1 0章配置：迈出正确的第一步
    -c
    命令（带参数）。如果程序是一个通常从标准输入接收命令的解析器，那么程序期
望-c参数选项会作为单行输入传递给该程序。这个约定在shell和类似shell的解析器中
特别强烈。示例：sh（1）、ash （1）、bsh （1）、ksh （1）和python（1）。比较以下的
-e选项。
    检查（check）（不带参数）。检查命令的文件参数是否正确，但并不真正执行正常的
过程。命令文件的解释程序频繁用此作为语法检查选项。示例：getty （1）和perl （1）。
    -d
    调试（debug）（带或不带参数）。设置调试信息级别。这个用法非常普遍。
    一d偶尔具有“删除（delete）"或“目录（directory）”的含义。
    -D
    定义（define）（带参数）。在解释器、编译器或（特别是）类似宏处理器的应用程序
中给某个符号赋值。C编译器的宏预处理器对-D的用法就是如此。这和大多数Unix程
序员的关系都很密切；不要违反。
-e
    执行（execute）（带参数）。包装器程序或可作为包装器使用的程序通常允许．e对其
交付给控制权的程序进行设置。示例：xterm（1）和pert（1）。
    编辑（edit），能以只读模式或编辑模式打开某项资源的程序通常用-e规定以编辑模
式打开资源。示例：crontab（1）和SCCS版本控制系统的get （l）实用程序。
-e偶尔具有“排除（exclude）"或“表达（expression）”的含义。
-f
    文件（file）（带参数）。经常带参数使用，为需要随机访问输入或输出的程序（所以
仅通过<或>重定向还不够）指定输入文件（或者输出文件，但这种使用不太多）。经典
的例子是tar （1）：其它例子也非常多。这个选项也用于表明通常从命令行获取的参数
值应该从文件中获取；经典的例子可参见awk （1）和egrep （l）。比较后面的-o选项；
-f选项是和-o选项相对的表示输入的选项。
    强制（force）（典型情况下不带参数）。强制执行通常在某种条件下施行的操作（如
文件锁定和解锁）。这种用法不常见。
www.pdf365.com
10.5命令行选项
245
    守护进程结合这两种方法使用一￡选项，强制处理（force）非默认位置的配置文件（file）。
示例：ssh （1）、httpd（1）和很多其它守护程序。
    -h
  表头（header）（通常不带参数）。启用、禁止或修改程序生成报表的表头。示例：pr
（1）和ps （l）。
    帮助（help）。实际上，这没有人们想当然的那样普遍——因为在Unix早期历史的大
部分时期，开发者往往把在线帮助视为他们无法承受的存储开销。相反，他们编写了手
册页（这形成了我们将在第18章讨论的手册页风格）。
    -i
    初始化（initialize）（通常不带参数）。把和程序关联的关键资源或数据库设置成初值
或空值。示例：RCS中的ci （1）。
    交互（interactive）（通常不带参数）。强制那些通常不查询确认的程序查询确认。有
几个经典的例子（rm （1）和mv（1）），但这种用法并不普遍。
    一工
    包含（include）（带参数）。在应用程序将要搜索的资源中增加一个文件或目录名。这
个含义在所有要包含其它文件的Unix语言编译器中都适用。如果这个选项字母用于其它
方式，会让人感到极其意外。
-k
  保留（keep）（不带参数）。禁止莱个文件、信息或资源的常规删除操作。参见：passwd
（1）、bzip （1）和fetchmail（1）.
-k选项偶尔具有“杀死（kill）"的含义。
-l
    列表（list）（不带参数）。如果程序是某种目录或档案格式的归档器或解释／播放程序，
那么-l除要求列举项目之外的任何用法都相当突兀。示例：arc （1）、binhex（1）和
nzip （1）。  （但tar （1）和cpio （1）例外）。
    在已经是报表生成器的程序中，一l几乎始终表示“长（long）”，以启用某种长格式
来显示比默认模式更多的细节。如：如（1）和ps （l）。
    加载（load）（带参数）。如果程序是～个链接器或某种语言解析器，-l在某种意义
上始终表示加载一个程序库。一参见：gcc （1）、j77（1）和emacs（1）。
UNIX编程艺I莱
  www.pdf365.com
246
第1 0章配置：迈出正确的第一步
    登录（login）。在rlogin（1）和ssh （1）之类要求网络身份的程序中，-l表示执行方式。
    -l偶尔具有“长度（length）’’或“锁定（lock）”的含义。
    -m
    消息（message）（带参数）。带参数使用的-m选项用于日志记录或通告，其参数是消
息字符串。参见：ci （1）和cvs（1）。
    -m选项偶尔具有“邮件（mail）’’、  “模式（mode）”或“修改时间（modification-time）”
的含义。
-n
    数字（number）（带参数）。例如，在head （1）、tail（1）、nroff（1）和troff（1）
程序中使用作页码范围。通常显示DNS名字的某些网络工具用-n以显示原始IP地址。
ifconfig（1）和tcpdump（1）是原型实例。
否（not）（不带参数）。用于禁用make （1）等程序的通常行为。
    输出（output）（带参数）。当程序要求根据命令行的名字指定输出文件名或设备名时，
可以交给-o选项来完成。示例：as （1）、cc （1）和sort（1）。在带有类似编译器接口
的程序中，看到这个选项用于其它用途都将让人极其意外。支持-o逸项的程序（如gcc）
逻辑是允许把一。选项放在常规参数的前面或后面进行识别。
    -p
    端口（port）（带参数）。特别用于要求指定TCP/IP端口号的选项。示例：cvs （1）、
PostgreSQL]二具、smbclient（1）、snmpd （1）和ssh ci）.
    协议（protocol）（带参数）。示例：fetchmail（1）和snmp，zetstat（】）。
    -q
    安静（quite）（通常不带参数）。禁止正常的结果输出或诊断输出。这种用法相当普
遍。示例：ci （1）、co （l）和make （1）。也参见一s选项的“缄默”选项。
-r （also -R）（也为-R）
    递归（recurse）（不带参数）。如果一个程序作用于目录，那么这个选项可告诉程序递
归进所有子目录。在对目录作用的程序中这个选项具有其它用法非常让人意外。经典的
www.pdf365.com
10.5命令行选项
247
例子当然是cp （1）了。
    反向（reverse）（不带参数）。示例：b（1）和sort（1）。过滤器可用这个选项反向
进行其正常的转换行为（比较一d选项）。
_s
    缄默（silent）（不带参数）。禁用正常的诊断输出或结果输出（和-q选项类似；如果
两者都支持，-q表示“安静”而一s表示“绝对缄默”）。示例：csplit（1）、ex （l）
和fetchmail（1）。
    主题（subject）（带参数）。这种用法始终用于发送或处理邮件或新闻消息的命令中。
因为发送邮件的程序期望这个选项，所以支持这种用法特别重要。示例：mail （l）、elm
（1）并口，”“盯（1）。
    -s偶尔具有“大小（size）”的含义。
    -t
    标记（tag）（带参数）。命名一个位置或指定一个字符串供程序作为检索关键字使用。
在文本编辑器和浏览器中应用尤多。示例：cvs （1），、ex （1）、less （1）和vi （1）。
-u
    用户（user）（带参数）。根据名称或数字UID来指定用户。示例：crontab（1）、emacs
（1）、fetchmail（1）、fuser（1）和ps （1）.
    -v
    冗长（verbose）（带或不带爹数）。用于启用事务监控性质的、更冗长的列表或调试
输出。示例：cat （l）、cp （l）、flex （1）、tar （l）和很多其它程序。
    版本（version）（不带参数）。在标准输出上显示程序版本并退出。示例：cvs （1）、
chattr（1）、patch （1）和uucp （1）。更常见的是由-V调用。
    -V
    版本（version）（不带参数）。在标准输出上显示程序版本并退出（通常也打印编译的
配置细节）。示例：gcc （l）、flex （1）、hostname（1）和很多其它程序。把这个选项
挪做它用特别突兀。
-w
    宽度（width）（带参数）。特别用于指定输出格式的宽度。示例：faces （1）、grops
（1）、od （l）、pr （I）和shar （l）.
    警告（warning）（不带参数）。启用或禁用警告诊断。示例：fetchmail（1）、刀蹦（1）
和nsgmls（1）。
    -x
    启用调试（带或不带参数）。同一d选项类似。示例：曲（1）和““印（1）。
    UNIX编程艺术
    www.pdf365.com
248
第1 0章配置：迈出正确的第一步
    提取（extract）（带参数）。列出从存储器或工作集待提取的文件清单。示例：tar （1）
和zip （1）。
    -y
    是（yes）（不带参数）。批准启用对程序通常要求确认的潜在破坏性行为。示例：fsck
（1）和rz （1）。
-z
    启用压缩（不带参数）。存档和备份程序经常使用这个选项。示例：bzip （l）、GNU
tar （1）、zcat（1）、zip （l）和cvs （1）.
    以上例子都来自Linux工具包，但在绝大多数的现代Unix下也应该适用。
    当为程序选择命令行选项字母时，可参阅类似工具的手册页。对于和手册页中类似
的功能，尽量使用一致的选项字母。注意一些特殊的应用领域，这些应用领域对命令行
开关具有特别严格的约定，违反这些约定非常冒险——编译器、邮件程序、文本过滤器、
网络程序和X软件都是值得注意的。例如，编写邮件代理程序的人如果不把一s用作标题
选项，肯定会因为这个选择而遭到轻视。
    GNU工程在GNU编码标准中建议为一些双划线选项选用常规含义。5它也列出了一
些尽管还没成为标准但已在许多GNU程序中使用的长选项。如果使用GNU风格的选项，
并且有些需要的选项具有和标准中所列的柏类似的功能，就应尽一切办法遵循最小立异
原则并复用这些名称。
10.5.2到其它操作系统的可移植性
    要有命令行选项，首先必须有命令行。MS-DOS系列当然也有命令行，尽管在Windows
中命令行隐藏在GUI下，而且也不提倡使用；选项字符通常用“／”而不是“一”当然这只
是一个细节。传统的MacOS和其它纯GUI环境没有和命令行选项密切对应的概念。
10.6如何挑选方法
    我们依次分析了系统和用户运行控制文件、环境变量和命令行参数。注意从最不易
改变到最易改变的顺序过程。表现良好的Unix程序如果不只使用一种设置方式，就应该
5参考GNU编码标准<http：／/WWW．gnu．org/prep／standards．html>。
UNIX编程艺术
www.pdf365.com
10.6如何挑选方法
249
按照指定的顺序来考虑，允许后面的设置覆盖前面的设置，这是Unix中非常严格的约定
（存在几个特殊的例外，如指定在什么地方找到点文件的命令行选项）。
    特别是，环境变量设置通常覆盖点文件设置，但又可能被命令行选项所覆盖。良好
的实践是提供如同makfJJ中的-e命令行选项，从而可以覆盖掉环境变量的设置或运行
控制文件中的声明；这样，无论运行控制文件看起来怎样，环境变量如何设置，程序都
可用脚奉控制，从而让行为符合预期。
    考虑使用哪种方法依赖于程序在调用间隙需要保持多少持久的配置状态。设计那些
主要用于批处理模式的程序（如管道线中的生成器或过滤器），通常完全由命令行选项
来设置。这种模式的良好范例包括厶（1）、grep （1）和sort （1）。在另一个极端，有
着复杂交互行为的大程序可能完全依赖于运行控制文件和环境变量，常规使用就只涉及
很少的命令行选项或根本就不需要命令行选项。大多数X window管理器就是这种模式
的好例子。
    （Unix有能力让同一个文件具有多个名称或“链接”。启动时，每个程序都能获悉
是通过哪个文件名调用的。所以，另一个向具有多操作模式的程序通知应该以何种面貌
出现的方法．是给每个模式创建一个链接，让程序根据从哪个链接进行调用，来相应改
变自身行为。但通常认为这种技术不够清爽，因此很少使用。）
    让我们看一看从上述三个地方收集配置信息的两个程序。这对于弄明白为什么以此
种方式收集给定配置信息是非常有意义的。
10.6.1  实例分析：幻tchma『／
    fetchmail程序仅使用USER和HOME两个环境变量。这些变量由系统在预定义设置
中初始化；许多程序都使用这两个变量。
    HOME值通常用于查找．fetchmailrc点文件，该文件包含的描述配置信息语法
相当复杂，遵循以前描述的类似shell的词法规定。这是恰当的做法，因为一旦设置好，
fetchmail的配置就很少改变了。
    fetchmail没有专用的／etc/fetchmailrc或其它系统级文件。通常此类文件包含
并非针对个体用户的配置信息。fetchmail确实使用在这个范围内一个很小的属性集——
特别是本地邮件管理员名称和几个描述本地邮件传输设置（如本地SMTP监听程序的端
UN/X编程艺术
  www.pdf365.com
250
第1 0章配置：迈出正确的第一步
口号）的变量值。然而，在实践中，这些编译进来的默认值很少改变。当发生变化时，
它们往往以用户专用的方式进行修改。因此就没有必要存在一个系统级的fetchmail运行
控制文件。
    fetchmail可以从．netrc文件检索主机／登录／口令（host/login/password）三元组。
这样，它以一种最小立异的方式获得验证者信息。
    fetchmail具有～个精心设计的命令行选项集，但重复了大部分（但不是全
部）．f etchmailrc所能够表达的内容。这个选项集本来并不大，但随着时间推移，新
功能不断增加到．f etchmailrc微语言中，从而自觉或不自觉地增加相应的命令行选
项，使得这个选项集越变越大。
    支持所有这些选项的目的是，通过让用户从命令行覆盖运行控制文件的设置使
fetchmail更容易脚本化。但结果是，除了少数选项，如- fetchall和- -verbose外，
对此（脚本化）的需求非常低——而且没有人会对满足于现场创建临时运行控制文件并
用-f选项反馈给fetchmail的shellscript。
    这样，大多数命令行选项从未用到，而回顾过去，包括这些选项很可钝就是个错误：
他们膨胀了fetchmail的代码却没有完成什么有用的任务。
    如果代码膨胀是唯一的问题，那么除了几个维护者之外，没有人会在意。但
是，选项过多提高了代码错误的几率，尤其当那些很少使用的选项发生无法预料
的交互作用时。更糟的是，他们使手册变得非常臃肿，这对每个人来说都是个负
担。
    -Doug Mcllroy
    这是个教训；如果一开始仔细考虑fetchmail的使用模式并在增加功能时少用一些专
用代码的话，过度复杂也许就可以避免了。
    处理这种情况又不弄乱代码或手册的另外一个方法就是拥有一个“设置选项
变量’’  （set option variable）的选项，如sendmail的一。选项，它让人们指定一个
选项的名称和值，并给值设定该名称，就好像这样的一个设置是在配置文件中给
出的一样。一个更加强大的变种是ssh处理一。选项的做法：一。选项的参数被视
为增加到配置文件的一行信息，采用配置文件的语法。以上任何一种方法都为具
有不寻常要求的人提供了在命令行覆盖配置信息的方法，从而不需要为每一个可
能被覆盖的配置信息提供独立选项。
-Henry Spencer
www.pdf365.com
10.6如何挑选方法
251
10.6.2实例分析：XFree86服务器
    X window系统是在Unix机器上支持位图方式显示的图形引擎。通过配各位图显示
器的客户端机器运行的Unix应用程序，可以由X获得输入事件并向X发送屏幕打印请
求。令人困惑的是，X“服务器”实际上运行在客户端机器上——它们的存在是为了响
应同客户端机器显示设备交互的请求。向X服务器端发送这些请求的应用程序称为“X
客户端”，尽管它们可能在服务器机器上运行。哦不，没有办法清晰解释这个倒置的搅
来搅去的术语。
    X服务器端有一个复杂得可怕的环境接口。这并不令人惊讶，因为它们必须处理大
量非常复杂的硬件和用户选项。因此，所有X服务器端都通用的环境查询，其文档可在
X （1）和Xserver（1）手册页找到，就是一个很好的学习实例。我们在此分析的实现版
本是XFree86，是Linux和其它几个开源Unix下使用的X实现。
    在启动时，XFree86服务器端检查系统级运行控制文件；确切的路径名根据X建构
平台的不同而不同，但基名都是XF86Config。XF86Config文件的语法与上所述类shell
的语法相同。例10.2是从一个XF86Config支件中摘取的一部分。
例10.2  ×配置示例
# The 16-color VGA server
    XF86Config文件描述了主机的显示硬件（图形卡、显示器）、键盘和指示设备（鼠
标腥艮踪球／触摸板）。这些信息都适合放在系统级运行控制文件里，因为这些信息适用于
机器的所有用户。
UNI×编程艺爿e

252
第1 0章配置：迈出正确的第一步
    一旦X已经从运行控制文件获得了硬件配置，它就使用环境变量HOME的值在调
用用户的主目录中找到两个点文件。这两个文件是．Xdefault和.xinit rc。6
    ．Xdefaults文件指定每个用户以及每个应用程序与X相关的具体资源（这方面
的小例子包括终端仿真器的字体和前景／背景色）。然而，“X相关”这个词组指出了一
个设计问题。在一个地方收集所有的资源声明当然便于对其进行检查和编辑，但是对什
么应该在．Xde f ault文件中声明，什么应该属于针对应用的点文件始终不太清
楚。．xinitrc文件指定了在服务器端启动后应该运行的命令以初始化用户的X桌面。
这些程序几乎都包括一个窗口管理器或对话管理器。
    X服务器端有一个很大的命令行选项集。其中一些命令行选项，如-fp（字体路径）
选项，覆盖了XF86Config。有～些则是特意用来跟踪服务器端bug的，如-audit选项；
如果要使用这些选项的话，它们很可能在测试运行时频繁变化，因此不太适合包含在运
行控制文件中。一个非常重要的选项是设置服务器端显示号的选项。在同一台主机运行
的多个服务器端也许各自拥有一个唯一的显示号，但是历有实例都共享同样的一个或多
个运行控制文件；因此，显示号不能单独由这些文件得出。
10.7论打破规则
    本章所描述的约定都不是绝对的，但是违反这些约定会增加用户和未来开发者的磨
合成本。如果必须打破规则，就放手去做——但在做之前要确信自己完全知道为什么要
这样做。如果确实要打破规则，必须确保常规方法进行的尝试都非常明显地失败了，同
时保证遵循补救原则给出了正确的错误反馈。
6 .xinitrc同Windows以及其它操作系统下的启动（S￡artup）文件夹类似。
www.pdf365.com
1 1
接口：Unix环境下的用户接口设
计模式
Interfaces: User-Interface Design
Patterns in the Unix Environment
A// our knowledge has its origins zn our perceptzons.
    我们所有的知识都来源于我们的感知。
    ~Leonardo Da Vinci
一达·芬奇
    一个程序的接口就是程序同人类用户以及其它程序通讯的方法总和。在第10章中，
我们讨论了关于环境变量、命令行选项、运行控制文件和其它程序启动时接口的使用。
在这一章中，我们要解开历史的纠结，解释Unix在启动之后接口与使用者的关系（语用）。
因为用户接口代码通常会占用40%甚至更多的开发时间，所以为避免许多错误的开始和
耗时的重写，分辨出良好的设计模式就尤其重要。
    在Unix接口设计的传统中，我们会反复涉足两个主题。一是与其它程序通讯方式的
前瞻性设计；另一个是最小立异原则。
    借由互助式的组合使用，Unix程序可以发挥更大的威力；我们在第七章已经讨论了
进行这种组合的各种方式。不像其它的操作系统，在Unix下，接口设计中“其它程序’’
部分并不是一个事后追加的考虑，或者一个边角情况。楣反，这是一个核心的挑战，需
要同人类用户的接口需求进行权衡和集成。
www.pdf365.com
254    第1 1章接口：Unix环境下的用户接口设计模式
    Unix社区关于程序接口设计的许多传统也许看来既奇怪又任性——抑或更甚，在
GUI时代看来，完全是退化——特别是第一次遭遇这种传统时。但是，抛开各种瑕疵和
无规律不说，这个传统有一套内在逻辑值得去学习和理解。在Unix悠久的历史中，这种
传统聚集了许多启发式方法可以与人类用户以及其它程序进行有效通讯。它也包含一套
创造了程序间共性的约定——它为广泛的共同接口设计问题定义了“最小立异”的选择
方案。
    启动之后，程序通常通过下列来源获得输入或命令：
    ●  程序标准输入端的数据和命令。
    ●  通过IPC的输入，比如X server事件和网络消息。
    ●  已知位置的文件和设备（比如由程序传递的或计算的数据文件名）。
    程序能够以完全同样的方式发布结果（输出到标准输出）。
    有些Unix程序是图形的，有些拥有面向屏幕的字符接口，而有些使用从机械电传打
字机时代遗留的、简单生硬的文本过滤器设计。对于一个没经验的人来说，常常很难看
出为什么给定的程序使用某一风格——或者，确实的，为什么Unix支持这么多的接口风
格。
    Unix有几种竞争的接口风格。存在即是合理；它们为不同的情形而优化。通过理解
住务和接口风格之间的配合，你将要学习到如何为你的工作选择正确的风格。
11.1  最小立异原则的应用
    最小立异原则：  “少来标新立异”，是所有接口设计中的通用原则，且并非仅局限
于软件设计。这是人一心不能二用的结果（参考《The Humane Interface》【Raskin]）。接
口设计的标新立异，往往把注意力牵到了接口本身，却忽视了其所属的任务。
    因此，为了设计可用的接口，最好避免设计～个全新的接口模型。新颖其实是进入
门槛，给用户加上学习负担，所以，能少则少。相反，应该仔细考虑用户群体的经验和
www.pdf365.com
11.1  最小立异原则的应用
255
知识，应该尝试去发现那些用户已知程序同自己程序之间的功能相似性。然后效仿己知
接口的相关部分。
    最小立异原则不应被理解为在设计中号召机械的保守主义。新颖性提高了用户与接
口最初几次的交互成本，但是糟糕的设计永远使得接口令人痛苦而多余。如同在其它设
计中一样，规则并不能替代良好的品味和工程判断。仔细掂量你的折衷——而且以客户
的视角看待问题。最小立异原则的偏爱值得有意识地把持，主要因为接口设计者（像其
他程序员一样）总是不自觉地在为用户着想时聪明过头。
    最小立异原则的一个含义就是：如有可能，尽量允许用户将接口功能委派给熟悉的
程序来完成。在第7章，我们已经讨论了，如果程序要求用户编辑大量的文本，应该调
用一个文本编辑器（可由用户指定）而不是自己写一个内嵌编辑器。用户比你更清楚自
己的偏爱，让他们选择最合适的方案。
    在本书其它部分，我们提倡以共生和委派策略来提高代码的复用并降低软件复杂度。
此处的要点是，如果用户能够截获委派，并且将其导向他们自己选择的一个代理时，这
些技法就不仅仅给开发者带来实惠，也主动地增强了用户的自主权。
    更进一步：不能委派时，那就效仿。最小立异原则的目的就是为丁减少用户在使用
接口时必须学习的复杂过程。继续先前的编辑器例子，这就意味着如果必须实现一个内
嵌的编辑器，编辑命令最好是那些著名通用编辑器命令集的一个子集。（或者多个子集。
bash和ksh都允许用户在vi和Emcas编辑风格之间进行选择。）
    比如，在Unix下的Netscape和MoziIJa网页浏览器，在填写表单字段的编辑器中，
同样支持Emacs编辑器的键盘绑定方案。“Control-A”定位到行的起始处，“Control-D，，
删除后一个字符等等。这种选择对于知晓Emacs的用户很有益处，至于其他用户，当然
也不会比任意的专用命令集更糟。唯一更好的方式就是采用某个比Emacs使用更广泛的
编辑器命令集；但是在Netscape最初的使用群体中，不存在这么个东西。
    这些准则适用于许多其它的接口设计领域。比如，当用户都已经习惯在HTML网页
浏览器中查看在线帮助时，创造一种新颖文档格式的在线帮助真的是很傻。即使在设计
一个街机游戏时，也应该明智地参考以前游戏中的动作设置，允许用户使用在那些游戏
中学到的操纵杆技术，这样可以给予用户一种舒适的感觉。
UNtX编腥YaC
    www.pdf365.com
256    第1 1章接口：Unix环境下的用户接口设计模式
11.2  Unix接口设计的历史
    Unix的出现远在现代倾向图形密集型的软件接口设计之前。在1969年Unix诞生后
的十年里，在电传打字机和文本模式哑终端上的命令行接口（CLI）就是标准。多数Unix
的基本工具（比如Is （1）、cat （1）和grep （1）程序等）仍然继承了这个传统。
    1980年后，Unix逐渐支持在字符阵列终端的屏幕绘图。程序开始混合命令行和可视
接口，常用命令由特定键组合来触发，没有屏幕回显。有些早期使用这类风格的程序（用
屏幕绘图光标控制程序库实现的，称为“curses"程序：第～个使用curses的程序出现后，
则称之为“rogue式’’程序）今天仍在使用；著名的例子包括地下城探险游戏rogue（1），
vi（1）文本编辑器，以及（稍后几年出现的）邮件程序elm （l）及其现代版本mutt （1）。
    几年后，到了1980年代中期，整个计算机世界开始吸收施乐Palo Alto研究中心
（ Xerox's Palo Alto Research Center）从1970年代早期就开始研究的图形用户接口（GUI）
的开拓性工作结果。个人计算机方面，施乐PARC昀工作促成了苹果Macintosh接口并
由此产生了微软Windows设计。而Unix方面，对这些思想的适应过程经历了一条相对
复杂的道路。
    1987年左右，X window系统打败了几个早期的竞争者和原型成果，成为Unix的标
准图形接口。从那时起，这到底是好是坏一直是争论的主题；其它一些竞争对手（著名
的如Sun公司的Network Window System，即NeWS）被公认更为强大和优雅。然而，X
系统存在一个压倒性的优势，那就是开源。X代码一直由MIT的一个研究组开发，他们
更注重去探索问题空间，而不是创造商业产品，并且代码可以自由地重新分配并修改。
这就广泛地吸引了众多开发者和那些不愿意跟在单个公司闭锁产品后面的赞助商。  （当
然，这也昭示了十年后Linux操作系统爆发中的一个重要主题。）
    X的设计者很早就决定了它应该鼓励“机制，而非策略”。他们的目标是把X做得
尽可能的灵活和跨平台，而尽可能少让X程序受到观感的束缚。观感，他们认定，应该
www.pdf365.com
257
由“工具包”，即调用链接到用户程序的X服务库来处理。X的设计也支持多个窗口管
理器1，并且不得要求某个窗口管理器拥有特权或是同X太过亲密。
    这条路完全与Macintosh和Windows商业产品方向相反，这些商业产品将观感强加
进系统里以强迫执行观感策略。方法的差异确保了X拥有长期发展的优势，在接口设计
上保持了对不断涌现的人类新发明的适应性——并确保了X世界被划分成多个工具包、
丰富的视窗管理器和各种观感体验。
    自1990年代中期，X在最低端的个人Unix机器上已经普遍存在。与具备图形能力
控制台相对的Unix文本模式终端的使用，已经快速地消亡并似乎走向绝灭。相应地，
curses风格接口的使用也在消亡之中；多数本来会使用此种风格的新应用程序现在都采
用了X工具包。而Unix古老的CLI设计传统仍然相当有生命力并在许多领域同X卓有
成效地竞争着，注意到这一点十分有意义。
    一些特殊的应用领域，curses风格（或是“rogue式”）字符阵列接口仍1日是标准——
特别是文本编辑器和交互通信的程序，比如邮件程序、新闻阅读器和聊天客户端。注意
到这一点，也是非常有意义的。
    由于历史的原因，在Unix程序中存在丰宫的接口风格。面向行的、面向屏幕字符阵
列的和基于X的——基于X的世界中几个相互竞争的X工具包和窗口管理器已成鼎足之
势（尽管在2003年的五年或三年前，这还不算什么）。
    所有的这些接口风格存活至今，是因为它们适用于不同的任务。对一个项目作出设
计决定，重要的是应该知道如何挑选一个（或组合多个）适合程序应用和受众群体的风格。
    我们将使用五种度量标准对接口风格进行分类：简洁、表现力、易用、透明和脚本
化能力。在本书前面我们已经使用了其中的一些术语，为这里的定义做好了准备。它们
是相比而言的，不是绝对的；它们需要对特定的问题域并结合用户技能基础的一定认知
1窗口管理器处理屏幕上的窗口同运行任务的关联，即处理诸如标题栏、布局、最小化、最大化、移
动，缩放和加阴影等行为。
    UNIX编程艺术
    www.pdf365.com
258    第1 1章接口：Unix环境下的用户接口设计模式
来进行评估。但不管怎么说，这些术语有助于组织我们的思考方式。
    程序接口的简洁是指一个事务处理需要的动作时间及复杂度有较低的上限（可以用
击键量、鼠标手势量和需要多少秒的注意力来衡量）。简洁的接口会以相对较少的比特
或状态变化包装更多的作用效果。
    接口具有表现力是指接口可以触发相当广泛的行为。最具表现力的接口可以启动程
序设计者没有预见的行为组合，并仍然给予用户有用和一致的结果。
    简洁性和表现力之间的区别相当重要。考虑输入文本的两种不同方法：从键盘，或
使用鼠标在显示屏上点选某个字符。这两种方式有相同表现，但是键盘方式更简洁（通
过比较平均操作时间就可以轻易验证）。另一方面，考虑同一编程语言的两种方言，一
个具有复数类型，另一个没有。在相同的问题域，二者的简洁性相同；但是对数学家或
电子工程师来说，具有复数数据的语言更富有表现力。
    接口易用性同接口要求用户记忆的东西成反比——为了使用接口，用户需要特别记
忆多少东西（命令，鼠标手势，原语概念）。编程语言的记忆负荷愈高、易用性愈低；
菜单和屏幕上标记良好的按钮就较为简单。
    回顾早些时候我们为“透明度’’花费了整整一蕈。在那一章中，我们接触到了接口
透明度的概念，并且将“audacity"音频编辑器作为一个优秀的范例。然而那时我们更关
注另外一种透明度，是关于代码结构，而不是关于用户接口。因此我们用来描述UI透明
度的是它的效果（问题域和用户之间毫无障碍），而不是产生这种透明度的专有特征。
现在，是瞄准这些特征的时候了。
    接口透明度是用户在使用接口时，几乎没有什么问题、数据或程序的相关状态需要
记忆。一个高度透明的接口，对于用户动作的效果，能够自然地给出中间结果、有用反
馈和错误通知。所谓的所见即所得（WYSIWYG，What You See Is \Vhat You Get）的接
口试图将透明度做到极致，但有时适得其反——尤其是对于定义域视图过度简化时。
    相关的可显性概念同样适用于接口设计。一个可显的接口向用户伸出学习的援手，
比如指向上下文帮助的提示消息，或是一个说明性的弹出式气球。尽管对于可显性，将
www.pdf365.com
11.4 CLI和可视接口之间的权衡
259
要支持的不同接口风格的实现可能大有不同，但是所能够获得的可显程度大部分独立于
接口风格。由此，在本章的讨论中，我们并不把可显性作为衡量标准。
    请注意，代码和设计的透明并不是就自然而然意味着接口也透明，反之亦然。指出
只具备其中一个品性的代码再容易不过了。
    脚本能力，是指接口能够容易地为其它程序所使用（例如，第7章讨论的IPC机制）。
可脚本化的程序通常被其它程序作为组件使用，从而减少了定制代码的昂贵需求并使得
重复任务的自动化相对容易。
    最后一点——自动完成重复的任务——比以往更值得注意。Unix程序员、管理员和
用户养成了一种思考习惯，即他们使用常规例程，然后将其封装，以后就再也无需手工
执行，甚至无需再挂在心上。当然，这个习惯依赖接口的可脚本化能力。这是种对生产
力无言但巨大的支持，而在其它大多数软件环境中却无法获得。
    关于这些度量标准，人类和计算机程序有着不同的价值函数，将这一点牢记心中非
常有用。初学者和专家用户在特定问题域上也是如此。我们将探索其间的权衡对于不同
的用户群体有怎样的不同。
11.4 CLI和可视接口之间的权衡
    早期Unix的CLI风格，在电传打字机消七了很久以后，其效用仍得以保留，这有两
个原因。一是命令行和命令语言接口比起可视接口来说，更具表达力，尤其是针对复杂
的任务。另一个是CLI接口具有高度的脚本化能力——正如我们在第七章讨论的一样，
它们很容易就能支持程序的搭配。通常（但并不总是）CLI在简洁性上也占据优势。
    当然了，CLJ风格的劣势在于，几乎总是需要费劲地记忆（易用性低），并且透明
度通常也很低。多数人（尤其是非技术型摄终用户）认为这种接口相对神秘、难以学习。
    另一方面，其它操作系统中“用户友好”的GUI，也存在自身的问题。找到
正确的按钮来按简直就像是在玩冒险游戏：接口同任何Unix的命令行接口一样令
人烦累，找得多了总能找对地方。而在Unix中，人们只需查手册。
-Brian Kernighan
UNIX编程艺术
    www.pdf365.com
260
第1 1章接口：Unix环境下的用户接口设计模式
    数据库查询就是此类接口的～个很好的例子，这里，点击按钮不仅累人，而且能力
非常有限。无论是全屏字符接口的击键命令，还是在图形显示器上的GUI手势，都不如
直接向服务器键入SQL语句那样简洁和富有表现力，在表示问题域的一个典型活动。毫
无疑问，让客户端程序直接说出一个SQL查询语句要比让它的模拟用户在GUI上点来点
去容易得多。
    另一方面，许多非技术型的数据库用户不愿记忆SQL语法，而宁愿选择一个相对不
简洁、表现力较差的全屏或GUI接口。
    SQL还适合作解说另～个问题的例子。最强大的CLI并不是命令的专门集合，而是
如我们在第八章所描述的方式设计的命令式微型语言。这些微型语言在命令行接口范畴
上属于最强大、最复杂的～端；它们的表达力最强，但是易用性最低。它们难以使用，
往往需要小心谨慎地对普通的终端用户隐藏，但是当接口能力和灵活性至关重要时，它
们的威力就无与伦比。如果设计得当，在脚本化能力方面它们也可以得到高分。
    有些应用，与数据库查询不同，天然就是可视的。绘图程序、网页浏览器和幻灯演
示软件是三个典型例子。这些应用程序定义域的共同之处是（a）透明性有极端偷值，和
（b）问题定义域的原语操作本身就是可视的：“画这个”、“显示所指物’’、“把它放
到这儿”等等。
    绘图程序的另一面是难以找到所操作图片之间的关系。例如，要让用户能以重复的
元素来处理图像的结构，程序就必须经过小心谨慎地设计。这是可视接口的普遍设计问
题。
    在第六章，我们检视了Audacity声音文件编辑器。它的接口设计是成功的，因为它
在音频应用定义域和一套简单视觉表示之间做了一个相当干净的映射（借鉴音响上的均
衡器显示）o能够做到这完全是因为通过一个简单转换的结果：声音到波形图。视觉操
作并不只是低级调整的拼凑，而是与那个转换紧密相关。
    然而，在那些并不是天然可视的应用中，可视接口最适用于初学用户简单一次性的
或者很少发生的任务（这一点数据库例子已经阐明了）。
    随着用户变得越来越熟练，对CLI接口的抵触也越来越少。在许多问题定义域上，
用户（特别是常用的用户）往往会达到一个交叉点，CLI的简要性和表达力变得要比避
免记忆负担更有价值。这样，例如，计算机初学者倾向于易用的GUI桌面，而老手常常
逐渐发现他们更愿意在shell中键入命令。
www.pdf365.com
11.4 C LI和可视接口之间的权衡
261
    当问题规模变大、程序行为日趋单一、过程化和重复时，CLI也常能发挥效用。例
如，创作诸如商业信函之类相对较小而无结构的文档，～个所见即所得的桌面发布程序
通常是晟容易的方式。但是如果文档达到一本书的规模，由数个部分组成，并且在写作
时需要许多全局的格式变更或是结构操控，这时，一个微型语言的格式化器比如troff、
TeX或某个XML标记处理器通常是更有效的选择（关于这个权衡更多的讨论请参考第
1 8章）。
    甚至在天然可视化的定义域中，问题规模的增大也会使天平向CLI风格倾斜。如果
需要从指定的URL获取和保存网页，指向十点击（或输入十点击）可以用。但是对于网
页表单，就要使用键盘。并且如果需要获取和保存50个URL的相关页面，那么一个可
以从标准输入或命令行读取URL的CLI客户端就能够节省许多不必要的操作。
    另外一个例子，考虑修改图像的颜色表。如果想要改变～种颜色（即，加亮图像但
效果只有看后才能知道），一个可视的颜色选取对话框几乎是必须的。然而想象一下，
需要用特定的一组RGB值来替换整个颜色表，或需要创建或索引大量缩略图。对于这些
操作，GUI的表现力往往就欠缺。即伎这样可行，调用～个设计得当的CLI或者过滤器
来完成这项任务则要简洁得多。
    最后（正如我们早些时候观察的一样），CLI风格在方便其它程序使用方面非常重
要。一个GUI图形编辑器如果要为～堆文件成批生成缩略图，往往是通过脚本语言编写
的插件去调用一个内部CLI图形编辑器（如GIMP中的“script-fu”）。Unix环境凸现了
CLI的价值，因为Unix的IPC方法多样，开销也低，并且还容易在用户程序中使用。
    1984年后对GUI兴趣的爆发，很不幸地掩盖了CLI的优点。尤其是消费类软件的设
计，已经变得严重倾向于GUI。尽管对于由初学者和随意用户构成的大多数消费市场来
说，这未尝不是个好的选择，但同时也被迫支付隐性成本，当有经验的用户遇到GUI表
达限制时，成本随着用户处理要求更高的问题而稳步上升。这么多的代价都来自于GUI
根本就不能脚本化——所有交互都需要由人来驱动。
    Gentner&Nielsen在《反Mac接口》  （The A，zti-Mac Interface）[Gentner-Nielsen]中
很好地总结了这种权衡：“（可视接口）在处理小数量物体简单行为的情况下，工作得很好，
但是当行为或是物体的数目螬加时，直接操作很快就变成了机械重复的苦差。一个可以
直接操作的接口，其缺点是一切都必须亲自操作。同一个发布高级指令的执行者相反，
UNIX编程艺．术
    www.pdf365.com
262
第1 1章接口：Unix环境下的用户接口设计模式
用户降格成了装配工，必须一遍又一遍地执行同样的任务”。著名科幻小说家，Neal
Stephenson，在《一开始就是命令行》（肪the Beginning Was the Command Line）这篇精
妙散文中，同样指出了这一点，只不过没有直截了当，而是调侃而谈。
    从不太理论的角度，一个典型的Unix老手这样阐述这个问题：

商业世界通常一窝蜂地支持初学者模式，因为（a）购买决定基于冲动，和（b）
  仅仅有个傻愣愣的GUI，用户支持工作得以降到最少。我发现许多非Unix系统常
  常令人沮丧，因为，比如，它们不提供对成百上千的文件进行某种处理的方法；
  想写一个脚本，又不支持。实质的问题是他们已经假定所有的用户总是入门级的，
  然后非难Unix，因为Unix并不迎合这种模型。
-Mike Lesk
    既然如此，长远来看——为了既能服务一般用户又能服务有经验的用户，为了同其
它的程序交互，不管问题定义域是不是天然可视化——既支持CLI又支持可视接口都是
非常重要的。在展示一个实例分析后，我们将检视Unix传统发展出来适应各种需求的特
征设计模式。
11 .4.1  实例分析：编写计算器程序昀两种方式
    让我们具体一点，对比一下GUI和CLI风格如何有效地应用于一个简单交互程序的
设计：桌面计算器。我们用来对比的例子是dc （l） lbc （1）和xcalc（1）。
    原始的Unix桌面计算器程序，是最先随版本7-起发布的dc （l）——逆波兰标记
法计算器，可以处理无限精度的算术运算。后来，代数（中缀标记法）的计算器语言，
bc （1），是基于dc上实现的（作为实例分析，这两个程序的关系我们在第7章和第8
章先后进行了讨论）。两者都使用命令行接口。可以在标准输入键入一个表达式，按下
回车后，表达式运算结果打印到标准输出上。
    另外，xcalc（1）程序，视觉上就是仿真一个简单的计算器，具有可点击的按钮和普
通计算器般的外观。
    xcalc这种方式更容易描述，因为它效仿的是一个即使初学者也熟悉的接口；实际上
其手册页干脆就说“数字键，正负号键，并且加减乘除等于这些符号都与人们所预想的
别无二致”。程序的功能通过按钮上的可见标签表露无疑。这是最小立异原则的最强烈
www.pdf365.com
11.4 C LI和可视接口之
图11.1  xcalc图形接口
表现形式，对于并不常用和新进的用户来说，不需要阅读手册就可以使用这个程序，在
这方面，拥有真正的优势。
    但是，xcalc同样几乎完整继承了计算器的不透明性；当求解一个复杂的表达式时，
无法看到击键的过程并进行验证——这可能是个问题。假如，在表达式（2.51+4.6）木0.3
中，弄错了一个小数点。没有历史纪录，所以无法检查。当然可以得到一个结果，但并
不是想要算式的结果。
    另一方面，在dc （1）和bc （1）程序中，可以一边键入表达式，一边剔除其中的错
误。它们的接口透明得多，冈为可以看到每～步计算的结果。这也更富有表达力，因为
dclbc解释器并不受限于适合通常大小计算器的可视模拟，还能包括许多更大的函数指令
（以及比如if/then/else、存储变量和迭代等功能）。当然了，这也导致了更高的记忆负
担。
    简洁性更难以定夺；打字好的人会发现CLI更简洁，但打字不好的会认为点击更
快。脚本化能力不难定夺；dc/bc可以轻易地用作过滤器，而xcalc根本就不具备脚本
他能力。
UNIX缩程艺：术
  www.pdf365.com
264    第1 1章接口：Unix环境下的用户接口设计模式
    在这里，初学者要求易用性和经验用户要求功用性之间的权衡清晰可见。对于随意
使用的情形，心算检查并非难事，xcalc当然具有优势。而对于更复杂的计算，不仅仅需
要步骤是正确的，还需要其正确性可见，或者在尽可能便利其它程序来驱动方面，dc/bc
胜出。
11.5透明、表现力和可配置
    Unix程序员继承了一个强烈的偏爱，愿意使接口富有表现力和可配置。就像其他传
统的程序员一样，他们考虑怎样将他们的接口同目标受众相匹配——但是在处理目标受
众不确定性时有所不同。经验主要来自客户端操作系统的软件开发者自然而然地会使得
接口简单：他们愿意牺牲表现力来获取易用性。Unix程序员默认地使得接口富有表现力
和透明，并且更愿意牺牲易用性来换取这些品质。
    这种态度常常被描述成，接口是“程序员写给程序员的’’。但这过度简化了事情的
某～重要方面。当Unix程序员倾向可配置能力和表现力而不是易用性时，并不是想当然
地认为他的日标受众仅仅由其他程序员构成，他们深入骨髓的本能反应是，如果不了解
终端用户的意图，最好不要迁就或者放马后炮。   这种态度（也是“机制，而非策略”的近亲）的不利方面是遮种倾向：当高
度可配置和富于表现力的接口完成后，任务就算完了……即使其结果就是除他自
己外的所有人不经长期学习几乎就无法使用。可配置能力的另一面，就是迫切需
要良好的默认值和简单恢复所有默认值的方法。表现力的另一面就是需要指导一
在程序本身或者在文档中一如何开始使用、以及如何取得通常最期望的结果。
-Henry Spencer
    透明原贝0也有～个影响。对于定义了一套控制选项的RFC或其它标准，当Unix程
序员在编写符合它们的程序时，往往会假定他要为所有选项提供一个完整透明的接口；
给定的任何选项用不用得上实际倒在其次。他的工作就是建立机制：而策略方面的任务
则属于用户。
    这种思路导致了对于标准一致性组成方面一个更苛刻的态度，不完全的支持是难以
容忍的。也许一个Macintosh或Windows开发者会说“我们不需要支持标准的所有特征：
www.pdf365.com
11.5透明、表现力和可配置
265
多数用户不会在意，而且对他们来说太复杂了”，而一个Unix开发者可能会说“我们并
不知道是不是有人永远都不会需要这种功能或者选项，所以我们必须支持它。’’
    当Unix程序员和其他程序员～起工作时，这些态度会导致冲突，因为其他程序员可
能会把这种设计认为是～种冒失的主观意愿，将用户置于对他们而言含混、无意义、甚
至是吓人的技术细节的负担之中。Mac或Windows的程序员害怕只是因为少数人的高级
需求而吓跑大多数用户。
    相反，Unix程序员更愿意认为对表现力的忽视是一种逃避，或者甚至是一种对未来
用户的背叛，这些未来用户对于他们自己的需求实际上会比现在的实现者还要清楚。具
有讽刺意味的是，尽管Unix的这种态度常常被视作是程序员的一种傲慢，但它实质上是
谦逊的另一种形式——往往伴随着好多年的战争创伤而获得。
    Unix这种态度的适应范围是不同的。读者如你，无论这种划分会把你归属到哪一方，
学会倾听他人的声音都是明智的，而理解对立观点的前提无疑同样明智。这样，就有可
能建立～种透明的接口，既具备高级功能又不碍眼，从而避开落入不是胁迫用户就是迁
就用户的陷阱。第6章audacitv和kmail裎序的实例分析就是很好的例子。
    最后是关于为非技术型终端用户设计接口的注意事项。这是一个要求颇高的艺术，而
Unix程序员也没有一个擅长于这方面的传统。但是拥有从Unix传统讨论中已经揭示出来
的思想，我们可以给出一个强力而有用的表述。那就是：当人们说一个用户接口是直观的，
他们的意思是（a）它是可显的，  （b）用法是透明的，  （c）遵循最小立异原则2。在这三
条原则中，最小立异原则是最弱的约束；可显和透明带来的长期使用回报完全可以消融
最初的讶异。
    今天移动电话（例如）用户接口记忆负荷相对较高，至少在大脑中需要有一个关于
接口菜单的大概轮廓，这样可以很快的使用它们而无需花费注意力研究到底处于哪一级
菜单。然而设计更好的接口很快就可以成为对用户而言的“直观”设计，因为他们具备
前述的三项品质。
    直观并不是同易用性一样的品质，因为（正如手机的例子所示）人们可以培养出任
何他们认为有关透明接口的“直观性’’。虽然那种接口有着相当规模的记忆负担，然而
2这种领悟来自于一个非技术型最终用户，恰好是作者的妻子Catherine Raymond。
UNIX 41S程艺-术
  www.pdf365.com
266    第1 1章接口：Unix环境下的用户接口设计模式
只要基本操作是容易的，并且存在一个发现路径，允许通过简单操作让隐藏在更深角落
的功能能够一次到位地触发。
11.6  Unix接口设计模式
    在Unix传统中，已经形成了良好的接口设计模式，可以完成以上讨论的权衡。下面
是这些模式及其分析和例子的传集。再接下来，我们会讨论如何应用这些模式。
    注意到这个传集并未包括GUI设计模式（尽管包括了一种能够将GUI作为组件使用
的设计模式）。没有原生的来自Unix的图形用户界面设计模式。关于GUI设计模式的
讨论《经验——用户界面设计的模式描述》  （Experiences-A Pattem Language for User
InterfaceDesign）[Coram-LeeJ，是一个颇有前途的起点。
    另外要注意程序的适用模式可能不只一个。例如，一个类似编译器的程序，当在命
令行没有指定文件参数时，其行为就像一个过滤器（许多格式转换器都是照此工作的）。
过滤器模式
    与Unix相关的最经典的接口设计模式非过滤器莫属。过滤器程序接受标准输入的数
据，转换成某种格式后，再将结果发送到标准输出端。过滤器不是交互的；也许会查询
启动环境，并且通带由由命令行选项控制，但并不要求用户在输入流中输入命令或给出
反馈。
    过滤器两个经典的例子是tr （l）和grep （l）。tr （I）实用程序以命令行指定的转
换原则将标准输入端的数据转换成标准输出端的结果。grep （l）程序根据命令行指定的
匹配表达式从标准输入端选出匹配行；并将结果送到标准输出端。第三个是sort （l）实
用程序，依照命令行指定的原则将标准输入端的数据排序，并将结果显示到标准输出端。
    除此之外，grep （1）和sort（1）  （但非fr（1））还可以从命令行指定的文件（或
是一组文件）接受输入，在这种情况下，它们并不从标准输入读取，代替的是按照出现
的顺序连续读取命名的文件。  （在这种情况中，也可在命令行将“一，，作为文件名，这会
明确告知程序，从标准输入读取数据。）“catlike”的过滤器程序，其原型就是cat（1），
www.pdf365.com
267
过滤器一般都应该按这样的方式运作，除非应用程序有特别的理由将命令行中给出的文
件区别地对待。
    当定义过滤器时，最好在心中牢记一些附带的原则，其中一部分曾经在第一章提到
过：
    1．牢记Postel原则：宽进严出。也就是说，尽可能自由宽松地接受输入格式，并
输出结构良好的严谨输出格式。前者的做法减少了过滤器在面对非预期输入时出错的可
能性，以及在某种情形下（或是在某一工具链中间）崩溃的可能性。后者提高了过滤器
终有一天能够作为其它程序有用输入的可能性。
    2．在过滤时，不需要的信息也决不丢弃。这也提升了过滤器将来能够成为其它程序
有用输入的可能。丢弃的信息，在管线后面就再也不能使用了。
    3．在过滤时，绝不增加无用数据。避免增加不必要的信息，避免以可能让管线下游
程序难以解析的格式输出。最常见的违例通常是修饰，比如页眉、页脚、空行／标尺行、
摘要、增加列对齐，或者把系数因子“1.5”写成“15096”等等。时间和日期尤其麻烦，
因为它们比较难以被下游的程序解析。任何这样的附加物都应该是可选、并由开关控制
的。如果程序需要输出日期的话，良好的实践是增加～个开关以强制转换成IS08601标
准的YYYY-MM-DD和hh:mm:ss-成者，更好是将标准格式作为默认的选项使用。
这种模式下的术语“过滤器”是Unix历史悠久的行话。
    “过滤器”确实历史悠久。在管道出现的时候就有了。这个术语是从电子工
程借用：数据从源头经过滤器流向接收器。信息源或者接收器可以是进程或文件。
既然已经很自然地把数据流比喻成管道，人们于是从未考虑过使用电子工程术语
“电路（ circuit）’’
    -Doug Mcllroy
    一些程序有着类似过滤器的接口设计模式，但更简单（当然，重要的是更容易脚本
化）。它们是“cantrip"模式、源模式和接收器模式。
UN/X编程2
  www.pdf365.com
268
第1 1章接口：Unjx环境下的用户接口设计模式
11.6.2 Cantrip模式
    cantnp接口设计模式是其中最简单的。没有输入，没有输出，只被调用一次，产生
退出状态数值。一个cantnp程序的行为只能由启动条件来控制。没有任何程序会比这种
方式更具备脚本能力。
    这样，如果程序在运行时除了简单地在启动时设置初始条件或者控制信息之外，并
不需要同用户交互，那么cantnip设计模式就是一个优秀的默认选择。
    事实上，因为可脚本化能力非常重要，Unix设计者学会了当cantrip模式足以应付需
要时，绝不编写更具交互性的程序。一组应用cantrip模式的程序总是从一个交互的包装
器或是shell程序驱动，但是交互的程序比较难以脚本化。良好的风格总是要求在受诱惑
而编写一个难以脚本化的交互接口之前，尝试为程序找到一个cantnp模式的设计。当交
互看来必须时，记住Unix从接口分离引擎的特征设计模式；通常，正确的做法是用脚本
语言编写一个交互的包装器，调用一个cantrip程序完成真正的工作。
    简单的控制台清屏实用程序clear （1），可能是最纯正的cantrip模式；它甚至没有
命令行选项。另外的经典例子是rm （l）祁touch（1）。用来启动X的startx（1）程序
则是一个复杂的例子，是整个一类守护程序使用cantrip模式的典型。
    这种接口设计模式，尽管相当普遍，然而传统中并没有命名；术语“cantnp”只是
我的发明。  （在辞源上，这是个苏格兰方言词，一种魔咒，被一个流行的魔幻角色扮演
游戏选中，命名一种咒语，可以随时发出，只需要很少或根本不需要准备。）
11.6.3源模式
    “源”是一种类似过滤器的程序，不需要输入；它的输出只能在启动条件中控制。
可以作为例证的程序是厶（l），Unix的列举目录命令。其它经典的例子包括who （l）
和ps （1）。
    在Unix中，报表产生器比如ls（1）、ps（1）和who （l）强烈地遵循源模式，所
以标准工具可以过滤它们的输出。
    术语“源”，正像Doug Mcllroy所指的那样，非常传统。但是并非想象中那么普遍，
因为“源”有其它更重要的意思。
www.pdf365.com
1 1。6 Unix接口设计模式
269
11.6.4接收器模式
    接收器是一种类似过滤器的程序，只接纳标准输入而不发送任何东西到标准输出。
同样，它对输入端数据的作用行为只能在启动条件中控制。
    这种接口模式较少用到，众所周知的例子很少。一个是lpr （1），Unix打印假脱机
程序（ spooler）。它将标准输入传来的文本编入打印队列，同许多接收器程序一样，它
也可以处理命令行指定的文件。另一个例子是在邮件发送方式下的mail （1）程序。
    许多第一眼看似接收器的程序，从标准输入获取信息或数据，但它们实际上是ed模
式（见下）的实例。
    术语“海绵（sponge）"有时也用来表示如同sort（1）类的接收器程序，这些程序在
做任何操作之前必须读入完整的数据。
    “接收器”术语传统而普遍。
    类似编译器的程序既无标准输出也无标准输入；然而它们会将错误信息发送到标准
错误端。相反的，一个类似编译器的程序从命令行接受文件或资源名，以某种方式转换
这些资源，然后再以改变后的名字输出。如同cantrip模式，类似编译器的程序在启动后
并不需要用户的交互。
    如此命名这种模式是因为其典范是C编译器，cc （l）（或是在Linux和其他许多现
代UnixT的gcc （l））。但是它也广泛地使用在其它的一些（例如）图像转换或者压缩
／解压程序上。
    前者的例子是用来将GIF（Graphic Interchange Format，图形交换格式）转换成PNG
（Portable Network Graphics，可移植网络图形）格式的gif2png （1）程序。后者的例子
是gzip（”和gunzip （1）3，GNU的压缩程序几乎一定能在你的Unix系统中找到。总
的来说，当程序经常需要处理多个命名资源，并且能够以较低的交互性来实现（它的控
制信息可在启动时提供）时，编译器接口设计模式就是一个不错的模型。类编译器的程
序可以很容易地脚本化。
3这个程序的源码以及类似接口的转换程序可以在PNG网站<h七七p：／／www．cdrom．com／
pub/png/>处获得。
www.pdf365.com
270    第1 1章接口：Unix环境下的用户接口设计模式
这种模式的术语“类编译器接口”被Unix社区广泛理解。
11.6.6 ed模式
    所有前述的模式都只有极低的交互能力；这些程序仅仅使用启动时传入的控制信息，
并且同数据是分离的。然而许多程序，在启动之后需要由与用户持续的会话来驱动。
    在Unix传统中，最简单的交互设计模式以Unix的行编辑器ed （1）程序作为代表。
其他这种模式的例子包括ftp （1）和sh （1） （Unix的shell）等等。ed （1）程序需要～个
文件名作为参数；然后可以修改那个文件。在输入端，它接受命令行。一些命令的结果
输出到标准输出端，作为与程序对话的一个部分，可以立即为用户所见。
    ～个实际的ed对话示例包含在第13章里。
    许多Unix下类似浏览器和编辑器的程序都遵循这种模式，甚至当所编辑的命名资源
并不是一个文本文件时也是如此。考虑gdb （1），GNU的符号调试器，就是这样一个例
子。
    遵循ed接口设计模式的程序并不像过滤器之类简单接口类型的程序那样容易脚本
化。命令可以在标准输入端流入，但比起只需设置环境变量和命令行的选项来说，要产
生一序列命令（或是解释任何回传的输出）就需要更多的技巧，如果命令的行为不可测，
运行状态不能没有监控（例如，行连续字符文档（here document）作为输入并且忽略输
出），所以，在调用过程中，驱动ed模式的程序就需要一个协议和相应的状态机。这就
引发了我们在第7章讨论从进程控制时需要注意的问题。
    不管怎么说，在支持完全交互的程序当中，这种模式最简单、也最具有脚本化能力。
相应地，作为我们下面要讨论的“引擎和接口分离’’模式的一个组成部分，这种模式仍
有相当作用。
11.6.7 Roguelike模式
    V
    Roguelike模式的名字来自这种模式的第一个例子：BSD下的地牢探险游戏rogue（1）
（参看图111.2）；以形容词“roguelike"来命名这种模式已经广泛地为Unix传统所接受。
Roguelike程序是设计来运行在系统控制台、X终端模拟器或视频显示终端上的游戏，使
用全屏幕、支持可视界面风格，但使用字符阵列显示，而非图形和鼠标界面。
www.pdf365.com
11.6 Unix接口设计模式
271
                                                                       a）  some food
                                                                               b） +1 ring mail [4] being worn
                           I                      e） 28 +0.+0 arrows
                               -十-                                f） a short bow
                          #                                 i） a magnesium wand
                            #                                 g） a magnesium wand
                        ###                            - j> a potion of detect things
1） a scroll of taleportation
-press space to continue-
 I               #
 I        ##
    图11.2  Rogue游戏最初版的屏幕截图
    尽管可以打开一个命令窗口（常常但并不总是，在屏幕的最后一行）来键入更复杂
的命令，但命令通常是单键触发而且不回显给用户（正好同ed模式的命令行相反）。命
令体系常常大量使用箭头键来选择屏幕或行位置以进行操作。
    这种模式的程序常常以Vi（1）或emacs（1）来作为模型，并且（遵循最小立异原
则）使用它们的命令集来作为如获取帮助或是终止程序之类的常规操作。也就是说，例
如，使用“x"、“q"或是“C-x C-c”来终止～个程序的方法也可以在这种模式中找到。
    其它有关这种模式的接口特征包括：  （a）使用每项一行的菜单，并且当前选中项加
粗或反白显示，和（b）“模式行”——程序状态摘要由一介高亮的屏幕行显示，常常在
屏幕的底部或者顶部附近。
    Roguelike模式是在一个视频显示终端的世界里发展而来的，很多中断没有箭头键和
功能键。在有图形能力的个人电脑世界里，字符阵列终端已经是一个褪色的记忆，很容
易遗忘了这种模式在设计上产生过的影响；但是早期的roguelike模式范本程序产生在
1981年IBM将PC机键盘标准化之前的好几年。结果，roguelike模式存在一个现在已成
为陈旧部分的传统，那就是任何时候，只要不作为编辑窗口中的待插入字符解释，  “h，
j，k，I”键便固定作为光标键来使用；而且总是“k”上，“j”下，"h”左和“l，，右。这

272    第1 1章接口：Unix环境下的用户接口设计模式
个历史也可以解释为什么老式的Unix程序常常用不到ALT键，对功能键的使用也非常
有限。
    遵循这种模式的程序如过江之鲫：vi （1）文本编辑器及其所有变种，和emacs （1）
编辑器；elm （1）、pine（1）、mutt（1）和多数其它Unix邮件阅读器；tin （l）、slrn
（1）和其它Usenet新闻阅读器；lynx（1）网页浏览器；还有很多。大多数Unix程序员
很多时候都是与这种接口的程序打交道。
    Roguelike模式的程序难以脚本化：实际上，甚至连脚本化的意图都很少有。另外，
这种模式使用原始方式的逐字符输入，这对脚本化来说并不方便。也很难以编程方式解
析其输出，因为它通常由一序列递增的屏幕绘制动作组成。
    在可视性方面，这种模式远没有鼠标驱动的完整GUI那般流畅。虽然使用全屏界面
是为了支持简单类别的直接操作和菜单接口，但roguelike程序仍然要求用户学习～个命
令集。的确，以roguelike模式构建的界面昭示了一种退化成令人迷惑的原始模式和使用
偏僻字符作为命令的趋势，只有硬派黑客才喜欢。这种模式似乎两方面都做得很差，既
不可脚本化，又下符合为终编用户设计这个新潮流。
    然而这种模式自有一定价值。Roguelike式邮件程序、新闻阅读器、编辑器和其它程
序仍然相当流行，甚至即使存在同类的GUI竞争程序，人们也总是愿意通过X显示模拟
终端来运行它们。更进一步，roguelike模式在Unix下非常普遍，甚至GUI程序也常常
模仿，虽然给命令和显示界面增加了鼠标和图形支持，但是看起来仍然像是roguelike程
序oX方式的emacs（1）和xchat （1）客户端就是这种改编的良好示例。那是什么使得
这种模式如此持久地流行呢？
    效率，可以察觉的效率，似乎是个重要的因素。Roguejike程序相对于GUI对手而言
常常更快捷轻巧。在Xterm中，考虑启动和运行速度，执行一个roguejike程序无疑比调
用一个消耗大量资源来建立显示并且响应更慢的GUI程序更为可取。同时，roguelike程
序可以使用在根本就不需要X的telnet连接或低速拨号连接中。
    指法熟练的人常常更喜欢roguelike程序，因为他们可以不用把手从键盘上挪开去移
动鼠标。可以选择的话，这类人更喜欢尽可能少用那些远离中间键位的键；这也许可以
说明vi （1）流行度为什么那么高。
    也评更重要的是，roguelike式的接口对于X显示上的有限屏幕空间，其使用量是可
以预计的，而且非常节俭；它们不使用多窗口、框架部件、对话框和其它GUI累赘。这
使得此种模式能够很好地适用于必须与其它程序频繁共享用户注意力的程序（尤其是在
www.pdf365.com
273
编辑器、邮件程序、新闻阅读器、聊天程序客户端和其它通讯程序的情况下）。
    最后（可能也是最重要的），roguelike模式常常更吸引重视命令集简要性和表现力
的人群，他们能够容忍记忆负担的增加。我们在上面已经看到这种偏爱的理由很充分，
尤其当任务更复杂、使用更频繁和用户经验更丰富时愈加普遍。Roguelike模式在迎合这
种偏爱的同时，也支持了ed模式无法提供的类GUI元素的直接操作。这样，rougelike
接口设计模式丝毫没继承两个世界的糟粕，反而是吸收了最精华的部分。
11.6.8  “引擎和接口分离’’模式
    在第七章中，我们反对将程序编制成单个庞然大物般的单进程，并且说明了将程序
分解成几个相互通讯的进程常常可以降低整体复杂度。在Unix世界中，这种策略的应用
方式通常是：将程序的“引擎’’部分（程序定义域的核心算法和逻辑规格）从“接口”
部分（接受用户命令、显示结果、或者提供交互帮助和命令历史记录）分离。实际上，
这种引擎接口分离模式可能是Unix最具特色的接口设计模式。
    （另一个更显然胜任于此的模式是过滤器。但是比起数据双向流动的引擎，接口组合
来说，过滤器在非Unix环境中更为常见。模拟管线很容翁；而IPC机制越复杂，引擎／
接口组合就越难以实现。j
    Owen Taylor，作为X下广泛用来编写用户界面的GTK+库维护者，在笔记《为什么
GTK_MODULES不是个安全漏洞》  （Why GTK- MODULES is not盘security hole）
<http：／/www．gtk．org／setuid．html>的末尾漂亮地给出了这种划分对工程的好
处；他这样结束到“安全可靠的setuid程序是一个500行规模的程序，只做该做的事，
并非～个500，000行规模、只做了用户界面的程序。”
    这并不是一个新想法。在施乐PARC图形用户接口的早期研究中，就提出了将“模
型一视图一控制器’’模式作为GUI原型的建议。
●  “模型”在Unix世界里通常称为“引擎”。模型包含了应用程序专用定义域的
    数据结构和逻辑。数据库服务器是模型的原型例子。
●  “视图”部分将定义域的对象渲染成可视形式。在一个真正分离得当的模型／视
    图／控制器应用程序中，视图组件由模型通知更新，并且自身作出相应反应，而
UNIX编程艺术
    www.pdf365.com
274    第1 1章接口：Unix环境下的用户接口设计模式
不是由控制器或被显式更新请求来同步驱动。
    ●  “控制器’’处理用户的请求并将它们作为命令传递给模型。
    在实践中，视图和控制器部分结合常常比两者同模型部分的结合更为紧密。例如，
多数GUI，组合了视图和控制器行为。而往往只在应用程序需要模型的多重视图时才把
它们分开。
    在Unix下，模型／视图／控制器模式比起其它领域都更为普遍，这恰恰因为Unix中存
在“只做一件事并做好”的牢固传统，同时IPC方法既灵活又易于实现。
    这种技法尤为强大的一种形式是将策略接口（通常是结合了视图和控制器功能的
GUI）和包含了一个专用定义域微型语言解释器的引擎（模型）相连。我们在第8章讨
论过这种模式，当时侧重微型语言的设计，现在看看这样的引擎是如何以各种不同方式
形成大型代码系统的组件的。
    下面是这个模式的几个变种。
11.6.8.1  配置者／执行者组合
    在配置者／执行者组合中，接口部分控制运行时无需用户命令的过滤器或者类似守护
进程的启动环境。
    fetchmail（1）和fetchmailconf（1）程序（我们已经作为可显性和数据驱动编程的分
析实例讨论过，并且还会在第14章语言的实例丹析中遇到）就是一个配置者／执行者组
合的很好例子。fetchmailconf是一个随fetchmail -起发布的交互式点文件配置器。同时，
fetchmailconf也可以作为一个GUI包装器以前台或者后台的模式运行fetchmail。
    这种设计模式让fetchmail和fetchmailconf可以让它们的专工发挥用武之地，并且也
确实根据任务定义域的不同而使用不同的语言写成。fetchmail，通常作为一个后台邮件
程序，不需要臃肿的GUI代码。相反的，fetchmailconf可以醉心于精致的GUl，而无需
被迫支付fetchmail已经耗费的规模和复杂度成本。最后，因为它们之间的信息通道定义
严谨得法，所以仍然保留了从命令行或脚本中，而不是用fetch，naitconf启动fetchmail的
能力。
术语“配置者／行动者”是我的发明。
www.pdf365.com
275
11.6.8.2
    在批处理模式需要序列化访问共享资源的情形下，一个配置者／执行者组合的轻微变
形非常有用；也就是说，当一个定义得当的任务流或申请序列需要访问某些共享资源，
又没有单个任务要求用户交互的情形下，这种变形十分有效。
    在这种假脱机／守护进程（ spooler/daemon）模式中，spooler或者前端仅仅简单地将
工作请求和数据放到待处理区域。工作请求和数据是简单的文件；spool区域典型上就是
一个目录。这个目录的位置和作业请求格式由spooler和daemon协商。
    守护进程永远在后台运行，不断轮询spool目录，看看那里是不是有工作可做。当它
发现一个作业请求，就会尝试处理相关数据。如果成功，作业请求和数据就会从spool
区域删除。
    经典的例子就是Unix打印服务系统，lpr（1）/lpd（1）。前端是lpr（1）；简单地将要
打印的文件放入spool区域供tpd定时扫描。lpd的工作仅仅就是序列化访问打印机设备。
    另一个经典的例子是at （1） latd （l）组合，按照时间表在指定的时间运行程序。第
三个例子，虽然现在使用不多，但在历史上很重要，就是UUCP-Unix到Unix的拷贝
程序（Unix-to-Unix Copy Program）．在1990年代互联网大爆炸之前，通常应用于拨号连
接上的邮件传输。
    Spooler/daemon模式在邮件传输程序（天然就是批处理方式）中仍然很重要。邮件
传输的前端比如sendmail（1）和qmail （1），常常只是经过SMTP通往外部的互联网连
接直接试发送邮件一次。如果失败，邮件便会放进一个spool区域：由一个后台版本或者
运行于邮件传输者模式的程序在稍后重发邮件。
    典型地，一个spooler/daemon系统具有四个部分：～个作业发布者、一个队列列表
器，一个作业撤销功能和一个带spooling的守护进程。实际上，前面三个部分就是明显
的线索，表明了在它们幕后某处一定有个后台spooler发送器。
    术语“spooler”和“daemon’’都是Unix的老行话。（“spooler，，实际上可以追溯到
早期的大型机时代。）
11 .6.8.3驱动／引擎组合
    在这个模式中，同配置者／执行者或spooler/server组合不同，组合的接口部分需要向
引擎提供命令并在启动后解释引擎的输出；而引擎的接口模式很简单。所使用的IPC方
法只是实现的具体细节：引擎可烈是驱动的一个从属进程（这方面我们在第7章有所讨
论）或者引擎和驱动可以通过套接字、共享内存或其它IPC方法进行通信。关键是（a）
两者的交互性，和（b）引擎以自身接口单独运行的能力。
UNI×编睡；艺术
  www.pdf365.com
276
第1 1章接口：Unix环境下的用户接口设计模式
    这样的组合写起来要比配置者／执行者组合更费脑筋，因为它们结合得更紧密且错
综复杂；驱动器不仅仅必须知道引擎期望的启动环境，还必须知道它的命令集和响应
格式。
    当引擎设计便支持脚本化时，驱动部分在很多情形中是其他人而不是引擎作者来编
写，一个给定引擎有不止一个前端驱动的例子不少见。程序gv （1）和ghostview（1）提
供了一个很好的例子，它们都是Ghostscript解析器gs（1）的驱动。GhostScript把PostScript
转换成各种各样的图形格式和底层的打印机控制语言。gv和ghosfi，i已w程序为GhostScript
提供GUI包装，以避免使用特殊的调用开关和命令格式。
    这种模式的另一个范例是xcdroast/cdrtools组合。cdrtools发布包提供～个命
令行界面的cdrecord（1）程序。而cdrecord程序代码专职于与CD-ROM硬件相关的所
有工作。xcdroast则是一个GUI:专门用来提供一个舒适的用户体验。xcdroast程序大部
分工作是通过调用cdrecord（1）来完成的。
    xcdroast也调用其它CLII具：cdda2wav（1）（一个声音文件转换器）和mkisofs
（1）（从一组文件中创建IS0-9660格式CD-ROM文件系统映像的工具）。如何调用
这些工具的细节被隐藏起来不为用户所见，所以用户可以更集中精力在制作CD的任务
上，而无需直接知道关于声音文件转换的奥秘或文件系统结构。同样重要的是，这些
工具的每一个实现者都能够集中精力在他们擅长的特定领域，而无需成为一个用户界
面的专家。
    驱动／引擎模式一个关键的缺陷是，通常驱动必须知道引擎的状态以便能反馈
给用户。如果引擎的动作非常快，就不存在问题，但如果引擎可能需要花费较长
时间（比如，当访问许多URL时），反馈的缺乏就会是个严重的问题。对错误的
响应也类似。例如，传统（尽管不太像Unix方式）的是否成功覆盖一个文件的确
认询问，要在驱动器／引擎世界中表现出来就相当困难；发现问题的引擎不得不请
求驱动提示确认信息。
-Steve Johnson
    设计引擎，重要的是不仅要让它能够正确地完成任务，还要通知驱动它在做些什么，
这样驱动才能表现为一个具有恰当反馈信息的优雅接口。
术语“驱动”和“引擎”使用并不普遍，但是在Unix社区已经习用。
www.pdf365.com
鹫1{，3  ×ogroa虢图澎器露
莲孽。6游；尊客户端／服务器缝叁
    客户端绸篓务器缀合类似驱动，弓|鬻，然而引擎部分是……个不需要交互、运行在螽台、
不需自费翔户界面的程序。邋常，设~'“后台程序来溺度对某种共享爨源的访闻——数据
库、事务流，戴专门的共享硬件，如声音设备。男一个这样设计的理由憝可以避免在程
序每次稿动时的操俸过j于复杂。
    过去的实际例子是却（i）抑露（i）程序对，它们实现了霹笋，（文件传输协议我i棼
T谶ns诧f驴簟。￡◇#◇{）；又或者是两个髫榭西辩群i“1）的运行实例，发送端在翦瑞，监听端在
后台，以此传输电子邮件。如今，任何浏览器／网页服务器组合都是这种模式。
    然而，这种模式不仪仅局限‘F通篱程序；另…‘4个重要的情况怒数据库，例如尹蓐∥（{）
勿甜㈤琏s据r（1）程序对。这：蘩，妒。9鸟萝连续谤阀…个由尹秽s氇㈨s瑟台程序管理的共享鼗据
库，传送SQL请求并显示网传的响应数据。
www.pdf365.com
278    第1 1章接口：Unix环境下的用户接口设计模式
    这些例子说明了这种配对的一个重要特性，那就是它们之间保持通信协议的简明清
晰处于第一重要地位。如果协议定义得当，并且由～个开放标准所描述，那么客户端程
序极有可能完全与服务器资源管理无关，并同时允许客户端和服务器端半独立发展。当
然，所有引擎，接口分离的程序都有可能从清晰的功能分离中获益，但在客户端朋艮务器情
况下，正因为管理共享资源在本质上相当困难，所以正确分离倾向的权重往往特别的高。
    消息队列和成对的命名管道也可以用作前端／后端的通讯，但是能够在与客户端不同
种类的机器上运行服务器的好处非常巨大，所以如今几乎所有现代的客户端／服务器都使
用TCP/IP套接字来完成通信。
11.6.9  CLI服务器模式
    在Unix世界中，统一掌控程序启动服务器进程是很平常的4，比如inetd（1）等，
它们通常的工作方式是：服务器从标准输入接收命令，然后将响应发送到标准输出；然
后掌控程序负责确保服务器的stdin和stdout连接到专用的TCP/IP服务端口。这种功能
划分的好处之一是针对所启动的全部服务器程序，守护程序都可以作为一个独立的安全
门卫。
    CLI服务器是经典的按口设计模式之一。这种程序以前端方式触发时，有一个简单
的CLI界面读取标准输入而写入标准输出；以后台方式运行时，一旦程序检测到这种方
式就将标准输入和标准输出连接到专门的TCP/IP服务端口。
    在这种模式的一些变体中，默认方式就是服务器后台运行，而当需要用前端方式运
行时应在命令行选项中指明。这是个细节；关键是多数代码的书写号既不知道也不关心
它是运行在前端还是在一个TCP/IP控制程序中。
    POP、IMAP、SMTP和HTTP服务器程序通常都遵循这种模式。这种模式可以和本
章早些时候讨论的任何服务器／客户端模式结合使用。  ．个HTTP服务器也能够作为一个
掌控程序运行；网页上提供大多数实况内容的CGI脚本运行在由服务器提供的特殊环境
4统一掌控程序是一个包装器，它的工作是让某种资源可以被它调用的程序访问。这个术语最通常用
来指测试掌控程序，它为当前需要被检验的输出获取测试负荷和（常常）正确的示范输出。
www.pdf365.com
279
中，在那里，它们可以从标准输入接受输入（表单参数），并且可以将生成的HTML输
出到标准输出。
  尽管这种模式有古老传统，但术语“CLI服务器”却是我的发明。
11.6.10基于语言的接口模式
    在第八章我们讨论了专用定义域微型语言，它把程序的规格说明提升到一个更高的
层次，从而更具灵活性、bug更少。这些优点使得基于语言的CLI成为Unix接口的一个
重要特点-Unix的shell本身即是一例。
    这种模式的威力，在本章稍前比较dc （l） lbc（1）和xcalc（1）的例子中表现得淋
漓尽致。我们原先评述过的优点（在表现力和脚本化能力方面的收益）是微型语言特有
的优点；并可以推广至其他情形，比如在一个专门的问题域里不得不将复杂操作序列地
进行组织。通常，与计算器例子不同的是，微型语言在简洁性方面也有明显优势。
    最有力的一种Unix设计模式，就是GUI前端同CLI微型语言后端的组合。这种类
型的优秀设计实例相当复杂，但是比起只涵盖微型语言小部分功能，而使用大堆专门代
码的做法，要简单灵活得多。
    当然，这种通用模式，并不为Unix所独有。例如现代几乎任何数据库套件都由一个
或几个GUI前端和报表生成器构成，这些前端仝部使用诸如SQL查询语言与一个统一的
后端通讯。但是这种模式主要在Unix下发展起来，并且比在其它任何地方都得到了更好
的理解和更广泛的应用。
    当实现这种模式的系统前端和后端在一个单一程序中结合起来时，程序往往被称为
拥有一个“内嵌脚本语言”。在Unix世界里，Emacs是这种模式最著名的范例之一；其
优点可以参考我们在第8章的讨论。
    GIMP的script-fu功能是另外一个范例。GIMP是一个强大的开源图形编辑器，拥有
一个类似Adobe Photoshop的GUI界面。Script-fu允许GIMP以Scheme（Lisp的一种方
言）进行脚本化；也可以使用Tc!、Perl或Python编写脚本。通过插件接口，用上述任
何语言编制的程序都可以调用GIMP内部函数。这项功能的示例应用就是一个网页-，该
 Script-Fu网页<ht七p : / /www . xc f . berkeley . edu／～gimp/ s cript - fu/scrip七- fu . html>。
UNIX绸睡；艺术
    www.pdf365.com
280
第1 1章接口：Unix环境下的用户接口设计模式
网页通过CGI接口给一个GIMP实例传递生成的Scheme程序，然后返回处理好的图像，
从而允许人们构建简单的1090和图形按钮。
11.7  应用Unix接口设计模式
    要促进脚本化和管道线能力（参考第7章），最好就是尽可能地选择晟简单的接口
设计模式——牵扯环境因素最少、交互最少的模式。
    在上述单个组件模式中，特别强调了该模式在启动之后是否需要和用户交互这一点。
当经常希望“用户”是另外一个程序（这样的“用户”当然缺少人脑的认知范围和灵活
性）时，脚本能力达到最大化就是一个很有价值的特征。
    我们已经看到了在各种不同情况下针对不同价值特征进行优化的各种接口设计。特
别地，在适合初学者和非技术型终端用户的GUI及其设计模式（这是一方），以及服务
于专家用户和最大化脚本能力（另一方）之间，存在一个强烈的与生俱来的冲突。
    摆脱这种两难境地的方法之一就是让程序能够以不止一种方式运行。一个优秀的例
子就是网页浏览器lynx （1）。对于交互式使用，它通常有一个roguelike式的接口，但
是调用时使用- dump，又以源模式工作，指定的网页被格式化为文本在标准输出端输出。
    然丽，当程序需要一个真正的GUI时，一般都不会尝试这样的双重接口。部分原因
是历史造成的，但最重要的原因是控制整体复杂度。GUI往往要求复杂的启动配置和大
量的专用代码：这些特征难以与简单模式共存。在最坏的情形下，一个双重模式的GUI/
非GUI程序需要两个独立的命令解释循环，这就意味着代码膨胀和潜在的不一致性。
    这样，当“选择最简单的模式”同生成一个GUI的需求相抵触时，Unix的方法是将
程序一分为二，这样“分离引擎和接口”设计模式派上用场。
    事实上，将这种思想同第7章的主题相结合，我们也许可以命名一种在Linux和其
他现代开源Unix中出现的新设计模式，尤其当GUI并不仅仅只是一个勉强的附属品，
而是一个众多开发工作的活跃焦点时。
www.pdf365.com
11.8网页浏览器作为通用前端
281
多价程序模式
    一个多价程序（polyvalent，多角色程序）有以下特征：
    1．程序的应用定义域逻辑封存在一个文档化的API库中，该库可被其它程序链接。
程序同外部的接口逻辑是一个基于库的薄胶合层。或者有几个不同风格的UI层，每一个
层都可以链接该库。
    2．一种UI方式是cantrip，类似编译器或以批处理方式执行交互命令的CLI模式。
    3．-种UI方式是GUI，可直接链接到核心库，或者作为一个独立进程来驱动CLI
接口。
    4．-种UI方式是脚本接口，使用现代的通用脚本语言，如Perl、Pvthon或Tcl。
    5．额外可选的一种UI方式是使用curses （3）的roguelike式接口。
    注意，GIMP事实上满足此种模式。
11.8网页浏览器作为通用前端
    自从1990年代中期万维网引起计算机世界天翻地覆的变化以来，将CLI后端从GUI
界面中分离出来已经成为一个愈来愈具吸引力的策略。对于一大类的应用程序，这种策
略使你根本无需编写一个定制的GUI前端，而是征用网页浏览器来扮演该角色。
    这种方法有许多优点。最明显的就是不必非要编写GUI程序代码——而可以用专擅
于此的语言（HTML相JavaScript）描述GUI。这就避免了许多昂贵、复杂、用途单一的
代码，无需为此花费整个项目一半的时间和精力。另外，这使得程序可以立即用在互联
网上；前端和后端既可以在同一个机器上，又可以远隔千里。此外，程序的所有次要表
现细节（比如字体和颜色）都不再是后端需要处理的问题，实际上可以由用户自己通过
一些像浏览器设置和级联样式单之类的机制按自己的口味定制。最后，网页界面的统一
元素充分减少了用户的学习负担。
    这种方法当然也有缺点。最重要的是（a）网页强迫以批处理风格处理交互操作，（b）
使用无状态协议管理持久会话非常困难。尽管这些并不是Unix专有的问题，但我们还是
UNIX奎静呈艺术
  www.pdf365.com
282
第1 1章接口：Unix环境下的用户接口设计模式
The program
    图11.4在多价程序中调用者／被调用者的关系
要在这里讨论——因为对于在设计层面思考清楚何时值得接受或绕开这些限制是非常重
要的。
    CGI-公用网关接口（Common Gateway Interface），通过它，浏览器可以调用服务器
主机上的程序，但它并不支持精细粒度的交互性。渐渐取代它的模板系统、应用服务器
和内嵌服务器脚本（我们将在本节使用CGI代表所有这些语言滥用）也不行。
    通过CGI网关并不能实现逐字符或逐GUI手势方式的v0;相反的，必须填完HTML
表单并且点击提交按钮才能将表单内容发送给CGI脚本。之后运行CGI脚本并由服务器
回传其产生的HTML页（可能本身也是另一个CGI表单）。
    这本质上是一种交互的批处理风格，不是那种早已消失的在输入口放入打孔带然后
得到打印输出的观念。使用JavaScript同用户交互，将事务批量处理成消息发送给服务器，
这种方法更为方便。
    Java小应用程序可以建立自己的字符流回连接服务器，以支持更平滑的交互行为。
但是Java还存在技术问题（仅仅只能在页面上使用固定的显示区域，并且不能够改变显
www.pdf365.com
11.8网页浏览器作为通用前端
283
示框之外的显示部分）以及更糟的政策问题（来自Sun公司的专利许可权耽误了Java的
部署，而且别人不愿意用它；不能指望所有的浏览器都支持Java小应用程序）。
    Java和JavaScript都会遇上浏览器不兼容问题。微软坚持不在Intemet Explorer上实
现JDK l.2和Swing，这对于Java小应用程序来说是个严重问题，而JavaScript版本的差
异也同样会崩掉程序（尽管JavaScript的bug比较容易纠正）。然而，处理这些问题通常
都不会比编写和部署一个定制的前端需要更多的努力。较难以处理的是越来越多世故的
用户，出于安全性问题和避免界面的滥用，惯例地将他们浏览器中的Java甚至JavaScript
功能都禁用了。
    另一个不相干的问题是，维护跨越多重CGI表单的会话信息需要太多技巧。服务器
不能够保留客户端同CGI事务处理之间的对话状态，所以不能依赖它将同一用户的前后
表单提交相关联。有两种方法来规避这个问题：链式表单和浏览器cookie。
    当使用链式表单时，必须安排CGI在第一个表单的不可见字段中为第二个表单产生
一个唯- ID，而第二个表单和所有后画的表单都将这个ID传递给它们的后继者。Cookie
以不太直接的方式达到同样的效果，有点像环境变量（细节参考关于众多CGI设计书籍
中的任何一本）。随便哪一种情形，CGI都必须使用ID作为一个会话索引（或是cookie
来直接缓存状态）和显式地处理复用会话。
    通常情况下，这些限制可以忍受。许多非平凡的应用程序，用单个表单和响应就可
以满足，从而可以规避那两个问题。即使这不现实，程序要求多重表单，但编制和发布
一个专门前端的复杂度和成本巨大，节省下来，完全可以轻易写出足够聪明的CGI来跟
踪自身对话。
    会话管理问题可以由应用服务器例如Zope或Enhydra来解决，它们提供了一个会话
抽象，并且为嵌入它们的程序提供了诸如用户验证的服务。这些程序的缺点也是它们的
优点：它们可以轻易地在服务器上保留每个用户的状态。但这可能会成为一个问题；它
消耗资源，必须设置超时，因为在事务处理之间没有方法可以知道用户是不是还在线上
的那一端。
    通常，最好的建议是尽可能选择最简单的模式。当简单的CGI和cookie就足以应付
工作时，要抵挡住靠Java或应用服务器来编写重量级设计的诱惑。
    浏览器作为通用前端的方法还存在一个问题，那就是CGI盾端不是立即可以从浏览器
环境中分离的，所以难以脚本化或是将事务自动化到后端。Unix的解法是三层结构——
UNIX编陋；艺_术
  www.pdf365.com
284
第1 1章接口：Unix环境下的用户接口设计模式
网页窗体调用CGI，CGI调用命令。而命令集就是自动化的接口。
    浏览器解开前端和后端耦合的方式具有重大意义。在网络上，随着网络的发展趋势，
将用户锁进某个封闭专属协议和API集变得越来越困难也越来越缺乏吸引力。软件开发
的经济大潮也越来越倾向于HTML、XML和其它开放的、基于文本的互联网标准。这种
趋势也以有趣的方式增强了开源开发模式的发展，这一点我们将在19章给予讨论。在网
络正在创造的世界里，Unix的设计传统——包括本章讨论的接口设计——看起来比以往
更加亲切。
11.9沉默是金
    在没有涉及缄默原则，这个Unix中最古老最持久的设计比喻之前，我们还不能就这
样抛开用户接口交互性这个主题。我们在第一章提到过如果程序没有什么有趣的或是惊
奇的东西要说就应该闭嘴，并且有充分的理由相信：它比Unix诞生时出现的缓慢电传打
字机还要长命。
    理由一：喋喋_小休的程序往往不能跟其它的程序很好地合作。如果CLI程序向标准
输出发送状态信息，那么尝试解析这个输出的程序就会落入是解析还是丢弃这些信息的
两难境地（即使一切都不会出错）。较好的方法是只把真正的错误信息发送到标淮的错
误输出端，而不要发送任何未请求的信息。
    理由二：用户屏幕的纵向空间是宝贵的。程序每产生一行垃圾，用户可见的信息就
少了一行。
    理由三：垃圾信息是对用户带宽的无谓消耗。在屏幕上，这又增加了一个分心的来
源，往往让人们不得不在处理更重要的前台工作（例如同他人的交流）的同时耗费心力。
    长时间的操作要提供进度条。这是个好传统——帮助用户有效地分时利用他的大脑，
暗示在等待完成的过程中可以离开去阅读邮件或是干点儿别的。不要杂乱地让GUI界面
弹出确认消息除非必要的警示而且进一步，父窗口最小化时应隐藏这些信息，又如果焦
点不在父窗口时，应避免这些信息。2界面设计师的工作是方便用户，而不是在用户面前
碍眼。
2如果你的窗口系统支持在用户和程序之间产生较少妨碍的半透明弹出框，那就使用它们。
UN/X编程艺术
    www.pdf365.com
11.9沉默是金
285
    通常，老是告诉用户他们已经知道的事情是非常糟糕的风格（“程序<foo>正在启
动…”，或是“程序<foo>正在退出”就是两个经典违例）。接口设计作为整体应该遵从
最小立异原则，但是信息内容应该符合最大惊奇原则——仅仅对偏离通常期望的情况详
加说明。
    这个原则对于确认提示有着更强的力量。不断询问的答案几乎都为“是”的请求确
认会造成用户根本不假思索就点击“是”，这个习惯会带来非常不幸的结果。程序应该
只在有足够理由怀疑答案可能是“不不不！”的时候请求确认。并非意外却要求确认是
糟糕设计的显著标志。任何确认提示本质上也许就是接口实际上需要一个撤销命令的标
志。
    如果为了调试，需要喋喋不休的进展消息，添加默认情况下禁用的高详细度（verbosity）
选项。在发布产品时，尽可能多地将需要显示的正常消息转移到启用高详细度选项开关
下。
UNIX编程艺术
  www.pdf365.com
www.pdf365.com
1 2
优化
Optimization
Premature optimization is the root of a// evil.
    过旱优化乃万恶之源。
    -C．A．R．Hoare
    这将是很短的一章，因为关于性能优化，Unix的经验告诉我们最主要的就是如何知
道何时不去优化。其次，最有效的优化往往是优化之外的其它事情，如：清晰干净的设
计。
12.1  什么也别做，就站在那儿
    程序员工具箱中最强大的优化技术就是不做优化。
    有几个理由支持这项禅式的忠告。其中一个是摩尔定律的指数效应——最聪明、最
便宜、常常也是最迅速的性能提升方法，就是等上几个月，期望硬件性能更好。考虑到
硬件和程序员时间成本比率，总是有更值得打发时间的事，别去优化一个工作中的系统。
    这是有数学上的理由的。如果仅仅只是为了减少资源使用的一个常数部分而优化，
那是很不值得的。更明智的做法是集中精力将时间复杂度或空间复杂度从O（n2）降至
UNIX编腥艺：术
  www.pdf365.com
288
第1 2章优化
O（n）或O（n log n）l，或者类似地，从一个更高次的指数降下来。线性性能增益往往很快就
会被摩尔定律覆盖了。2
    另一个非常有建设性的“无为”方式就是不写代码。程序性能不可能因不存在的代
码而降低。而存在、但不如所设想那样高效的代码可能会降低程序的性能——但那是另
一码事了。
12，2先估量，后优化
    如果有真凭实据证明应用程序运行缓慢，这时（仅当此时）才可以考虑优化代码。
但付诸实施前，要先估量。
    回顾第一章Rob Pike的六条法则。最初的Unix程序员最先学到的经验之一就是要
明确瓶颈所在，直觉实在是个糟糕的向导，即使特别熟悉可疑代码的人也不例外。Unix
同多数其它操作系统不一样，它通常带有性能剖析程序（profiler）；要善加利用。
    阅读profiler诊断的结果是一门学问。存在几个经常出现的问题：一是工具误差，二
是外部强加的延迟，三是过度调用图中顶部节点。
    根本的问题是工具误差。Profiler靠插入指令来工作，这些指令可以报告子程序入口
和出口之间、以及程序内嵌代码中固定间隔的执行时间。这些指令的执行同样需要时间。
结果就是减少了调用时间的差量：很短的子程序往往看起来较实际费时，茌相当的调用
时间中，存在大量工具噪声，而对于长一些的程序，工具的额外开销是很难察觉的。
1对于不熟悉O记法的读者，这是一种表示一个算法的平均运行时间如何随着输入量大小而变化的
方法a一个o ci）的算法，其运行时间是常数。一个O（n）的算法，其运行时间可以预测为An+
C，这里，A是某个待定的比例常数，而C是某个未知常量代表启动时间。线性链表查找的时间复
杂度是0 （n）。一个O（n2）算法的运行时间是An2加上低次项（可能是线性的、对数的，或任何其
它低于二次的函数项）。链表中重复值的查找（不经排序的简单方法）就是0（112）的。同样的，O（n3）
算法的平均运行时间可以用问题规模的三次方来预测，这对于实际用途往往过于缓慢。树查找是典
型的O（Iog n）算法。对算法的明智选择常常可以将运行时间从O（n2）降至O（log n）。有时我们希望蓣
测算法的内存利用量时，也可以注意到同样有0（1）或O（n）或O（f12）的区别；总的来说，空间复杂度
是O（F12）或更高的都是不适用的算法。
2引用摩尔定律：每十八个月性能翻一番。这暗示晚六个月买新机器就可以获得26%的性能提升。
UNIX编程艺术
www.pdf365.com
12.2先估量，后优化
289
    谨记工具误差，明智的做法是假定在最快和最短子过程的执行时间中，存在不少泡
沫。频繁调用会耗去大量时间，所以，要特别注意统计它们调用次数。
    外部延迟问题也是根本的。在profiler背后，会有许多不同种类的延迟和畸变。最简
单的带有不预期延迟操作的额外开销——磁盘和网络访问、缓存填充、进程切换等等。
如果仅仅是这些那还好了——也许你刚要检测它们，特别地，如果想检测整个系统的性
能而不仅仅只是某个关键的内部循环。问题是它们存在随机的因素，那意味着任何单一
的profiling结果并没有多大用处。
    将这些误差源影响降到最低的一个方法，就是综合多次profiler结果，可以在一般情
况下得到更好的运行时间图。有不少充足理由支持在优化之前为程序编制测试工具和测
试负载；这远比性能调整重要得多，在程序改变之后，可以进行回归测试以检验其正确
性。一旦这样做了，就可以对相同负载的重复测试运行profile，这是一个很好的副作用，
能够获得更有用的信息比单独手动的几次profiling强。
    各种各样的效应常常导致时间耗费在调用例程而不是例程本身上，从而造成调用图
中项部节点负担过重。例如，函数调用开铛，就常常算到调用例程上（这一点部分依赖
于机器体系以及profiler工具是不是允许插入探针（probe））。如果编译器支持的话，
宏和内联函数，根本不会在profiling报告中显示；它们耗费的每一份时间都算在了调用
函数的头上。
    更重要的是，许多时间分析工具都将子程序的时间开销加到了调用程序中。  （随开
源Unix -道发布的gprof（1）就是如此。）如果同一过程有不止一个调用者，简单地从
调用程序开销中减去被调用程序开销的结果用处不大——这样会人为缩小两者的时间
差距。尤其麻烦的是如下这种常见情况：一个公用函数存在多个调用点，其中一些是简
单调用，而其它地方却产生～些复杂的调用。
    为了得至Ⅱ更透明的结果，分解代码，让高级例程尽可能多地调用底层例程、而不是
内嵌代码。如果能够保持高层控制逻辑的开销最小，代码的这种调用结构往往可以让
profile报告相对来说更容易阅读一些。
    使用profiler，并不只是简单收集孤立的性能数字，更应该把它当作一个具备许多有
趣参数的函数（例如，问题规模、CPU速度、磁盘速度、内存大小、编译优化，或其它
相关因素）来研究性能是如何随之变化的，这样，才会有更多领悟。接着可以使用开漂
UNIX编腥艺-术
    www.pdf365.com
290
第1 2章优化
的R软件或是高质量的专有软件比如MATLAB，试着将这些数据拟合成一个模型。
    在模型模拟中，自然平滑的数据往往集中在大的效应上，小的有噪声的常常
  被忽略。例如，用MATLAB模拟立方体的矩阵翻转例程，来处理10×10到1000
  ×1000的随机矩阵，很明显地，我们的情况正好具备清晰定义的边界，大致对应
  “在缓存中’’、  “在内存中但不在缓存中”和“不在内存中”。即使目的并不在
  此，但数据仍向我们揭示了这种效应，你只需看看与最好的拟合曲线有多少偏差。
12.3非定域性之害
-Steve Johnson
    最有效的代码优化方法就是保持代码短小简单。我们在本书的前半部分已经给出了
许多保持简单的良好理由。这儿还有个新的：永远不要将核心数据结构和时问关键循环
抛出缓存。
    把目标机器看成一个存储类型的分层结构，按照距离处理器的远近来排列：处理器
自身的寄存器；指令管线；一级缓存（LI）；二级缓存（L2）；可能还有三级缓存（L3）：
主存（Unix老手仍然别致地称之为“核心”）；以及交换空间所在的磁盘驱动器。诸如
对称多处理SMP、共享内存集群和非均匀存储访问（NUMA）之类的技术给这个图增加
了更多的层次，但仅仪增加了总体的延展宽度。
    每一种对此栈的访问方式变得越来越快。处理器周期几乎不用考虑，除了一些苛刻
的应用，例如核爆炸建模和实时视频压缩等等。但是，随着处理器速度的提升，别的也
发生了，那就是存储层级间的速度比率也上升了。这样，缓存未命中的相对成本也提高
了。
    所以我们有一个有趣的悖论。随着机器资源成本的直线下降，庞大数据结构的平均
开销也随之而降——但是因为相邻级别缓存的切换开销上升了，大型结构突破缓存容量
对性能的影响也就增加了。
    因此在这里，  “小即是美”的建议比以往更有用，尤其是考虑到核心数据结构必须
留在最快的缓存里。该建议也同样适用于代码；通常，指令加载要比执行花费的时间更
多。
www.pdf365.com
12.4吞吐量和延迟
291
    这彻底推翻了某些传统的建议。编译器优化，如循环分解，去掉相对昂贵的机器指
令而增加代码的总行数，那是不值得的。另一个例子是预先计算的小型表格——例如，
在3D图形引擎中，优化旋转操作的sin（x）函数表在现代机器中占据365 X4字节的空间。
在处理器缓冲速度没有内存查询快时，这显然是个速度优化。但是现在，比起函数表产
生的附加缓存击不中的可能开销，每次重新计算可能更快。
    但在将来，也许随着缓存的增大又会反过来。更普遍的是，不妨悲观地认为，许多
优化方法都是暂时的而且常常随着成本比例而变化。唯一可去了解的方法就是衡量后再
看。
12.4吞吐量和延迟
    快速处理器的另一个效应是性能经常受限于1/0以及——尤其是网络程序——网络
事务的开销。所以要知道为得到良好性能而进行网络协议的设计是非常有价值的。
    最重要的问题是尽量避免协议的往返。每个要求握手的协议事务都有可能从任何连
接延迟发展到潜在的严重降速。避免这样的握手并不是Unix传统做法，但需要提及，因
为许多协议设计在这个问题上造成大量性能损失。
    延迟问题怎么说都不够。X1I在避免请求来回上比X10做得好：Render扩展
  就做得更好。X（及观在的HTTP/1.I）是流协议。例如，在我的手提电脑上，每
  秒中可以运行4百万绘制lxl矩形的请求（8百万无操作请求）。但是往返请求
  的代价比这要昂责成百上千倍。如果任何时候能让客户端不用连接服务器就可以
  工作，你就成功了。
    -Jim Gettys
    实际上，经验法则是尽可能低的时延设计，和忽略带宽成本，除非profiler明白无误
地告知应该反其道而行。带宽问题可以在开发的后期通过一些技巧，比如现场压缩协议
流等等来解决，但是要在已有的设计中去除高时延则要困难得多（往往根本就不可能）。
    而这种效应在网络协议设计中最为明显，吞吐量和延迟时间的权衡就是更为普遍的
现象。在编写应用程序时，对于昂贵的计算操作，通常面临这样的选择，是一次计算反
复使用，还是按需计算（即使那意味着要经常重新计算）。在多数情况下，如果面临如
UNIX编腥艺术
    www.pdf365.com
292
第1 2章优化
此的选择，正确的做法是偏向低时延。也就是说，不要预先计算昂贵的操作，除非存在
吞吐量的要求，并且通过测量确切知道吞吐量确实很低。预先计算看起来似乎很有效率，
因为它最小化了处理器周期的使用，然而处理器周期是廉价的。除非在做计算密集的应
用程序，例如数据挖掘、动画渲染或前面讲到的爆炸模拟，否则，更好的选择是短暂的
启动和快速的响应。
    在Unix早期的日子里，这个建议也许会被视作是异端邪说。那时，处理器慢得多、
成本比例大不一样；并且，Unix的模式更倾向于强大的服务器操作。提出低延迟价值，
部分也是因为即使是新兴的Unix开发者有时也继承了旧的文化而偏向于吞吐量的优化。
但是，现在世道变了。
    有三种常规的策略来减少时延，  （a）对可以共享启动开销的事务进行批处理，  （b）
允许事务重叠，和（c）缓存。
12.4.1  批操作
    通常图形API是基于更新物理屏幕的固定配置成本非常大而编写的。因此，写操作
实际上改变的是内部缓冲区。最终还是程序员来决定什么时候将这些更新累积到可以成
批处理，然后调用某个操作来更新物理屏幕。选择正确的物理刷新间隔可以在图形客户
端产生非常不一样的感觉。Roguelike程序使用的X server相curses（3）库就是这样组织的。
    持续的服务守护进程是更典型的Unix式批处理实例。编写持续的守护进程（与每次
启动带来全新会话的CLI服务器相反）有两个理由，一个是显然的，一个有点深奥。显
而易见的理由是控制共享资源的更新。不太明显的理由，即使后台程序并不是处理更新，
也可因此分期偿还通过多请求读取后台数据库的成本。一个完美的例子是DNS后台服务
程序named（8），它有时必须处理每秒上千万的请求，每个请求都可能会阻塞用户的网页
载入。named（8）高速的原因之～就是访问保持在内存中的缓存，而不应对磁盘上描述
DNS区文本文件的昂贵解析操作。
www.pdf365.com
12.4吞吐量和延迟
293
12.4.2重叠操作
    在第五章中我们比较了查询远程邮件服务器的POP3和IMAP协议。注意到IMAP
请求（与POP3请求不同）被打上了由客户端产生的标记：服务器发送响应时，也含入
了属于该请求的标记。
    POP3请求必须由客户端和服务器端一步接一步地处理：客户端发送一个请求，等待
该请求的响应，只有在此之后才能准备并发送下～个请求。另一方面，IMAP请求是带
标记的，因此可以相互重叠。如果IMAP客户端希望获取多条消息，它可以将好几条读
取请求（每一条都有不同的标记）以流方式发向IMAP服务器，而不需要等待每条请求
的响应。每个响应也做了同样标记，当服务器就绪时，传送回来；所以，先前请求的响
应很有可能在客户端发送后续请求时，就回来了。
    这种策略在比网络协议更广泛的领域里也适用。对于减少延迟来说，阻塞或等待中
间结果都是致命的。
12.4.3缓存操作结果
    有时，按需计算出昂贵的结果，再缓存起来为以后使用，通过这种方法可以兼得鱼
和熊掌（低延迟和高吞吐量）。我们先前提到过的named程序通过批操作降低延迟：其
实，它也通过缓存先前同其它DNS服务器的事务结果的方式来降低延迟。
    缓存有其自身的间题和权衡，可以由一个应用程序很好地阐明：二进制缓存的使用
可以消除有关文本数据库文件解析的开销。一些Unix变种已经使用这种技术来加速口令
信息的访问速度（特别巨大站点的通常目的就是降低登录时的时延）。
    这种方法要想实施，所有涉及二进制缓存的代码必须检查两个文件的时间戳，如果
主文本更新了，则必须相应更新缓存。换句话说，主文本的所有变化都必须通过一个能
够更新二进制格式的包装器来完成。
    ～旦采用了这种方法，SPOT原则会引导我们发现它所有的缺点。重复的数据表明
这种存储不具备经济性——这是一个纯粹的速度优化。但真正的问题是确保缓存和主文
本一致的代码非常容易产生漏洞和bug。频繁更新的缓存文件仅仅因为秒级的时间戳分
辨率就会导致难以捉摸的竟态条件。
    ～致性在简单情况下可以保障。看看Python解析器，当第一次导入Python库文件时，
编译文件将p-code以扩展名．pyc的形式存放在磁盘上，以后都是运行p-code的一份缓
UNIX编腥艺．术
    www.pdf365.com
294
第1 2章优化
存拷贝，除非源码发生改动（这就避免了每次运行都要重新解释库源码）。Emacs Lisp
以.el和．elc文件使用同样的技术。这种技术能起作用，是因为缓存的读写访问都通
过一个简单的程序来实现。
    主文本的更新模式越复杂，同步代码就越容易产生漏洞。几个Unix变种，使用缓存
技术来加速关键系统数据库访问速度，以频发系统管理员恐怖事故而臭名昭著，恰好反
映了这一点。
    总的来说，二进制缓存文件是一项不稳定的技法，应尽量避免。在某种情况下为降
低延迟而进行的专门优化工作，常常可以更好地改善应用程序设计，从而不再有这样的
瓶颈——或者甚至可以转而加速文件系统或是虚拟内存实现。
    认为迫切需要缓存的时候，明智的做法是能够从更深层次来考虑，并问问为什么缓
存是必须的。这比将缓存的所有边界条件都考虑到要容易得多。
www.pdf365.com
1 3
复杂度
尽可能简单，
但别简单过了头
Complexity: As Simple As
Possible， but No Simpler
Everything should be made as simple as possible，but no simpler.
    事情要尽可能简单，但别简单过了头。
    -Albert Einstein
    在第1章末，我们概括Unix的哲学为“Keep It Simple，Sfupid!”。贯穿整个“设计”
部分的不变主题就是尽可能保持简单设计的重要性。但什么是“尽可能的简单’’？又如
何断定？
    这个问题的讨论一直拖延到现在，因为对“简单”的理解是复杂的。需要某些在“设
计”部分讨论的思想，尤其是第4章和第1 1章的思想，作为背景。
    本章的大部分问题都是Unix传统的核心问题，有一些甚至触发了造成数十年混乱的
内战。本章从已形成的Unix实践和专业术语出发，然后走得比本书剩下部分稍微更深入
一些。我们并不是简单地尝试给出这些问题的答案，因为根本没有答案——我们希望你
能够在概念上有所收益，从而挖掘出自己的答案。
UNIX编程艺．宋
  www.pdf365.com
296
第13章复杂度：尽可能简单，但别简单过了头
13.1  谈谈复杂度
    如同前述讨论的模块化和接口设计问题，Unix程序员往往有某种发自本能、得于经
验的反应，然而却无法清晰表述。所以，我们需要先给出一些术语。
    首先我们将定，义什么是软件复杂度。然后我们会横向比较几种不同复杂度之间的差
别，比较过种中有时免不了顾此失彼。最后我们会进行更重要的纵向比较：哪些是我们
不得不与之共处的，哪些则可以去除。
13.1.1  复杂度的三个来源
    对于简单性、复杂度和软件最佳规模的疑问，Unix世界注入了极大的热情。Unix程
序员已学到了～种世界观：简单即美即雅即善，而复杂即丑即怪即恶。
    Unix程序员追求简单的激情，源自注重实效的事实：复杂度就是成本。复杂的软件
更难于开发，难于测试，难于调试，难于维护——最重要的，难以学习和使用。而复杂
所带来的成本，开发时便汹涌而来，部署后更变本加厉。复杂是bug滋生的温床，在整
个的软件生存期，世界都将不得安宁。
    所有种种压力将程序员拖进复杂度的泥沼中。在前面的几章里，我们已经审视了这
些祸害；其中两个最臭名昭著的就是功能蠕变和过早优化。传统上，Unix程序员以一种
宗教般的热忱来抵御这种趋势．即谴责所有复杂度都非好事。
    那我们所说的“复杂度”究竟是什么？这～点必须板上钉钉，因为不同人有不同的
看法。
    Unix程序员（像其他程序员一样）往往注重于实现的复杂度——基本上，也就是程
序员为了能够试图理解一个程序，从而建立其思维模型并调试该程序的困难程度。
    另一方面，顾客和用户往往从程序界面的复杂度来看待这个问题。在第1 1章，我们
讨论了易用性及其对立面——记忆负担。对用户而言，复杂度与记忆负担紧密关联。而
如果一个拙劣的界面强迫用户进行许多易错或仅仅是冗长的低级操作，而不能进行高级
操作，那么低下的表现力和简洁也脱不了干系。
www.pdf365.com
13.1谈谈复杂度
297
    同时受这两者驱使的第三个度量标准就简单多了：系统中的代码行总数，即代码量。
用生命期成本的话来说，这通常是最重要的衡量方式。理由也许能从软件工程最重要的
经验主义结论中找回，我们以前也曾经引用过：代码的缺陷密度，每百行代码出错率，
往往是一个与实现语言种类无关的常量。更多行的代码意味着更多的bug，而调试常常
是开发中最昂贵、最耗时的部分。
    代码量、接几复杂度和实现复杂度可能同时上升。这就是功能蠕变的通常结果，所
以程序员对其特别恐惧。过早的优化并不增加接口复杂度，但是对于实现复杂度和代码
库规模有着负面的影响（常常特别糟糕）。这种防御复杂度方式相对容易实现；困难在
于，必须在这三者之间进行权衡。
    我们已经提到过两种尺度会导致不同方向变化的情况：用户界面，如果设计时首先
考虑容易实现或代码规模，可能就会简单地将许多底层任务都抛给用户。（对Unix程序
员是难以想象的，但在别的系统中普遍存在的一个拙劣的例子，就是一个缺乏全局替换
操作的编辑器。）尽管这种设计失误实在很普遍，但传统上，却没有一个名称。我们将
称之为“manularity’’（人力尺度）陷阱。
、    迫于保持代码库适度规模的压力，下得不使用极端晦涩复杂的实现技法，这往往会
导致系统实现复杂度的层层叠加，成为无法调试的一团乱麻。这种情况经常发生在程序
为适应极小规模系统而必须用汇编语言写成，或需要自修改代码之类的技巧的时候：如
今，这种情况在嵌入式系统之外难得一见，就算在嵌入式系统中，也变得愈加稀少。这
种设计失误传统上也没有一个名称，但有人会称之为“blivet"（硬撑）陷阱，这个词语
来自于军队，原本描述把十磅马粪硬塞进五磅麻袋里的行为。
    我们预先定义“blivet"陷阱，是为了与其对立面对比之用，但它并不出现在我们的
实例分析中。如果项目设计者对实现复杂度特别敏感，而拒绝使用统一但复杂的方式来
解决一整类问题，相反地更愿意对问题个体编写重复、专用代码，  “blivet，，便会出现。
其结果就是代码库尺寸暴涨，而维护问题远较使用统一方法严重。例如，一个网站工程，
其页面背后其实需要一个集中式的关系数据库，可能反而却采用几个不同的关键数据文
件，在页面生成时将它们包含的信息聚齐。这种失误太过普遍。它没有传统叫法；我们
将称之为“adhocity"（过专用）陷阱。
UNI×编程艺术
  www.pdf365.com
298
第1 3章复杂度：尽可能简单，但别简单过了头
    这就是复杂度的三个面孔，以及一些设计者有时往往为了规避反而掉进的陷阱。1本
章稍后我们在实例分析中将审视更多的例子。
13.1.2  接口复杂度和实现复杂度的折中
    一篇极透彻的关于Unix传统的观察来自Unix世界以外-Richard Gabriel的论文
《Lisp:好消息，坏消息以及如何获得大胜》（Lisp: Good News，Bad News，and How to Win
Big》> [Gabriel]。Gabriel是Lisp社区的长期领导者，此论文最初是作为Lisp独特设计风
格的一个论证，但是作者自己承认文章被人记得的主要原因是“The Rise of Worse Is
Better（‘差即是好’的兴起）”一节。
    文章认为：Unix和C语言有病毒般的特性；在软件设计发展过程的奋斗中，那些促
成快速传播（传染）的特征，如实现的简单性和可移植性等，比起设计的正确性和完备性更
为有效。Gabriel几乎预见了开源软件“多眼球”效应，而开源社区在1997年后的回顾
中，也将他视为他们中的一位理论家。
    较少为人所记的是，Gabriel的中心论点是关于实现和接口复杂度间的一个精准权衡，
宦正好就是我们在本章中检视的分类。Gabriel在更关注接口简单性的“MIT”哲学和更
重视实现简单性的“New Jersey’’哲学之间进行了比较，然后提出，尽管MIT哲学能够
引导软件在抽象上做到更好，但New Jersey模型（差者）更具传播特质。随着时间的推
移，人们更多的注意力都集中到了New Jersey风格，所以它提高得更快。差的变成了好
的。
    实际上，MIT和New Jersey哲学同Unix设计传统自身冲突的趋势有些相像。Unix
思想中的一个主题就是强调工具小巧锐利，设计从零开始，接口简单一致。这种观点最
著名的支持者是Doug Mcllroy。另一种思潮则强调创作简单的可工作实现，然后快速发
布，方法笨无所谓，边界情况不妨搁置。Ken Thompson的代码和他关于编程的信条常有
这种倾向。
    这两种方法间的平衡恰恰是因为有时可用复杂度换来更简单的接口，或者反之。
Gabriel最初的例子，耗时运算系统调用如何处理无法保留或屏蔽的中断，仍然是最好的
‘我们为这三个陷阱创造的名称，听起来虽然像，但是均非出自[Raymond96]中描述的已确定的黑客
行话。
www.pdf365.com
13.1谈谈复杂度
299
实例之一。在MIT哲学中，应该暂停系统调用，伺中断处理完成之后自动恢复之——这
较难实现，但接口更为简单；而在New Jersey哲学下，系统调用会返回一个错误表明已
被中断，用户必须重新执行——这实现起来非常简单，但编程接口却较难使用。
    两种方式都历经考验。Unix老手当会想起System V和BSD处理软件信号的风格，
后者追随MIT哲学，而前者来源于New Jersey思潮。在它们之间作出选择的根本迫切问
题与软件的感染性并无直接关系：如果目标是抑制整体复杂度，最愿意牺牲的是什么地
方？什么地方又最该被牺牲掉？
    一个Garbiel文章中没有提到的划时代实例来自于分布式超文本系统。早期的分布式
超文本工程，诸如NLS和Xanadu，严重局限于MIT哲学的假定：无被指物的链接在用
户界面上是一个不可接受的障碍；这就限制了系统要么只能在一个受控制的闭集文档中
浏览（例如在单个CD-ROM上），要么必须实现各种曰益复杂的复制、缓存、索引方法
来防止文档的随机丢失。Tim Bemers-Lee转而用经典的New Jersey方法解决了这个疑难
杂症。他所采用的简单实现就是允许“404: Not Found～可以作为一个响应，这使得万维
网非常轻便，并获得了广泛的传播和巨大的成功。
    Gabreil自己尽管坚持“坏的”更具感染性而往往能取得最后胜利，但关于其潜在复
杂度的相关问题是否确实是一件好事，他已经数次公开地改变了意见。他的不确定性恰
好反映了许多在Unix社区中正在进行的设计争论。
    我们并不能提供一个放之四海而皆准的答案。对于本章大多数的问题，良好品味和
工程判断力要求，情况不同，则答案不同。重要的是要培养斟酌每一个设计的习惯。正
如我们在讨论软件模块性之前的建议一样，复杂度的算盘必须打好。
13.1.3本质的、选择的和偶然的复杂度
    在理想世界，Unix程序员只愿意手工打造小巧完美的软件宝石，每个都那么小巧、
那么优雅、那么完美。然而现实中很不幸的是，太多复杂问题需要复杂的解决方案。仅
UNIX编腥艺l术
  www.pdf365.com
300
第13章复杂度：尽可能简单，但别简单过了头
仅十行的程序，再优雅也无法控制喷气客机。那儿有太多的装备、太多的通路和界面，
太多不同的处理机——太多不同操作人员定义的子系统，他们甚至连基本的约定都无法
统一。即使能够成功地将航空控制系统所有的个体软件部分都做得优雅，但拼装结果很
有可能是一堆庞大、复杂、糟糕的代码，当然（希望如此）也有个优点，就是确实能够
工作。
    喷气客机的复杂是必然的。过去有个相当尖锐的观点，不能为简单性而牺牲掉功能，
因为飞机必须要能飞。正是这个事实，航空控制系统并不会产生关于复杂度的圣战——
Unix程序员往往敬而远之。
    喷气客机当然不会对因过度复杂而导致的系统故障有免疫功能。但是在需求较灵活
的软件中，设计问题更容易辨别和考虑，也容易在预期的功能性和复杂度中做出权衡。
（此处，以及本章的剩余部分，我们从总体方面使用“功能”来包括诸如性能提升或是
接口整体修饰之类的东西。）
    为了看得更敏锐，我们需要从注意偶然复杂度和选择复杂度的区别开始。2偶然复杂
度的产生是因为没有找到实现规定功能集合的最简方法。偶然复杂度可以由良好的设计
或重新设计来去除。另一方面，选择复杂度，同某个期望的功能相关联．只能由改变工
程的目标来去除。
    当无法区分选择和偶然复杂度时，设计争论就会变得异常混乱。“什么是工程目标”
的夹杂着简单即美的问题，也会牵扯到人们是不是足够聪明。
13.1.4映射复杂度
    迄今为止，我们已经发展出考虑复杂度的两个不同等级。这些等级实际上彼此正交。
图13.1或许可以帮助澄清它们之间的关系。该图共有九个方框，每一个都列出了某种特
殊复杂度种类的常见来源。
2偶然和选择复杂度的差别意味着我们在此处讨论的分类跟Fred Brooks文章No Silver Bullet（没有银
-）[Brooks]中的本质和偶然有所不同，但是它们在哲学上都有同样的祖先。
www.pdf365.com
13.1谈谈复杂度
301
复杂度
种类
偶然复杂度
选择复杂度
本质复杂度
代码库规模    实现复杂度    接口复杂度
复杂度来源
图13.1  复杂度种类及其来源
    在本书的稍早部分我们已经接触过各类复杂度，特别是属于偶然复杂度的那种。在
第4章中，我们注意到偶然复杂度常常缘于接口设计并非正交——即没有仔细地分解接
口操作以使得每个操作只完成一件事情。偶然代码复杂度（比能够完成工作所需的更复
杂）常常来自于过早的优化。臃肿的偶然代码库往往缘于对SPOT原则的违背、重复的
代码或糟糕的组织，以至于重用机会渺茫。
    本质接口复杂度通常无法去除，除非调整软件的基本功能需求（在本章的实例分析
中我们会更多地展开这个主题）。代码库的本质大小同选择的开发工具有关，因为如果
功能清单固定不变，决定代码库规模大小最重要的因素可能就是实现语言的选择（正如
我们在第8章暗示的一样）。
    选择很难地有效的归纳可能复杂的来源，因为它们往往依赖于值得为何种功能付出
复杂度代价的精微判断。可能接口复杂度往往缘于让用户感觉更加好用、而非程序基本
功能的附加便利性。代码库规模大小的可能增涨（假设用户可视的功能和采用的算法固
定不变）通常来自于使其更具可维护性的不同实践——增加吏多注解，使用更长变量名
称等等。工程所涉及的任何方面均可产生可能实现复杂度。
    复杂度的不同来源必须以不同方法应对。代码库规模可以采用更好的工具来解决。
实现复杂度可以选择更好的算法来处理。接口复杂度必须着眼于更好的交互设计，一种
UNI×编腥艺术
  www.pdf365.com
302
第13章复杂度：尽可能简单，但别简单过了头
考虑了人类工程学和用户心理学在内的技能。这种技能，比编码能力更为少见（并可能
更加困难）。
    另～方面，处理各种复杂度，必然更仰赖于见识而非方法。通过发现更简单的方法，
可以去除偶然复杂度。依赖上下文环境判断哪些功能值得去做，可以去除选择复杂度。
而要去除本质复杂度，就只能通过对现实真谛的洞察和顿悟，从根本上重新定义所要解
决的问题。
13.1.5当简洁不能胜任
    对于Unix坚持简单的传统，往往伴随着一种错误的理解模式，Unix程序员常常认
为（有时甚至依此行事）似乎所有的可能复杂性都是偶然复杂性。更为甚者，在Unix传
统中存在一个强烈的偏好，宁可去掉功能，也不接受可能复杂性。
    这种态度的例子很容易产生（的确，本书大部分内容就是防止这个的）。干净的简约
主义让我们在多个层面上感觉良好，为此设计也是非常有价值的防范措施，能够防止软件
系统表面光鲜但内里功能不足的自然趋势。但是，计算资源以及人类的思考，同财富一样，
不是靠储藏而是靠消费来证明其价值的。同其它美学形式一样，我们需要注意何时设计上
的简约已经不再是有价值的自律形式，而开始成为一件伪装的苦行者外衣——一种实陈上
把美德作为借口来敷衍工作的纵容方式。
    这是一个危险的问题，确实太容易变成支持彻底抛弃良好设计准则的论据。Unix老
手常常羞于谈及，害怕防范复杂臃肿可能的最坚固阵线无法扼守，会将我们推向无情的
毁灭。但它避无可避。我们会在分析本章的研究实例中直接处理它。
13.2五个编辑器的故事
    现在我们将使用五个不同的Unix编辑器来作为案例。在检视这些设计时，在心中牢
记以下基准任务会非常有用：
●  纯文本编辑。即操作纯ASCII（在如今这个国际化的时代，也许是Unicode）文
  件，编辑器只知道其字节或者行结构。
www.pdf365.com
13.2五个编辑器的故事
303
●  富文本编辑。即编辑带有属性的文本：这些属性可以包括字体的变化，颜色或
    者其它类型的文本内属性（比如一个超链接）。具备这种能力的编辑器必须能
    够在某个用户界面的属性表示同磁盘上的数据表示之间进行转换（例如HTML、
    XML或其它富文本格式）。
●  句法感知。一个句法感知的编辑器知道输入事件存在语法，在识别出编程语言
    中一个范围块的开始或结束时能够自动更改缩进级别，或其它类似动作。一个
    句法感知的编辑器一般也能够以不同的颜色或特别的字体加亮文本。
●  批命令输出的输出解析。Unix世界最常见的情况就是从编辑器内运行一个C编
    译器，捕捉其错误信息，从而无需离开编辑器就能够跳至任何出错地点。
●  同辅助子进程交互。这些子进程在不同的编辑器命令间保留和维护状态。当具
    备这种能力时，会产生以下强大的结果：
    ●从编辑器内部可以驱动版本控制系统，无须离开编辑器到～个shell窗口或
    独立的公用程序就可以实施文件的检入检出（checkin/checkout）。
    ●编辑器可以作为符号调试器的前端，当发生那些诸如调试程序运行停止在
    某个断点上之类的情况时，编辑器可以自动访问恰当的文件及其文本行。
    ●通过识别指商另一个主机的文件名  （比如符合
    /us-er@host：/path/to- firle语法），可以在编辑器内编辑远程文件。
    假设拥有访问权，这类编辑器可以自动运行诸如scp （1）或ftp （l）的公
    用程序获取本地的一个拷贝，然后在保存文件时自动地将编辑后的版本传
    回远程位置。
    我们分析的所有实例都可以编辑纯文本。  （读者不应该把这种能力视作理所当然——
还有许多称之为编辑器的东西，比如“字处理器”，就太过于专用化而无法编辑纯文
本！）下面我们就开始来了解这些编辑器在处理更复杂任务时产生的不同程度的选择
复杂度。
UNIX编鼹艺-求
  www.pdf365.com
304
第13章复杂度：尽可能简单，但别简单过了头
13.2.1  ed
    ed （l）是真正Unix简约主义者编辑纯文本的方式。它自电传打字机时代就存在。3它
有一个简单俭朴的CLI:没有屏幕显示。在接下来列出的实例中，着重突出计算机输出。
ed sample．tx匕
sample. txL:  No  such  file  or directory
#这是注释行，不是命令。
抖上面的信息警告sample．txt是新创建的。
a
the quick lorown fox
jumped over the lazy dog
{}那是一个追加命令，表示向文件加入文本。
}}一个点号占据一行表示追加文本的结束。
1s/f[a-z] x/dragon/
#在第一行，用‘dragon’替换第～个匹配f后接任意a-z的小写字母再后接x的字符串。
样lowercase  alphabetic  followed  by x with  'dragon..  The
样substi七ute comrnand accepts baslc regular expressions.
}}替换命令接受基本的正则表达式。
l，$p
the quick brown dragon
jumped over the lazy dog
#从头到尾打印所育的行。
W
5 1
}}将文件写到磁盘上。‘q’命令结束编辑对话。
# editing session.
q
    对于现代读者来说这似乎难以置信，绝大多数Unix的最初代码都是用这个编辑器编
写的。有DOS经历的读者在这儿可能会辨认出这是行编辑器EDLIN的粗糙原型。
    如果把编辑器的工作定义为仅仅让用户创建和修改纯文本文件，那么ed （1）足堪
使用。从Unix设计有关正确性的观点来说，重要的是它不做别的任何事情。许多1日学派
的Unix程序员半认真地坚持所有功能比ed更多的编辑器都是臃肿的——并且少数仍然
～丝不苟的坚信这个观点。
实际上，ed是Ken Thompson对早期qedRitchieQEDl编辑器的有意简化，qed编辑
3年轻读者可能不会知道那些终端是打印的。在纸上打印。非常慢。
www.pdf365.com
13.2五个编辑器的故事
器——跟ed非常相似（而且是第一款以Unix特有方式使用正则表达式的编辑器）但具
备Ken故意放弃的多缓冲区能力。Ken认为它不值得付出更多复杂度。
    ed （1）及其所有衍生品最显著的特征就是命令的对象操作格式（上述对话实例展示
了’p’命令作用的明确指定行范围）。可以有相对强大的语法来指定行范围，或者以数字
形式，或者用正则表达式来模式匹配，或者用当前行和末行的简捷表示方式。多数编辑
操作都可以在任何范围起作作。这是一个良好的正交性实例。
    今天，耐（1）主要作为在脚本中由程序驱动的编辑工具来使用——具有更复杂交互
模式的编辑器并不适合此用。有～个很相似的称为e（1）的变种，增加了一些例如命令
提示之类的交互特性；在一些非常罕见的情况下，例如必须通过非常缓慢的串行线来完
成编辑，或者在某个不同寻常的崩溃恢复情况下，程序库支持需要运行的其它编辑器无
法访问，ed （1）就有用武之地了。正是这些原因，每个Unix版本都包含了一个ed的实
现，而多数Unix版本也同样包含了ex。
    sed（1），这个在第9章提到的流编辑器也与ed紧密相关；许多基本命令完全一样，
但sed设计为通过命令行开关调用，丽非读取标准输入。
    几乎所有的Unix程序员都已经偏离了苦行和简约主义的美德，通常使用至少拥有
roguelike这种面向屏幕界面的编辑器。4然而，坚持ed的虔诚道出了许多值得关注的Unix
思想。
13.2.2  vi
    最初的vi（1）编辑器是将可视的roguelike界面套到ed （l）命令集上的首次尝试。
与ed一样，它的命令通常是单键式，特别适合可以盲打的人使用。
    鼠标支持、编辑菜单、宏、指定键盘绑定，或是任何形式的用户定制在最初的VI中
都没有。追随ed的信仰，VI的信徒认为这些功能特性的缺乏恰恰是个优点。从这个角度
来说，Vl编辑器最重要的一个美德就是，在新的Unix系统上可以立刻开始编辑，而无须
转移原来的定制或担心默认的命令绑定会危险地与习惯相悖。
    Vi使初学者饱受挫折，这是由于其简明扼要、单键击发式命令所致。它有一个模式
界面——或者处于命令模式，或者处于文本插入模式。在文本插入模式，可用的命令仅
4著名的一个Usenet帖子就是ed信仰的例证之一，读者可以通过网络搜索“Ed is the standard editor”
找到这个a尽管都知道这是个调侃，但毫无疑问这决不是完全的玩笑话。多数黑客都会将此认作是
”Ha ha，only serious”的实例。
UNIX编，程之≥长
    www.pdf365.com
306
第13章复杂度：尽可能简单，但别简单过了头
仅只有使用ESC键退出该模式以及（在新版本中）光标移动键。在命令模式，键入的文
本会被解释成各种命令，而且还会给文本内容带来奇怪的（可能是毁灭性的）后果。
    另一方面，VI拥趸特别吹捧的一个命令集特性就是继承来自ed的对象操作格式。大
多数扩展的命令也可以自然地用于任何行范围。
    年复一年，vi已经相当庞大了。现代的版本加入了鼠标支持、编辑菜单、无限撤销
操作（最初的Vi仅仅只支持撤销最近的一次命令），独立缓冲区的多重文件，以及用运
行控制文件进行定制。然而，运行控制文件很少使用，与Emacs相比而言，内嵌通用脚
本的使用也不流行。相反的，通过加入C代码到编辑器本身，VI实现已经发展出独立完
成任务的能力，例如C代码的语法感知以及C编译器错误信息的输出解析。VI编辑器不
支持子进程的交互。
13.2.3 Sam
    Sam编辑器5在八十年代中期由Rob Pike在贝尔实验室编制而成。Sam是为我们将在
第20章讨论的Plan 9操作系统而设计的。虽然Sam编辑器在贝尔实验室外并不广泛为
人所知，但许多参与了最初Unix设计而后来又继续用Plan 9工作的开发者都很喜欢，包
括Ken Thompson奉人。
    Sam编辑器是ed -个相当直接的后裔，比VI更接近它们的父辈ed。Sam仅仅只加
入了两个新观念：curses风格的文本显示和能够用鼠标选中文本。
    每个Sam对话都只有一个命令窗口，以及一个或多个文本窗口。文本窗口编辑文本，
命令窗口接受ed风格的编辑命令。鼠标用来在两个窗口间进行切换，以及用来在文本窗
口内选择文本区域范围。这是个干净、正交、无模式的设计，避免了VI的大部分接口复
杂度。
    绝大多数命令操作默认地施用在一个可以由鼠标拖拽操作绘出的选中区域上。一个
命令的选中区域也可以用ed方式的行范围指定来设置，但Sam允许用户选择比行单位
更精确的粒度，这让Sam获得了相当可观的威力。因为可以通过鼠标选择和快速地在缓
冲区（包括命令缓冲区）间切换，所以Sam不需要和vi编辑器等价的默认（命令）模式。
许多VI的扩展命令都成为多余，而在Sam中被删除了。总之，Sam编辑器只在ed命令
5  ht t-p : / /plan9 . bell-labs _ com/ sys/doc/sam/ sam . h七ml
UNIX编I程艺：术
www.pdf365.com
13.2五个编辑器的故事
307
集的17个命令中增加了12个，总共加起来不超过30个。
    Sam编辑器的四个新命令加上两个继承自ed （1）和vi （l）的命令，作为应用正则
表达式的方法来完成施用在选定文件或文件区域上的任务。这些为命令语言提供了有限
的但是有效的循环和条件功能。然而没有方法可以命名或给命令语言过程加上参数。语
言同样不能交互控制一个子进程。
    Sam -个有趣的特点是它被分成了两个部分，将处理文件和搜索的后端从处理屏幕
界面的前端分离开来。这个“分离引擎和接口”的实例拥有立杆见影的实践收益，尽管
程序具有GUI部分，但仍然可以很容易地通过一个低带宽的连接就可以编辑远程服务器
上的文件。同样，前端和后端可以相对容易地重新改用。
    Sam编辑器，像Vl的最近版本一样，支持无限撤销操作。Sam编辑器被设计为既不
支持富文本编辑，也不支持输出解析，还不支持子进程交互。
13.2.4  Emacs
    Emacs无疑是现存最强大的程序员编辑器。它是一个庞大的、功能丰富的程序，具
有强大的灵活性和可定制能力。正如我们在第14章Emacs Lisp部分描述的一样，Emacs
拥有一个完整的编程语言，可以编写出任何强大的编辑器功能，
    与vi不同，Emacs没有各种界面模式；相反地，命令通常都是以控制字符或者ESC
在前引导。然而，在Emacs中，可以将任意的命令绑定到任何的按键序列，而且命令可
以是库中的或定制的Lisp程序。
    Emacs可以编辑多个文件，每个置于独立的缓冲区内，同时支持在这些不同的缓冲
区内移动文本。在X下的版本本身具有鼠标支持。
    绑定在Emacs按键上的Lisp程序可以在～个缓冲区里执行任意的文本变换。这种功
能频繁使用，尤其是在为许多不同语言和标记格式（正如从VI开始支持的C代码颜色加
亮，但并不仅限于此）定义语法感知和富文本编辑模式中。每种模式都是简单的Lisp代
码库文件，可以在需要时加载。
    Emacs Lisp程序也可以交互地控制任意子进程。这种能力的一些明显结果已经在早
些时候列出：可以作为版本控制系统、调试器等前端服务的能力。
UNIX编睡；艺术
  www.pdf365.com
308
第13章复杂度：尽可能简单，但别简单过了头
    Emacs的设计者建立了一个可编程的编辑器，6可以将与任务相关的知识定制进去，
以针对数以百计的不同类特殊编辑任务。设计者赋予了它可以驱动其它工具的能力。结
果就是Emacs支持在一个共享的上下文环境中处理所有的文本操作——文件、邮件、新
闻、调试符号。它可以用作任何拥有交互文本界面命令的定制前端。
    有个流行的笑话，Emacs的支持者和批评者都知道，在这个笑话中，Emacs被描绘
为伪装成编辑器的操作系统。这有些过于夸大，但Emacs当然完全成功扮演了非Unix
操作系统上集成开发环境（lDE，我们将在第15章回头讨论这个议题）的角色。
    这种强大来自于复杂度的代价。要使用一个定制化的Emacs，就必须携带定义个人
Emacs参数选项的Lisp文件。学习如何定制Emacs简直就是门学问。Emacs因此要比V1
更维学习。
13.2.5  Wily
    Wily编辑器7是Plan 9 acme编辑器的一个翻版8。它有些功能同Sam编辑器相似，但
目的是提供一个全然不同的用户体验。尽管Wily可能是所有这些编辑器使用范围晟小的
～个，但仍相当有趣，因为它展示了～种不同的、存在争议晌、更Unix的方式来实现类
似Emacs的可编程编辑器。
    Wily可以视作是满足最低要求的IDE，可以视作是Emacs风格可扩展性的～个实现，
而无伴随Emacs数十年之久的累赘。在Wily中，甚至作为Unix编辑器要素的全局搜索
和替换，都由外部程序提供。内建的命令几乎毫无例外地同窗口操作相关。Wjly设计之
初就完全支持尽可能多地使用鼠标。
    Wily并不仅仅试图取代常规的编辑器，同时试图取代诸如xterm（1）的终端窗口软
件。在Wily中，主窗口（其中包含多个不重叠Wily窗口）中的任何文本都可以是一个
行为或搜索表达式。使用鼠标左键来选择文本，使用中键将文本作为～个命令执行（内
6 Emacs的设计者是Richard M. Scallman. Bemie Greenberg和Richard M. Stallman。原始Emacs是
Stallman发明的，第一个拥有内嵌Lisp的版本出自Greenberg，而现在的权威版本是Stallman继承自
Greenbergo在2003年，t，macs的设计历史还没有完整的档案，但Greenberg的Multics Emacs: The
History， Design， and Implementation （Multics Emacs:厉史、设计和实现）有些说明，通过网络上的关键
字搜索可以很容易地找到。
7  http:／/www. cs .yorku. ca/~oz/wily
8  http:／/plan9. bell-labs. com/ sys/doc/acme/acme. ht ml
UNIX绸翻呈艺术
www.pdf365.com
13.3编辑器的适当规模
309
建的或者外部的），使用右键来在Wily的缓冲区或文件系统中搜索文本。不需要主菜单
或弹出菜单。
    在Wily中，键盘仅仅就是为输入文本而用的。快捷方式不使用键盘的特殊用法，而
是采用同时按下不止一个鼠标键的方式。这些快捷方式总是等价于使用鼠标中键激发某
个内建命令。
    Wily也可以作为C、Python和Perl程序的前端使用，无论何时一个窗口改变了，或
一个执行、搜索命令通过鼠标完成后，都可通知那些程序。这些插件功能很像Emacs的
模式，但和Wily并不运行在统一地址空间；相反地，它们通过一个非常简单的远程过程
调用集合同Wily通讯。Wily编辑器常常打包了一个类似xterm的程序并使用它作为编辑
前端的邮件工具。
    因为Wily太过于依赖鼠标，所以它不能使用在仅仅只支持字符阵列的控制台显示
上；也不能使用在没有X转发（X forwarding）的远程连接上。作为一个编辑器，Wily
是为编辑纯文本而设计的；它只有两种字体（一种比例字体和一种等宽字体），也没有
可以支持富文本编辑或语法感知的机制。
13.3编辑器的适当规模
现在让我们用本章开头展示的复杂度分类来研究这些案例。
13.3.1  鲰别复杂度问题
    每款文本编辑器都有一定量的本质复杂度。至少，它必须支持文件或多个文件的内
部缓冲区拷贝。最低要求是文件数据的导入导出功能（通常是磁盘存取，尽管流编辑器
sed（1）是个有趣的例外）。某种修改缓冲区的方法必须支持，但是没有功能描述的话，
我们无法指定用何种方法。而我们四个例子展示的各种可能偶然复杂度级别非常宽泛，
不限于此。
    在几个编辑器当中，ed （l）复杂度最低。在其命令集中，不正交的功能特性也就是
许多命令接受“p"或“l"的后缀来打印或是列出命令结果。即使这三十年来功能不断
增加，编辑命令还是少于三十个，而大多数用户常用的命令～般也少于十二个。编辑器
没有太多的选择复杂度可以去除，也根本难以确定任何偶然的复杂度。ed的用户接口非
常紧凑。
UNIX编程艺l术
  www.pdf365.com
310
第13章复杂度：尽可能简单，但别简单过了头
    另～方面，ed接口并不真正适合完成编辑任务，甚至包括快速翻看文本文件这样的
基本任务。对于交互编辑，要让ed作为可接受的解决方案，就不得不严格限制编辑目标。
    如果我们加入“支持可视化浏览／编辑多个文件’’的目的又如何昵？通过最小的ed
扩展而达到目标，Sam编辑器似乎与此需求很接近。显然，其设计者并未改变继承自ed
命令集的语义；他们保持了现有的、正交的命令集合，同时增加了一个相对较小、自身
也是正交的能力集合。
    复杂度的巨大增涨可能（实现）源于Sam编辑器的无限撤销能力。另一个显著的增
涨是命令语言中新增的基于正则表达式的循环和迭代功能。这些，加上鼠标能够作为选
取设备使用的事实，使得Sam编辑器同一个即使具备了鼠标和窗口界面的ed编辑器仍
有显著差别。
    任何Sam编辑器中的偶然复杂度，如果没有全盘的代码审计，都难以确认；而在设
计层面，也确实难以甄别。接口至少是半紧凑的，至于严格的紧凑则存有争议。这个编
辑器做到了最高级别的Unix设计标准——想想它的出身，这并不奇怪。
    比较而言，VI看起来相当臃肿而不紧凑。存在上百条命令，许多都是重复的。这些
复杂度充其量只足可能性或偶然性的。据推测，多数用户知道的命令集不会超过5%。由
于在我们面前有Sam的例子，当然会奇怪Vl的接口复杂度为什么会如此之高。
    在第1 1章我们讲述了早期roguelike程序由于缺乏标准箭头键所带来的后果：VI程
序正是这当中的一员。在编写Vl的时候，作者知道许多用户需要能够使用Unix“玻璃电
传打字机”上传统的光标移动键。这使得模式接口无法避免。一旦hjkl键在编辑缓冲区
中的意义依赖于模式，就实在太容易陷入以专用方式增加新命令的习惯。
    Sam编辑器，既然依赖于兼具箭头键和鼠标的位图显示，自然可以简洁得多。也确
实如此。
    但是VI命令的杂乱只是一个相对表面的问题。VI存在接口复杂度，没错，却是那种
多数用户确实可以忽略的（从第4章我们所述的角度来说，接口是半紧凑的）类型。深
层次的问题是个专用陷阱。历经多年，VI已经日益拴合了越来越多的C代码来执行某些
任务，而这些任务，Sam编辑器拒绝完成，Emacs编辑器以Lisp代码模块和子进程控制
来解决。在Vl中，扩展并不象Emacs中一样作为扩展库需要时才载入进来；用户始终必
须为随之而来的臃肿代码付出代价。结果，现代Vl和现代Emacs之间的规模差剐远非人
们想象的那般大；在2003年中期，在Intel体系的机器上，vim有1500KB，而GNU Emacs
是900KB。在这900KB中还有～大堆选择和偶然复杂度。
www.pdf365.com
13.3编辑器的适当规模
31 1
    对于vi信徒，没有一个内嵌的脚本语言——不是Emacs-已经成为一致性问题，
成为VI是个轻量级编辑器这个共享传奇的核心部分。虽然Vl发烧友喜欢讨论用外部程序
以及脚本过滤缓冲区来达到Emacs内嵌脚本所能完成的事情，但现实是Vl的“！”命令
不能够在比行范围更高级别的粒度上对选择的缓冲区进行区域过滤（Sam和Wily，尽管
并没有比V1更多的子进程控制，至少能够在文本的任意范围上进行过滤，而不仅仅只是
行范围）。所有在一个更小粒度上有所区别的文件格式和语法知识（大多都有区别），
如果V1编辑器需要能够访问，都必须编写进C代码中。这样在Emacs和V1代码库规模
大小的比例上，几乎没有希望能在V1方面得到改善：的确，这似乎可能更糟。
    Emacs十分庞大，其历史也十分夹杂不清，所以如果要将它的选择复杂度从偶然复
杂度中分离出来是一个相当大的挑战。但我们至少可以把Emacs设计中可有可无的偶然
复杂度从不可或缺的本质复杂度中分离出来作为起点。
    也许Emacs设计中最可有可无的部分就是Emacs Lisp。我们今天称之为内嵌脚本语
言的特性对Emacs而言是必要的，但如果那个语言是Python成Java或Perl的话，Emacs
在能力上也不会有什么不同。然而在1970年代进行tmacs设计的时候，Lisp是唯一拥
有某些特征（包括类型种类无限以及垃圾收集）、适合完成这项任务的语言。
    大部分Emacs事件处理以及位图显示器驱动（包括国际化支持）的特殊方式都属于
偶然复杂度。在其历史上最大的分裂（GNU Emacs和XEmacs分支）就涵盖了这个问题，
并且也展示了余下的设计并不是非优选或要求哪种事件驱动模式不可。
    另一方面，把任意事件序列绑定到任意内置或用户定义功能的能力是不可或缺的。
脚本语言可以换掉，事件模型也可以改变，但是如果不是任何对象都因连接方式不同而
呈现不l刊面貌，Emacs设计就不成气候也不成其为自身了。这样，扩展模式不得不为了
有限事件集的所有权而彼此斗争，而且激活同一缓冲区的多重协作模式也十分困难或者
根本就不可能。
    随着Emacs -道发布的巨大扩展模式库也同样属于偶然复杂度。构建这种扩展的能
力也许是必要的，然而某个专用集合却是历史和偶然的产物。全部扩展都可以不同或被
替换；Emacs结果还是Emacs，面貌依旧。
    但是子进程交互是不可替代的。没有它，Emacs模式就不能够怍为各种不同工具的
IDE环境或前端。
    一些小型的编辑器复制了默认的键盘绑定以及Emacs的外观，但没有模仿它的扩展
能力，这样的经验是很有意义的。已经有好几个这样的克隆，其中最著名的大概非
UNIX编程艺术
  www.pdf365.com
3 12
第13章复杂度：尽可能简单，但别简单过了头
MicroEmacs和pico莫属，但都没能获得大量的追随者。
    鉴别Emacs设计中哪些本质、哪些偶然，可以帮助我们理解它的复杂度哪些是可能
性、哪些是偶然性的。然而，更重要地，这帮助我们透过上述三个编辑器表面的不同，
而直达关键之处：事实上Emacs设计的目标非常宽泛。Emacs想要成为所有文本处理工
具的统一接口。
    Wily跟Emacs形成有趣的对比。同Sam -样，选择复杂度含量很低；Wily用户接
口仅用一页纸就可以简明扼要地描述清楚。
    但是优雅是有代价的；除了有限的鼠标组合动作之外不可能将功能绑定在任何的按
键或是输入手势。除了基本的文本插入和删除之外的任何编辑功能都必须以外部的程序
来代替实现：一个独立的脚本，或是一个可以侦听Wily输入事件的专用共生进程。（前
者技术上依赖于外部程序的启动必须非常迅速、不会产生可觉察的界面延迟，这在诞生
Emacs的环境中或是首次移植到的各种Unix下都绝对不成问题。）
    Emacs因采用Lisp扩展模式实现而导致的选择复杂度，在Wily中相应地分布在专
门化的共生体中；每个共生体都必须知晓Wily特殊的消息接口。这种有式的一个优点就
是这样的共生体可以由用户选择的任何语言来编写。另外，共生体（因为它们在外部运
行）不会彼此影响或危害Wily核心（Emacs的各种模式并非如此）。这种方式的一个缺
点是Wily自身不能直接与普通的Unix工具进行予进程交互。
    在这个或其它方式上，wily的分布式脚本机制并不如Emacs的内嵌脚本那样强大有
效。Wily的目标范围相对狭窄；作者放弃了在感知语法编辑或富文本编辑方面的功能，
例如，Wily以及它Plan 9的祖先acme都不处理这些事情。
    这里以一种更尖锐的方式来提出本章的中心问题：什么时候一个庞大程序的宏伟目
标是正当而有效的？
13.3.2折中无用
    Sam和VI的比较，显著昭示了至少在涉及编辑器方面，试图在简约主义的ed和无
所不能的Emacs之间进行折衷是达不到好效果的；Vl尝试这样去做，结果两头落空，而
掉进了过度专用的陷阱。Wily则规避了这个陷阱，但是威力无法跟Emacs相比，并且为
www.pdf365.com
13.3编辑器的适当规模
3 13
了无论在何处都能结合紧密，每个交互的共生体必须提供一个定制的进程接口。
    显然有关编辑器的某些方面往往将其推向更高复杂度。在vi的例子中，这不难甄别；
那就是对便利性的渴望。尽管ed或许在理论上是够用的，但是很少有人（也许除了Ken
Thompson自己）会为了声讨软件的臃肿而放弃面向屏幕的编辑。
    更普遍地，在用户和外部事务间调和的程序往往加入各种功能，这一点臭名昭著。
不仅是编辑器，网页浏览器、邮件和新闻组阅读器以及其它通讯程序，所有这些软件的
发展都遵循“软件信封定律”，即Zawinski定律：  “每个程序都试图扩展直到能够阅读
邮件。不能如此扩展者，将被能者取代。”
    Jamie Zawinski，定律的发明人（Netscape和Mozilla网页浏览器的主要作者之一），
主张更一般的情况：所有真正有用的程序都想变成瑞士军刀。在Unix世界外大型的成功
商业整合应用程序套件通常也证实了这～点，而且直接挑战了Unix的最简哲学。
    某种程度上，Zawinski定律是正确的。它表明有些程序需要小巧，有些程序需要庞
大，但中间道路是行不通的。V1编辑器的表面问题可以归咎于历史，然而更深层欢的问
题应该追溯到增加功能的压力同vj信徒，往往由此联系到过度规模，而拒绝增加与内嵌
脚本语言和子进程控制功能的结合。在～个不同的级别上，接受了接口中存在两种方式
（插入和特性运动），将会捅到马蜂窝——添加新功能很容易根本考虑不到对整体设计
的复杂度影响。
    Emacs和Wily的例子进一步表明，为什么有些程序需要做得如此庞大：这样几个相
关任务就可以共享环境。从实现者的角度，编辑和版本控制（或者编辑和邮件操作，编
辑和符号调试等等）是独立的——但是用户经常更愿意有一个大的环境让它们能够指向
文本部分，无需花费时间和精力在拥有相同文件名或是相同剪切内容的程序之间切来切
去。
    更普遍地，让我们假设整个Unix环境可以视作是社区的单一设计工作。那么“小巧
锐利工具”的教义，降低接口复杂度和代码库规模的压力，可能正好会导向过手工
（ manularity）陷阱——用户不得不自己维护所有共享的上下文环境，因为工具并不会为
他完成此项工作。
    返回编辑器的特定背景，Sam向我们展示了V1是个错误。Wily是避免巨大Emacs
的勇敢尝试，但却因功能不足不能感知语法。但是Wily，或者某个彻底卸掉了历史包袱
的Emacs设计思想实现舨本，也许是正确的。选择复杂度的价值依赖于对目标的选择，
UNIX编曜艺l宋
  www.pdf365.com
314    第13章复杂度：尽可能简单，但别简单过了头
而在所有与任务相关的面向文本工具间共享上下文环境的能力是非常有价值的。
13.3.3  Emacs是个反Uni×传统的论据吗
    传统的Unix世界观，极其依恋简约主义，所以并不擅长区分VI的专用陷阱问题和
Emacs的选择复杂度。
    Vi和Emcas在老派的Unix程序员中从不流行的原因是丑陋。这个抱怨也许
是“老Unix”的话语，但如果不是老Unix的单一风味，  “新Unix”就不会存在
-Doug Mctlroy
    VI用户对Emacs的攻击——同仍旧依恋ed的旧学派中坚分子对vj的攻击一道——
是一个更大争论的一段情节，～场富有和俭朴之间的品德角逐。这个争论同新老学派Unix
风格之间的冲突有关。
    “老Unix的单一品味”部分是同日本简约主义一样贫穷的结果——学会在无法获得
更多条件的情况下最有效地以少量资源完成更多任务。但是Emacs（以及在威力强大的
PC机和快速网络上重新发明的新学派Unix）却是财富之子。
    同旧学派的方式不一样。贝尔实验室资源丰富，所以Ken不会被受限去写一
个过时产品。想想Pascal因为没有足够的时间写封短信而抱歉信写长了。
    -Doug Mcilroy
肌那时起，Unix程序员就一直维持着在过度花费上追求一流的传统。
    另一方面，Emacs的庞大，并非源自Unix，而是由于Richard M. Stallman在一个不
同的文化中发明了它-1970年代繁荣的MIT的人工智能实验室。这个实验室是计算机
科学院校最富裕的地方之一；那里的人们学会了把计算资源当作廉价资源，并预测了一
种在别处直到十五年后才可行的态度。Stallman可不关心简约主义；他追求的是代码最
大功用和最广适用范围。
www.pdf365.com
13.3编辑器的适当规模
315
    少吃多干还是多吃多干，～直是Unix传统的主要冲突。这个冲突在许多不同的背景
下重现，往往在不断地挣扎在具备干净简约主义品性的设计和不惜以高昂复杂度代价而
选择表达力范围和威力的设计之间。自从1980年代初期Emacs第一次引入Unix之时起，
便有了支持与反对的冲突双方。
    诸如Emacs那样既有用又庞大的程序会使Unix程序员极不舒服，恰恰因为它们强迫
我们面对这种冲突。这些程序表明，旧学派Unix的简约主义作为一个原则虽然有其价值，
但我们可能已经陷入教条主义的错误之中。
    Unix程序员可以有两种方式解决这个问题。一种就是否认：大实际非大。另一种就
是发展出一种考虑复杂度的不是教条的方法。
    替换掉Lisp和扩展库的实验思想赋予我们一个新的角度，来看待对Emacs由于扩展
库庞大而臃肿的再三控诉。抱怨Emacs大，和把系统中所有shell脚本都算上而抱怨
／bin／sh大，同样是不公平的。Emacs可以视作是一个围绕在小巧锐利工具集合上的虚
拟机或框架，只不过这个工具集恰好是用Lisp编写罢了。
    从这个角度，shell和Emacs的主要区别就在于Unix发布者并没有把所有的shell踯
本都同shell -起发布。因为Emacs内置了感觉臃肿的通用语言而反对Emacs，就像因为
shelll具有条件和for循环而拒绝使用shell脚本一样无聊。如同并非必须学习shell脚本才
能使用shell -样，使用Emacs也不是非学习Lisp不可。如果Emacs存在设计问题，与
其说是Lisp解释器的问题，还不如说是模式库历史性增长成为一堆乱麻的问题——然而
这是一个用户可以忽略的复杂度来源，因为用不到的部分并没有影响。
    这种论证方式非常令人鼓舞。可以应用到其它的工具整合框架中，例如（令人不舒
服的庞大的）GNOME和KDE桌面项目。这种方式在那里也有效（说服力）。而且，同
样地，我们必须怀疑任何可以如此优美地解决所有疑问的“观点”；它只能是个合理原
则，而不是基本原则。
    因此，让我们避免否认或接受Emacs既有用又庞大——这其实是反对Unix简约主义
的论据。在我们对Emacs复杂度种类和动机的分析中，还有什么更意味深长的暗示？又
有什么理由相信那些从教训归纳出来的东西？
UNIX编程艺l宋
    www.pdf365.com
3 1 6
第13蕈复杂度：尽可能简单，但别简单过了头
13.4软件的适度规模
    小巧锐利工具的Unix教义隐藏着二重性；许多Unix从业者都没有注意到，一个十
分不明显的背景，就像鱼没有注意到它游着的水一样。这就是框架的存在。
    Unix风格的小巧锐利工具存在数据共享的困难，除非它们能生存在彼此之间通讯便
利的框架结构之中。Emacs就是这样一个框架，而对共享上下文环境的统一管理正是其
选择复杂度换来的。共享上下文统一管理的实际效果就是用户不需要负担底层的命名和
资源管理问题。
    在旧学派的Unix中，唯一的框架就是管道、重定向以及shell;整合工作由脚本完成，
而共享上下文环境（本质上）就是文件系统本身。但这并不是进化的终点。
    Emacs将非常多的文本缓冲区和援助进程同文件系统统一在～起，大大超越了shell
框架。Wily也有缓冲区和援助进程，但将shell框架也并进了自身。现代的桌面环境为
GUI提供了一个通讯框架，也大大超越了shell框架。每种框架都有自身的优点和缺点。
而框架成为了各种工具生态系统之家——例如shell之于脚本，Emacs之于Lisp模式，或
者桌面环境之于众多通过拖放以及诸如对象代理（object broker）乏类更为复杂的GUI
通信方式。
    最简原则暗示：选择需要管理的上下文环境，并且按照边界所允许的最小化方式构
建程序。这就是“尽可能简单，而不过于简单”，集中关注选择共享上下文环境。实际
上，这并不仪仅适用于框架，也适用于应用和程序系统。
    然而，究竟共享上下文环境该有多大实在很容易草率对待。隐藏在Zawinski定律后
的压力往往驱使应用程序需要为便利性而共享上下文环境。很容易因为负载太多任务、
太多需求设想而最终失败，也很容易就把程序编制得过于复杂、臃肿和庞大。上世纪九
十年代的例证是，“mailto:URL"导致了越来越多网页浏览器中内嵌了庞大的邮件客户
端。
    矫正这种趋势的方法直接来自于旧学派Unix的赞美诗集。这就是吝啬原则：只有实
证了其它方法行不通时才写庞大程序——也就是，已经尝试过分解问题但遭到失败。格
言表明了对待庞大程序的～种严谨怀疑态度以及一种谨慎的策略方法：首先寻找小巧程
序的解决方案。如果单个小程序无法完成这项工作，尝试在现有框架结构内构造一个协
作小程序工具包来解决问题。如果两者都失败了，才可以自由地构建一个巨型程序（或
一个新框架），而不会觉得已经完败于设计挑战。
www.pdf365.com
13.4软件的适度规模
3 17
    当编制一个框架时，牢记分离原则。框架是机制，尽可能少地包含策略。在多数情
况中，根本就不需要什么策略。尽可能多地将行为分解到使用框架的模块中去。编制或
重用框架的好处之一，是能够有益于将“不这样做会是大块策略”的东西分离到独立的
模块、模式或工具——可以有效地同其它程序重新组合起来的部分中去。
    这些准则是颇有价值和启发性的方法，但是Unix传统深处的这种矛盾冲突，并不能
将任何给定的工程划为合理的最佳规模，并分而治之。具体情况具体分析，而锻炼良好
的判断力和品味恰好是软件设计者所追求的。正如曹洞禅所说，行程才是目的；顿悟在
每日的实践中。
UNIX鳎翻星YaC
    www.pdf365.com
www.pdf365.com
PartⅢ
Implementation
www.pdf365.com
www.pdf365.com
1 4
  r  C还是非C
、五言．
口亡=I．
Languages: To C or Not To C
14.1  Unix下语言的丰饶
The limits of my language are the limits of my world.
    Tractatus Logico-Philosophicus 5.6， 1918
    我语言的极限便是我世界的极限。
    《逻辑哲学论》5.6， /9/8
    一路德维希-维特根斯坦
    Unix所支持的应用程序语言，其范围比当今其它任何一种操作系统的都要广泛：事
实上，Unix上运行的语言种类完全可能超过计算史上其它所有操作系统的总和1。
    至少有两个充分的理由造成了这种巨大的多样性。一是Unix广泛用于研究和教学平
台。另外一个事实（同程序员更加密切的）是，应用设计和实现语言的合理搭配对生产
力有极大促进。因此，Unix传统鼓励专门领域语言的设计（正如我们在第7章和第9章
所述）和现在…般称为“脚本语言”的东西——为了把其它应用程序和工具胶合起来而
专门设计的语言。
1详情参见  Free  Compiler and  Interpreter List  （自由编译器和解释器总表）
<f tp:／/f tp. idiom. com/pub/   compilers-list/free-compilers>。
UNIX缟程艺．术
  www.pdf365.com
322
夸占1』音0E言．广、节K量j-Fr、
，由l叶早k]口：  o Zl二天E_'卜U
    术语“脚本语言’’可能源自术语“脚本”，它用于为一个通常情况下的交互
程序提供简短输入，特别是sh或ed-这个术语比我们从Unix前辈CTSS那儿
继承下来的术语“runcom”更合适。  “脚本”最早出现在V7手册（1979年）中。
我不记得是谁造就了这个字。
    -Doug Mcllroy
    说实话，  “脚本语言”是个有点蹩脚的术语。很多通常这么称呼的主要语言（ Perl、
Tcl、Python等）都已经超越了最初意义的脚本用途，已经成为威力相当强大的独立通用
编程语言。一些语言，特别是Lisp和Java，在风格上与脚本语言非常相似，但是这个术
语模糊了两者间的区别。继续使用这个术语的唯一理由是还没人想出更好的。
    把所有这些语言都纳入“脚本语言”的部分原因在于，这些语言都具有非常～致的发
展历程。在运行期完成解释使得动态存储管理的自动化相对容易，而这几乎要求采用引
用（存储地址不透明且无法进行运算）而不是传值或显式指针。使用引用可使下一步更
容易实现运行期的多态性和00。瞧！这就是现代的脚本语言！
    要有效应用Unix哲学，在工具包中就不能只育C语言，必须学会使用Unix的其它
语言（特别是脚本语言），并且学会如何在大型程序系统中把担任各个专门角色的多个
语言轻松自在地融合在一起。
    本章我们要分析C语言及其最重要的替换语言，讨论各种语言的长处、不足以及它
们最适合的任务类型。涉及的语言包括C、C++、shell、Perl、Tcl、Python、Java和Emacs
Lispo每段分析将包括由该语言编写的应用实例，同时也引用了其它例子和指导材料。
所有使用这些语言实现的高质量开源实现都可以在Intemet上获得。
    警告：对应用程序语言的选择是InterneUUnix世界中应该认真考虑的原型问题之一。
人们太爱某些工具，有时会不顾～切维护它们。如果本章达到了目的，也许会冒犯各种
语言的狂热支持者，但其他所有人肯定都能从中受益。
www.pdf365.com
14.2为什么不是C
323
14.2  为什么不是C
    C是Unix的母语。自1980年代早期起，C语言几乎就垄断了计算机工业中所有的
系统编程。除了Fortran在科技和工程计算领域内不断缩小的空间和COBOL在银行和保
险公司大量外人无法得知的财务应用外，C和C的后代C++迄今为止（2003年）垄断应
用编程超过了整整10年。
    因此，作为对新应用程序开发工具的选择，现在断言C和C++几乎～定是蹩脚的似
乎理由不足。然而事实如此；C和C++以增加实现时间和（特别是）调试时间为代价来
优化效率。尽管以C或C++编写对时间要求极高的系统程序或应用程序内核似乎还有意
义，然而自从这些语言在1980年代崛起，世界已经发生了很大变化。在2003年，用几
乎同样的价钱能够买到的处理器快了1000倍，内存大了1000倍，而磁盘容龟也大了10000
倍2。
    急剧下降的成本从根本上改变了编程的经济含义。大多数情况下，和C-样节约机
器资源已经不再有任何意义。相反地，经济方面的最优选择已经变成尽可能减少调试时
间、尽可能延长人类对代码的长期可维护性。因此，用较新一代的解释语言和脚本语言，
能够更好地为绝大多数种类的应用实现（包括应用程序酌原型设计）服务。这种转变和
历史车轮中上一次C/C++崛起而汇编语言衰落的情况类似。
    C和C++的中心问题在于它们要求程序员自己完成内存管理——声明变量、显式管
理链表、设置缓冲大小、检测或防止缓冲溢出，以及分配和回收动态存储。这些任务部
分可以通过不自然的方法来自动化，例如，给C配备Boehm-Weiser实现之类的垃圾收
集器，但C本身的设计使它无法成为一个完整的解决方案。
    C的内存管理是复杂性和错误的渊薮。对于处理复杂数据结构的程序而言，有研究
（据（Boehml称）估计30%～40%的开发时间都用于存储管理。这个估计甚至还没有包
括对调试成本的影响。尽管缺乏确凿坚实的数据，但很多经验丰富的程序员都相信，内
2在Unix世界外，这种硬件性能三个数量级提升的效果很大程度上被软件性能的相应下降所掩盖。
    UNIX编陛艺：术
    www.pdf365.com
324
第1 4童语言：C还是非C
存管理产生的bug是真实代码持续产生错误的最大单体来源3。缓冲溢出是产生崩溃和安
全漏洞的常见原因。动态内存管理造成诸如内存泄漏、指针失效问题等阴险、难以跟踪
的bug，特别臭名昭著。
    就在不久前，手动内存管理还有意义。但现在再没有“小型系统”了，至少在主流应
用编程中没有了。在今天的条件下，自动化内存管理（并以使用更多的时钟周期和内存
为代价而减少一个数量级的bug）的实现语言更有意义。
    最近一篇论文[Prechelt】为一个观点收集了一系列惊人的统计数据，但在两个世界
都有经验的程序员可能会发现这个观点似是而非：同C或C++相比，使用脚本语言的
生产力可以提高1倍。这个观点完全和前面提到的30%～40%的损失估计加上调试开
销后一致。使用脚本语言的性能损失对真实世界的程序来说经常微不足道，因为真实
世界的程序往往受I／0事件等待、网络延迟以及缓存列填充等限制，而非CPU的自身
效率。
    Unix世界在实践中慢慢意识到了这个观点，尤其是在1990年前后，Perl和其它脚本
语言越来越流行。但是实践（到2003年中期）还没有发展为自觉地产生巨变；许多Unix
程序员仍然在汲取Perl，Python的经验。
    我们可以在Unix世界外看到同样的趋势，尽管速度更慢——例如，在Microsoft
Windows和NT的应用开发中从C++到Visual Basic的明显转变以及大型机世界中向Java
的转变。
    反对C和c++的论据同样适用于其它传统的编译语言，例如Pascal、Algol、PUI、
FORTRAN和编译Basic等。尽管偶有壮举，如Ada，但这些传统语言在基础设计时把内
存管理留给程序员，因此其间的差别几乎无关紧要。尽管绝大多数传统语言在Unix下都
有高质量的开源实现，但在Unix或Windows世界中应用很窄；这些语言都因为得到C
3这个问题的严重性可以通过Unix中描述各式各样问题所形成的大量行话来证明：“aliasing bug，，（别
名错误）、“arena corruption”（内存分配区无效）、“memory leak”（内存泄漏）、“buffer overflow”
（缓冲区溢出）、“stack smash”（堆栈崩溃）、“fandango on core”（内核混乱）、“stale pointer”（指
针失效）、“heap trashing”（堆破坏）以及可怕的“secondary damage“（二次损伤）等。具体说明参见
行话文件<http：//www_ catb．org／—esr／j argon>。
www.pdf365.com
14.4语言评估
325
和C++的好处而被废弃。因此，我们不在此分析这些语言。
14.3解释型语言混合略
    避免手工管理内存的语言通过在运行期可执行体中嵌入一个内存管理器来完成内存
管理。通常情况下，这些语言的运行环境分成程序部分（运行脚本本身）和解释器部分，
解释器管理动态存储。在Unix（以及其它现代操作系统）中解释器内核由多个程序部分
共享，减少了各个程序的实际开销。
    脚本在Unix世界中从不是新概念。早在1970年代中期，在机器能力弱得多的时代，
Unix shell（Unix控制台的输入命令解释器）就是作为一个完全解释型编程语言设计的。
即使在那时，这样的实践也很普通，完全用shell编写程序，或者用shell编写胶合逻辑、
把现有的公用程序同C编写的定制程序结合成比各部分总和更大的整体。对Unix环境的
经典介绍（如Unix Programming Environment （Unix编程环境）[Kernighan-Pike84]）非常
详细地描述了这个策略，理由就是：它是Unix最重要的创新之一。
    高级shell编程可自由混合语言编程，从数种或更多语言中为子任务开发二进制
和解释型组件。每种语言都完成自己最擅怅的任务，每个组件都是具有同其它组件间
狭窄接口的模块；整体的全局复杂度要比使用某个通用语言编制的单个的庞然大物低
得多。
  14语言t'
  混合语言足一种知识密集型（而不是编码密集型）的编程。要让它能够工作，我们
不仅应该具备相当数量的多种语言应用知识，并且还必须具备能够判断这些语言在什么
地方最适合、以及怎样把它们组合在一起的潜经验。本部分，我们将尽量帮助大家认识
各种语言，然后再纵览那些潜经验。对于每种语言的分析，我们都会用成功的程序实例
来说明这种语言的长处。
UNIX编程艺．术
    www.pdf365.com
326
第1 4章语言：C还是非C
14.4.1  C
    尽管存在内存管理问题，但C语言还有一些仍然可以在其中称王称霸的生态环境。
要求速度最快并且具有实时需求的程序，或者与OS内核紧密联系的程序非常适合用C
编写。
    必须在多个操作系统上移植的程序也非常适合用C编写。然而，以下将要讨论的某
些其它替代语言不断打入主流的非Unix操作系统；也许在不久的将来，C的可移植性优
势将不复存在。
    有时，从现有程序中，诸如可以生成C代码的词法分析生成器或GUI构建器之类，
可以获得相当大的借力；完全值得用C语言编写除此以外并无太多工作的小型应用程序。
    当然，已经证明了，对于所有C的替换语言开发者来说，C都是不可或缺的。此处
要分析的其它任何一种语言，透过实现层深究下去都可以发现用可移植纯C语言实现的
内核。这些语言继承了C语言的许多优点。
    在现代条件下，也许最好把C视作适用Unix虚拟机的高级汇编器（回顾一下第4
章作为实例分析的、对C成功之处的讨论）。C语言的标准已经把这个虚拟机的很多功
能，比如说标准I／0库，引出到其它操作系统之中。C语言就是既要尽量接近裸机又要
仍然保持稳定的最佳选择。
    即使更高级的语言能够满足编程的要求，我们仍然耍学习C，其中一个充分理由就是C
能帮助我们学会在硬件体系层次上考虑问题。对于已经是程序员的人来说，学习C的最好参
考和指导仍然是《The CProgramming Language》  （C编程语言）[Kemighan-Ritchie]。
    在Unix变种之间移植C代码几乎总是可行的，通常也很容易，但在一些特殊的变化
领域（例如信号和进程控制）可能非常需要技巧才能做对。我们将在第19章重点讨论这
些问题。尽管Windows NT至少在理论上支持符合ANSI/POSIX标准的C语言API，但
其它操作系统上C的不同约定肯定会导致一些移植问题。
    高质量的C编译器的开源软件可以在网上找到；其中最著名、使用最广泛的是自由
软件基金会的GNU c编译器（GCC （GNU Compiler Collection/GNU编译器集合）的组成
部分），GCC已经成为所有开源Unix系统、甚至很多闭源世界中Unix系统自带的C实
现。甚至Microsoft操作系统也有GCC。GCC的源码可在FSF的FTP站点
<ftp://ftp. gnu.org/pub/gnu>获得。
    总结：C语言最佳之处是资源效率和接近机器语言。而最糟糕的地方是其编程简直
就是赍源管理的炼狱。
www.pdf365.com
14.4语言评估
327
14.4.1.1  C实例分析：fetchmail
    C语言最好的案例分析是Unix内核本身，对于Unix内核而言，一个自然支持硬件
层操作的语言实际上就是～个巨大优点。但fetchmail是那种最适合使用C编写的用户态
实用程序范例。
    fetchmail只完成最简单类型的动态内存管理：它仅有的复杂数据结构是邮件服务器
控制块的单向链表，只在启动时创建，之后发生相当微小的变化。这避开了C的最大弱
点，从而大大削弱了并不适用C的情形。
    另一方面，这些控制块相当复杂（包括所有的字符串、标记和数字数据），在一个
缺乏C struct对应特征的实现语言中，很难将这些控制块作为一致的常规访问对象进行处
理。在这方面，绝大多数代用品都比C弱（Python和Java是明显的例外）。
    最后，fetchmail要求能够解析针对邮件服务器控制信息的、相当复杂的规格说明语
法。在Unix世界中，这类任务的经典解法是使用C代码生成器，C代码生成器从声明的
说明规格中为标记器（ tokenizer）和语法分析器生成源码。Vacc和lex的存在是使用C
语言编程的有力支持。
    fetchmail完全有理由使用Python编写，尽簪可能产生显著的性能损失。其规模大小
和复杂的数据结构可能马上就排除了shell和Tcl编程，Perl也非常不适合，其应用领域
也不在Emacs Lisp的自然范围内。Java实现本可以成为一个合理的方法，但Java面向对
象的风格和垃圾收集针在fetchmail的具体问题中并不会获得太多收益，简单的内存管理
用C就已经足够解决了。C++也没有办法可以更简化fetchmail相对简单的内部逻辑。
    然而，fetchmail成为C程序的真正原因是，fetchmail其实是从一个原本使用C编写
的前辈程序逐渐演化而来的。现有的实现已经在许多不同的平台和稀奇古怪的服务器上
进行了广泛的测试。把所有这些隐性的知识贯穿到用不同语言的重新实现中会非常棘手
和困难。更何况，fetchmail的一些功能（如NTLM认证）取决于外来代码，而这些代码
只在C版本才有。
  fetchmail的交互式配置器并没有C的遗留问题，所以使用Python编写；我们将在讨
论Python时分析该实例。
14.4.2  C++
当C++在1980年代中期首次公布于世时，面向对象（00）语言正被大肆吹捧为解
UNIX编震，艺术
    www.pdf365.com
328
第1 4章语言：C还是非C
决软件复杂度问题的“银弹”。C++面向对象的特性对于其前辈C而言是个压倒性的优点，
其拥趸期望C++能够迅速废掉更古老的C语言。
    这种情况当然并没有发生。部分可归因于C++本身的问题；对向后兼容C的要求迫
使C++在设计中做出了许多妥协。而且这个要求阻碍了C++完全自动化动态内存管理，
从而无法解决C语言最严重的问题。后来，薄弱、不成熟的标准化努力，并不能限制各
个不同编译器实现者之间的功能特征竞赛，C++变得过份精微复杂了。
    另外一部分原因必须归咎于00本身并没有达到期望值。我们已经在第4章分析了
这个问题，阐述了00方法往往导致厚重胶合层和维护问题。今天（2003年），对开源
文档（在这些文档中，语言的选择反映了开发者的判断而不是企业行政命令）的分析表
明C++的使用仍然大量集中于GUI、多媒体工具包和游戏（00设计的主要成功领域），
而在其它地方用得很少。
    也可能C++对00的实现特别容易产生问题。有证据表明C++程序比等价的C、
FORTRAN或Ada程序具有更高的生存期成本。这是00的问题还是C++特有的问题或
者是两者共同的问题，答案还不清楚，尽管有理由怀疑两者都牵涉萁中[Hatton98]。
    近年来，C++已经包含了一些重要的非00概念；它具有和Lisp类似的异常；也就
是说，在被处理程序捕捉之前可以沿调用栈向上抛出值或对象。STL（标准模板库）提
供了泛型编程；也就是说，可以编写独立于数据结构的算法并将其编译而在运行期完成
任务o  （只有执行编译期静态类型检验的语言需要它；更动态的语言只传递无类型的引
用，而在运行时支持类型识别。）
    高效的编译型语言；对C的向上兼容；面向对象的平台；STL和泛型等最前沿的技
术工具-C++试图满足所有人的所有要求，但代价是C++比任何一个程序员所能处理
的复杂度都要高。正如我们在第4章指出的～样，这个语言的主要设计者已经承认他不
指望任何一个程序员能够完全掌握C++。Unix黑客对此并没有很好的反应；一段匿名但
非常著名的评论这样描述“C++:狗被钉上软肢而变成的章鱼”。
    然而，说白了，C++最根本的问题还是在于它根本上只是另外一种传统语言。在标
准模板库发明后，C++的内存管理控制有所改善，比C好得多，但仍然十分脆弱；除非
代码仅使用对象，否则控制仍1日无用。对许多类型的应用而言，C++的00特性并不重要，
www.pdf365.com
14.4语言评估
329
没有带来多少优势，徒增复杂度而已。尽管存在不少开源的C++编译器；
确比C高级，那C++现在肯定占尽优势了。
    总结：C++的最佳之处是编译效率以及面向对象和泛型编程的结合。
非常怪异复杂，往往鼓励过分复杂的设计。
    如果现有的C++工具包或服务库为应用程序提供了强大有效的方法，
用领域正是上述00语言具有巨大优势的领域，可以考虑C++。
但如果C++的
最糟之处是它
或者所在的应
    C++的经典参考资料是Stroustrup的The C++ Programming Language （C++编程语言）
【Stroustrup]。有关C++和00基本方法的优秀入门指导是C++:A Dialog[Heller]。《C++
详注>  （C++ Annotations）[Brokken]则是针对C专家程序员的简明介绍。
    GCC包含一个C++编译器。因此这个语言广泛应用于Unix和Microsoft操作系统：
前面对C提出的有关说明在此处同样适用。非常强大的开源支持库可从
<http：／／www．boost．org／>获得。C++的ISO标准草案（到2003年中）正处于准
备期，而实际的C++实现往往遵循其相差甚大的子集．正是这个事实恰恰损害了C++
的可移植性4。
14.4.2.1  C++实例分析：Qt工具包
    Qt界面工具包是C++在当今丌源世界中最成功的故事之一。它提供了在X下编写图
形用户界面的窗口构件和API，是为了仿效Motif、MacOS Platinum或Microsoft Windows
界面的可视化观感而专门设计的。实际上，Qt不仅提供GUI服务；也提供了可移植应用
层，具备众多类库，可供完成XML、文件访问、套接字、线程、定时器、时间／日期处
理、数据库访问、各种抽象数据类型和Unicode处理。
    在开源世界中，有两项工作创造了有竞争能力的GUI和集成桌面生产工具包，KDE
是其中资格较老的一个，而Qt工具包则是KDE项目中关键的可视组成部分。
    Qt的C++实现展示了00语言在封装用户界面构件方面所具有的优势。在支持对
象的语言中，通过类实例的分层可在代码中清楚表达出界面窗口部件的可视化分层。
尽管这类任务在C中可以通过手动书写方法列表进行明确的转向调用来模拟，但用C++
编写的代码要干净得多。将此同C编写的、非常复杂的Motif API比较非常具有启发意
义。
4最近的一个C++标准从1998年开始，实现甚广，但仍旧根弱，特别是在代码库领域。
UNIX -4iO&-'2t肴
  www.pdf365.com
330
第14章语言：C还是非C
Qt的源码和参考文档可在Trolltech站点<http：／/www．trolltech．com/>获得。
14.4.3  Shell
    Unix版本7的“Bourne shelr'（ sh）是Unix第一个（而且在很多年中也是Unix唯
一的）可移植的解释型语言。今天，最先的Boume shell很大程度上已经被向上兼容的
Kom Shell （ksh）的各种变种所替代；其中最重要的一个变种是Boume Again Shell，
即bash。
    也存在其它一些shell、也可交互使用，但这些语言不足以作为编程语言：其中最著
名的恐怕就是C shell即csh了，csh以不适合编写脚本而出名5。
    简单shell程序的编写极其容易和自然。Unix使用解释型语言的快速原型设计传统就
始于shell。
    我用1 50行shell脚本编写了第一版netnews。它支持多个新闻组，可以交叉
  发贴；新闻组是目录，交叉发贴则以对文章的多个链接来实现。虽然用于实用太
  过缓慢，但其灵活性允许进行无穷的协议设计试验。
-Steven M. Betlovin
    然而，随着程序规模越来越大，这些程序往往变得非常专用。部分shell语法（特剔
是其引用和声明语法规则）变得十分混乱。为了shell作为交互式命令行解释器的实用性，
而在设计中对语言部分做了折中，这些缺点就是这么来的。
    即使程序不完全使用shell编写，但包含人量对sort“／）之类的C过滤器或sed （1）、
awk （1）之类的标准文本处理微型语言的使用，则也可称为“用shell”编写而成。然而，
这类程序在过去数年内逐渐式微，现在此类复杂的胶合层通常用Perl或Python编写，而
shell只是为最简单的包装器（那些语言使用在包装器上是大材小用）和系统启动时的初
始化脚本（不能假设已经安装了什么语言）而保留。
5参阅Tom Christiansen的文章Csh Programming Considered Harmful （Csh编程有害论），网上很容易
搜索到。
www.pdf365.com
14.4语言评估
331
    任何入门级Unix书籍都对此类基本的shell编程作了充分的说明。The Unix
Programming Environment （Unix编程环境）[Kernighan-Pike84]仍然是最好的中高级shell
编程参考书之～。每个Unix上都有Kom shell的实现或翻版。
    复杂的shell脚本经常产生可移植性问题，主要原因并不在于shell本身而在于shell
使用了某些它假定存在的程序。尽管偶尔可在非Unix操作系统中发现Bourne和Kom
shell变种，shell程序（实际上）根本无法移植到Unix之外。
    总结：shell的最佳之处在于书写小型脚本非常自然快捷。最糟之处在于大型shell
脚本必须依靠大量辅助命令，而这些辅助命令不一定在所有目标机器上都表现～致甚至
不一定存在。要在大型shell脚本中分析依赖关系并不容易。
    既然所有的Unix系统和Unix仿真器都配置了shell，因此几乎从来不需要编译或安
装shejl。在Linux和其它先进的Unix变种上的标准shell已经是bash了。
14.4.3.1  案例分析：xml七。
    xmlto是一个驱动脚本，调用所有必要的命今将XML-DocBook文件转换成HTML、
PostScript、纯文本或其它格式中的任何一种（我们将在第1 8章具体分析DocBook）。
它用bash编写而成。
    xmlto使用恰当的样式表处理XSLT引擎的调用细节，然后把结果传递给后续处理
器。对于HTML和XHTML，XSLT转换完成全部的工作。对于纯文本，XML也先处理
成HTML，然后传递给后续处理器——以- dump模式调用lynx（1），它把HTML转换
成纯文本。对于PostScript，XML转换成XML FO（formatting objects，带格式对象），
由后续处理器将其映射成TEX宏，通过tex（1）转换成DVI格式，最后由众所周知的
dvi2ps（1）工具转换成PostScript。
    xmlto是单体前端shell脚本。它调用某个根据目标格式命名的脚本插件。每个插件
都是一个shell脚本。根据调用方式的不同，xmlto提供一个样式表供前端使用，或者以
各种预置的参数调用适当的后续处理器。
    这种架构意味着特定输出格式的所有信息都存放在一处（相应的脚本插件），因此
根本无需涉及前端代码就可以增加新的输出类型。
    xmlto是中型shell虚用程序的范例。由于C或C++都难以编写脚本，因此不适用。
本章描述的其它脚本语言虽可以用于此，但由于它只是简单的命令分派，没有内部数据
结构或复杂的逻辑，因此shell就足够了。而使用shell的重要优势就是在预期的目标系
UNfX编程艺术
  www.pdf365.com
332
第1 4章语言：C还是非C
统中shell普遍存在。
    理论上这个脚本可在支持bash的任何系统上运行。真正的限制是系统必须存在某个
XSLT引擎以及所有后处理器。实际上，除了现代的开源Unix，这个脚本不大可能运行
在其它任何地方。
14.4.3.2  实例分析：Sorcery Linux
    Sorcerer GNU/Linux是一个Linux发布版本，作为一个小型可启动简单系统而安装，
但它足以运行bash （1）和其它一些下载程序。一旦代码就绪，就可以启用Sorcery，即
Sorcerer包系统。
    Sorcery处理各种软件包的安装、卸载和完整性检验。输入指令后，Sorcery下载源
代码，对其进行编译和安装并保存安装的文件（以及编译日志和所有校验文件）。安装
好的软件包可删除或卸载。也可以列举软件包和进行完整性检验。更多详情参见Sorcery
项目竭}点<hLtp：//sorcerer .wox - org>。
    Sorcery系统完全使用shell编写而成。安装程序往往是很小的简单程序，shell对此
最为合适。在这个具体应用中，因为Sorcery的作者可以确保需要的辅助程序都在这个简
单系统中，所以shell的主要缺蠃被抵消了。
14.4.4  Perl
    Perl是增强了的shell。它为代替awk （l）而专门设计，并扩展用来代替shell作为
混合语言脚本编程的“胶合剂”使用。Perl首次发布于1987年。
    Perl最强功能是其内置的对文本、面向行的数据格式进行模式导向的处理功能。比
起shell，Perl包含更加强大的数据结构，包括混合元素类型的动态数组和支持名一值对的、
查找方便迅捷的散列（字典）类型。
    此外，Perl还包括一个完备的、经过深思熟虑的全套Unix API的内部支持，显著减
少了对C的需求并使其非常适合完成简单的TCPfIP客户端甚至是服务器端的工作。Perl
的另外一个优势在于围绕Perl已经形成了一个强大的开源社团。社团在网络上的主页是
Perl综合典藏网（Comprehensive Perl Archive Network） <http：／/WWW - cpan．org>。
献身于Perl的黑客们已经编写了成百上千个自由重用的Perl模块，可完成多种不同的编
程任务，从目录的结构遍历树、用于GUI构件的X工具包，到HTTP机器人和CGI编
程。
www.pdf365.com
14.4语言评估
333
    Perl的主要缺点在于某些部分丑陋到无法补救，某些部分过于复杂，某些部分必须
谨慎地、～成不变地使用以防出错（Perl的函数参数传递约定就是所有这三个问题的典
型例子）。同shell相比，Perl较难起步。尽管使用Perl编写的小型程序能够特别有效，
但随着程序规模越来越大，要遵守严格约定才能保持模块性和设计的可控性。由于无法
推翻Perl历史上一些限制性的设计决定，许多更高级的功能都具有一种脆弱、拼凑的感
觉。
    Perl的权威参考是Programming Perl （Perl编程）[Wa112000]。该书几乎包含了需要了
解的一切内容，但其结构出名的差；必须从中挖掘出要了解的知识。Leaming Perl（学习
Perl） [Schwartz-Christiansen]则提供了更有叙述技巧的入门级内容。
    Perl在Unix系统非常普遍。主版本相同的Perl脚本往往在各种Unix版本之间可以
直接移植（前提是这些Perl脚本不使用扩展模块）。Microsoft操作系统和MacOS上也
有Perl实现（甚至具备很好的文档）。而Perl/Tk提供了跨平台GUI能力。
    总结：Perl的最佳之处是作力强力工具以供大量涉及正则表达式匹配的小型胶合脚
本使用。最糟之处在于当程序很大时Perl会变得非常丑陋、刻板，几乎无法维护。
14.4.4.1  小型Perl程序案例分析：blq
    blq脚本是查询拒收列表（网站列表，已经确认为未经请求就大批量发送邮件，即
垃圾邮件的惯常发布源）  的工具。现行源码可在bla项目主页
<http：//www．unicom．com/ sw/blq/>上获得。
    blq是小型Perl脚本的范例，说明了Perl语言的优点和缺陷。它大量使用正则表达
式匹配。另一方面，Net::DNS Perl扩展模块可能需要额外安装，因为无法保证它在指定
的Perl安装上已经存在。
    blq和其它Perl代码一样特别干净和规范，因此我推荐其为良好风格（blq项目主
页引用的其它Perl工具也是好例子）的典范。但除非熟悉Per】具体的语法风格，否则有
部分代码是无法读懂的——代码的第一行，即$o=。8 1．★／！！j，就是个例子。尽管所
有的语言都有这类晦涩，但Perl是其中最晦涩的。
    Tcl和Python也非常适合编写这种类型的小脚本，但这两种语言都缺乏blq中大量
使用的正则表达式匹配，这在Perl中非常简便；采用任何～种语言来实现也许都有理由，
UNIX编罹艺I术
  www.pdf365.com
334
第1 4章语言：C还是非C
但可能都不如Perl紧凑和富有表达力。Emacs Lisp实现甚至可能比Perl实现编写更快、
更紧凑，但可能使用起来是令人痛苦不堪的慢。
14.4.4.2  大型PerI实例分析：keeper
    keeper是在ibiblio站点为大型Linux自由软件档案归档外来包并维护FTP和WWW
索引文件而使用的工具。可以在ibiblio档案站点<http：／/www．ibilolio．org>的搜索
工具子目录中找到源码和文档。
    keeper是大中型交互式Perl应用程序范例。命令行界面是面向行，并以专门的shell
或目录编辑器的面貌出现：内嵌的帮助功能值得注意。工作部分大量使用文件目录处理、
模式匹配和模式导向编辑。注意，keeper从程序模板生成网页和电子邮件通知非常便
利。也请注意，它使用白带的Perl模块来自动化在目录树不同功能之问的遍历。
    这个应用程序大约有3300行，町能提升了我们对~个Perl程序应有规模大小和复杂
度的期望极限。尽管如此，这个程序大部分在六天之内编写完成。如果使用C、C++或
Java，至少可能需要六周，而且完成之后特别难以调试或修改。这个程序对纯Tcl来谠过
大了。Python编写的版本可能在结构上更干净、更可读、而且可维护性也更好——但可
能也更冗长（特别是在模式匹配及相关部分）。Emacs Lisp模式也完全可以胜任编写工
作，但Emacs不太适合在telnet连接上使用，因为它经常因为服务器拥挤而速度慢得像
蜗牛。
14.4.5  Tcl
    Tcl（工具命令语言）是一个设计来连入C编译库的小型语言解释器，提供C代码的
脚本控制（扩展脚本）。Tcl的最初应用是控制电子仿真器所用的程序库（SPICE之类的
应用程序）o Tcl也适用于内嵌脚本——即从C程序内部调用脚本然后返回值。Tcl于1990
年首次发布。
    在Tcl之上构建的一些功能在Tcl社区以外得到了广泛的使用。其中最重要的两个功
能是：
●  Tk工具包，一种更亲切和更友好的X接口，便于快速构建按钮、对话框、菜单
    和滚动文本窗口并从这些构件中收集输入信息。
www.pdf365.com
14.4语言评估
335
    ●  Expect，一种更容易编写具有更多种响应纯交互程序的语言。
    Tk工具包如此重要，使得这个语言经常被称作为Tcl/Tk。Tk也频繁用于Perl和Python
中。
    Tcl自身的主要优势在于它特别灵活而且本质上非常简单。语法非常奇特（以位置分
析器（ positional parser）为基础），但整体上是统一的。没有保留字，在函数调用和内置
语言特性间也没有语法区别；这样，Tcl语言解释器本身就可以在Tcl内部有效地重新定
义（这就是象Expect之类程序的合理性所在）。
    Tcl的主要缺点在于纯Tcl语言只有十分薄弱的命名空间控制和模块性功能，而且如
果使用不当，其中两个（upvar和uplevel）相当危险。同时，除了关联列表以外，
Tcl也没有数据结构。因此，很难扩展Tcl-即使是中等大小（超过几百行）的纯Tcl
程序也很难在不绊倒自己的前提下进行组织和调试。在实践中，几乎所有大型的Tcl程
序都使用其00扩展。
    语法的怪异最初也是个问题：字符串引号和括号之间的区分可能让人头疼一阵，何
时使用引号、何时使用括号也需技巧。
    纯Tcl只提供对Unix API相对较小的常用部分的访问（基本上只是丈件处理、进程
生成和套接字）。实际上，Tcl具有～种实验的意味，看看一个脚本语言究竟变到多小还
依然有用。Tcl扩展（与Perl模块类似）提供了更为丰富的能力集，但（和CPAN模块
一样）不能保证处处都有安装。
    Tcl最早的参考资料是Tcl and the Tk Toolkit （Tcl和Tk工具包）[Ousterhout94]，但这
本书大部分已经被Practical Programming in Tcl and Tk （Tcl和Tk实用编程）[Welch]所替
代了o  Brian Kernighan对现实世界中的Tcl项目进行了一番描述[Kemighan95]，总结了
Tcl作为快速原型设计和开发工具的长处和不足；其中与Microsoft Visual Basic的对比非
常客观并具有指导意义。
    同Perl、Python不一样的是，Tcl世界并没有一个由核心团体管理的中央资料库，但
有几个优秀的网站互相链接并涵盖了大部分的Tcl工具和扩展开发。首先看以下的Tcl
Developer Xchange<ht tp：／／www. tcltk．com>;这个站点除了其它内容外，还提供了
一个交互式Tcl指导材料的来源。在SourceForge站点<ht七p：／／sourceforge．ne七
／foundry/tcl-f oundry/>上也有一个Tcl资料库。
    Tcl脚本也具有和shell脚本类似的可移植性问题；这个语言本身非常适于移植，但
它调用的组件未必如此。Microsoft操作系统、MacOs和许多其它平台也存在Tcl实现。
任何具有GUI能力的平台都可以运行Tcl/Tk脚本。
UNI×编翟艺术
  www.pdf365.com
336
第14章语言：C还是非C
    总结：Tcl的最佳之处在于它节俭、紧凑的设计和Tcl解释器的可扩展性。最糟之处
在于其古怪的位置分析器和孱弱的数据结构及命名空间控制——这个缺陷使其很难适用
于大型项目。
14.4.5.1实例分析：TkMan
    TkMan是Unix手册页和Texinfo文件使用的浏览器。这个程序大约1200行，使用
纯Tcl编写，应该说相当庞大，但代码出乎寻常地成熟和模块化。它使用Tk来提供GUI
界面，比原有公用程序man门j或xman（，，j支持的GUI界面更加友好。
    TkMan是个很好的研究实例，充分展示了Tcl的全套技法。突出表现在Tk集成、脚
本控制Unix的其它应用（如Glimpse搜索引擎），以及解析Texinfo标记的Tcl使用上。
    在其它任何一种语言中，都不可能用类似于它的代码产生如此直观的Tk GUI界面。
    在网络上查找关键字TkMan可以找到一些源码和文档。
14.4.5.2  Moodss:大型Tcl案例分析
    Moodss系统是一个系统管理员使用的图形界面监控应用程序。它可以监控系统日
志，为MySQL、Linux、SNMP网络和Apache等收集统计信息，并通过称为“dashboardw
的类似电子表格的GUI控制面板提供这些统计信息的摘要。监控模块也可象Tcl -样使
用Python、Perl等编写。这段代码非常精美、成熟，被视为Tcl社区中的典范。项目网
站为<http://j￡ontain.free.fr/moodss/>.
    Moodss内核包含18，000行Tcl代码。它使用了数个Tcl扩展，包括一个定制对象系
统：Moodss的作者承认，如果没有这些扩展的话，“编写如此巨大的一个应用程序是不
可能的”。
    再一次，在其它任何一种语言中，都不可能用类似于它的代码产生如此直观的Tk
GUI界面。
14.4.6  Python
    Python是一种脚本语言，设计本意是与C语言紧密集成。它既可以从动态载入的C
库程序中接收数据也可以向其传输数据，它也能够在C中作为嵌入脚本语言调用。Python
的语法介于C语言和Modula系列语言之间，但有个非常罕见的特征，即代码块结构实
www.pdf365.com
．-月月lE言{∞t七
I't．叶  匝口阡『口
337
际上用缩进来控制（没有明确的begin/end或C花括号之类的东西）。Python最早公开
发布于199 1年。
    Python语言的设计是非常干净优雅，具有非常出色的模块化特性。它提供了设计者
用面向对象风格编码的可能，但并不把这个选择强加于设计者（可以用更加经典的类C
方式编码）。它的类型系统，其表达力和Perl系统相当，包括动态容器存储对象和关联
列表（ association list），但并非那样怪异（实际上，Perl对象系统模仿了Python对象系
统是有案可查的）。它甚至因为具有匿名lambda对象（以函数为对象值，可在迭代器之
间传递并被迭代器使用）而迎合了Lisp黑客。同Python -起发布的一般还有Tk工具包，
可以非常方便地构建GUI界面。
    Python标准发布包括大多数重要网络协议（SMTP、FTP、POP3、IMAP和HTTP）
的客户类以及HTML生成器类。因此它非常适合构建协议机器人和网络管理工具。它也
非常适合Web CGI任务，并能在这个高复杂的领域中同Perl竞争，并取得一席之地。
    对于扩展需要协同开发的大型复杂项目，在我们描述的所有觯释型语言中，Python
和Java无疑是两个最佳的语言。在很多方面Python都比Java简单，并且它对快速原型
设计的亲和性，使它独立使用在那些既不太复杂又不要求速度致胜的应用程序中并优于
Java。Java实现的Python，其设计目的是为了促进这两种语言的混合使用，目前已面世
了并用于开发；称之为Jython。
    Python在纯执行速度方面无法同C或C++竞争（尽管在现今快速处理器上应用混合
语言策略使这点已经相对不那么重要）。实际上，人们通常认为Python是主要脚本语言
中效率最低、速度最慢的语言，这是它为运行期类型多态付出的代价。然而当心，别因
为这些原因而拒绝Python，Python能够提供的性能实际上已经满足人多数应用程序，即
使那些似乎需要更好性能的程序通常也受到网络等待或磁盘等待等外部延时的限制，从
而完全抵消了Python解释型开销产生的影响。作为补偿，Python特别容易和C结合起来，
因此性能关键的Python模块可以很方便地转换成C语言来显著提高速度。
    对于小型项目和大量依靠正则表达式能力的胶合脚本，Python不如Perl的表达力强。
对于太小的项目，Python是大材小用了．shell或Tcl也许更适合。
    同Perl -样，Python也形成了一个组织良好的开发社区，其核心站点
<http：／/www．pyt hon．org>包含大量有用的Python实现、工具和扩展模块。
    Python的权威参考是《Programnung Python》（Python编程）[Lutz]。Python网站上也
有关于Python扩展的大量在线文档。
    Python程序往往可在各种Unix之间移植，甚至可以移植到其它操作系统；标准库非
UNIX编瞬l艺．宋
    www.pdf365.com
338
第1 4章语言：C还是非C
常强大，显著减少了对不可移植的辅助程序的使用。Microsoft操作系统和MacOS上也
有Python实现。只要有Tk或其它两种工具包就可以跨平台实现GUI开发。Python/C应
用程序可以被“冻结”（frozen），准编译成纯C源码，这样就可以移植到没有安装Python
的系统上。
    总结：Python的最佳之处在于它鼓励清晰、易读的代码，易学易用，又能够扩展到
大型项目。最糟之处在于，不仅相对于编译语言，而且相对于其它脚本语言，它也是效
率低下、速度缓慢的。
14.4.6.1  小型Python案例分析：imgsizer
    imgsizer是一个改写www网页的公用程序，能够在图像标记中加入图像的正确尺
寸（这提升了在很多浏览器上的网页载入速度）。可以在ibiblio档案站点
<ht tp：／／mⅢ．ibiblio．org>的URL WWW工具子目录下找到源码和文档。
    imgsizer最初使用Perl编写，几乎是Perl擅长的那种小型、模式驱动的文本处理
工具的理想实例。后来为了利用Python对HTTP获取的库支持优势而转化成了Python；
这消除了对外部网页获取程序的依赖。注意宦使用了file（1）和ImageMagick identify（1）
作为提取图像像素大小的专用工具。
    动态字符串处理和复杂正则表达式匹配的需求让使用C或C++来编写imgsizer变
得异常痛苦；而且相应的版本也会更加庞大、更加难读。Java当然也可以解决隐含的内
存管理问题，但在文本模式匹配方面几乎不会比C或C++更有表达力。
14.4.6.2  中型Python案例分析：fetchmailconf
    在第II章，作为分离实现和接口的例子我们分析了fetchmaiUfetchmailconf程序对。
fetchmailconf很好地展示了Python的优势。
    fetchmailconf使用Tk工具包来实现多面板GUI配置编辑器（Python中也有GTK+
和其它工具包的，但每个发布Python解释器中都包含Tk工具包。）
    在专家（expert）模式，GUI支持编辑六十个左右的属性，分成三个面板。属性窗口
部件包括复选框、单选按钮、文本框和滚动列表栏。尽管这样复杂，但配置器的第一个
全功能版本只花了我不到一周的时间就完成了设计和编码，其中还包括学习Python和
Tk的四天时间。
www.pdf365.com
339
    Python擅长GUI界面的快速原型设计，而且（正如fetchmailconf所示）此类原型通
常也是可交付的。Perl和Tcl在此领域也有类似的优势（包括为Tcl编写的Tk工具包），
但很难控制到fetchmailconf的复杂度（大约1400行）级别上。Emacs Lisp不适合GUI
编程。而选择Java会提高复杂度开销，且不会为这个非速度致胜型程序带来显著收益。
14.4.6.3  大型Python案例分析：PIL
    PIL，即Python Imaging Library （Python图像库），支持位图图像处理。它支持许多流
行的格式，包括PNG、JPEG、BMP、TIFF、PPM、XBM和GIF。Python程序可用它来
转换图像；支持的变换包括裁剪、旋转、缩放和切变：也支持像素编辑、图像卷积和色
彩空间转换。PIL发布包括从命令行运行这些功能的Python程序。这样，PIL可用于批
处理模式的图像转换或作为一个强力工具包执行由程序驱动的位图图像处理。
    PIL的实现表明Python能够直接使用可装载的目标码扩展模块增强Python解释器。
为了提高速度，在位图对象上执行基本操作的库内核是用C编写的。上屡和前后逻辑则
是用Python编写的，速度慢，但更容易阅读、修改和扩展。
    使用Emacs Lisp或shell编写类似的工具包会非常困难，甚至不可能。因此Emacs Lisp
或shell根本没有C扩展接口，而如果用Tcl编写的话，PIL会大得令人不舒服。Perl具
有类似的功能（Perl XS），但同Python相比，它过于专用，文档不全，十分复杂，也不
稳定，因此使用得少之又少。Java的本地方法接口（Native Method Interface）似乎能够
提供和Python大致相当的功能；PIL可能成为～个相当合理的Java项目。
    在项目站点<http：／/www．pythonware．com/produc tS /pil/>可获得PIL的
代码和文档。
14.4.7  Java
    Java编程语言的设计目标是“wnte once，run anywhere（-次编写，到处运行），，，
并且支持网页中嵌入交互程序（即applets），可在任何一个浏览器中运行。由于其所
有者Sun Microsystems的一系列技术和战略失误，Java没有实现这两个最初的设计目
标。但它在系统编程和应用编程方面仍然十分强大，足以挑战c和C++c， Java岔布于
1995年。
UNIX编窿艺-术
    www.pdf365.com
340
第1 4章语言：C还是非C
    尽管远比C++小巧简单，但Java设计非常聪明地抓住了自动管理内存的巨大优势，
也抓住了支持00设计这一虽小却并非不重要的优点。Java保留了大量的类C语法，大
多数程序员对此感觉非常舒服。它也包括支持动态载入的C调用并支持在C中把Java
作为嵌入语言调用。Sun公司在网上提供良好Java文档的工作完成得非常出色，这一点
作用也不可小觑。
    Java的负面，我们可以说（例如，同Python相比较）有些部分显得过于复杂，而另
外一些部分则不够完善。Java中，类的可见／不可见区域的规定非常复杂。接口功能虽然
避免了多继承产生的复杂问题，但理解和使用并不会简单多少。内部类和匿名类等特征
可能会导致非常混乱的代码。而缺乏可靠的析构方法则意味着内存以外的其它资源，例
如互斥（ mutex）和文件锁定等，难以保证得到正确管理。Unix操作系统的重要功能也
无法从Java主体中访问，包括信号、poll和select等。尽管Java的1/0功能非常强大，
但文本文件的简单读取并不简单。
    Java库存在一个特别令人反感的问题，和Windows DLL hell问题非常相像。Java没
有管理不同库版本昀方法气这在应用服务器之类的环境中会产生巨大的问题，因为服务
器可能配置的是（比如说）某XML库版本，但应用程序却随另外（通常是较新的）版
本一起发布。对此类问题的唯一处理是使用CLASSPATH环境变量，但却是不断产生配
置问题的错误来源。
    更进一步，Sun公司对Java语言的处理无论在政策上还是在技术上都十分迟钝。Java
的第一个GUI工具包AWT一团糟，必须完全替换掉。而把该语言从ECMA/ISO标准中
撤出进～步激怒了早已为Sun Community Source License（SCSL）感到恼火的众多开发人
员。SCSL的限制还妨碍了Java l.2的开源实现和J2EE（Java 2 Enterprise Edition/Java 2
企业版）规格说明。这损害了Java普遍移植的初衷。
    悲哀的是，浏览器applets已经消亡了。Microsoft在IE中不支持Java l.2的决定实
际上绞杀了它们。然而，Java似乎在计算业中发现了一个安全的生存空间，让“servlets"
在网页应用服务器的内部运行。Java也经常用于不和数据库或网页服务器直接相连的企
业内部编程。它也已经成为Microsoft的ASP/COM乎台和Perl CGI的主要竞争者。最后，
作为初级编程（Java特别适合这个角色）的教学语言，Java的使用越来越广泛。
    总而言之，我们可以认为，对于除系统编程以及大多数速度关键的应用程序外的一
切编程而言t  Java比C++高级（C++复杂得多，而且没有为解决内存管理问题作出多少
努力）。经验似乎表明，和C++程序员相比，Java程序员掉进过度00分层这一陷阱的
可能性似乎要小一点，尽管这仍然是个大问题。
www.pdf365.com
14.4语言评估
341
    如何权衡Java和我们本章描述的其它语言，目前还不清楚，可能主要取决于项目
的规模。我们可以设想Java的正确使用范围和Python比较相近。同Python -样，Java
无法和C或C++在原始执行速度方面竞争，也无法和Perl在大量使用模式引导编辑的
小项目竞争。Java对小项目是大材小用（这一点比Python更确定）。我们可以认为，
Python在小一些的项目上具有优势，而Java在大一些的项目上具有优势，但这并非定
论。
    最好的参考书可能是Java In A Nutshell （Java技术手册）Flanaganjava】，但这不是最好
的入门级指导材料；最好的入门级指导可能是Thinking in Java Clava编程思想）[Eckel]。对
全球所有Java网站的链接始于Sun公司的Java站点<http：／／j ava．sun．com>，该站点
也具有可免费下载的完整HTML文档。开源目录Java网页（Open Directory Java Page）
<ht tp：／/dmoz．org/Computers/ Programming/Languages/Java/>也汇集了许
多有用的Java键接。
    所有的Unix操作系统、Microsoft操作系统、MacOS和其它很多平台都有Java实现。
    可在Kaffe项目站点<http：／/www．kaffe．org／>获得Kaffe（ -个开源Java实现，
类库符合大多数JDK l.1和部分JDK l.2的要求）的源码。
    GCC也有一个Java前端。GCJ可以把Java代码编译成Java bytecode或本机码，
也可以把Java bytecode编译成本机码。它配置了执行大部分JDK l.2要求的开源类库·
和一个称为gij的Java bytecode解释器。  详情参见GCJ项目网页
<http: //gcc. gnu. org/j ava/>。
在JDEE项目站点<ht tp：／／jdee．sunsite．dk/>有基于Emacs的Java IDE。
    Java语言本身的可移植性非常优秀。但不完整的库实现（特别是不支持新JDK l.2
的老JDK l.1库）是个问题。
    Java的最佳之处在于它非常接近“…次编写、到处运行”的目标，作为～个独立于
操作系统的环境非常有用。最糟之处在于Java l/Java 2的分裂令人沮丧地损害了这个目
标的实现。
UNIX编程艺_术
    www.pdf365.com
342
第1 4章语言：C还是非C
14.4.7.1  案例分析：FreeNet
    Freenet足一个对等网络项目，目的是创建没有审查和内容禁止的网站6。Freenet开
发者设想了以下应用：
    ●  争议信息的不审查分发：Freenet保护言论自由，范围从民间另类新闻到受禁曝
    光材料的林林总总，都可以不经审查地匿名发表。
    ●  高带宽高效内容发布：用Freenet的适应性高速缓存（adaptive caching）和镜像
    来发布Debian Linux更新软件。
    ●．通用个人发布：Freenet让任何人都能够拥有没有空间限制和强制性广告的网站，
    即使没有电脑而想成为网站管理员的人也能如愿以偿。
    Freenet通过提供一个虚拟空间来达到这些目标，在这个虚拟空间中发布的文档不与
任何具体的机器相关。发布信息和Freenet内部数据索引通过网络进行复制分发，即使是
Freenet管理员在任何给定时间里也不清楚所有的物理文档会在哪里。Freenet浏览者或信
息提交者的隐私通过强密码系统加以保护。
    Java作为这个项目的上上之选至少有两个理由。首先：项目目标非常重视最广泛的
实现兼容性，因此Java的高度可移植性成为一个主要优势。其次：这个顼目的本质促使
网络API变得非常重要，而Java恰好内置了一个强大的API。
    C通常用于对性能要求很高的基础项目上，但缺乏标准的网络API使移植变得非常
困难。C++也存在同样的困难。Tcl、Perl或Python可以减轻移植负担，但代价是牺牲太
大的性胄皂。Emacs Lisp速度缓慢得令人痛苦因而完全不适用。
14.4.8  Emacs Lisp
    Emacs Lisp是一种脚本语言，用于Emacs文本编辑器的行为编程。它首次发布于1984
年。
    从本章其它语言分析的相同角度来说，Emacs Lisp并不是一种通用语言：尽管它足
够强大，理论上可以作为通用语言使用，但传统上，它只用于为Emacs编辑器编写本身
的控制程序，并不像现代脚本语言那样能和其它软件顺畅通讯。
6 Freenet项目的网站：<http：//freenetproj ect .org>。
www.pdf365.com
14.4语言评估
343
    尽管如此，在相当范围的应用中，Emacs Lisp比其它语言更为有效。这些程序大多
都与为开发工具提供一个前端有关，包括C编译器和链接器、make （l）、版本控制系
统和符号调试器等等；我们将在第15章讨论这些内容。
    更一般的是，Emacs之于模式导向或语法导向的爻互编辑，就如同Perl之于模式导
向的批处理编辑一样。任何涉及交互编辑特定文件格式或文本数据库的应用程序，使用
Emacs模式（一种定制编辑器行为的Emacs Lisp程序）进行原型设计（甚或交付）都是
上佳的选择。
    Emacs Lisp也非常适合构建必须和文本编辑器紧密整合在～起的应用程序，或是主
要作为文本浏览器而兼具某些编辑功能的应用程序。email和Usenet新闻的用户代理就
属于此类。一些数据库前端也是如此。
    Emacs Lisp是一种Lisp语言。它自动进行内存管理，就像黑夜之后是白天一样自然，
因而比大多数传统语言更雅致、更有效，或者，确切地说，也比大多数新兴语言都更雅
致、更有效；在这个方面它可以同Java或Python竞争，更远超C/C++、Perl、shell或
Tclo Lisp缺少标准的可移植OS规范，这个老毛瘸已由Emacs内核解决，实际上Emacs
内核就是其OS规范。
    Lisp另外一个老毛病——狂吃资源一一在现代机器上也不再是个问题。  “Emacs
Makes A Computer Slow"  （Emacs让计算机变慢）和“Eventuallv Munches All Computer
Storage"（最终吃光所有计算机内存）之类的调侃曾经非常流行（实际上Emacs发布本
身就包含这样的一个笑话列表）。但现在其它许多经常使用的程序（如网页浏览器）都
比Emacs更大、更复杂，所以比较而言，反而Emacs似乎变得比较适中了。
    Emacs Lisp的权威参考是The GNU Emacs Lisp Reference Manual （GNU Emacs Lisp
参考手册），可在Emacs的"info"帮助系统中浏览。如果没有，可从FSF的FTP站点
<ftp：／／ftp．gnu．org/pub/gnu>下载。如果觉得太深，《Writing GNU Emacs
Extensions》（编写GNU Emacs扩展编写）[Glickstein]可能会有帮助。
    Emacs Lisp程序的可移植性非常卓越。所有的Unix操作系统、Microsoft操作系统和
Mac搡作系统都有Emacs实现。
    总结：Emacs Lisp的最佳之处在于结合了非常优秀的基础语言Lisp，其域原语对文
本操作非常有效。最糟之处在于性能较差，难以和其它程序通讯。
更多详情参阅后续章节“选择编辑器”中对Emacs的讨论。
UNIX编霜已艺：习}
    www.pdf365.com
344
第1 4章语言：C还是非C
14.5未来趋势
    表14.1大致表明了当今语法使用的分布情况。我们给出了来自SourceForge7和
Freshmeat的数据8，这是到2003年3月为止两个最重要的新软件发布站点。
    SourceForge的数字在几个方面有所欠缺：最明显的，SourceForge的查询界面不允
许同时将OS和语言作为过滤条件，所以其中部分数字代表的是MacOS和Windows项目。
其结果可能就是C++和Java的份额相对会放大一些。然而，基于Unix的项目充分地占
据了垄断地位（大概是3:1的比例），所以除了上述两个语言，其它语言的数据可能并
没有多大的变形。
    Freshmeat的样本数据较小，但是站点本身只发布基于Unix的项目——而且统计的
是确确实实的发布版本，不像SourceForge -样包括大量失败的、停顿的项目。有趣的是
同SourceForge相应统计相比，其比率几乎都是1:2，当然正好也要除去一些情况（C++
和Java），我们可以认为那不成比例，是因为Freshmeat缺少基于Windows的项目。
    本章最初在1997年起草；在2003年年中完成。这足一个相当长的时间段，趼以上
述我们检视的语言，自从第一次写作以来，其相对地位已经发生了改变，并显现出一种
采用趋势，而这趋势恰好昭示了其语言特征。  （对于这些最常使用语言的开源实现，其
提高和改善工作，社区规模就是一个重要的质量和数量因子；而其增长和衰落往往更增
加了说服力。）
    宽泛地说，C、C++以及Emacs Lisp在1997 - 2003时间段保持稳定，在2003年与
1997年一样，吸引着相同数量的支持者。C得到缓慢增长，占据了如FORTRAN更古老
传统语言的份额：另～方面，C++被Java夺取了些许阵地。
    Perl使用的增长非常可观，但语言本身在一段时间已停滞不前。Perl内部非常糟糕；
认识到语言实现需要推倒重来已经有好几个年头，但在1999年的努力却以失败告终，而
在2003年中的另一努力似乎也停滞了。不管怎样，Perl仍然还是八百磅巨型猩猩式的脚
本语言，并且在网页脚本和CGI方面占据主导地位。
    Tcl已经处于一个相对衰减的时代，或者至少是出镜次数逐渐减少的时代。在1996
7勿0计q次字来自<hLtp：／/sourcef orge．net/sof twaremap/Lrove_list．php?form_cat=160>，
8*TCj+4~~来自<ht tp：／／freshmeat.net/browse/160／?topic_id=160>.
www.pdf365.com
14.5未来趋势
345
年一个广泛流传的看似真实的估计中，就社区规模而言，每有一个Python使用者，对应
就有5个Tcl使用者，12个Perl使用者。今天，SourceForge的数据表明这个比率大概是
3:1:7。然而，据说Tcl被广泛使用在好几个工业领域的专门化脚本组件方面，包括电子
设计自动化（EDA），广播电视业以及电影业等。
表14.1  语言选择
┏━━━━━━━━┳━━━━━━┳━━━━━━━┓
┃    语言        ┃SourceForge ┃    Freshmeat ┃
┣━━━━━━━━╋━━━━━━╋━━━━━━━┫
┃    C           ┃    10296   ┃    4845      ┃
┣━━━━━━━━╋━━━━━━╋━━━━━━━┫
┃    C++         ┃    9880    ┃    2098      ┃
┣━━━━━━━━╋━━━━━━╋━━━━━━━┫
┃    Shell       ┃    1058    ┃    487       ┃
┣━━━━━━━━╋━━━━━━╋━━━━━━━┫
┃    Perl        ┃    4394    ┃    2508      ┃
┣━━━━━━━━╋━━━━━━╋━━━━━━━┫
┃    Tcl         ┃    649     ┃    328       ┃
┣━━━━━━━━╋━━━━━━╋━━━━━━━┫
┃    Python      ┃    2222    ┃    948       ┃
┣━━━━━━━━╋━━━━━━╋━━━━━━━┫
┃    Java        ┃    8032    ┃    1 900     ┃
┣━━━━━━━━╋━━━━━━╋━━━━━━━┫
┃    Emacs Lisp  ┃    '       ┃    3 1       ┃
┗━━━━━━━━┻━━━━━━┻━━━━━━━┛
    Python随着Tcl的衰落而迅速崛起。尽管Perl社区的规模仍然有Python的两倍大，
但一个明显的趋势是，最精明的Perl黑客都流向了Python，这对Perl语言是相当不利的
——尤其是根本就没有反向迁移。
    Java在已经投入Sun Microsvstem技术的站点中广泛使用，也作为大学生计算机科学
课程的指导性语言而广泛部署。然而在别的地方，只比1997年稍微流行一些。Sun -意
孤行的所有权许可模型妨碍了许多当年评论家预浏的主要突破；而在Linux和更广泛的
开源社区，Java对C并没有获得像在别处取得的那种进展。
    还没有出现新型的通用语言，对已经在此讨论的语言构成严重的挑战。PHP正在侵
蚀网络开发，挑战Perl CGI（以及ASP和服务器端Java），但是几乎从未使用在单机编
程中o Non-Emacs Lisp方言，一个曾经十分有前途的语言在上世纪九十年代似乎能够驶
向辉煌，但最终还是淡出了。最近的成果，例如Ruby（日本人开发的Python-Perl-Smalltalk
杂交体）和Squeak（～个开源的Smalltalk移植）看起来似乎很有前途，但至今既没有吸
引到除自身开发组之外的用户，也没有展示出持久力。
www.pdf365.com
346
第1 4章语言：C还是非C
14.6  选择X工具包
    同选择开发语言相关的问题是选择GUI编程工具包。回顾一下第一章中关于X如何
    分离机制和策略的讨论。每个可能选择的工具包都将带来些许不同的观感。
    X工具包的选择在两方面影响着同开发语言的选择：首先，有些语言的本身就绑定
    了某个偏爱的工具包，其次，一些工具包可以绑定进的语言是个有限的集合。
    当然，Java存在本身内建的跨平台工具包，所以选择只会落在AWT（普遍都有配置）
    和Swing（更强大、更复杂、更缓慢，仅仅在JDK l.2/Java 2中支持）之间。所以这部分
    余下的内容集中在我们已经讨论过的其它语言中。类似的，如果使用Tcl，Tk是捆绑而
    来的。没什么其它选择的余地了。
    曾经无处不在的Motif工具包实际上已宣告死亡。它已经跟不上无发布限制和无需
    许可费用的新兴工具包。这些新兴的工具包吸引了更多开发者的努力，无论在能力和特
    性方面都淹没了老旧的闭源工具包。现在，竞争全部来自开源阵营。
    在2003年，有四个工具包值得认真考虑，分别是Tk、GTK、Qt和wxWindows，  当
    然GTK和Qt无疑是领跑者。所有四个T具包都移植到了MacOS和Windows中，所以
    迭择其中任何一个都具备跨平台开发能力。
    Tk工具包是四个中最悠久的一个，优势当然是资历深厚；该工具包原生于Tcl，Python
    接口随Python本身一起发布。也有供C和C++程序库使用的Tk语言接口。不幸的是，
    Tk在其标准的窗体构件集方面也老态毕现，既有限又丑陋。另一方面，其它工具包要达
    到Tk中Canvas控件具备的能力还有些困难。
    GTK生来就是为了取代Motif，并且支持GIMP。现在是GNOME工程项目酷爱的
    工具包，为成百上千的GNOME应用程序所使用。原生API是C的；也有C++、Perl、
    Python接口，但并没有包含进语言的主发布。GTK是四个工具包中唯一的C原生接口。
    Qt工具包被KDE工程所使用，是原生的C++库，也有Python和Perl接口但并不同
    解释器本身一同发布。Qt获得了四个工具包中最佳设计和最具表达力API的声誉，然而
    早先许可授权版本的争论阻碍了它的广泛采用，C接口总是迟迟不予以发布的事实也进
    一步延缓了它的广泛采用。
    wxWindows是原生的C++库，同时可以获得Perl和Python接口。wxWindows开发
    者着重强调它们的跨平台开发，也以此作为工具包的主要卖虑。另一个卖点是
    wxWindows实际上是基于每个平台上原生（GTK、Windows和MacOS 9）窗体构件的包
UNIX编程艺术
    www.pdf365.com
14.6选择X工具包
347
装器，这样使用该工具包编写的应用程序保留了原味观感。
    在2003年年中，几乎没有各种工具包的详细对比说明，但是网络搜索“X toolkit
companson”或许能得到一些有用的采样数据。表14.2汇总了各种工具包的状态。
表14.2  X工具包总结
┏━━━━━━┳━━━━━━┳━━━━━━━┳━━━━━━━━━━━━━━━━━━━┓
┃    工具包  ┃  原生语言  ┃  发布对象    ┃    绑定接口                          ┃
┣━━━━━━╋━━━━━━╋━━━━━━━╋━━┳━━━┳━━━┳━━━┳━━━━┫
┃            ┃            ┃              ┃  C ┃ C++  ┃Perl  ┃ Tcl  ┃ Python ┃
┣━━━━━━╋━━━━━━╋━━━━━━━╋━━╋━━━╋━━━╋━━━╋━━━━┫
┃    Tk      ┃    Tcl     ┃  Tcl， Python ┃  Y ┃  Y   ┃  Y   ┃  Y   ┃    Y   ┃
┣━━━━━━╋━━━━━━╋━━━━━━━╋━━╋━━━╋━━━╋━━━╋━━━━┫
┃    GTK     ┃    c       ┃  Gnome       ┃  Y ┃  Y   ┃  Y   ┃  Y   ┃    Y   ┃
┣━━━━━━╋━━━━━━╋━━━━━━━╋━━╋━━━╋━━━╋━━━╋━━━━┫
┃    Qt      ┃    C++     ┃    KDE       ┃  Y ┃  Y   ┃  Y   ┃  Y   ┃    Y   ┃
┣━━━━━━╋━━━━━━╋━━━━━━━╋━━╋━━━╋━━━╋━━━╋━━━━┫
┃  wxWindows ┃    C++     ┃              ┃    ┃  Y   ┃  Y   ┃  Y   ┃    Y   ┃
┗━━━━━━┻━━━━━━┻━━━━━━━┻━━┻━━━┻━━━┻━━━┻━━━━┛
    架构方面，这些程序库都是在同一抽象层次上编写的。GTK和Qt都使用类似的接
收／发送信号的事件处理机制，所以移植起来据说几乎是小菜一碟。因此，在几个工具包
间选择，其它都没问题，最主要的局限是它们提供何种语言的接口。
UNIX编腥艺-术
  www.pdf365.com
www.pdf365.com
1 5
    I    _    ●
    l■I一．
    ●    _  ■  ●
    _—L_-●
．-—■．-．，、●
开发的战术
Tools: The Tactics of Development
Unix is  user-friendly-it rS just choosV about who  its friends are.
Unix对用户是友好的一只不过是挑剔的友好。
    一佚名
15.1  开发者友好的操作系统
    Unix作为一个良好的开发环境长期以来享有盛誉。许多程序员为程序员而写的工具
使它配备精良。这些工具自动完成了不少琐碎的工作，从而让人心无旁骛地专注于开发
中最重要（也是最享受）的部分——设计。
    尽管所需要的工具都是现成的，文档也做得很棒，但并没有通过一个集成开发环境
（IDE）结合在一起。所以往往需要花费相当的努力才能找到它们，装配起来，从而形成
～套适合需要的工具。
    也许读者过去习惯于一个完备的IDE-在Macintosh和Windows系统中常见的、
配备了编辑器、配置管理器、编译器和调试器的GUI系统——那么Unix的方法似乎显
得随意、含混、太过简陋。但那确实是Unix中的方法。
    IDE对于缺乏工具的单一语言编程非常有意义。如果所作所为仅限于机械地以手工
作坊式地研磨出C或C++代玛，IDE就相当适合。然而在Unix下，语言和实现的选择广
泛多样。所以同时使用多个代码生成器、定制配置器以及许多其它标准定制工具就是司
UNIX Sga艺-宋
  www.pdf365.com
350
第1 5章工具：开发的战术
空见惯的事情了。
    在Unix中也有IDE（有数个开源实现，包括Macintosh和Windows上主要IDE的模
拟器）。可是它们难以控制编程工具开放的多样性，因此并未广泛使用。Unix提倡一种
更灵活的风格，一种以编辑／编译／调试循环为中心、排它性更少的风格。
    在本章中我们将介绍Unix下的开发策略——编译代码、管理代码配置、性能分析、
调试以及自动完成各种脏活累活，而让人更专注于有趣的部分。同以往～样，说明更注
重整体结构、而不是具体做法。如果需要了解这方面的细节，本章介绍的大多数工具在
《Programming with GNU Software》（用GNU软件编程）[Loukides-Oram]中都有很好的
叙述。
    当然这些工具自动完成的许多事情都可以手工解决，但这只会更慢，错误率也只会
更高。攀爬学习曲线的～次性付出，得到的是更有效编写程序的能力；精力也可以更多
地放在设计层面而不是低层次的细节操作。
    传统上，Unix程序员就从其他程序员那里学习如何使用这些工具，潜移默化、悉心
钻研。如果你是位新手，请特别留意；我们将一开始就通过展示正确做法来让你完成Unix
学习曲线上最大的～跳。如果你是位忙碌的有经验的Unix程序员，可以跳过本章——但
也许不该如此。这儿的一些有用知识可能恰好你并不知道。
15.2编辑器选择
    首要和最基本的开发工具是一个适合修改和编写程序的文本编辑器。
    一一数来，在Unix下有十几种文本编辑器；编写一个文本编辑器似乎是入门级开源
玩家标准的练手程序之～。这些编辑器多数都暂如朝露，除了作者之外并不适合其他任
何人扩展使用。有些模拟了非Unix系统的编辑器，对于习惯其它操作系统的程序员，可
以作为转换的帮助。在SourceForge或ibiblio或其它主要的开源档案站点有种类繁多的
编辑器。
    对于严肃的编辑工作，两款编辑器完全统治了Unix编程界。两者都有几个次要的变
种实现，有一个标准版本，可以毫无疑问地在任何现代Unix系统上找到。它们是vf和
Emacs。我们在第13章关于软件的适当规模～节中讨论过。
www.pdf365.com
15.2编辑器选择
351
    正如我们在第13章注意到的一样，这两款编辑器在设计哲学上表现出尖锐的对立，
但两者都极端流行并且赢得了可观的核心用户群。Unix程序员民意调查～直表明两个阵
营大约对等，而其它所有的编辑器几乎都排不上号。
    在我们先前对vi和Emacs的检视中，主要关心的是可能复杂度以及相关的设计哲学
问题。此外值得去了解的，是它们蕴含的工程实用精神和Unix文化修养。
15.2.1  了解vi
    VI这个名字是“visual editor（可视编辑器）”的缩写，发音为/vee eVe/（不是/vie/并且
绝对不是/ iks/!）。
    Vf并不是最早的面向屏幕编辑器；那是Rand editor，即re的荣誉，它在1970年代
运行在Unix版本6上。但V1是最长寿的、仍在使用的、为Unix编写的面向屏幕编辑器，
而且已经成为Unix传统中的一个神圣部分。
    Vi的原始版本在1976年随最早的BSD软件发布；现在已经废弃了。替代的是随着
4.4BSD -起发布的“新VI”，也可以同时在一些现代的4.4BSD变种诸如BSD/OS、FreeBSD
和NetBSD系统中找到。还有几个具有扩展功能的变种，著名的有vzm、vile、elvis祁xvi;
在这些版本中，vim可能是最流行的，可以在许多Linux系统上找到它。所有的这些变种
都十分相似，并且共享～个从最初vi版本以来就没有变化过的核心命令集。
也有移植到Windows操作系统和MacOS上的Vl编辑器。
    多数介绍Unix的书籍都会用整整一章来描述基本的Vl用法。关于VI的常见问题解
答可以在Editor FAQ/vi<ht tp：／/WWW．faqs．org/faqs／editor- faq/vi/>处获得；
以包含“VI”和“FAQ”网页名称为关键字做WWW搜索，可以找到许多其它资料。
15.2.2  了解Emacs
    Emacs代表“Editing MACros”（宏编辑，发音为/eemaks/）。最初是在1970年代
作为一个叫做TECO编辑器的一套宏而编写的，随后又以不同的方式重新实现了好几次。
一个意想不到的有趣转变是，现代的Emacs实现包含有～个模拟TECO的模式。
    在早些时候讨论编辑器和可能复杂度时，我们注意到许多人都认为Emacs太过沉重。
然而，花时间学习它可以获得很大的生产力回报。Emacs支持许多威力强大的编辑模式，
能够为输入各种编程语言和标记语言提供语法上的帮助，我们在本章稍后部分可以看到
UNIX编程艺术
  www.pdf365.com
352
第1 5章工具：开发的战术
Emacs是如何同其它开发工具组合起来，从而获得并不逊于常规IDE（在许多方面甚至
超过）的能力。
    在现代Unix中普遍存在的标准Emacs是GNU Emacs;在Unix shell提示符下键入
emacs通常都会运行它。GNU Emacs源码和文档可以在自由软件基金的存档站点
<ftp：//gnu．org/pub/gnu>处获得。
    唯一的主要变种叫做XEmacs；它有着更好的X界面，但在功能上非常相似（它派
生自Emacs 19）。XEmac.s的主页是<http：／／www. xemacs．org>。Emacs（连同Emacs
Lisp）在现代的Unix中通常都可以获得。同时也已经移植到MS-DOS（那里工作得很差）
和Windows 95以及NT中（在那儿据说运行得相当好）。
    Emacs包含自带的交互教程以及非常完备的在线文档；可以在Emacs的默认启动屏
幕中找到调出它们的说明。《Leaming GNU Emacs》（学习Emacs）【Cameron]是一本优秀
的参考书。
    在Netscape/Mozilla的Unix版本和Internet Explorer的文本窗口（表单和邮件发送器]
中使用的键盘命令拷贝自Emacs中绑定的基本文本编辑命令。这些绑定最适合作为跨平
台编辑器的键盘命令标准。
15.2.3非虔诚的选择：两者兼用
透。
许多人经常规则地使用Vi和Emacs来做不同的事情，并且认为非常值得把两者都摸
    总的来说，V1最适合用来完成小型任务——邮件的快速回复、系统配置的简单调整
等。尤其是正在使用一个新系统（或者通过网络的远程系统）而自己的Emacs定制文件
又无法唾手可得时特别有用。
    在处理复杂任务、修改多个文件、需要使用其它程序结果扩展编辑时，Emacs开始
显现威力。对于在控制台使用X的程序员（这在现代Unix上非常典型），一登录通常
就启动一个Emacs窗n，并一直运行下去，然后可能会在多个Emacs子窗口访问十几个
文件甚至运行程序。
15.3专用代码生成器
Unix长期存在一个宿主工具的传统，这些工具明确设计来生成不同专门目的的代码。
www.pdf365.com
15.3专用代码生成器
353
这种值得尊敬的传统典范，需要追溯回到版本7甚至更早的日子-1970年代用来编写
原始可移植C编译器的lex（1）和Vacc （1），它们作为GNU工具包的一部分，今天仍
被大量使用，而它们向上兼容的现代后继者是flex （l）和bison（1）。这些程序已经树
立了一个榜样，并在诸如GNOME的Glade界面构建器项目中发扬光大。
1 5.3.1     yacc ~O lex
    vacc和lex是用来生成语言词法分析器的工具。我们在第8章叙述过，通常自己的
第一个微型语言可能确实是出于偶然而不是一个明确的设计。这个偶然很可能需要一个
手工编码的词法分析器，这会花费非常非常多的维护与调试时间——尤其是如果还没有
意识到它是个词法分析器，不能正确地将其从应用程序的其余部分独立出来时。词法分
析器的生成器是个工具，可以比偶然专用的实现做得更好；它们并不仅仅只是在一个更
高的层次上表达规格说明的语法，同时也能够将词法分析器的所有实现复杂度从其它代
码中隔离出来。
    如果有需要计划从头开始实现一门微型语言，而不是扩展和内嵌一个现有的脚本语
言或者解析XML，那么vacc和lex也许就成为仅次于C编译器的最重要工具，
    Lex和yacc两者分别为一种单一功能生成代码——“从输入流中获取标记符号”和
“解析一系列标记符号来检查是否符合某个语法”。通常地，yacc生成的语法分析功能
在每次需要得到另一个标记符号时会调用一个lex生成的tokenizer功能。如果yacc生成
的语法分析器中根本不存在用户编写的C回调函数，所做的一切就是语法检查：返回值
将告诉调用者输入是否匹配预期的语法。
    更通常地，在生成的词法分析器中内嵌的用户C代码，在解析输入时会附加地生成
～些运行期数据结构。如果微型语言是声明式的，应用程序可以直接使用这些运行期数
据结构。如果设计是命令式的，数据结构也许会包含一个分析树，传给某种求值函数。
    yacc的接口相当丑陋，通过前缀为yy-的形式导出全局变量名。这是因为yacc的产
生还在C struct之前；事实上，还在C语言产生之前；yacc的第一个实现是用C语言的
前任B语言编写的。yacc生成的词法分析器校正解析错误时的算法（直到一个显式的生
成错误得到匹配才弹出标记符），尽管有效但很粗糙，还会导致包括内存泄漏在内的一
些问题。
    如果正在构造分析树，并使用malloc分配节点，在勘误过程中如果开始将数
据出栈，兢不可能恢复（释放）内存。yacc不能完全知道栈中究竟有些什么，因
UNIX编程艺术
  www.pdf365.com
354
第1 5章工具：开发的战术
此它无法做到这一点。如果yacc用C++写成，可以设想值是某个类从而“析构’’
它们。而在“真正的”编译器中，分析树节点由使用基于分配区（ arena-based）
的分配器生成，所以节点不存在泄漏，但无论如何在工业强度的勘误时总有逻辑
的遗漏需要考虑。
-Steve Johnson
    lex是一个词法分析器的生成器。它是grep （l）和awk （1）功能族的一员，但是更
强大，因为它可以为每个匹配安排执行任意的C代码。它接受声明式微型语言作为输入
并且生成C语言代码骨架。
    对于lex生成的符号分析器究竟做些什么，有种粗略但有效的解释：把其视作grep
（1）程序的逆操作。grep （1）接受单个正则表达式、返回输入流中所有匹配的列表，
而每次调用lex生成的符号分析器则是接受一批表达式并标明在数据流中出现了哪～个。
    即使不用Yacc和Lex，并且所处理的“标记符号”同编译器的大不一样，将
  输入分析分解成符号化输入和解析符号流也是个十分有用的策略。不止一次地，
  我已经发现，尽管分解本身会增加复杂度，但将输入处理分解成两个层次确实可
  使代码更简单也更容易理解。
-Henry Spencer
    lex是缟写来为编译器自动生成词法分析器（tokenizer）的。但最后却令人惊讶地广
泛适用于其它种类的模式识别，并且从此被描述为“Unix编程的全能瑞士军刀”，。
    如果正在处理某类模式识别或状态机问题，并且可能的输入可用一个字节描述，lex
生成的代码比手工编制的状态机代码更为有效和可靠。
    Holmdel（AT&T的一个实验室）的Jahn Jarvis使用lex来寻找电路板中的疵
点，扫描电路板，使用链编码技术来表示电路板上的边界区域，然后使用Lex来
定义可以捕获一般制作错误的模式。
-Mike Lesk
    最重要地，lex规格微型语言比等价的手工C语言编码层次更高也更紧凑。Perl（网
上搜索“lex perl”）也有可以使用flex开源版本的模块，Python中作为PLY的一个部分，
也有类似的实现。
1后来Perl的“瑞士军链锯（Swiss-army chainsaw）”这个常见说法其实是个派生。
www.pdf365.com
15.3专用代码生成器
355
    lex生成的解析器一般比手工编码的解析器慢一个数量级。这并不就是采用手工编码
的好理由，相反，这是个明证，应该使用lex进行原型设计，然后只有当原型确实存在瓶
颈时再进行手工编码。
    yacc是一个词法分析生成器。当然，也是为了自动化编译器的部分编制工作而编写
的程序。同BNF（Backus-Naur Form，巴科斯一诺尔范式）类似，将输入作为一个说明
性微型语言的语法规格说明，而语法的每个元素都有相对应的C代码。它生成一个分析
器函数，调用时，从输入流中接受匹配语法的文本。一旦识别出任何一个语法元素，函
数就执行相应的C代码。
    lex和yacc的组合使用对编写任何种类的语言解析器都特别有效。尽管大多数Unix
程序员从不会写一个通用语言编译器（这两个工具的本来目的），但是将它们当作解析运行
控制文件语法和域专用微型语言的解析器也十分好用。
    lex生成的符号分析器在识别输入流中的低级模式相当快速，但是lex能够了解的正
则表达式微型语言却不擅长统计事物，或是识别递归嵌套结构。为了能够解析这些，就
需要yacc。另一方面，尽管理论上可以编写vacc语法来完成自身的符号收集解析，但其
说明面能非常臃肿并且解析速度非常缓慢。从输入中萃取符号标记需要lex。这两个工具
是相辅相成的。
    如果能够在比C语言更高的语言级别实现解析器（我们推荐如此：参见第14章的讨
论），那就参考其它等价的工具，例如Python的PLY（包含lex和yacc的功能）2或者
Perl的PY和Parse::Yapp模块，再或者Java的CUP3、Jack4或Yacc[M5模块包。
    同宏处理器一样，这些代码生成器以及前处理器的问题之～是编译时如果在生成码
中有错，其行号是生成代码的（并不想编辑这里）而不是生成器的输入代码（这才是需
要修正的）的。yacc和lex通过生成同C预处理器一样的#line结构来解决这个问题；
2 PLY可在<http：／／systems．cs .uchicago．edu/ply/>处下载。
3  CUP可在<http：／／www．cs．princet on．edu/-appel/modern/j ava/CUP／处出下载。
4 Jack可在<http：／／www.]avaworld. com/j avaworld/jw-12 -1996/jw-12 -j ack.html>
处下载。
5 YaccfM可k<ht tp：//david。tribble．com/yaccm_ html>处下载。
UNIX编暖；艺：术
    www.pdf365.com
356
第1 5章工具：开发的战术
该结构为错误报告设置当前行号，这样出来的行号就是正确的。任何生成C或C++代码
的程序都应该如此。
    更普遍地，良好设计的程序代码生成器，应该永不需要用户手动地改变甚至查看到
自动生成的部分。把这些做好，是代码生成器的本分。
15.3.2  实例分析：f etchmailrc的语法
    规范的示例似乎在曾经编写的每个lex和yacc教程中都有：玩具型交互式计算器，
用来解析和对用户输入的算术表达式求值。我们还是省省这个重复的老调吧；如果确有
兴趣，参考GNU项目中的bc （1）和dc （1）计算器的实现，或是[Kernighan-Pike84]中
的"hoc”范例6。
    为了取而代之，fetchmail运行控制文件的语法解析器提供了一个关于lex和yacc用
法的中等规模实例分析。有几点十分有趣。
    在rcfile_l.1中的lex规格说明，是非常典型的shell式语法实现。注意同时支持
单引号和双引号字符串的两个补充规则；这种做法普遍适用。接受（可能带符号的）字
面整数的规则和抛弃注释的规则也相当通用。
    在rcfile_y -y中的yacc规格说明，虽然有些见长但很直白。它并不进行任何
fetchmail昀动作，仅仅只是在内部控制块的列表中设置标记。启动之后，fetchmail的普
通模式操作仅仅就是反复遍历这个列表，对每个记录在其远程站点收取会话。
15.3.3实例分析：Glade
    我们在第8章将Glade作为一个说明性微型语言的范例审视过。我们也注意到它的
后端可以产生几种语言中任意一种的代码。
    Glade是应用程序代码生成器的当代范例。使它具备Unix精神的那些功能特征，绝
大多数的GUI构建器（特别是专有的GUI构建器）都没有，可以总结如下：
    ●  并不是胶合成一个大个单体，Glade的GUI和Glade代码生成器遵循分离原则
    （遵从“分离接口和引擎’’设计模式）。
6见http : / /cm . bell-labs . com/cm/cs/upe/>。
www.pdf365.com
15.4 make:自动化编译
357
●  GUI和代码生成器由（基于XML的）文本数据文件格式相连，可以由其它工
    具浏览和修改。
●  支持多个目标语言（相对仅支持C或C++而言）。要增加目标语言也很容易。
这种设计意味着，完全可以替换Glade GUI编辑器组件，而且决不会痛苦不堪。
15.4  ma始：自动化编译
    程序源码自身并不能形成一个应用。如何将它们装配在一起以及如何打包成发布版
本的方式才真正重要。Unix提供一个半自动化这些过程的工具；这就是make （l）。绝
大多数介绍Unix的书籍都涵盖了make。作为真正详尽的参考书，可以查阅《Managing
Projects with Make》（使用Make管理项目）[Oram-Talbot]。如果使用GNU的make（最先
进的make，通常伴随开源Unix -起发布），《Programming with GNU Software》  （用
GNU软件编程）[Loukides-Oram]在某些方面的处理可能会更好一些。多数预装GNU make
的各种Unix都同时支持GNU Emacs:如果你的Unix也是如此，那通过Emacs的信息文
档系统可能会找到完整的make在线手册。
GNU make豹DOS和Windows移植的版本可以从FSF获取。
15.4.1  make的基本理论
    如果使用C或C++进行开发，构建应用程序的一个重要部分是将源代码变成二进制
可运行文件的编译和链接命令集合。输入这些命令是枯燥乏味的细活，多数现代的开发
环境都包含有某个方法将它们放入命令文件或数据库中，可以自动地重复执行以编译应
用程序。
    Unix的make （1）程序，是所有这些程序的鼻祖，专门设计来帮助C程序员管理这
些命令。可以在一个或多个makefile中书写项目文件之间的依赖关系。每个makefile都
由一组“生成物’’构成；其中每项都告知make给定的某个目标文件会依赖哪些源文件集，
并且告知．malce如果那些源文件比目标文件更新时该做什么。实际上并非必须将所有的依
赖关系都写下来，make程序可以通过文件名和扩展名推导出一些显然的依赖关系。
    例如：如果需要在makefile中说明二进制可执行文件“myprog’’依赖三个目标文件
myprog．O、helper．o和stuff．。。如果确实存在文件myproq．c、helper．c和
stuff．c，不用说，make也会知道每个．。文件都依赖相应的．c丈件，并且应用它自己
UNl×编睡；艺．莱
    www.pdf365.com
358
第15．章工具：开发的战术
的标准解决方案将．c文件编译成，。文件。
    Make程序最初来源于Steve Johnson（yacc等程序的作者）的一个拜访，那天
他风风火火的闯进我的办公室，诅咒命运女神让他浪费了一个早上来调试一个正
确的程序（bug改了但是文件还没有编译，因此CC★．o无效）。而我也花了前
一晚上的部分时间在我参与的项目中解决同样的灾难，这样，编写一个工具来解
决这个问题的想法就诞生了。最开始是精细的依赖关系分析器，浓缩为更简单的
东西后，周末就出炉了Make。新兴工具的使用也是Unix文化的一个部分。Make
文件都是文本的，不是神秘的二进制编码，因为这就是Unix的精神：可打印、可
调试、可理解。
-Stuart Feldman
    如果在项目的目录中运行make，make程序会查看所有生成物及时间戳，然后做需
要的最少工作来确保派生出的文件能够更新。
    作为一个中等复杂的范例，可以读读fetchmail源文件中的makefile。在下面的部分，
我们还会引用到它。
    非常复杂的make文件，尤其当它们还要调用附加的make文件时，往往将编译过程
复杂化而不是简单化。一个当代的经典警示来自Recursive Make Considered Harmful【递
归Make有害论）7。这篇文章中的论证自从1997年问世以来已经广泛为人接受，而且几
乎颠覆了以前的社区实践。
    如果不认同make （1）中包含了Unix有史以来最糟糕的设计修补，那么我们的讨论
就不完整。Tab字符（制表符）作为关联生成物命令行的引导符使用，而它和空白符的
视觉区别无法令人觉察，这可能导致对makefile解释的灾难性不同。
    为什么在第一列需要tab? Yacc是新的，Lex更是崭新的。我两者都没有用过，
所以我认为这是个学习的好借口。在我跟Lex首次受挫的纠缠后，我就使用更简
单的换行+tab模式。它工作了，就那样了。而几个星期以后，make有了十几个用
户，大多数都是朋友，而我又不愿意纠正我的基本错误。余下的，很不幸，成为
了历史。
-Stuart Fefdman
 7可以访问网页<http：／/www．tip．net．au/-millerp/rmch/recu-make-cons -harm．html>
阅读本文。
www.pdf365.com
15.4 make：自动化编译
359
15.4.2  非C/C++开发中的make
    make并不仅仅只是对C/C++的有用。如同在第14章所述的一样，脚本语言可能并
不要求传统的编译和链接步骤，但是也常常有其它的依赖关系，make（l）正好可以有帮助。
    例如，假设使用第9章中的某个技法，确实从规格说明文件中生成了部分代码。就
能够使用make来将规格说明文件和生成的源码文件结合在一起。这会确保无论何时修改
规格说明之后重新make，生成码都会自动重新编译。
    和编程一样，使用makefile来完成制作文档的任务也非常普遍。经常会看到使用这
种方法从一个某标记语言编写的主文本（比如HTML或是我们将在第1 8章讨论的Unix
文档宏语言）来自动生成PostScript或其它派生文档。实际上，这种用法相当普遍，值得
我们用一个案例来演示。
15.4.2.1  案例分析：make用于文档转换
    在fetchmail的makefile中，例如，会发现三个生成文件，名为F'AQ、FEATURES和
NOTES，同HTML的源文件fet chmail- FAQ．html、fetchmail- features .html
和design-notes。html相关。
    HTML文件是从fetchmail的主页上阅读的，但是不使用网页浏览器浏览那些HTML
标记非常别扭。因此FAQ、FEATURES和NOTES纯文本文件在需要阅读fetchmail源码
本身（或者，可能在并不支持网页访问的FrP站点）时，可以通过编辑器或分页程序来
快速阅览。
    纯文本格式可以使用普通的开源hnx ci）程序从它们的HTML主文本生成；lynx
是只显示文本的网页浏览器，但是当以- dump选项调用时，同样可以作为HTML到ASCII
的格式转换器使用。
    当生成文件就位，开发者就可以编辑HTML的主文本，而不需要牢记事后必须人工
更新纯文本格式文件，就能够确保FAQ、FEATURES和NOTES都能够在任何需要的时候
得到更新。
15.4.3通用生成目标
很多常用的典型makefile中根本没有文件依赖关系。它们是将某些开发者想要自动
UNIX箱睡；艺术
  www.pdf365.com
360
第1 5童工具：开发的战术
化的小过程捆绑在一起的方法，例如制作一个发布包或者在编译源码时去除所有中间生
成的目标文件．
    生成目标非文件，这早已有之。  “make all"和“clean”是早些日子我自己的
    习惯。有一个老Unix笑话，输入“make love”，输出是“Don't know how to make
    love”  。
    -Stuart Feldman
    关于通用生成目标应该表示什么，以及它们该如何命名已经有了一组良好的约定。
遵从这些会让自己的makefile更容易理解和使用。
a//
    生成工程中所有可以执行者。通常全部产品并没有明确的定义；往往指工程中高阶
的目标文件（并且，并非偶然地，常常有文档说明会包括哪些）。它通常应该是makcfile
的第一个生成目标，因此它往往是开发者不带参数键入make就执行的那一个。
test
    运行程序的自动测试套件，典型地，包括一组单元测试（Unit Test）8来查找递归、
bug，或是其它在开发过程中偏离预期行为的误差。“test”目标也可以由软件的最终用
户来确保安装程序能够正常工作。
cZP以咒
    删除make all时产生的所有文件（例如二进制可执行文件和目标文件）。make
clean虚该将软件的编译过程重置到良好的初始状态。
dist
    制作源文件档案（通常使用tar （1）程序归档），它可以作为在另一台机器上重新
编译的单元。该目标应该同make all做同样的依赖关系检测，这样make dist可以
8单元测试就是同某个模块关联、用来验证执行是否正确的代码。使用术语“单元测试”表明测试是
由代码开发者并发编写的，也形成了模块发布必须附带测试码才算完整的纪律。术语和概念源自Kent
Beck大力推广的“极限编程（Extreme Programnung）”，但大概自从2001年来，也在Unix程序员
中得到了广泛的接受。
www.pdf365.com
15.4 make:自动化编译
361
在制作发布包之前自动重新编译整个工程——这是一个良好的避免最后一分钟困境的方
法（例如，在fetchmail中实际上是从HTML文件产生纯文本README文件）。
distclean
    删掉所有的文件，除了那些使用make dist打包时指定包含的文件。它和make
dist效果一样，它可能和make clean相同，但是需要独立存在，并以文档说明。当
与make clean不同时，通常是会删除make all编译过程部分之外的本地配置文件
（例如autoconf（1）生成的文件，关于autoconf（1），我们将在第17章讨论）。
reafCZ已髓n
    删除所有用makeile构建的文件。这有可能同make distclean的作用完全～样，
但无论如何，应该作为单独的目标，并且以文档说明。当与make distclean不同时，
它删除的文件往往可以用其它文件生成，但（因种种原因）又需要同工程源码一起发布。
install
    在系统目录中安装项目工程的可执行文件和文档（通常需要root用户权限）以让普
通用户访问。同时初始化或更新启动执行文件所需的任何数据库或库文件。
uninstall
    删除白make install安装在系统目录中的所有文件（一般要求root用户权限）。
这应该是make inatall彻底完美的逆过程。uninstall的存在显示了一种人性化的设置，
有经验的Unix用户常常认为是周到的设计；反之，如果没有uninstall，软件做得再好充
其量也是粗枝大叶的，  （例如，软件安装创建了庞大的数据库文件）甚至是考虑欠佳、
相当粗糙的。
    所有这些标准目标的可工作的范例在fetchmail的makefile中都可见到。作为整体研
究时，就会看到一个模式的出现，而且（并不是偶然地）会学到更多fetchmail的打包结
构。使用这些标准目标的好处之～就是其项目路线不言自明。
    但是不要局限在这些通用目标上。一旦掌握make，就会越来越频繁地使用makefile
机制来自动化那些依赖项目文件状态的小任务。makefile就是一个方便存放完成这些小
任务脚本的重要地方；而使用make可以在检视如何完成这些小任务时一目了然，并且避
免了小脚本将项目工作空间弄得凌乱不堪。
UNIX编健艺-术
  www.pdf365.com
362
第1 5章工具：开发的战术
15.4.4生成Makefile
    较之于许多内嵌从属数据库的IDE来说，Unix make明显的优势之一就是makefile
是简单的文本文件——可由大多数程序生成。
    在1980年代中期，对于庞大Unix程序的发布来说，包含一个精致的可以探测环境
并收集信息构建来定制makefile的用户shell脚本相当普遍。这些定制配置器的规模甚至
达到了荒唐的程度。我曾经编写了3000行shell脚本，几乎是它所配置程序任何单个模
块的两倍——而且这并不少见。
    社区最后说“够了！”，而许多人开始着手编写工具来自动维护makefile的部分或
全部过程。这些工具一般试图解决两个问题：
    一个问题是可移植性。Makefile生成器通常为不同的硬件平台和Unix变种编制。它
们往往试图推断出本地系统的信息（包括从机器字大小到机器可以获得的工具、语言、
服务库甚至文档格式化器等一切）。它们常常尝试使用这些信息编写makefile，以利用
本地系统的功能，或是补偿本地系统的欠缺。
    另一个问题是派生依赖关系。分析源文件本身可能推导出大量C源码文件间的依赖
关系（尤其是它们使用和共享了哪些包含文件）。许多makefile坐成器这样做就是为了
能够机械地生成make依赖关系。
    每种不同的makefile生成器以不同的方式来解决这些目标问题。可能有十几个或更
多的生成器，但大多数都被证明功能不足或难以使用或两者兼有，但是有些还在现实中
使用。我们将在这里研究其中几个主要的。所有这些工具都可以在互联网上获得其开源
版本。
15.4.4.1makedepend
    几个小工具都可以分别处理问题的规则自动化部分。这一个，随着MIT的X window
系统一起发布，是其中最快、最有用的。在所有现代的Unix下，包括所有的Linux下都
有预装。
    makedepend收集C源码集合，然后从它们的#include指令中为相应的．。文件生
成依赖关系。这些可以直接追加到makefile中，而实际上，makedepend也正是这样做的。
    makedepend只对C项目有效。它并不试图解决除了makefije生成以外的问题。但是
它做的事相当漂亮。
www.pdf365.com
15.4 make：自动化编译
363
    makedepend的手册页文档充分。在终端窗口键入man makedepend可以很快地了
解调用它所需要知道的一切。
15.4.4.2Imake
    Imake是为了X window系统机械化生成makefile而编写的。它基于makedepend并
且既可处理依赖派生，又可处理移植性问题。
    Imake系统有效地使用Imakefile代替了传统的makefile。Imakefile采用更紧凑更强
大并（有效地）以makefile的表示法编写。编译过程使用规则文件，该文件专门针对目
标系统并且包含了许多关于本地环境的信息。
    Imake非常适合X特有的移植性和配置困难，并且通常使用在X系统某个部件项目
中。然而，在X开发者社区之外它并不流行。它难以学习，难以使用，难以扩展，而且
产生的makefile生成文件，其复杂程度和庞大规模令人刚磴口呆。
    Imake工具可以在任何支持X的Unix上获得，包括Linux。有个创举[DuBois]尝试
让丰申秘的Imake能够为非X编程者所知。如果打算进行X编程，学习这些当然值得。
15.4.4.3  autoconf
    见识了Imake却又拒绝Imake万法之后，有人编写了autoconfo它为每个工程生成类
似旧有的客户脚本配置器的configure shell脚本。这些confiaure脚本能够生成
makefile（和其它的东西）。
    Autoconf着重于可移植性并且根本就没有内置派生依赖。尽管它可能同Imake般复
杂，但是它更灵活也更容易扩展。不是依赖每个系统的规则数据库，autoconf生成“配
置’’shell代码去搜索系统以获得信息。
    每个c。nfigure shell脚本来自于必须事先编写的项目模板，称为configure．in。
它一旦生成，c。nfigure脚本就是独立的，可以在任何本身并不存在日“toconf（1）程
序的系统上配置项目。
    au！toconf生成makefile的方法就像在imake中为项目开始编写一个makefile模板一
样。但是口“toconf的Makefile．in文件基本上就是makerile文件，只不过多了用于简
单文本置换的占位符；不需要学习另外的表示法。如果需要依赖派生，必须显式地调用
makedepend（1）或相类似的工具——或者使用automake（1）。
UNIX编程艺|术
  www.pdf365.com
364
第1 5章工具：开发的战术
    autoconf文档以GNU信息格式的在线手册存在。脚本源码可以从FSF存档站点获得，
但是在许多Unix和Linux版本上都有预装。应该可以通过自己的Emacs帮助系统浏览其
手册。
    尽管缺乏对依赖派生的直接支持，并且尽管它的方法很特殊，但在2003年年中，
autoconf毫无疑问地是最流行的makefile生成器，并且已经流行了数年。它已经蚕食了
Imake的份额，并至少废掉了一个主要竞争者（metaconfig）。
    参考书籍请阅《GNU Autoconf， Automake and Libtool [Vaughan]》。另外，我们将
在第17章从一个略微不同的角度讨论autoconf更多的细节。
15.4.4.4  automake
    automake尝试在autoconf（l）上增加一个fmake式的依赖派生关系。用广泛的Imake
式的表示法编写Makefile．am模板；automake（l）编译成Makefile．in文件，然后该
文件供autoconf的conf igure脚本操作。
    在2003年年中，automake仍然是一项相对较新的技术。好几个FSF项目使用了这
项技术，但足别的地方并没有广泛采用。尽管它的生成方式似乎很有前景，但还是相当
脆弱——按规则使用时能够工作，但如果想用来做点儿别的，就会失败得很惨。
    完整的在线文档随同automake -起发布，并可以在FSF档案站点处下载。
15.5版本控制系统
    代码在发展。项目从原型的第一笔到交付使用的过程中，要经过多个周期，其中新
问题的探索、调试、把已经完成的东西稳定化。这种发展历程在第一次发布产品时并不
会停止。绝大多数项目在1.0阶段后，都需要维护并增强，会存在多次再版。而追踪所
有那些细节恰恰是计算机而非人类所擅长的事情。
1 5。5.1  为什么需要版本控制
    代码的不断发展产生了好几个实际问题，可能成为主要的阻碍和难题来源——这当
然会严重耗费生产力。耗费在这些问题上的每～刻，都无法投入到项目设计和使功能正
确的工作中。
www.pdf365.com
15.5版本控制系统
365
    也许最重要的问题就是回归。如果改变了代码却发现并不可行，如何恢复到一个已
知的良好版本？如果回归是困难的或不可靠的，改变代码就太过冒险（有可能会崩掉整
个项目，或者为自己凭空增加许多小时的痛苦工作）。
    几乎同样重要的是变化追踪。知道代码已经发生了改变；但知道为什么吗？稍后再
看它们却很容易就忘记了改变的原因。如果项目存在合作者，又如何知道在自己不注意
时合作者改变了什么，另外，每个修改该由谁负责？
    常常令人惊奇地发现，即使没有合作者，问问自己从上一个已知的良好版本
  后改变了什么也非常有用。这也常常会揭露不必要的改变，例如被遗忘的调试码。
  我现在在检入（ check in）变化前，一般就会做这项工作。
-Henry Spencer
    另一个问题是bug追踪。在代码经历了相当的变化后得到一个新的bug报告相当普
遍。有时能够立即发现bug已经被解决了，但通常不能。假设在新版本中bug并没有显
现。但为了重现和理解bug，如何恢复到代码的旧版本？
    为了解决这些问题，需要能够保留项目历史，并且加上注释来解释它。如果项目不
止一个开发者，同时还需要一种机制能够确定开发者不会覆盖彼此的版本。
15.5.2手I版本控制
    最原始（但仍旧很普遍）的方法是全手工的操作。定期手工地将一切文件复到～个
备份以作为项目的快照。当然可以在源文件中包含历史评注。也可以通过口头的或邮件
的安排让其他开发者在自己修改时不要动那些文件。
    这种手动方式的隐性成本非常高，尤其（也常常发生）当时间不允许的时候。而整
个过程异常耗费时间和精力；容易出错，在压力之下或项目处于水深火热时又往往会被
遗忘——而这正是最需要版本控制的时候。
    如同多数的手动修改一样，这种方式很难用在大规模项目中。变化追踪的粒度也十
分有限，而且细节经常丢失：比如变化次序、谁做的、为什么等。恢复一大批变化的过
程极度乏味又耗费时间，而在尝试某些并不能很好工作的修改后，开发者往往不情愿地
继续回退到更老的版本。
UNIX编曜艺术
  www.pdf365.com
366
第1 5章工具：开发的战术
15.5，3自动化的版本控制
    为了避免上述问题，可以使用一个版本控制系统（ version-control system VCS），这是
一组程序套件，能够自动化保存项月的历史评注，并避免修改冲突。
    多数VCS共享同样的基本逻辑。使用时，一开始先注册源文件集合——也就是说，
告知VCS开始记载这些存档文件的变化史。因此，在需要编辑这些文件中的某一个时，
必须检出（ check out）这个文件——在其上声明一个排它锁。修改完成之后，检入（check
in）这个文件，把变化加入存档中，释放锁定，并且说明修改了什么东西。
    项目的历史变化不一一定是线性的。实际上所有常用的VCS允许维护不同版本的树型
结构（比如不同机器架构间的移植版本），并提供工具来将不同的分支合并回主要的“主
干”版本。随着开发小组规模和分散性的增长，这个功能特征会变得越来越重要。然而
需要谨慎使用；具有多重活动版本的代码库特别容易混淆（例如，仅仅将bug报告同正
确版本相关联就非易事），同时各分支的自动归并不能保证结合的代码就一定能够运行。
    VCS余下所做的一切比较容易：标注，并报告与这些基本操作的相关特征，提供工
具允许查着不同版本间的差别，或者将给定的各个版本文件聚合在一起作为统一命名发
布，以便任何时候在可以不丢失后续改动前提下，进行检查或恢复。
    VCS自身存在一些问题。最大的问题就是每次使用VCS编辑文件时都需要涉及额外
的步骤，这些步骤如果是手工操作的话，匆忙的开发者都想跳过它。本章接近结尾的地
方，我们会讨论解决这个问题的方法。
    另一个问题是，某些很自然的操作往往会弄乱VCS。文件改名就是～个臭名昭著的
问题源；当～个文件改名时要自动地确保文件的版本历史还能够随之而在，这并不容易。
特别当VCS支持分支版本时，这个问题尤其难以解决。
    尽管存在这些麻烦，VCS仍然在许多方面对生产力和代码质量都带来巨大的实惠，
甚至对于小型单开发者项目也是如此。它们自动化了许多乏味的过程。对从错误中恢复
过来大有帮助。而可能最重要的是，可以确保很容易地恢复到一个已知的良好状态版本，
解放了程序员，从而可以自由地不断实验与探索。
    （VCS，顺便提一下，并不仅仅针对程序代码有效；本书原稿在写作的过程中就是
作为RCS下的文件集来维护的。）
www.pdf365.com
15.5版本控制系统
367
15.5.4  Uni×的版本控制工具
    在历史上，Unix世界中，三个VCS占据了重要的地位，我们将在此检阅。对于更多
的介绍和指导，参考《Applying RCS and SCCS》（RCS和SCCS应用）[Bolinger-Bronson]。
15.5.4，Il  源码控制系统（Source Code Control System，SCCS）
    第一个这样的系统是SCCS，最初在1980年前后由贝尔实验室开发，并在System IIl
Unix中出现。SCCS似乎是第一个在统一源码控制系统的重大尝试；由它开拓的观念在
某些层次上仍然可以在后来所有的版本控制系统中见到，包括诸如ClearCase在内的Unix
和Windows商业产品。
    然而SCCS本身现在已被废弃；它是贝尔实验室的专有软件。更好的开源替代品已
经开发出来，而且Unix世界中的大多数都已经转而采用了它们。SCCS在一些商业公司
中仍然用于管理某些古老的项目，但新项目并不推荐使用。
    SCCS没有完整的开源版本实现。存在一个克隆产品，叫做CSSC（ Compatibly Stupid
Source Control）在FSF的赞助下进行开发。
15.5.4.2  停订控制系统（Revision Control System， RCS）
    更好的开源替代品从RCS（修订控制系统）开始，在SCCS的几年后在普渡（Purdue）
大学诞生，最初发布在4.3BSD Unix上。它在逻辑上与SCCS相似，但是具有更简洁的
命令接口，还可以通过符号名将整个项目发布组合在一起。
    RCS现在是Unix世界中使用得最为广泛的版本控制系统。一些其它Unix版本控制
系统则使用它作为后端或底层。它非常适用于单一开发者或小型团队。
    RCS源码由FSF维护和发布。也可以找到Microsoft操作系统和VAX VMS的免费
移植版本。
15.5.4.3  并发版本系统（Concurrent Version System， CVS）
    CVS（Concurrent Version System/并发版本系统）是作为一个RCS的前端开始其生
命的，在】990年代早期开始开发，然而其使用的版本控制模型与原版本大相径庭，所以
立即具备了成为一个新设计的资格。现代的实现版本并不依赖RCS。
    同RCS和SCCS不一样，CVS在检出（check out）时并不排它地锁定文件。相反，
在检入（check in）回来时，它尝试自动地调和雨相冲突的改动，同时让人来帮助仲裁冲
UN）×编程艺-术
    www.pdf365.com
368
第1 5章工具：开发的战术
突的变化。这种设计是有效的，因为修改中的冲突远比直觉想象中的要少得多。
    CVS的接口比RCS要复杂得多，也需要更多的磁盘空间。这些性质使其作为小项目
的选择并不明智。另～方面，cvs非常适合庞大的多开发者项目，开发者分布在由互联
网连接在一起的好几个开发站点。客户端机器上的CVS工具可以很容易地对另外主机上
的代码库进行操作。
    开源社区在项目中大量使用CVS，例如GNOME和Mozilla。典型地，这些CVS代
码库允许任何人从远端机检出源码。因此任何人都可以制作项目的一份本地拷贝并进行
修改，然后将改动补丁邮寄给项目的维护者。代码仓库的实际写访问权存在更多的限制，
必须明确得到项目维护者的授权。拥有这种权利的开发者可以选择直接从本地的修改拷
贝上实施提交，这样本地的改动会直接并入到远程代码库之中。
    在GNOME CVS站点<http：／／cvs．gnorne．org>可以看到一个运行良好的、通过
互联网访问的CVS代码库实例。这个站点说明了诸如Bonsai等支持CVS的浏览工具的
用法，这在帮助一个庞大分散组织中的开发者彼此协调工作时非常有用。
    伴随使用CVS产生的人文方法和哲学踉工具的细节同等重要。它们假定，项目将是
开放和分散的，而且代码主体需要经过同行的复审和检验，甚至由那些并非项目组正式
成员的开发者完成。
    同样重要地，CVS非锁定的哲学意味着如果一个程序员在改动的中途离去时，他的
锁定不致于阻塞整个工程。CVS因此能够让开发者免于“单点失败”的问题；反过来，
这也意味着项目的边界可以是流动的，随意贡献相对容易，并且项目不要求有一个精心
的控制层级。
CVS源代码由FSF维护和发布。
    cvs也存在某些重大问题。有些仅仅只是实现中的bug，但有一个基本问题：项目
的文件命名空间并不能像对文件本身的改动那样可以进行版本控制。这样，CVS很容易
就被文件的改名、删除和增加给弄混。同时，CVS的变化记录基于每个文件，而不是针
对多个文件的改动集。这就难以恢复到某个特殊的版本，也难以处理部分检入操作。幸
运地，这些问题并不是非锁定风格固有的问题，而且已经由新的版本控制系统成功解决
了。
15.5.4.4其它版本控制系统
    CVS存在的设计问题足够引发对更好开源VCS的需求。在2003年中，有数项工作
在进行中。其中最著名的是Aegis和Subversion。
www.pdf365.com
15.6运行期调试
369
    Aegis<http：／/WWW.pcug.org.au/-millerp/aegis/aegis.html>在这些
候选者中历史最长，自从1 991年就已经开始开发了，而现在是个成熟的产品系统。它的
特点是非常强调回归测试和合法性确认。
    Subversion<http：／/subversion．tigrls．org/>完全解决了已知的种种问题，
确定了“把CVS做对”的地位，而且在2003年看来，也许是近期最有希望取代CVS的
软件。
    BitKeeper<h七tp：／/www．bltkeeper．com>项目开拓性实验了某些有趣的设计思
想，如“改动集”以及多个分布式代码仓库。Linus Torvalds使用BitKeeper来开发Linux
内核源码。然而，BitKeeper的非开源许可，引起了争议，并且严重地延缓了接受该产品
的过程。
15.6  运行期调试
    只要拥有超过一星期编程经验的人都会知道，让程序符合正确的语法是调试中相对
容易的部分。凼难的是在这之后，需要r解为什么语法正确的程序并不如期望的那样运
行。
    Unix传统提倡开发者通过透明性设计先人一招地解决这个问题——特别在程序设计
对，考虑内部数据的流向容易被人眼和简单工具审视，并且易于建模。我们已经在第6
章详细地涵盖了这个议题。透明设计在防止bug和减轻运行期调试任务两方面都是非常
有价值的。
    然而，透明性设计本身还不够。当需要在运行期调试一个程序时，能够检查运行期
的程序状态、设置断点以及以一种可控的方式执行某个低至单～语句层次部分是极其有
用的。Unix存在一个提供工具来帮助完成这些任务的长期传统。多数开源Unix都拥有
威力巨大的gdb（也是一个FSF项目）支持C和C++调试。
    Perl、Python、Java和Emacs Lisp都支持设置断点、控制执行以及一般的运行期调试
操作的标准软件包或程序（包含在基本发布版本中）。Tcl，这个设计用来为小型项目开
发的小巧语言，没有这方面的功能（尽管它存在可以在运行期监视变量的跟踪功能）。
    牢记Unix哲学。将时间花费在设计质量上，而不是低层次的细节上，尽可能地自动
化一切——包括运行期调试的细节工作。
UNIX编程艺：术
    www.pdf365.com
370
第1 5章工具：开发的战术
15.7性能分析
    作为通用法则，程序90%的执行时间都耗费在lO%的代码上。性能分析软件（profilers）
可以帮助确定那10%抑制程序速度的区域。这可以让程序跑得更快。
    但在Unix传统中，profiler有个更为重要的功能。它能够让人不去优化其余90%的
代码。这很棒，并不仅仅由于这样节省了工作。其实不去优化余下90%代码真正有价值
的效应是降低了整体复杂度，减少了bug。
    有人可能会回忆起我们在第1章引用的Donald Knuth评论“过早优化乃万恶之源’’，
以及Rob Pike和Ken Thompson关于这个论题的尖锐观点。这是经验之谈。做好设计。
首先考虑什么是正确的。然后再调整效率。
    Profiler帮助完成这一切。如果养成使用它们的好习惯，可以改掉过早优化的坏习惯。
Profiler工具不仅改变工作的方式，也改变思考的方式。
    编译型语言的profiler工具依赖于度量对象代码，所以它们比编译器更依赖于平台。
另一方面，编译型语言的profiler并不关心其衡测程序的实现语言。所以在Unix下，一
个profiler程序gprof （1）就可以处理C、C++和其它所有韵编译型语言。
    Perl、Python和Emacs Lisp在它们的基本发布版本中都包含有自带的profiler程序；
这些程序都可以移植到其宿主语言可以运行的所有平台上。Java有内建的profiler。但Tcl
至今还没有profiling支持。
15.8  使用Emacs整合工具
    Emacs编辑器非常擅长的事之一就是作为其它开发工具的前端（我们在第13章已经
从～个哲学的角度讨论过这个问题）。实际上，几乎本章讨论的所有工具都可以在Emacs
编辑器对话中使用Emacs作为前端驱动，而相比这些工具单独运行来说，这个前端往往
更为易用。
    为了展示这一点，我们以典型的编译／测试／调试循环来一起审视Emacs与这些工具
的组合使用。但对于它们的细节，请参考Emacs本身的在线帮助系统：本部分仅仅只是
给出一个总揽以激发学习热情。
    读然后学——这并不仅仅针对Emacs，也是培养在程序之间寻找协作方法的思想习
惯，以及培养创造这些协作方法的思想习惯。尝试以哲学指导来看待这一节，而不局限
在技术层面。
www.pdf365.com
15.8使用Emacs整合工具
371
15.8.1   Emacs和 make
    输入Emacs命令ESC-x compile，回车后就可以启动Make。这将在当前目录运
行make（1），截获Emacs缓冲区的输出。
    这粗看用处不大。但是Emacs的make模式了解Unix C编译器和许多其它工具产生
的错误信息格式（均带有源文件名和行号）。
    如果任何由make运行的程序产生错误，命令Ctl-x、（control-X-backquote）将尝试
解释它们、依次定位每个错误，并弹开一个窗口载入错误文件并将光标定位至发生错误
的行上9。
这就可以很容易一步步浏览整个编译过程，并纠正任何自上次编译后的语法错误。
15.8.2  Emacs和运行期调试
    为了捕获运行错误，Emacs提供了类似的对符号调试器的集成——即可以使用某个
Emacs模式在程序中设置断点并检视程序运行时的状态。通过Emacs窗口传送命令就可
以运行调试器。无论何时调试器停止在断点上，Emacs将解析调试器回传的源码位置相
关信息，并在源码断点附近弹出窗口显示。
    Emacs的Grand Unified Debugger模式支持所有主流的C调试器：gdb（l）、  sdb（l），
dbx（1）和xdb（l）o使用perldb模块的话还可支持Perl符号调试，同时支持Java和Python
的标准调试器。内建于Emacs Lisp本身的功能也支持Emacs Lisp代码的交互调试。
    在本书创作（2003年年中）期间，Emacs还不支持Tcl的调试。Tcl的设计似乎决定
了这种特性不太可能加入到Emacs之中。
15.8.3  Emacs和版本控制
    - Ea完成了程序的语法错误修订和纠正了运行期bug之后，也许会要把改动保存到
版本控制文档中。如果只能从shell运行版本控制工具，就不好责备自己忘记了这个重要
的步骤。谁记得住每次编辑操作之后都必须运行checkouUcheckin命令昵？
9更多的信息以及编译控制命令可以参考Emacs help菜单下的p+processes->compile。
UNIX编腥艺：术
  www.pdf365.com
372
第1 5章工具：开发的战术
    幸好Emacs在这方面也提供了帮助。Emacs内建代码实现了SCCS、RCS、CVS或
Subversion的简易使用前端。单一命令Ctl-x v v在正访问的文件上进行下～步的逻辑
版本控制操作。这些操作包括注册～个文件，检出（check out）和锁定，以及将文件检
入（checkin）回去（同时允许在弹出窗口中加入修改注释）10。
    Emacs同时也帮助用户浏览受版本控制文件的变化历史，而且还可以撤销不想要的
改动。Emacs使得对整个文件集合或项目文件目录树进行版本控制也非常容易。总之，
Emacs做得非常好，让版本控制操作不再是件痛苦的事。
    除非用惯了，不然这些功能的意义要比你所能想象的深远得多。一旦习惯了快速方
便的版本控制，才会发现真正得到了自由。而正是因为知道总是可以恢复到已知良好的
状态，才可以更自由地以一种灵活的探索方式进行开发，才可以试验多种变化来查验它
们不同的效果。
15.8.4   Emacs和 Profiling
    令人惊奇……这也许是唯一一个开发周期中Emacs前端不能提供实质性帮助的阶
段。Profiling本质上是个批操作——衡测自己的程序，运行它，查看统计数据．用编辑
器对代码进行速度调整，然后重复整个过程。在整个开发周期中的专用于profiling的部
分并没有太多的余地留给Emacs来发挥作用。
    然而，对于我们思考Emacs和profiling之间的关系有个良好的指导性理由。如果发
现自己需要分析众多profiling报告，也许值得编写一个模式可以在profile报告某行上点
击鼠标或敲下键盘，就可以访问源文件的相关函数部分。其实使用Emacs的“tags”代
码，这相当容易实现。事实上，在阅读到本文的时候，也许某个读者已经编写了这样的
一个模式，并且把它贡献到了公共的代码库之中。
    这里所谓真正的要点同样是一个哲理。别蛮干——这会浪费时间和生产力。如果发
现在低层次的机械开发部分花费了太多时间的话，先站住。应该运用Unix哲学。使用工
具自动化或半自动化地完成任务。
    然后，作为对所有继承的回报，将自己的解决方案作为开源软件放置在互联网上。
帮助把程序员同行们从蛮干中解放出来。
10参考Emacs在线文档中标题为“版本控制”一小节，以获取这些相关命令更多的细节。
UNIX编程艺：求
www.pdf365.com
15.8使用Emacs整合工具
373
15.8.5像IDE一样，但更强
    本章稍早时，我们断言Emacs具备类似那些常规集成开发环境的能力，而且只会更
强。现在，已经有足够的事实证明所言非虚。可以在Emacs中运行整个的开发项目，敲
几下键盘就可以完成底层的技术性细节，从而减少了不断切换环境的脑力开销和那种不
连贯的感觉。
    Emacs带来开发风格舍弃了某些高级IDE的功能，例如像程序结构的图形视图。但
那些都是些虚饰。Emacs相应赋予的是灵活性和控制力。你不会被IDE设计者的想象局
限：使用Emacs Lisp，可以调整、定制以及增加与任务相关联的知识。同时，比起常规
的IDE来说，Emacs在支持混合语言开发上做得更好。
    最后，可以并不局限于某组IDE开发者所认为适合支持的事物。通过密切注意开源社
区，可以从千万的同行、以及面对同样挑战的Emacs使用开发者中受益。这更有效——也
更有趣。
UNIX编睡；艺术
    www.pdf365.com
www.pdf365.com
1 6
重用：论不要重新发明轮子
Reuse:
On Not Reinventing the Wheel
When  the superior man  refrainsfrom acting，  his force isfeltfor n thousand miles.
    不言之教，无为之益，天下希及之。
    -Tao Te Ching （as popularly mistranslated）
    一《道德经》
    不愿做不必要的工作是程序员的一大美德。如果中国圣人老子活到今天并仍然还
在传道的话，他可能会被错解为：不编之码，天下希及之。事实上，近来的译者已经
建议，传统上认为等价于“不作为”或是“节制行为”的中国专有名词“无为”，或
许应该解释成“最小行为’’、  “最有效行为”或是“按自然法则行为”，这更适合描
述良好的工程实践。
    牢记经济原则。每个新项目都从刀耕火种开始干起简直就是极端的浪费。请想想：
和其它耗在软件开发的花费比起来，时间无疑是最宝贵和最有价值的；所以相应地，应
该耗费在解决新问题，而不是对那些已存在确切解决方案的问题老调重弹。这种态度对
于开发投入来说，无论是在人员资本的“软”含义，还是在投资经济收益的“硬”含义，
都可以收到最好的回报。
UNI×编睡；艺-莱
  www.pdf365.com
376
第1 6章重用：论不要重新发明轮子
    重新发明轮子之所以糟糕不仅因为浪费时间，还因为它浪费的时间往往是平
方级。走捷径往往产生粗糙、未经思考的版本，长期而言这是假性节约，但通过
这种方式来节省重新发明时间的诱惑几乎总是无法抵抗的。
-Henry Spencer
    避免重新发明轮子的最有效方法是借用别人的设计和实现。换句话说，重用代码。
    下到单个库模块，上到整个程序，在各种级别上，Unix都支持重用，它帮你实现脚
本化和重组合。系统级的重用是Unix程序员区别于其他程序员的最重要行为特征；Unix
的经验是，养成良好的习惯，尝试通过最少的新发明，组合现有组件以形成原型，而非
匆忙地编写独立的、只能使用一次的代码。
    代码重用的品质是软件开发中如同苹果派和母爱般基本的主要美德。但是许多有其
它操作系统经历的开发者进入Unix社区后从未学会（或者从未学好）系统级重用的习惯。
浪费和重复工作相当普遍，尽管这种行为似乎既侵害代码生产者也侵害代码购买者的利
益。为什么这种病态行为会持续存在？知道了原因，就走出了改正的第一步。
16.1  猪小兵的故事
    程序员为什么会重新发明轮子？原闪很多，从狭隘的技术原因到程序员心理状态，
再到软件生严系统的经济学，方方面面都会导致如此行为，这种特有的顽疾正在肆虐。
    猪小兵是个刚走出大学的程序员，拿到了第一份正式工作。让我们假设他（或她）
已经知道了代码重用的价值并且满怀青春激情地准备大干一把。
    小兵的第～个项目是随团队编制一个大型应用。为了实例说明的方便，让我们认为
那是一个帮助终端用户能够智能构造查询和浏览庞大数据库的GUI。项目经理已经组合
了他们认为适合的工具和组件集，不仅包括开发语言，也包括许多程序库。
    那些程序库对于项目来说至关重要。它们包装了许多服务——下到窗口构件和网络
连接，上至诸如交互帮助的整个子系统——否则需要特别大量的额外编码，会严重影响
工程预算和发布时间。
www.pdf365.com
16.1猪小兵的故事
377
    小兵有些担心发布时间。他或许缺乏经验，但他看过Dilbert（呆伯特）漫画，还从
有经验的程序员那儿听过一些传说。他知道管理上有个趋势，说得好听点儿，进度上比
较“积极”。也许他已经读过Ed Yourdon的Death March（死亡之旅）【YourdonJ，那书
早在1996年就注意到，绝大多数项目的时间和资源预算都至少缩水了一半，并且会越缩
越厉害。
    然而小兵聪明伶俐，精力充沛。他想像出最可能成功的机会：学习分配到他手上的
工具和程序库，还得机灵点儿。他活动了～下打字的手指，一头猛扎进挑战之中……然
后就进了地狱。
    一切都要比他想的费时和痛苦。在程序库表面光鲜的示例程序下，正在重用的组件
似乎在一些边界情况下表现得无法预料或具有破坏性——而这些边界情况在他的代码中
常常遇到。小兵经常奇怪写程序库的家伙究竟是怎么想的。但他没法知道，因为组件的
文档不全——那些文档是技术文员写的，他们既不是程序员，想问题的方式也不像程序
员。他也不能通过阅读源码来了解程序库究竟是干什么的，因为程序库是处于专有许可
证下不透明的目标码。
    小兵不得不为组件问题不断地编写复杂的迂回代码，使用程序库已经到了得不偻失
的地步。迂回方法使得他的代码越变越糟。他碰到了程序库的软肋，库无法简单地像其
规格说明那样完成某些至关重要的任务。有时他也确信肯定有某种方法可以让这个黑盒
跑起来，但却无法断定究竟是什么方法。
    小兵发现，随着在程序库上花费的精力越多，他的调试时间就越成指数级地上升。
代码处于崩溃和内存泄漏的痛苦之中，追下来又往往发觉祸根就是那个程序库，或者是
某些他无法查看和修改的代码。小兵知道再追也许会追回到自己的代码，但是没有源代
码，就算想追回到自己代码也是不可能的。
    小兵开始沮丧了。大学里他曾经听说在业界，一个星期完成一百行代码就可以视为
是良好的业绩。那时他狂笑不已，因为在班级项目和写着玩的代码中，他的生产力是这
个的许多倍。现在这不再好笑。小兵不仅仅同自己的经验缺乏斗争，也同由别人的粗心
或者不胜任所制造的积压问题而斗争——这些问题他改不了，只能绕开。
    项目进度在变缓。梦想成为架构师的小兵发现，自己简直成了砖瓦匠，正在试图用
堆不起来的砖盖房，而且压力一大就会塌掉。而经理并不想听到新手的借口；大声地抱
怨组件质量太差，那些选择组件的经理和高级人员之间肯定会找他的麻烦。而且即使能
UNIX编程艺：术
  www.pdf365.com
378
第1 6章重用：论不要重新发明轮子
够成功说服他们，改换组件也将是一个复杂的提议，牵涉大群紧盯许可证法律条款的律
师。
    除非小兵非常、非常幸运，他不可能在项目的有生之年修正程序库的bug。在清醒
的时候，他也意识到库里面也有许多能工作的代码，他太注意那些bug和疏漏了。他
很愿意能够坐下来同组件的开发者好好谈谈，他们又不是白痴，从他们的代码能看出
来，他们一样是程序员，也工作在～个令人受挫的系统中。但是小兵甚至不知道他们
是谁——而且即使能知道，他们就职的软件商也多半不会让他们同他讨论这个问题。
    绝望中，小兵开始打造自己的砖块——用较稳定的库模拟不太稳定的库，并且开始
从零编写自己的实现。用来置换的代码是他自己的，思维模式他一清二楚，并且能够反
复阅读，更新认识，比起被替代的不透明组件和迂回方法所混合的代码，往往工作得相
对更好也更容易调试。
    小兵学到一个教训：越少用别人的代码，他的代码产量越高。这个经验满足了他的
自尊。像其他所有年轻的程序员一样，在思想深处都觉得自己比别人都聪明。他的经历
也似乎在表面上证实了这一点。所以小兵开始构建属于自己的工具包，一个自己用起来
更顺手的工具包。
    不幸的是，小兵此时获得的白己动手的习惯性思维，是一个短期的局部优化，会引
发长期的问题。他或许可以编写更多行的代码，但是如果不能重用，这些代码产生的实
际价值很可能会相当大幅度地降低。代码多并不等于代码好，至少在编写低层次代码和
大量重复投入时是如此。
    在换工作时，小兵至少还得准备经历～个挫折。他很可能发现带不走他的工具包。
如果他带着在公司编写的代码走出公司大门，其1日雇主就有理由认为他侵犯了知识产权。
如果承认重用了旧代码，新雇主如果知道了，也大有可能很不爽。
    即使小兵能够偷偷摸摸地在新工作中使用原先的代码，他也会发现自己的工具包用
处不大。新雇主也许使用一套不同的专有工具、语言和程序库。极有可能的是，在每个
新项目中，小兵都不得不学习一个稍微新～点的技术并重新发明一套轮子。
    这样，程序员重用代码（以及其它诸如模块性、透明性等随之而来的良好实践）便
是技术问题、知识产权壁垒、行政问题以及个人自我意识的综合。成千上万的小兵们，
年复一年地随着年龄的增长，变得越来越愤世嫉俗，也越来越习惯那种系统。对于多数
www.pdf365.com
16.2透明性是重用的关键
379
软件行业的现状，这就是巨大的时间、资本和人力资源浪费——这还没算上商家市场策
略、管理缺乏竞争、不可能期限以及所有其它阻碍工作的压力因素。
    小兵经历反映的职业文化可以折射出大部分的情况。软件公司有种“非自己做不可”
的强烈情结。他们对于代码重用是矛盾复杂的，一方面为了赶进度逼迫程序员使用功能
不足但很有市场的商业组件，同时又拒绝重用程序员自己经过良好测试的代码。这些软
件公司费力生产的是大量专用重复的软件，其实编制软件的程序员知道结果会是垃圾，
但除了自己的代码，别的哪儿也动不了。
    代码好不容易写出来了就决不能扔，只有不断地修修补补，即使所有的人都知道扔
掉重写会更好些，这个教条，就是在这种文化里形成的最接近代码重用的对等物。这种
文化产生的产品，即使其中涉及的每位人员都尽最大努力做好工作，随着时间的推移，
写出的程序还是会变得越来越臃肿，bug也越来越多。
16.2透明性是重用的关键
    我们埘许多有经验的程序员讲述了猪小兵的故事。如果读者本身正好是位程序员，
我们相信你会和他们一样有感同身受的无奈。如果你不是程序员却管理着一群程序员，
我们真诚地期望你能从中得到启发。这个故事试图谠明，反对重用的压力来自各个层面，
无法预料那一大堆问题究竟出自哪个原因。
    因此，对于大多数已习惯了软件行业背景的我们，常认为把这个问题的主要原因从
叙述的故事中提炼出来要花费相当大的努力。但最后，这些原因其实并不十分复杂。
    猪小兵的多数麻烦（也意味着大规模质量问题）归根结底是透明性——或者更确切
地说，是缺乏透明性。无法修正不通内情的东西。实际上，任何具有非平凡API的软件，
如果无法深入肌理，甚至无法正确使用。只有文档，不仅在实践上不足，在原则上同样
不够；文档并不能传达代码具现的所有细微差别之处。
    在第6章，我们评述了透明性对于优秀软件是何等的重要。只有目标码的组件破坏
了软件系统的透明性。如果在尝试重用时，其源码可以被阅读或修改，那么代码重用失
败的那种刺痛感要少得多。注释良好的代码本身就是良好的文档。源码中的bug也可以
UNtX编腥艺术
  www.pdf365.com
380
第1 6章重用：论不要重新发明轮子
改掉。有了源码，可以装备程序来进行衡测，可以通过编译来进行调试，这样在晦涩模
糊的情况下就更容易探询程序的行为。而如果需要改变程序的行为，当然也可以做到。
    需要源码还有另外一个重要的原因。Unix程序员在几十年中学到了“只有变化才是
永恒的”，经验是，源码可以永续，目标码则不行。硬件平台改变了，支持库的服务组
件改变了，操作系统发展了新的API并废弃旧的API。一切都变了——但是不透明的二
迸制执行码却无法适应变化。它们是脆弱的，不能够可靠地向前移植，不得不靠日益庞
大和错误百出的环境模拟代码层来支持。二进制可执行码将用户桎梏在编译构建者的设
想中。源码是必需的，因为即使不想或不需要改动软件，可能还得在新的环境中重新编
译以保证它能继续运行。
    透明性的重要，以及代码遗留问题，是要求重用代码开源以供检验和修改的两个理
由。但这并不是需要“开放源码”的完整论据；因为“开放源码”具有更深远的意义，
而不仅仅只是简单地要求代码是透明的和可见的。t
16.3从重用到开源
    在Unix的早期时代，操作系统组件、函数库以及相关实用程序都是随源码一起发布
的；这种开放性是Unix文化的生命力历在。在第2章我们描述了这种传统在1984年中
断以后，Unix是如何失去了它的原动力。我们也描述了再十年后，GNU工具包和Linux
是如何促使人们重新发现开放源码的价值。
    今天，开源代码又一次成为所有Unix程序员工具箱中最强大的工具之一。相应地，
尽管“开源”的明确观念以及最广泛使用的开源许可证要比Unix iS身晚数十年，但要在
如今的Unix文化中进行前沿开发，理解这两者是非常重要的。
    开放源码和代码重用的关系，在许多地方很像浪漫爱情和有性生殖的关系；你可以
用后者的术语来解释前者，但这样做就忽略了前者的趣味。开放源码并不能仅仅归纳为
一个在软件开发中支持重用的策略。它是一种自然而然发生的现象，是开发者以及用户
1  NASA（美国国家航空航天局）有意识地编制具有数十年服务期的软件；它已经意识到，需要坚决
要求所有空间航空电子学软件的源码都可获取。
www.pdf365.com
16.4生命中最美好的就是“开放”
38 1
直谏，为了保护透明性相关优势的社会契约。同样地，存在好几种方法来促成这种理解。
    本书早些时候在相关历史的描述中，我们选定的视角，集中在Unix和开源之间随意
的文化上的关系。我们将在第19章讨论开源开发的规则和策略。在讨论代码重用的理论
和实践时，更明确地考虑开放源码，非常有助于直接回应猪小兵故事中戏剧性表现出来
的问题。
    软件开发者希望他们使用的代码是透明的。更进一步，他们在换工作时不希望失去
他们的工具包以及他们的专有经验。他们厌倦了成为受害者，腻烦了被生硬的工具和知
识产权壁垒弄得灰心丧气，受够了不断地重新发明轮子。
    这些就是开放源码的动力，从猪小兵痛苦的初步重用经历中产生的动力。这其中涉
及了自我意识：设计最好的实践需要情感的投入，而不是冷漠无聊的过程。软件开发者，
同其它任何类型的工匠和技师一样；他们想要成为艺术家，这并不是什么私密。他们有
艺术家的动力和需求，也有拥有听众的欲望。他们不仅仅希望重用代码，他们也希望自
己的代码得到重用。这种势在必行的意念驱动，超越和颠覆了任何短期经济目标的达成，
也不是闭源软件生产所能够满足的。
    开放源码是种从意识形态上解决这些历有问题的优先方法。如果猪小兵在重用过程
中的多数问题的根源都在于闭源代码的不透明性，那么生产这种闭源代码的体制构想就
应该被击个粉碎。如果还考虑商家的领域地位，就必须抨击或直接绕过，直到公司意识
到它们的领域性习惯思维应该自我毁灭。代码重用竖起大旗并得到拥护者之后，开放源
码就是接下来自然而然要发生的事。
    相应地，自从1990年代晚期，在介绍代码重用的策略和战术时，如果不讨论开放源
码、开源实践、开源许可证以及开源社区，就毫无意义。当然，尽管这些问题在别处可
以分开讨论，但是在Unix世界中，它们已经无法避免地要绑在一起。
    在本章的余下部分，我们会纵览有关重用开源代码的几个不同问题：评估、文档和
许可证。在第19章，我们将更广泛地讨论开放源码开发模型，并研究向他人发布代码时
所必须遵从的约定。
16.4生命中最美好的就是“开放”
    在Intemet上，可以利用的Unix源代码，包括各种系统软件、应用软件、服务程序
库、GUI工具包以及硬件驱动等等确切地需要以TB来计算。大多数都可以使用标准工
UNI×编程艺术
  www.pdf365.com
382
第1 6章重用：论不要重新发明轮子
具在几分钟内编译并运行起来。只要念个咒：，/configure; make; make install;
当然，通常情况下必须在root用户下才能做安装部分的操作。
    来自Unix世界以外的人们（特别是非技术人员）往往倾向于认为开源（或“自由”）
软件必然比商业软件差，是假冒伪劣的，不可靠的，带来的麻烦只会比所能免除的更多。
但这遗漏了重要一点：一般来说，编写开源软件的人都很在乎它，也需要它，自己使用
它，而且通过发布这个软件在同行中赢得个人声誉。他们的时间也往往更少地耗费在会
议、反馈设计更改或是各种官僚的开销中。他们也因此具有更强的动力和更好的立场来
完成卓越的工作，远远超过那些薪水的奴隶，他们只会在专有软件公司大厦的小隔断里
费力地做着呆伯特似的工作，来迎合无法达成的最终期限。
    此外，开源用户社区（那些同行）不会羞于抓bug，而且他们的标准很高。发布不
够格软件的作者会承受许多的社会压力来修正或撤回代码，如果需要的话还能得到许多
专家级的帮助。结果，成熟的开源软件包一般都是高质量的而且常常在功能上比任何专
有等价物都要高级。这些开源软件或许看起来并不漂亮，想看懂文档或许也下容易，但
其至关重要的部分通常都会工作得相当漂亮。
    在同行评审效应之外，另外一个可以推测出质量上佳的理由是：在开源世界的开发
者，从来不会受最终期限的压迫，不会一闭眼、一拍脑门就发布软件。因此开源实践同
其余地方的一个区别就是，l.0级别的版本实际上意味着软件可以使用了。事实上，0.90
或者更高的的版本号就相当可靠，表明代码已经是成品了，但是开发者还是不敢拿这个
软件来赌自己的声誉。
    如果是来自Unix世界以外的程序员，也许很难相信这种主张。如果是这样，想想看：
在当代各种Unix上，C编译器本身几乎总是开放源码的。自由软件基金的GCC （GNU
Compiler Collection，GNU编译器集）是如此的强大可靠，文档又是如此的完善，专有的
Unix编译器根本没有市场空间，所以Unix的某些商家将GCC移植到他们自己的平台而
不是自己开发内部的编译器就再正常不过。
    评估开源软件包的方法是阅读其文档和快速浏览它的部分代码。如果所见的代码编
写恰当，文档完备，那么鼓励使用。如果能够证明软件包已经有些年头并且存在实质具
体的用户反馈，就可以断定它是相当可靠的（无论如何还是测测为佳）。
www.pdf365.com
16.4生命中最美好的就是“开放”
383
    在README文件以及项目新闻或源码发布历史文件中，所提到的除原作者之外的人
数，是度量成熟度以及用户反馈量大小的好方法。很多人呈报修正和补丁本身就是良好
的表征，既表明存在一个相当重要的用户群保持着对软件作者的敦促和警醒，也表明软
件维护者是恪守职责的，能够对反馈作出响应并订正错误。当然，这也是一个暗示，如
果早先的代码是充满bug的雷区，不用等到最近的爆炸，早就有受惊的人群踩得响噼里
啪啦的了。
    如果软件拥有自己的网页，在线常见问题解答（FAQ，Frequently Asked Questions）
列表，以及相关的邮件列表或Usenet新闻组，也是良好软件的表征。这些都是一个鲜活、
充实、有兴趣的社区已经围绕这个软件而成长起来的标志。网页上，最近的更新以及扩
展的镜像站点列表也同样是可靠的标记，表明这个项目拥活跃的用户群体。荒废的软件
包不可能有这种持续的投入，因为不值得。
    已经移植到了多种平台上也是个有价值的表征，说明用户群体多种多样。项目主页
往往明确地大肆宣扬新的移植版本，因为这样表明了软件的可信度。
    这儿是～些有关高质量开源软件的网页的实例：
    ●  GIMP<h七tp：／/www. gimp.org/>
    ●  GNOME<ht tp：／／www.gnome.org>
    ●  KDE<http://www. kde.org>
    ●  Python<http:／/www .python. org>
    ●  The Linux kernel<ht tp:／／www. kernel. org>
    ●  PostgreSQL<http:／/www. postgresql. org>
    ●  XFree86<http:／/xfree86.org>
    ●  InfoZip<http: //www. info- zip. org/pub/infozip/>
    看看Linux的各种发布版本是另一个寻找高质量软件的妙法。Linux和其他各种开源
Unix的发布制造者都拥有许多专业经验，知道哪些项目是最好的——这正是他们的发行
版本中最大的亮点。如果已经在使用开源的Unix，那么需要检查的就是待评估的软件包
是不是已经包含在自己的操作系统版本中了。
UNIX缩程艺_术
  www.pdf365.com
384
第1 6章重用：论不要重新发明轮子
16.5何处找
    因为在Unix世界可以获取的开源软件非常丰富，找到可被重用代码的能力就成为巨
大资本——远远超过其它操作系统的情况。这些代码的来源形式多种多样——独立代码
的摘录和实例，代码库，可以在脚本中重用的公用程序。在Unix下，大多数的代码重用
当然不是在程序中拷贝粘贴——如果发觉自己在这样做，便可以肯定你遗忘了一个更优
雅的重用方式。相应地，在Unix下工作，最管用的技能之一就是熟练地掌握将代码粘合
在一起的各种方法，从而能够应用组合原则。
    寻找可重用的代码，应该从自己的眼皮底下开始。Unix总是以多种多样可重用公用
程序以及函数库的工具包为特征；现代的版本，比如任何当前的Linux系统，包含数以
千计可重用的程序、脚本以及函数库。简单的man -k加上一些关键字进行搜索常常可
以得到很有用的结果。
    要想在此之外看看令人吃惊的丰饶资源，可以浏览SourceForge、ibiblio和
Freshmeat.net。读到此书时，也可能会有类似的其它重要站点出现，但是这三个都在过去
很多年中显示出了持续的价值和声望，并且似乎很有可能维持下去。
    SourceForge<ht tp：／／www. sourceforge．net>是个软件的展示站点，这些软件明
确地设计来支持合作开发，并拥有相关的项目管理服务。SourceForge不仅仅是个存放软件
的地方，还提供自由的联合开发服务，在2003年中期，毫无疑问，是世界上最大的纯开
源活动中心。
    在SourceForge之前，最大的站点是ibiblio<http：／／www - ibiblio．org>的Linux
归档。ibiblio归档是被动的，仅仅是个发布软件包的地方。然而，它确实比起多数被动
站点的网页界面都要好得多（创造其网页外观的程序，是我们在第14章讨论Perl时的一
个实例分析）o这个站点也是Linux文档项目（Linux Documentation Project）的主页，
维护着许多供Unix用户和开发者使用的优秀资源。
    Freshmeat<ht tp：／／www．freshmeat．net>是个专注于提供新软件以及已有软件
新版本发布公告的系统。它允许用户和第三方给这些版本添加评审。
    这三个多用途站点包含许多语言的代码，但是多数是C或C++。还有一些站点专门
针对某些我们在第14章讨论过的解释型语言。
    CPAN archive是Perl话言自由有用代码的重要储存库。可以很容易地从Perl主页
<http：／/v，rww.perl.com/perl>访问。
    Python Software Activity是一个Python软件和文档的归档，可以从Python主页
<http：／/WWW .python．org>访问。
www.pdf365.com
16.6使用开源软件的问题
385
    Java  Applets  Page<ht tp：//j ava．sun．corn/applets/>可以找到许多Java小应
用程序以及指向自由Java软件的站点链接。
    作为Unix开发者，最有价值的时间投资方法之一就是，花时间在这些站点上去了解
可以获得什么东西来重用。节省下来的编码时间就是自己的。
    浏览软件包的元数据（ metadata）是个不错的主意，但别到此为止。也请试验一下代
码。这样能够对代码究竟做些什么会有个更好的领悟，从而更有效地使用。
    更一般地，阅读代码是为未来而投资。可以从中学到甚多——新技术、分解问题的
新方法、不同的风格和手段。使用代码和学习代码都能得到有价值的回报。即使并不使
用所研究代码中的方法，学习他人解决方案中改良的问题定义，也许能够帮助自己发现
一个更好的方法。
    写之前先读：培养阅读代码的习惯。很少有什么彻底全新的问题，所以几乎总是能
够发现非常接近的代码，成为自己需要的一个良好起点。即使当问题真正非常新颖时，
也很有可能与某人之前已经解决的问题相关，而解决方案也很可能是从某个已经存在的
方案发展而来。
16.6使用开源软件的问题
    使用或者重用开源软件存在三令主要问题；质量、文档以及许可证条款。正如我们
上面所看到的～样，如果花一点判断力挑选一下，一般都会发现一个或者更多的软件拥
有令人肃然起敬的上乘质量。
    文档通常是个更严重的问题，许多高质量的开源软件包的应用范围和它们在技术上
的领先不相协调，就是因为它们的文档很糟糕。Unix传统鼓励了太过专门的文档风格，
这种风格（尽管或许会在技术上涵盖软件包所有的功能特征）往往假设其阅读者也相当
熟悉应用程序的定义域，并且阅读得非常仔细。这样做也有很好的理由，我们会在第18
章进行讨论，但这种风格呈现出一种壁垒。幸运地，从这样的文档中提炼有价值的东西，
这个技能值得学习。
    用软件包名字或者主题关键字加上“HOWTO”或“FAQ”字符串，用它作为关键
字在网上搜索。对初学者来说，通常会发现比手册页更有用的资料。
    重用开源软件（特别是在任何商业产品中）最重要的问题是理解软件包的许可证，
如果存在许可证，你就会承担某些义务。在接下来的两个部分，我们将从细节上讨论这
个问题。
UNIX编程艺I术
    www.pdf365.com
386
第1 6章重用：论不要重新发明轮子
16.7许可证问题
    任何非公共领域的东西都有一个或更多版权。在美国联邦法律中，即使一件没有版
权声明的作品，其作者也拥有版权。
    在版权法下确定谁能够成为作品的作者可能非常复杂，尤其是经过多人之手形成的
软件。这就是为什么许可证非常重要的原因。许可证能够授权代码以某种方式使用，否
则在版权法之下是禁止或者需要付费的；许可证同时也保护用户免受版权所有者任意专
断行为的侵害。
    在专有软件世界里，许可证条款是设计来保护版权的。条款是在尽可能地为持有人
（版权所有者）保留领域范围利益，同时也授予用户某些权利的方法。版权所有者非常
重要，而许可证逻辑限制相当严格，所以许可证条款中确切的技术细节通常反而并不重
要。
    正如后面将要看到的那样，许可证可以使人们在版权所有者希望无限期存在的条款
下自由地获取代码，版权所有者多数情况下会使用版权来保护许可证。否则，仅有少数
权利得以保留而多数选择都交给了用户。特别地，对于别人已经拥有的拷贝，版权所有
者不能更改上面的条款。因此，在开源软件中，谁是版权所有者并不重要，但许可证条
款却至关重要。
    一般地，一个项目的版权所有者是该项目的领导者或赞助组织。项曰转让到～个新
领导者时，常常由版权所有者的变动显现出来。然而，这也并不是严格的准则；许多开
源软件都有多个版权所有者，并且这也没有导致法律问题的案例记录在案。一些项目选
择把版权指派给自由软件基金，理论上，自由软件基金确有为开放源码辩护的利益所在，
也有可以利用来进行辩护的律师资源。
16.7.1  开放源码的资格
    出于授权许可的目的，我们需要区分一个许可协议可能传达的几种不同权利。这些
权利包括重新分发权，使用权，供个人使用的修改权，以及修改版本的重新发布权。
    开放源码定义（Open Source Definition） <http：／/www，opensource．org/osd. html>
是思考什么让软件成为“开放源码”或（用旧术语）“自由，，的产物。在开源社区，
这作为开源开发者间社会契约的一个表述而广泛接受。其在许可证上的约束加有如下的
要求：
www.pdf365.com
16.7许可证问题
387
    ●  准予无限的复制权。
    ●  准予以无修改形式重新发布的无限权利。
    ●  准予供个人使用的无限修改权。
    这个方针禁止对二进制软件修改后的重新发布施加限制；这满足了软件发布者的需
求，他们希望能够毫无羁绊地转载可运行代码。这也允许作者要求修改的源码再发布时
以旧源码加补丁的形式发布，这样对于他人的修改，保证了原作者取舍和审查跟踪的权
利。
    OSD是“OS[ Cerifed  Open  Source"认证标志的法律定义，也是任何人所能提出的
最好的“自由软件’’定义。所有的标准许可证（MIT、BSD、Artistic、GPL/LGPL和MPL）
都满足它（尽管有些，例如GPL，具有其它的限制，在选择之前应该有所理解）。
    注意，只允许非商业使用的许可证并不等同于开源许可证，即使那些许可证往往基
于GPL或别的什么标准许可证。这样的许可证有区别地对待特别的行业、个人以及团体，
而这是OSD条款5明确禁止的。
    条款5是在几年的痛苦经历之后而加入的。仅供非商业性使用的许可证带来一个问
题，如何找到一种法律检验来确认某个再发布是“商业的”。将软件作为一个产品来
出售，这种情况当然毫无疑问。但如果以一种名义上的零价格同其它较件或数据一起
发布，而其实际价格以整体收费又该如何？而如果软件对于整体的功用是否关键又如
何区分？
    没人能够回答。仅供非商业使用许可证产生了再发布者认定的不确定性，事实上
恰好是个对它们自身严重的不利因素。OSD的目标之一就是确保处于符合OSD的软件
发布链中的人，不需要咨询知识产权律师来确定他们的权利到底是些什么。OSD禁止
将复杂的限制有区别地加诸于个人、团体以及行业，这样处理软件作品集的人就不需
要面对组合激增的爆炸式问题：这样或那样处理究竟有何微妙的不同（也许甚至是冲
突）。
    这种关心并非没有道理。开源发布链中重要的一环就是CD-ROM发布者，他们收集
许多非常有用的作品，从简单的软件集合CD到可启动的操作系统。如果那样限制，就
会让这些光碟发布商生活困顿窘迫，而其它试图商业传播软件源码的行为，也受到了禁
止。
    另一方面，OSD并没有讨论什么司法权法。有些国家的法律禁止出口某些限制技术
到所谓的“流氓国家”。OSD并不能反对这些，它只是说被许可人不能擅自增加自己的
UNIX编腥艺：术
  www.pdf365.com
388
第1 6章重用：论不要重新发明轮子
限制。
16.7.2标准开放源码许可证
这里是一些你可能碰上的标准开放源码许可证条款。～般而言都使用以下列出的缩写。
MIT <http:／/www. opensource. org/licenses/mit - licenBe. html>
MIT X联盟许可证（如同BSD -样，但是没有广告相关的条款。）
BSD <http:／/www. opensource. org/licenses/bsd- license .html>
版权属于加利福尼亚伯克利大学董事会（使用在BSD代码上）。
Artistic License <http:／/www. opensource. org/ licenses/artistic -
license．html>
同Perl技术许可证完全一样。
GPL <http:／/www. gnu .org/copyleft. html>
GNU通用公共许可证
LGPL  <http:／/www. gnu. org/copyleft. html>
库（或“弱”GPL）
MPL <http: //www* opensource. org/licenses/MPL-1. 1.html>
Mozijla公共许可证
    我们将在第19牵从一个开发者的角度来讨论这些许可证更多的细节问题。就本章目
的而言，它们之间唯一重要的区别就是他们是不是具有传递性。如果许可证要求许可证
软件任何的派生产品也同样置于许可证条款的限制之下，那该许可证就是传递的。
    在这些许可证下，对于使用开放源码唯一真正需要担心的问题就是专有产品结合自
由软件的情形（相对于仅仅使用开源开发工具制作的产品）。倘若许可证不是传递的，
即使是直接的合并，只要在产品的文档说明中准备和包含了对正确许可证的致谢以及所
使用文件的出处，就应该是安全的。
    GPL既是最广泛使用，又是最受争议的传递性许可证。它的条款2（b），要求任何
派生至GPL程序的作品本身也得遵从GPL，就是这引起了争议。  （条款3（b）要求许可
人必须让源码可以在物理媒介上按需索取，曾经也引起了部分争议，但是互联网的爆炸
发展使得按3 （a）要求的源码文件发布极其容易，所以没有人再担心这个要求了。）
www.pdf365.com
16.7许可证问题
389
    没有人能完全确定条款2 （b）中“包含或派生自”的意思，稍后几段关于什么样的
使用受到“纯聚合（mere aggregation）”保护的表述也是如此。有异议的问题包括链接
库以及包含遵从GPL许可的头文件。出现这种问题部分是因为美国的版权法并没有定义
什么是派生；这留给了法庭在判例法中推敲出定义来，而在计算机软件这个领域，这个
过程几乎还没有开始（到2003年中期止）。
    一方面，“纯聚合”确实保证将专有代码同GPL许可的软件一起在统一介质上发布
是安全的，只要它们彼此之间不互相调用和链接。它们甚至是可以处理同～种文件格式
或磁盘结构的工具；在这种情况下，依据版权法，不存在一个派生自另一个的关系。
    另一方面，将遵从GPL的代码摘出，插入在专有代码之中，或是链接遵从GPL的
目标码到专有目标码中，肯定让该代码成为一个衍生产品，从而需要遵从GPL许可。
    通常都认为一个程序将另一个程序作为子进程执行并不会导致其中任何一个程序成
为另一个程序的派生。
    产生争论的情形是动态链接共享库。自由软件基金的立场是，如果一个程序以共享
库方式调用另一个程序，那么这个程序就成为了该库的派生。有些程序员认为这个声朗
过了头。双方都有技术的、法律的以及行政的论据来支持己方的观点，我们在这儿并不
想老调重谈。既然自由基金组织编写并拥有许可证，就当FSF立场是正确的前提下谨慎
工作，直到另有法律条文。
    有些人认为条款2 （b）的表述是故意设计来感染那些商业软件的全部内容的，虽然
它们仅仅只摘用了一小部分遵从GPL的代码：这些人更愿把它称作GPV，或是“通用公
共病毒（General Public Virus）”。另外有些人认为“纯聚合”表述涵盖了所有没有将
GPL或非GPL代码混合在同一个编译或链接单元中的一切。
    这种不确定已经在开源社区造成了太多的不安，所以FSF不得不发展出特别的、稍
微缓和的“Library GPL’’（已经改名为“Lesser GPL”）来打消人们的疑虑以继续使用
随FSF GUN编译器集一起发布的运行库。
    条款2 （b）的解释需要你自己选择；绝大多数律师都不会理解所涉及的技术问题，
而且也没有什么判例法。事实上，经验告诉我们FSF从未（至少从1984年它创建起到
2005年年中）以GPL控告过任何人，但它确实以威胁提起诉讼来强迫实行GPL，且在
所有已知的案例中都获得了成功。同时，作为另外一个经验事实，网景（ Netscape）茌它
的商业Netscape Navigator浏览器中包含了遵从GPL的程序源码和目标码。
    MPL和LGPL具备的传递性比GPL更为有限。倘若GPL或非GPL代码之间所有的
通路都通过一个API或其它良好定义的接口来实现，那么链接进专有代码中并不会让该
    UNIX编l程艺术
    www.pdf365.com
390
第1 6章重用：论不要重新发明轮子
专有代码成为派生产品，这在MPL和LGPL中是明确允许的。
16.7.3何时需要律师
    本节内容专门为那些考虑把纳入以上许可证标准的软件整合进闭源码产品的商业开
发者而设。
    经历了这么多法律措词之后，在此，我们最希望的就是赶紧发表一个严肃的权利放
弃书，说明我们不是律师；如果对于利用开源软件在法律上有任何疑问，最好立即去咨
询律师。
    这是彻底的废话，尽管出于对法律职业的尊重。这些许可证使用的语言同法律术语
一样清晰——就是为了清晰才使用书面表达——而且如果仔细阅读的话应该根本就不难
理解。律师和法庭其实比你还困惑。软件版权法含混不清，在开源许可证上的判例法（在
2003年中期）还不存在；没有人曾经因为这个而被控告。
    这意味着一位律师并不太可能比一个细心阅读许可证的人拥有更好的见地。但律师
常常职业性地对他们不懂的东西患有妄想症。因此，如果咨询律师，他可能更会告诉你
不要随便靠近开源软件，尽管事实上他可能对技术方面根本一窍不通，或者并不见得比
你更能理解作者的意图。
    最后，将作品置于开源许可证之下的人们往往并不是什么大企业，没有那些鸡蛋里
面挑骨头的律师群照顾；他们只是一些个体或志屦群体，主要就是想发布他们的软件。
极少数的例外（那些既在开源许可证下发布软件又有钱雇佣律师的大公司）却常常在开
放源码上有投资，并且也不想挑起法律麻烦，与产生开放源码的开发者社区为敌。所以，
被以无辜的技术侵权罪名拖进法庭的可能性，大概会低于下星期遭雷劈的概率。
    这并不是说应该把这些许可证当作笑话来对待。那对凝结在软件中的创造力和血汗
未免有失敬意，而且官司轻重不说，你恐怕也不会把激怒作者、成为第一被告的经历当
作享受吧。但在缺少权威判例法的情况下，能做的99%就是明确承诺努力满足作者的要
求；另外的或许可以（或许不能）通过咨询律师来达到保护自己的1%的额外努力，而这
又有什么不同呢。
www.pdf365.com
PartⅣ
Community
www.pdf365.com
www.pdf365.com
1 7
可移植性：软件可移植性
与遵循标准
Portability: Software Portability and
Keeping Up Standards
     The realiZation that the operating systems of the target machines were as great an
obstacle to portability as their hardware architecture led us to a seemingly radical suggestion:
to evade thatpart of the problem altogether by moving the operating system itself.
    对于可移植性，目标机器的操作系统和其硬件结构都是障碍，意识到这一点，可能
会导致相当激进的意见：完全规避问题的方法，就是移植操作系统本身。
-Portability of C Programs and the UNIX System  （ 1978 ）
C程序的可移植性和Unix系统（1978）
Unix是第一款移植到不同系列处理器上的生产级操作系统（Unix版本6，1976-
1977）。现今，Unix可以被移植到每一款足够强大可以运行内存簪理单元的新机器上，
这已经毫不稀奇了。应用程序也常常在差异极大的不同硬件上运行的Unix间移来移去；
事实上，还没听说哪次移植失败过。
www.pdf365.com
394
第1 7章可移植性：软件可移植性与遵循标准
    移植性一直是Unix的主要优势。Unix程序员往往设想硬件是易变的，只有Unix API
才是稳定的，尽可能少地假定诸如字长、字节顺序和存储体系等机器的特殊细节。实际
上，在Unix圈中，以任何方式超出C的抽象机器模型而依赖于硬件的代码，都会被认定
为不良的形式，仅允许发生在诸如操作系统内核等极为特殊的情况下。
    Unix程序员已经了解到，一旦设想软件项目的生命期很短，就非常容易犯错。1所以，
Unix程序员往往尽量避免软件依赖于某种特殊易逝的技术，而严谨地遵循开放标准。这
种考虑可移植性的编码习惯在Unix传统中根深蒂固，甚至应用于那些一次性小型单用途
的代码中。这种习惯也始终贯穿于Unix开发工具的设计，以及例如Perl、Python和Tcl
之类在Unix下发展起来的语言中。
    可移植性最直接的效益是工具和应用程序无需每隔几年就重写，因为Unix软件比起
原生的硬件平台来得长久，这是再正常不过的。今天，最初为Unix版本7（1979）所编
写的应用程序，不仅用在其直系后裔中，也用在那些按照Unix规范编写操作系统API，
但并没有从Bell实验室源码树共享代码的交种中，如Linux。
    间接的益处并不明显但可能更为重要。可移植性的戒律往往在架构、接口和实现上
施加了一种简单化的影响。这既提高了项目成功的几率也降低了生命期的维护成本。
    本章概览Unix标准的范围和历史。我们将讨论哪些部分在今天仍然意义重大，并描
述Unix API中或多或少变化的部分。我们将检视某些Unix开发者用来保持代码可移植
性的工具和惯例，同时逐步展示出对良好实践的建议。
7．  C语言的演化
    C语言及其附带服务接口（挑明了，就是标准输入输出库函数及其友元）的稳定性
一直以来都是Unix编程经历的主要核心事。诞生于1973年的一门语言，在三十年来的
频繁使用中，只有很少的变动需求，这真是非常了不起：在计算机科学和工程领域中尚
无人出其右。
    在第4章，我们论述了C语言如此成功是因为它可以作为计算机硬件上的薄胶合层，
近似于【BlaauwBrooks]的“标准架构”。当然，成功的因素并不仅止于此。为了理解其余
的内幕，我们需要简要地回顾一下C语言的历史。
1  PDP-7 Unix和Linux都是持久性出乎意料的例子。Unix最初是作为一个研究玩具由几个研究者在
项目工程间编制而出，一半是为了实验文件系统的创意，一半悬为了运行一个游戏。而Linux则被其
创造者总结为“长了腿的终端模拟器”【Torvalds]。
www.pdf365.com
395
17.1.1  早期的C语言
    C语言诞生在在1971年，最初作为Unix移植到PDP-Il的系统编程语言，基于Ken
 Thompson早期的B语言解析器，脱胎于BCPL （Basic Common Programming Language），
于1966-1967在剑桥大学诞生2。
    Dennis M. Ritchie的原始C编译器（也常常以他名字的首字母称为“DMR”编译器）
在Unix版本5、6、7快速持续增长的社区中都有应用。版本6的C编译器派生了
Whitesmiths C编译器，这个重新的实现成为了第一款商业的C编译器，也是软件通用型
IDRIS的核心。但是多数现代的C语言实现都以Steven C．Johnson的“可移植C编译器
（PCC）"为模型，该编译器在版本7中首次亮相，并在System V和BSD 4.x的发布中
完全取代了DMR编译器。
    在1976年，版本6的C语言引入了typedef、union和unsigned int声明。带初值的
变量初始化语法和一些复合操作符也有改动。
    最初C语言的参考手册是Brian Kernighan和Dennis M. Ritchie原创的《The C
Programming Language》<C编程语言），即《白皮书》[Kernighan-Ritchie]。该书出版于
】978年，同年Whitesmiths C编译器问世。
    白皮书描述了增强的版本6C语言，包含一个涉及公用存储处理的重要例外。基于
任何能够处理FORTRAN语言的机器都可以立即处理C语言的理论，Rithie原意是仿造
FORTRAN语言中“COMMON”声明的规则。在公用块（common-block）模型中，公用
变量也许会被声明好几次；相同的声明由链接器合并。但是两个早期的C移植（ Honeywell
和IBM 360大型机）恰好是那种限制公用存储或链接器较为原始或两者兼有的机器。这
样，C编译器版本6采用了在白皮书中描述的、较为严格的定义引用模型（要求任何公
用变量至多只有一处声明，并在引用处使用关键字extern来标记）。
    许多现存源码都依赖较为宽松的规则，所以这个决定在随着版本7发布的C编译器
中被颠覆了。向后兼容的压力也阻碍了另一个转换尝试（1983年的System V Release l），
直到1988年ANSI标准草案才最终解决了定义引用原则。公用块公共存储依然是标准许
可的变体。
2C语言中的“C’’因此代表“Common[通用）”——或者，代表“Christopher”。BCPL最初表示
“Bootstrap CPL（引导性CPL）”-CPL的一个非常简化的版本，CPL是一种非常有趣但抱负过
大而从未实现的牛津剑桥通用编程语言，也被亲切地称之为“Christopher's Programming Language
（Christopher编程语言）”，以这门语言的主要贡献者，计算机科学的先驱Christopher Strachey命名。
UNIX编程艺术
  www.pdf365.com
396
第17章可移植性：软件可移植性与遵循标准
    C版本7引入了enum，并且将struct和union的值作为第一类对象，可被赋值，可
作为参数传递，也可作为函数的返回值（而不是靠地址传递）。
    V7中的另一个主要变化是Unix的数据结构写在了头文件中，并可以被包含。
原先的Unix将这些结构（如目录）打印在手册中，人们需要将其复制到代码中。毋
庸多言，这是个重要的移植性问题。
-Steve Johnson
    System III C版本的PCC编译器（也随BSD 4.lc -起发布）改变了struct声明的处
理，这样不同struct中的同名成员不会冲突。同时引入了void和unsigned char声
明。函数内的extern声明，其作用域也限制在函数体中，而不再覆盖所有位于声明以
后的代码。
    ANSI C草案提议标准（The ANSI C Draft Proposed Standard）加入了const（只读存
储）和volatile（表明在程序控制的线程中例如内存映射寄存器等需要异步修改的地
方）。unsigned类型修饰符泛化了，可以应用于任何类型，同时加入了一个对称的
signed修饰符。也加入了auto数组、结构初始化器以及union樊型的初始化语法。
最重要的，加入了函数原型。
    早期C语言最重要的变化就是，转型为定义引用和在ANSI C草案提议标准（Draft
Proposed ANSI C Standard）中引入的函数原犁。自从1985-1986年X3JI1委员会关于标
准草案的工作报告将委员会的意向传达给编译器的实现者之后，C语言在本质上一直都
很稳定。
早期C语言更详细的历史，可以参阅其设计者编写的《Ritchie93》。
17.1.2  C语言标准
    C语言标准的发展一直是个保守的过程，原始C语言的精髓得以小心留存，更认可
现存编译器中的实验技术而不是发明新的特征。C9X宪章（charter）3文档很好地表述了这
个任务。
3可- rXib-问网页<http：//anubis．dkuug．dk/JTCI/SC22 /WG14 /www/charter>。
UNIX霸葶醒芝易笊
www.pdf365.com
17.1  C语言的演化
397
    第一个官方C语言标准化工作在X3J1l ANSI委员会的赞助下始于1983年。主要的
功能增加在1986年末就已经解决，在这一点上，对于编程者来说，区别“K&R C”和“ANSI
C”变得很普遍。
    许多人都没有意识到C语言标准化努力的工作是多么的不同寻常，尤其是最
  初的ANSIC工作，它坚持只将经过测试的特征列入标准。很多语言的标准委员会
  把大量时间花在新的语言特性上，而几乎不考虑应该如何实现。确实，极少数凭
  空产生的ANSIC特征——例如，臭名昭著的“三字母操作符（Lrigraphs）”——就
  是C89中最讨厌最不成功的特征。
    -Hen哼Spencer
    标准化努力的部分结果是发明了void指针，并且成为赢家。但是Henry的观
点也被很好地接受了。
-Steve Johnson
    尽管ANSI C的核心早就确定了下来，关于标准库内容的争论还是拖延了好几年。
正式的标准直到1989年末才发布，那是在许多编译器都已经实现了1985年的建议之后。
该标准最初称为ANSI X3.159，但在1990年国际标准组织（ISO）成为新的赞助方后重新设
计为ISO/IEC 9899:1990。该标准描述的语言变体通带称为C89或C90。
    第一本关于C语言和Unix可移植性的书籍，《Portable c and Unix Svstems
Programming》（可移植的C语言和Unix系统编程）[Lapin]，于1987年出版（在那时追
于雇主压力，此书以公司笔名出版）。第二版的《Kernighan-Ritchie》于1 988年出版。
    C89 -个次要的修订，称作修订l/AMI/C93，在1993年付诸实施。该修正增加了对
宽字符集和Unicode更多的支持。这就是ISOfIEC 9899-1:1994。
    C89标准的修订始于1993年。在1999年，ISO/IEC 9899（通常称作C99）为ISO
所采用。该协议集成了修订1并增加了许多次要的特征。其中也许对大多数编程者最重
要的一个就是，具备了像C++一样可以在代码块任意点，而不是仅仅只能在开始处声明
变量。同时也加入了参数个数可变的宏。
    C9X  工作组的网页是<http：／／anubis．dkuug．dk／JTC1／SC22/WG14/
www/proj ects>，但是在2003年中期还没有第三个标准化工作列入计划。正在为嵌入
式系统发展一个C语言的补遗。
    在c语言标准化工作开始烈前，可工作的兼容实现已经运行在广泛的不同系统上，
这个事实极大地协助了c语言的标准化工作。但这也更难以论证究竟哪种特征应该加入
UNIX编翟艺术
    www.pdf365.com
398
第17章可移植性：软件可移植性与遵循标准
到标准之中。
17.2 Uni×标准
    1973年用C语言重写后，Unix史无前例地容易移植和修改。结果，始祖的Unix分
别发展出了一系列早期操作系统。发展Unix标准最初就是为统- Unix系列不同分支的
API。
    在1985年后发展的Unix标准在这方面相当成功——因此而成为了现代Unix实现极
具价值的API文档。实际上，现实世界的诸多Unix都紧密地遵循公开标准，所以开发者
能够（也常常这样做）更依赖诸如POSIX规格说明的文档，而不是手头使用中的变种
Unix官方手册页。
    实际上，在新近的开源Unix（例如Linux）中，就往往使用公开标准作为其操作系
统功能特征的规格说明。我们在本章稍后审视RFC标准化过程时还会回到这一点来。
17.2.1  标准和Unix之战
Unix标准发展的原动力是第2章叙述过的AT&T和Berkeley阵线在发展上的分裂。
    4.x BSD Unix源自1979年的版本7。在1980年4.IBSD发布后，BSD阵线很快赢得
了Unix发展前沿的好名声。重要的新特性包括V1可视编辑器，从单一控制台管理多重
前后台任务的作业控制功能，以及信号的改进[参见第7章）。迄今为止最重要的增加
是TCPfIP网络，但是尽管Berkeley在1980年就获得了该合同，’rCPIP三年内都没能随
对外发布的版本一起交付。
    但是另一个版本，1981年的System III，成为了AT&T后来发展的基础。System III
重编了版本7的终端接口，使之更简洁，更优雅，但同Berkeley的改进完全不兼容。它
保留了老的（无重置）信号语义（也请参考第7章关于这点的讨论）。1983年1月发布
的System V Release 1整合了某些BSD实用程序（如vi（1））。
    在1983年2月，UniForum进行了架通两者的第一次尝试，这是一个很有影响的Unix
用户组。它们的Uniforum 1983年标准草案（UDS 1983）描述了一个“核心Unix系统”，
由System III核心的一个子集和函数库加上文件锁定原语构成。AT&T宣布支持USD 83，
www.pdf365.com
17.2 Unix标准
399
但是标准只是基于4.IBSD的发展实践的不完全子集。在1 983年4.2BSD发布的时候，
这个问题加重了，它为该版本增加了许多功能（包括TCPfIP网络），也引入了许多跟原
先版本7并不兼容的东西。
    1984年Bell运营公司的剥离以及Unix战争的开始（参考第2章）使问题更加复杂。
Sun Microsystems朝BSD方向领导着工作站产业；AT&T甚至一边继续向诸如SUfl的竞
争对手授权操作系统，一边利用对Unix的控制作为战略武器并试图进入商务领域。为了
保持竞争优势，所有商家作出的商业决策都是差异化他们的Unix版本。
    在Unix内战中，在某种意义上，技术标准成为相互合作技术人员奋力推动的东西，
而产品经理不是勉强接受就是积极反对。重大而重要的例外是AT&T，当它在1984年1
月发布System V Release 2（SVr2）时，宣布了同用户组在标准设立上的合作计划。1984
年的UniForum草案标准第二次修订版，追踪和影响了SVr2的APJ。后来的Unix标准中，
除了某些BSD功能在效用上特别领先的领域，均倾向遵从System V（例如，现代Unix
标准描述了System V晌终端控制而不是BSD同样功能的接口，就是这个原因）。
    在1985年，AT＆T发布了System V接口定义（System V Interface Definition，SVID）。
SVID结合UDS84为SVr2 API提供了一个更为正式的说明。后来的版本，SVID2以及
SVID3遵从了System V release 3和4的接口。SVID成为了POSIX标准的基础，而POSIX
最后在系统和C函数库上Berkeley/AT&T的分歧中，大多数都偏向了AT&T。
    但趋势在好几年内都仍不明显；其间，Unix之争仍战事频繁。例如，1985年，网络
共享文件系统就发布了两个竞争的API标准：Sun的网络文件系统（Network File System，
NFS）以及AT&T的远程文件系统（Remote File System，RFS）。Sun的NFS更流行一些，
因为Sun公司不仅愿意共享规格说明还愿意将代码公开。
    这个成功的经验其实更应该值得指出，因为纯粹基于逻辑判断来说，RFS远远更加
优秀。它支持更好的文件锁定语义以及在不同系统用户身份更好的映射，并且总的来说，
作出了相当的努力以期获得Unix文件系统语义更好更淮确的细节，而不像NFS。然而这
个成功的经验却往往被忽略，甚至在1987年，开源X window系统战胜了Sun专有网络
视窗系统（ Networked Window System （NeWS》时，也不例外。
    1985年后，主要的Unix标准化推进传递给了美国的电气电子工程协会（lnstitute of
Electrical and Electronic Engineers，IEEE）。IEEE的1003委员会发展了一系列的标准，
UNIX编程艺-术
  www.pdf365.com
第1 7章可移植性：软件可移植性与遵循标准
通常称作POSIX4。这些标准不仅描述系统调用和C函数库功能，还说明了具体的shell
语义和最小命令集，并具体化了各种非C编程语言的接口。它首次发布于1990年，1996
年发布了第二版。国际标准组织采用其作为ISOfIEC 9945。
    关键的POSIX标准包括：
1003.1 （1990年颁布）
    函数程序库。描述了C系统调用API，大部分同版本7相同，除了信号机制与终端
控制接口。
1003.2 （1992年颁布）
    标准shell和实用程序。Shell语义几乎同System V的Boume shell -模一样。
1003.4 （1993年颁布）
    实时Unix。二元信号量、进程内存锁、内存映射文件、共享内存、优先调度、实时
信号、时钟和定时器、IPC消息传递、同步I/O、异步1/0、实时文件。
    在1996年的第二版中，1003.4分成了1003.lb（实时）和1003.c（线程）两个部分。
    尽管在几个关键的领域里（比如信号处理语义上）说明不足，也遗漏了BSD套接字，
最初的POSIX标准还是成为了所有后来Unix标准化工作的基础。它仍然作为一个权威
被引用，纵使许多都是通过POSIX Programmer's Guide（POSIX裎序员指南）[Lewine】等间
接引用。实际上的Unix API标准仍然是“POSIX+套接字”，以后的标准主要是增加功
能以及在不常见边界情况更紧密的一致性规定。
    下一个参与者是X/Open（后来更名为Open Group），它是在1984年形成的Unix商家
联盟。它们的X/Open Portability Guides （XPGs）最初与POSIX草案平行发展，而在1990
年之后，XPGs整合扩展了POSIX。POSIX试图捕捉所有Unix的安全子集，而XPG更
倾向前沿开发的普遍实现；即使是1985年的XPGI，就跨越了SVr2和4.2BSD，还包含
了套接字。
    1987年的XPG2增加了终端处理API，基本上是System V的curses（3）。1990年的
XPG3融合了XII API。1992年的XPG4完全遵从了ANSI C 1989标准。XPG2、XPG3
4最初1986年的试用标准叫做IEEE-IX。  “POSIX”的名称是Richard Stallman的建议。POSIX.I的
介绍说：  “应该发[pahz-icks】的音，而不是[poh-six】或别的什么，公布发音方式是为了以尝试传播一
种il用标准操作系统接口的标准化方法。”
www.pdf365.com
17.2 Unix标准
401
和XPG4极度关注国际化的支持，并描述了一套详尽的API来处理字符集和消息目录。
    在阅读Unix标准的时候，也许会碰到“Spec 1170"（自1993年）、“Unix95"（自
1995年）和“Unix 98”（自1998年）。这些认证标记都基于X/Open标准；现在仅仅只
是历史的兴趣罢了。但是XPG4完成的工作成为了Spec 1170，而Spec 1170又转变成第
一版的“单- Unix规范’’  （Single Unix Specification，SUS）。
    1993年，包括每个主要Unix公司在内的75个系统和软件提供商对Unix战争作出
了了断，宣布支持X/Open开发出Unix的通用定义。作为协商的一部分，X/Open组织获
得了Unix商标权。整合的标准变成了单- Unix苏磋版本1。接下来就是1997年的版本
2。在1999年X/Open并入了POSIX的活动。
    在2001年，X/Open（现在的The Open Group）发布了单- Unix标准版本
3<ht tp：／/wwW。unlx．org/version3 1>。所有Unix API的标准化流程最终汇合到一
起。这反应了如今的现宴状况；不同种类的Unix已经会聚在～个通用API集合中。并且，
至少对1980年代的动荡记忆犹新的老一辈人来说，这太令人愉悦了。
17.2.2庆功宴上的幽灵
    但很不幸地，有个尴尬的情况——支持整合努力的1日学派Unix商家处于新学派开源
Unix的严峻压力之下，在某些时候不得不抛弃（有利于Linux）已经为确保一致性付出
巨大努力的专有Unix。
    单一Unix规范的一致性验证检测是个昂贵的任务。每个发布都需要做一次，但这超
出了大多数开源操作系统发布者的能力。无论如何，Linux的变化如此之快，任何发布版
本在获得认证时，可能都已经过时了5。
    诸如单- Unix规范之类的标准并没有完全失去实用性，它们仍然对Unix实现者有
很高的指导价值。但是Open Group以及其它旧学派Unix标准化机构如何适应开源发布
的节奏（以及开源开发组低预算或零预算运作），还有待观察。
5有个Linux发布商，英国的Lasermoon，确实获得了POSIX．】FIPS 151-2认证～一它已经倒闭了，
因为潜在用户对此根本不关心。
UNtX编|腥艺术
    www.pdf365.com
402
第1 7章可移植性：软件可移植性与遵循标准
17.2.3开源世界的Unix标准
    在1990年代中期，开源社区开始了自己的标准化努力。这些努力建立在由POSIX
及其继承标准确保的源码级兼容性之上。特别是Linux，它从头到尾都是按POSIX之类
类Unix API标准编写的。6
    在1998年，Oracle把领先市场的数据库产品移植到了Linux上，这场运动正是Linux
被大型机所接受的一次重大突破。在被记者问及Oracle必须战胜的困难是什么的时候，
负责移植的工程师的回应很有说服力：API标准工作完成得相当出色。他回答：  “我们
键入‘make'。
    由此看来，新学派Unix的问题并不是在源码层次上API的兼容性。每个人都理所当
然地认为在不同的Linux、BSD和专有Unix发布之间移植源码是轻而易举的。新问题不
是源码而是二进制的兼容性。因为由于商业PC机硬件的胜利，Unix的底层基础已经发
生了微妙的变化。
    在旧时代，每种Unix都运行在实际上属于它自己的硬件平台上。存在许多种类的处
理器指令集和机器体系，所以应用程序若要移植就必须在源码层次上完成。另一方面，
又只有极少数几个Unix的重要版本，相对来说其有较长的生命期。而诸如Oracle之类的
应用程序提供商能够为三到四个硬件／软件组合分别编译和提供独立的二进制发布版本，
因为他们可以通过大量的使用人群和较长的产品生命期来摊低源码移植的成本。
    但是后来小型机和工作站商家淹没在了基于386廉价的个人机中，而开源Unix改变
了规则。商家发现再也不能找到一个稳定的平台来发售它们的二进制程序。
    首先，表面的问题是，大量的Unix发布者——随着Linux发布市场的统一，越来越
清楚真正的问题是时间变化率。API是稳定的，但是系统管理文件的预期位置、实用程
序以及用户邮箱名和日志文件的前缀路径等常常发生变化。
    首次标准化努力是新学派Linux和BSD社区自身中发展出来（始于1993）的文件系
统层次标准（Fijesystem Hierarchy Standard，FHS）。此标准被集成到Linux标准基础（Linux
Standards Base，LSB）中，它标准化了一套预期的服务库和辅助应用程序库。两个标准
6进一步讨论请参考《Just for Fun》（玩玩而已）[Torvalds]。
www.pdf365.com
17.3 IETF和RFC标准化过程
403
都成为了自由标准组织（Free Standards Group） <http:/／www．freestandards．
org/>的行为，到2001年，该组织已经扮演了在旧学派Unix商家中X/Open的角色。
17.3  IETF和RFC标准化过程
    当Unix社区同互联网T程师文化相结合时，也继承了从互联网工程任务组（Intemet
Engineering Task Force，IETF） RFC标准化过程中形成的思维方式。在IETF传统中，标
准必须来自于一个可用原型实现的经验——但是一旦成为标准，同标准不一致的代码就
被认定是不合规范的，必须无情地抛弃。
    不幸地是，这并不是标准通常发展的方式。计算机历史充满了许多这样的例子，技
术标准是别有企图研究的最糟糕特征与黑暗密室政治结合的产物——这样产生的规格说
明在任何曾经的实现中都找不到踪影。更糟糕的是，许多规范不是严苛得无法实际实现，
就是说明不够充分，解决的问题远不如产生的困惑多。这些规范随之被塞给软件商，它
们如果发现什么地方不易实现，就忽略掉标准。
    标准无用最臭名昭著的例子就是，1980年代同TCP/IP竞争的开放系统互联（Open
Systems  Interconnect）扔议——它的七层模型乍看很优雅，但在实际中却被证明是过度复
杂而不可实现的7。视频显示终端功能的ANSI X3.64标准是另～个恐怖故事：同标准保
持一致的实现版本之间居然存在微妙的不兼容性，真是该死。即使在字符阵列终端大部
分被位图显示终端所替代以后，这些也还是问题（特别地，这就是为什么xterm （1）中
功能和热键偶尔会失效的原因）。串行通讯的RS232标准也是说明不够充分，有时候似
乎没有两个串行线是相似的。关于标准类似的恐怖故事真是可以写一本厚厚的书。
    IETF的哲学已经被概括为著名的“我们反对国王、总统和投票。我们信任大致的共
识和可运行代码”8。首先，要求可工作实现将使其免于最糟的莽撞行为。实际上，它的
规范更严格：
7网络搜索可以找到一个流行的幽默帖子，将OSI七层模型和七层玉米卷比较一一前者还处于劣势。
8这句最初是由IETF的高级干事Dave Clark在混乱的1992年会议上，IETF拒绝OSI协议时所说的。
UNIX编睡！艺I术
  www.pdf365.com
404
第17章可移植性：软件可移植性与遵循标准
    （任何）候选规范在被采用为互联网标准之前，必须得到实现，对操作的正确性
    以及众多独立方的互操作性必须得到测试，以及必须已经使用在要求越来越高的
    环境中。
    互联网标准过程一一修订稿3（ RFC 2026）
    所有的IETF标准都要经过RFC（请求评注）的阶段。RFC的提议过程故意地设置
为非正式的。RFC可以提出标准、调查结果、建议后续RFC的哲学基础，或者甚至是玩
笑。每年4月1日愚人节RFC年鉴的出现就是互联网玩家中最盛大的庆祝仪式，并且产生
许多如宝石般的精华标准，例如Transmission of IP Datagrams on Avian Carriers （IP数据报
的信鸽传递，RFC 1149）9、Hyper Text Coffee Pot Control Protocol（超文本咖啡壶控制协议，
RFC 2324）10、Security Flag in the IPv4 Header （IPv4包头的安全标志位，RFC 3514）。11
    但是搞笑RFC大概是唯一能够立即成为RFC的提议。严肃的提议实际上以“互联
网草案（lntemet-Drafts）"开始，通过IETF在／L个著名主机上的目泵让公众评注。没有
正式身份的互联网草案个体，其提出者在任何时候都可以改动或终止。如果他们既不撤
销也不提升到RFC状态，在六个月后草案将被移除。
    互联网草案并不是规范，而软件实现者和软件商被特别禁止宣称符合某条草案，并
将其按规范对待。互联网草案通常是在一个由电子邮件列表联系在一起的工作组讨论的
焦点。当工作组领导认为适合的话，就把互联网草案提交给RFC编辑，从而被分配～个
RFC号码。
    一旦互联网草案作为一个带编号的RFC发布，就成为其实现者可以宣称与之相符的
规格。接下来，RFC的作者和社区将开始以实际实验来更正规格说明。
    ～些RFC就到此为止了。一个未能吸引用户和经受现场测试的规格可能被默默遗忘
了，而且最后被RFC编辑标记为“Not recommended（不推荐）”或“Superseded（被取代）”。
失败的提议通常认为是进程的日常开销，相关的提议不会因此打上耻辱的印记。
9 RFC 1149见网页<http：／／www. ietf .orgirfc/rfc1149．txt>。不仅如此，其实现参见
<ht tp:  //www. blug. linux. no/rfc114 9 /wri t eup. html>.
10 RFC 2324兄网页<http：／/www.ietf.org/rfc/rfc2324.txt>。
‘1 RFC 3514见网页<http：／／www.ietf.org/rfc/rfc3514.txt>。
www.pdf365.com
17.4  规格DNA，¨油马RNA
405
    IETF的指导委员会（IESG，或者Internet Engineering Steering Group）负责将成功的
RFC推向标准之路。他们将合格的RFC标明为“Proposed Standard（提倡标准）"。对
于具备提倡标准资格的RFC，其规格必须稳定，经过同行评审，并且已经吸引了互联网
社区的极大兴趣。当然，一个RFC成为提倡标准，并不绝对要求存在实现，如果有则最
好不过；如果RFC改变或可能动摇互联网核心协议，IESG则有权要求RFC提供实现。
    提倡标准仍可能被修订，如果IESG和IETF确实有更好的解决方案，甚至还会被撤
消。它们并不推荐在“崩溃敏感环境”中使用——不要将他们使用在空中交通控制系统
或是需要精心照料的设备上。
    对于提倡标准，如果至少存在两个可工作的、完备的、独立发展出来的、可互用的
实现，就能够由IESG提升到“草案标准”状态。如RFC2005所说：  “提升到草案标准
阶段是个重要的进步，表明有充分理由相信规格是成熟而有用的。”
    一旦RFC达到了草案标准状态，就只能更改规格说明中的逻辑错误。草案标准可随
时被部署使用在崩溃敏感环境中。
    当草案标准经道了实现的广泛测试并且达到了普遍接受的程度，就可以成为一个互
联网标准（Internet Standard）。互联网标准保留自身的RFC编号，也可以申请一个STD
序列号。在本书写作时，虽然有3000多个RFC，但仅仅只有60个STD。
    尚未成为标准的RFC被标记为Experimental（实验性）、Informational（资料性）（搞
笑RFC就被赋予该标记），或者Historic（历史性）。历史性的标记被用于过时标准。RFC
2026注释为：  “（完美主义者建议这个词应该是“Historical（历史上的）”；但是，在这
一点上，  “历史性”一词的使用是历史上的原因。）
    IETF标准化过程有意提倡由实践而非理论驱动的标准化过程，并确保标准协议都经
受过严格的同行评审和测试。这种模式的成功结果显而易见——全世界的互联网。
17.4  规格DNA，代码RNA
    甚至在PDP-7的旧石器时代，Unix程序员就比其他业界同行更倾向于认为代码是可
弃的。这无疑是Unix传统注重模块性的产物，使其更容易在无损失的情况下抛弃和更换
UN/X编翟Yae
    www.pdf365.com
第17章可移植性：软件可移植性与遵循标准
系统的各个子部分。Unix程序员已经从经验中认识到补救糟糕的代码或设计比起重新开
始常常更费时费事。在其它编程文化中，被迫弥补大型单个程序是种本能的反应，因为
从头再来需要太多太多的工作，而在Unix文化则主张干脆拆毁重来。
    IETF传统反复教导我们将代码作为标准的从属物来思考。正是标准让程序可以协
作，将各项技术结合起来成为比部分之和更大的整体。IETF向我们展示了，精细的标准
化过程，瞄准获得最好的实践，其实是种强有力的形式，相比于无法实现的完美理想的
信誓旦旦来说，能够获得更大的成功。
    1980年后，Unix社区越发受到这个教训的影响。从1989年以来的ANSI/ISO C标准
虽并非毫无瑕疵，但考虑到其长度和重要性，它的确异常简洁和实用。单- Unix规范在
更广泛的领域中包含三十年来的实验和改进，比ANSI C更为凌乱。但是标准的组成相
当良好。一个强有力的证明就是，Linus Torvalds通过它而成功从头开始编制了一个Unix。
IETF强大的示范给Linus Torvalds的壮举创造了一个关键背景，并使其成为可能。
    尊重已颁布标准和IETF过程已经在Unix丈化中根深蒂固；故意违反Internet STD
就是不妥当的。这一点有时候往往会造成Unix背景的技术人员同其它技术人员之间相互
不理解，其它技术人员往往设想最流行或最广泛配置的协议实现就是定义上的正确——
即使定义严重地违反标准而不能与完全符合标准的软件进行协作。
    Unix程序员可能大力反对其它种类的前规格说明，他们对已颁布标准的尊敬显得很
有趣。当“瀑布模型”（首先详尽说明，然后实现，然后调试，在任何阶段都没有反向
动作）在软件工程学中失宠时，在Unix程序员中成为笑柄其实已经好几年了。经验以及
合作开发的浓厚传统，已经训练了Unix程序员，先原型然后循环不断地测试和演进才是
更好的方法。
    Unix传统清楚地意识到良好的规格说明具有巨大的价值，但是需要像“互联网草案，，
和“提议标准”的方式那样，被视作是暂时的、需要订正的对象，必须通过在现场实验
中的不断改进。在最好的Unix实践中，程序的文档就近似于规范主体的“提议标准”，
需要不断修改订正。
www.pdf365.com
17.4  规格DNA，代码RNA
407
    与其它环境不同，在Unix开发中，文档常常在程序之前，或者至少同程序一
起编写。对于X11，X核心标准在X第一版发布之前完成，并且自从那时起基本
上就没有改动过。不同X系统间的兼容性更进一步地被严格的规格驱动测试所改
善。
    有了良好编写的规格说明，开发X测试套件便更加容易。在X规格说明中的
每一项声明都转换成代码来测试其实现，在这个过程中发现了几个次要的、跟规
格不一致的地方，其最终结果就成为了一个测试套件，覆盖了X实例库和服务器
中重要的代码路径，并且不引用实现源码。
    -Keith Packard
    生成半自动化的测试套件被证实为～个主要优势。尽管图形艺术的现场实验和发展
导致对X设计基础的许多批判，尽管X的某些部分（例如安全和用户资源模型）似乎笨
拙而实现过度复杂，但X在稳定性和跨系统发布的互用性方面达到了非同一般的良好水
平。
    在第9章我们讨论了将编码尽量往上推以最小化常数缺陷密度效应。Keith Packard
含蓄地说明X文档并不仅是期望功能列表，而是以高级代码形式来表述。另外一个X的
关键开发者证实了这一点：
    在X中，规格说明就是一切。有时规格存在缺陷需要修正，但是代码通常此
  规格说明具备更多的bug（对任何值得着墨的规格说明）。
—■im Gettys
    Jim继续阐明X的过程实际很像IETF过程。它的功用并不是仅仅局限于构建优良的
测试套件；它也意味着相关的系统行为争论可以在关于规格的功能层面解决，避免了太
多实现问题的纠缠。
    以考虑周全的规格说明来驱动开发可能会引起“bug还是功能”的小小争论；
但没有正确实现规格说明的系统就是破损不全的，必须得到修正。
我怀疑这在我们当中是如此的根深蒂固，有时反而忽略了它的威力。
www.pdf365.com
408
第1 7章可移植性：软件可移植性与遵循标准
    一个在Bellevue以东一家小公司工作的朋友奇怪，Linux应用程序开发者为
什么可以随着应用程序发布版本同步地进行OS改动。在那个公司里，主要的系
统级API频繁改动以容纳一些古怪念头，所以基本的OS功能必须常常随着每个
应用程序一起发布。
    我向他描述了规格说明所具有的威力以及实现应当如何遵从规格，然后接着
断言，如果一个应用程序按接口文档得到一个非预期的结果，那么不是违反了规
格，就是发现了bug。他认为这个观念非常令人吃惊。
    分辨这类bug再简单不过了，只要检查接口实现是否违反了规格。当然，如
果有实现的源码会更简单。
    -Keith Packard
    这种标准先行的态度对于最终用户同样有益。Bellevue以东的那个小公司变大了，
它难以兼容以前发行的办公软件，而在1988年为X11编写的GUI应用程序在今天的X
实现中仍然没有改变地运行着。在Unix世界中，这种长寿是很正常的——这也就是为什
么将标准视作DNA的原因。
    经验表明，遵从标准、喜欢抛弃重建的Unix文化，虽然花费额外时间，但相比于因
为没有标准提供指导和连续性，而必须不停地对代码基础库缝缝补补，往往熊够产生更
好的互用性。这真的或许是Unix最重要的教益。
    Keith最后的评注直接引出一个问题，也是随开源Unix的成功而提到前台的问题
—二开放标准和开放源码间的关系。我们将在本章末尾讨论这个问题——但在这之前，
是讨论Unix程序员如何能够使用大量的标准和知识来获得软件可移植性的实践问题的
时候了。
17.5可移植性编程
    软件可移植性通常是准空间问题：代码可以从其诞生的环境移到别的硬件和软件平
台吗？但是几十年的Unix经验告诉我们时间上的持久性同样重要，甚至更重要。软件的
未来如果可以详细地预测，最好现在就来预测——然而，在可移植性编程中，我们应该
www.pdf365.com
17.5可移植性编程
409
尝试考虑选定最可能持续的软件环境特征作为构建软件的基础，同时要避免不久的将来
就可能消亡的技术。
    Unix二十年对详述可移植性API问题的关注，在很大程度上解决了这个问题。在单
- Unix规范中描述的功能今天几乎仍然存在于现代的Unix平台中，将来也不会不支持。
    但并不是所有的平台依赖性都同系统和库函数API相关。实现语言也有关系；源系
统和目标系统之间文件系统设计和配置的不同也是个问题。还好，Unix实践已经发展出
解决方法。
17.5.1  可移植性和编程语言选择
    可移植性编程的首要问题是实现语言的选择。所有我们在第14章讨论过的主要编程
语言，从在全部现代Unix上都有兼容实现的角度来说，均具有较高的可移植性；而大多
数在Windows和MacOS下也有实现。在这里，可移植性问题往往并不在于核心的编程
语言，而在于支持库以及同本地环境整合的程度（尤其是IPC、并发进程管理以及GUI
的基础设施）。
17.5.1.1  C的可移植性
    C语言核心的可移植性非常高。标准的unix实现是GNU C编译器，它在开源Unix
和现代专有Unix中普遍存在。GNU C也已经移植到了Windows和古典的MacOS申，
但在那里使用并不普遍，因为缺少对本地GUI的可移植接口。
    标准输入／输出库、数学例程以及国际化支持都可以移植到所有的C实现中。如果小
心谨慎地只使用在“单- Unix规范”中描述的现代API，文件1/0、信号、进程控制也
可以移植到各个Unix;老一些的C代码常常需要经过条件预处理宏才能移植，但使用
POSIX之前接口的代码往往来自于古老专有的Unix，而且在2003年这些Unix如果不是
已经废弃就是接近废弃了。
    对于IPC、线程以及GUI接口，C的可移植性问题开始有些严重了。我们在第7章
已经讨论过IPC和线程的移植问题。真正实际中的问题是GUI工具包。许多开源的GUI
工具包可跨越各种现代Unix使用，还被移植到了Windows和传统的MacOS中-Tk、
wxWindows、GTK和Qt是其中四个最著名的，可以通过网络搜索得到的源码和文档。
但是它们中没有一个随所有平台一起发布，而且（更多的是法律而不是技术因素）没有
UNIX编惺艺术
  www.pdf365.com
410
第17章可移植性：软件可移植性与遵循标准
一个能够提供所有平台原汁原味的GUI观感。我们已在第15章给出了处理这个问题的
指导原则。
    已经有大批关于如何编写可移植性C代码的书了，本书并不想成为其中的一本。我
们推荐阅读Recommended C Style and Coding Standards（C的推荐风格和编码标
准）[Cannon]以及《The Practice of Programming（程序设计实践）》[Kemighan-Pike99]）中关
于可移植性的相关章节。
17.5.1.2 C++的可移植性
    在操作系统层次上，所有C语言的移植性问题C++都有，当然也存在一些自身的问
题。其中一个增加的问题是开源的C++编译器已经落后于专有的实现；这样，在2003年
年中，仍然没有一个统一的像GNU C-样能够成为事实标准的基础。更进一步，仍然没
有一款C++编译器完全实现了C++99 ISO语言标准，尽管GNU C++是最接近的一个。
17.5.1.3 Shell的可移植性
    很不幸，shell脚本的可移植性非常糟。问题不在shell本身．bash（1）（开源的Bourne
Again shell）已经普遍存在，所以纯shell卿本几乎可以到处运行。问题是大多数的shell
脚本大量使用了其它可移植性差的命令和过滤器，而且绝不保证在任意指定的机器上它
们都存在。
    这个问题可以借助一些额外的工作来克服，比如autoconf （l）工具。但是这个问题
很严重，所以大多数在shell中稍重量级的编程都转移到诸如Perl、Python、Tcl等第二代
脚本语言中完成。
    Perl的可移植性良好。Perl的核心版本甚至提供一套支持跨Unix、MacOS和Windows
平台GUI的rk工具包接口。然而也有个问题很讨厌。Perl脚本常常要求来自CPAN
（ Comprehensive Perl Archive Network）的插件库，无法保证它在每个Perl实现中都存在。
17.5.1.5  Python的可移植性
    Python可移植性极其出色。如同Perl -样，Python的主干版本甚至提供一个Tk包
的可移植接口，可支持Unix、MacOS和Windows的GUI。
www.pdf365.com
4l l
    Python主干版本存在比Perl更丰富的标准函数库，但是没有等价于Perl程序员可以
依靠的CPAN;重要的扩展模块常常随主干Python的次要版本的发布一起发布。这是以
牺牲空间来换取时间，使得Python更少成为模块丢失效应的对象，代价是Python的次版
本号要比Perl发布的版本级别重要得多。在实践中，权衡似乎对Python更为有利。
17.5.1，6 Tcl的可移植性
    Tcl的可移植性总的来说不错，但是随着项目复杂度的不同而有极大差异。为跨平台
GUI编程而生的Tk包原生于Tcl。同Python -样，语言核心的发展相对顺利，很少存在
版本不兼容问题。但不幸的是，Tcl甚至比Perl更依赖那些并不能保证随着每个实现一
起发布的扩展功能——也没有像CPAN -样的地方来集中发布这些扩展功能。
    因此，对于不依赖扩展的小项目，Tcl的移植性相当高。但是大项目往往大量依赖扩
展，和（同shell编程一样）调用在目标机器可能存在也可能不存在的外部命令；这些东
西的移植性相当糟。
    具有讽刺意味地，Tcl也许吃够了容易增加扩展的苦头。当一个特殊的扩展开始引人
注目，似乎可以成为标准发布中的一个部分时，一般都已经夺在好几个不同的版本了。
在1995年的Tcl/Tk学术研讨会上，John Ousterhout对为什么没有在标准Tcl发布中加入
00支持而解释道：
    想想五位大学者围坐一圈，一起叫着“杀死他，异教徒”。如果我把某个特
  殊的oo设计加入到内核中，其中一个就会说“祝福你，我的孩子，吻我的戒指
  吧j”，而另外四个则说“杀死他，异教徒”
    语言设计者并不一定愉快。
17.5.1.7 Java的可移植性
    Java的可移植性特别出色——毕竟，它是以“一次编写，到处运行”作为主要设计
目标的。然而，可移植性仍非尽善尽美。麻烦主要是JDK l.1及老AWT GUI工具包（一
方面）和JDK l.2及新Swing GUI包之间的版本兼容问题。这有几个重要的原因：
●  Sun的AWT设计不完善，不得不用Swing来代替。
UNIX编程艺术
  www.pdf365.com
412
第1 7章可移植性：软件可移植性与遵循标准
    ●  微软拒绝在Windows中支持Java开发并试图以C#来取代Java。
    ●  微软决定继续保留IE中对JDK I.I版的小应用程序的支持。
    ●  Sun许可证授权让JDK l.2的开源实现完全小可能，这延缓了它的部署进程（特
    别是在Linux世界）。
    对于涉及GUI的程序，追求移植性的Java开发者在可预知的未来，时常面临一个选
择：采用糟糕设计的JDK l.1/AWT工具包取得最大可移植性（包括移植到Microsoft
Windows），或者采用更好的工具包和JDKl.2功能而牺牲部分可移植性。
    最后，正如我们前面注意到的一样，Java对线程的支持也存在移植性问题。Java API，
不像其它抱负较小语言的操作系统接口，它勇敢地去尝试弥补不同操作系统提供的不同
进程模型之间的差异：但还没有掌握诀窍。
17.5.1.8  Emacs Lisp的可移植性
    Emacs Lisp的可移植性相当好。Emacs安装往往频繁地升级，而严重的过时失效情
况很少出现。相同的Lisp扩展到处都被支持，而所有的扩展都随Emacs本身一起发布。
    而且，Emacs的原语集相当稳定。几年前就获得了一个编辑器应有昀完备性（缓冲
区处理，shell脚本支持）。仅仅只是X的引入损害了这个优点，并且需要感知X的Emacs
模式也非常少。可移植性问题通常表现在操作系统功能C层次接口上的格格不入；例如，
邮件代理模式的从属进程控制大概是唯一这种表征经常出现的地方。
17.5，2避免系统依赖性
    一旦选定开发语言和支持库，下～个可移植性问题通常就是系统关键文件和目录的
放置：邮件池同志文件目录等等。这类问题的原型一般就是邮件池目录到底是
/var/ spool/mail还是/var/mail。
    通常可以通过退一步重新架构这个问题来避免此类依赖性。为什么要打开邮件缓冲
目录下的文件？如果需要写入，简单地触发本地邮件传输代理，来完成以获得正确的文
件锁定不是更好吗？如果需要读入，通过POP3或IMAP服务器查询不是更好吗？
www.pdf365.com
17.6国际化
413
    同类的问题在别处同样适用。如果发现需要手动打开日志文件，为什么不使用
syslog（3）代替？通过C库函数调用的接口比起系统文件定位容易标准化得多。应当利用
这个事实！
    如果必须在代码中使用系统文件定位，最好的选择取决于是发布源码还是采用二进
制形式。如果发布的是源码，我们在下个部分讨论的autoconf工具能够提供很好的帮助。
如果发布的是_进制形式，良好的实践是在程序运行期试探是否可以自动地适应本地条
件——例如，实地检查／var／rnail和／var/spool/rnail是否存在。
17.5.3移植工具
    通常可以使用我们在第15章介绍的开源GNU autoconf（1）来处理移植性问题，进
行系统配置探查，定制出makefile文件。如今，从事源码编译软件的人们往往希望能够
键入  configure;make;make  install  来干净利落地编译。  在
<http：／/seul．org／docs／autotut／>处有这些工具的优秀指导手册。即使是发布二
进制码，autoconf（1）工具也能够帮助自动化处理针对不同平台的条件代码问题。
    其它解决这个问题的工具中，其中两个较为知名的是与X window泵统相关的
Imake（l），以及由Larry Wall（后来的Perl语言发明者）编制的Configure工具，也被许
多项目采用。所有的工具至少都跟autoconf套件一样复杂，使用也不如以往频繁。它们
无法覆盖众多的目标系统。
1 7。6  国际化
    软件代码的国际化设计使得接口容易适应多种语言和各种字符集，对于这方面的深
入讨论超HJJ了本书的范围。然而，在Unix经验中有一些良好实践的突出事例。
    首先，分离信息库和代码。良好的Unix实践应把程序使用的消息字符串同程序代码
分离开来，这样不用修改代码就可以增加其它语言的消息字典。
    完成此项工作最知名的工具就是GNU的g已ttext，这个工具要求把需要进行国际化的
原生语言字符串包装在一个特殊的宏中。该宏使用各个字符串作为各文件提供的各种语
UNIX编腥艺_术
    www.pdf365.com
414
第1 7章可移植性：软件可移植性与遵循标准
言字典主键。如果某种语言的字典不可访问（或者存在该字典但查询没有匹配返回），
那么宏就简单地返回其参数，也就是隐式地退回到代码的本地语言。
    尽管在2003年中期，gettext本身一团乱麻，但其总体指导思想却是可靠的。对于许
多项目，使用这种思想可以手工打造出这种国际化设想的轻量级版本，并收到良好的效
果。
    其次，在现代Unix中有种清晰的潮流：抛弃所有历史上与多字符集相关的记法而让
应用程序原生地使用UTF8，八位移位Unicode编码字符集（或者相反地说，让他们原生
地使用1 6位宽字符）。UTF-8的前128个字符就是ASCII，前256个字符是Latin-I，这
就意味着它向后兼容使用得最广泛的两个字符集。XML和Java事实上促进了这种选择，
但是即使没有XML和Java，趋势也会如此。
    第三，使用正则表达式时，当心字符的范围。【a—z】元素并不必然包含所有的小写
字母，如果脚本或是程序应用于（比如说）德语，B被认为是小写字母但并没有包含在
上述范围之内；法语中的重音字母也存在类似的问题。安全的方式是使用【[．lower：】】，
以及其它在POSIX标准中拙述的符号范围。
17.7可移植性、开放标准以及开放源码
    可移植性需要标准。无论是发布传播一项标准还是敦促专有软件商遵循标准，开放
源码基准实现都是已知最有效的方法。而对于开发者，已颁布标准的开源实现既极大地
减轻了编码负担，也允许产品（有意或意外地）从他人的劳动中获益。
    让我们设想，例如，为数码相机设计一个图像捕捉软件。既然存在（正如我们第5
章所提到的）功能齐全经过良好测试的PNG读写开源库，那为什么要编写自己的格式来
存储图像数据或是购买专有代码呢？
    开放源码的新生（重生）同样给标准化过程带来了重要的影响。尽管并非正式要求，
IETF自从大约1997年前后，愈发抵制连一个开源基准实现都没有的RFC成为预备标准。
将来与某标准是否一致，似乎愈发有可能以“是否同已经得到标准作者们认可的开源实
现相一致（或者完全使用该实现）”来判定。
www.pdf365.com
17.7可移植性、开放标准以及开放源码
415
暗含的意思就是，成为标准的最好办法就是发布一个高质量的开源实现。
-Henry Spencer
    最后，确保代码移植性最有效的一个环节就是不要依赖于专有技术。永远不会知道
所依赖的闭源库／工具／代码生成器或网络协议何时会结束生命，接口何时会以某种非向后
兼容的方式改变，从而崩溃掉已有的项目。而使用开源代码，即使前沿版本的改变方式
足以崩溃已有的项目，也有前行之路；因为可以获取源码，如果需要，就可以向前移植
项目到新的平台。
    直到1990年代晚期，这个建议都还是不切实际的。少数几个代替依赖专有操作系统
和专有开发工具的软件还只是昂贵的实验品、学术上有待证实的观点或者小玩意。但互
联网改变了一切；在2003年中期，Linux和其它开源Unix不但存在，并且已经证明了自
身完全可以是出产高质量生产级软件的平台。现在开发者有了更好的选择，而不是依赖
于为垄断而设计的短期商业决策。实施防御性设计——基于开放源码编程，便不会束手
无策。
UNIX编程艺术
  www.pdf365.com
www.pdf365.com
1 8
文档：向网络世界阐释代码
Documentation: Explainin  Your
Code to a Web-Centric World
    I've never met口human being who would want to read J 7:000 pages of documentation，
    and if there was，，fd kill him to get him out西the gene pool.
我从没见过一个愿意阅读1 7000页文档的人，如果有，我会杀了他，这样人的基因
    必须抹去。
    -Joseph Costelio
    在1971年，Unix的第一个应用，是作为文档整理的平台-Bell实验室用来整理专
利文件以进行归档。那时，计算机驱动的照排还是新颖的想法，但几年后，1973年Joe
Ossana的troff（1）格式器出台，一举决定了这门艺术的地位。
    自那时起，各种复杂精致的文档格式器、排版软件、版面设计程序就已经成为了Unix
传统中的一个重要主题。尽管troff（1）令人吃惊地持久耐用，Unix还是在这个应用领
域中促生了许多其它具有突破意义的软件。现在，由万维网的发明而触发了文档实践的
深远转变，Unix开发者和Unix工具正站在这种转交的前沿。
    在用户表示层，自从上世纪九十年代中期以来，Unix社区的实践已经迅速地朝着“一
切皆HTML，所有引用都是URL”的方向发展。越来越多的现代Unix辅助浏览器完全
可看做解析确定特殊种类URL的网页浏览器（例如，“man:ls（l）”将ls（l） manpage转换
UNIX编腥艺-术
    www.pdf365.com
41 8
第1 8章文档：向网络世界阐释代码
成HTML）。这解决了不少因为主文档格式太多而产生的问题，但并不彻底。文档编辑
器仍然挣扎在哪种主格式最适合需求的权衡中。
    本章，我们将讨论许多种不同的文档格式，以及经受了几十年考验而传承下来的文
档工具，  “太多”意味着“不幸”。当然，我们也会逐步发展出良好实践和风格的指导
准则。
18.1  文档概念
    我们要讨论的第一项区分，就是“所见即所得”（WYSIWYG）的文档程序同以标记
为中心的工具之间的差异。大多数的桌面出版程序和字处理器都属于前者：具备图形用
户界面、键入的文字可以直接插入到文档在屏幕上的表示之中，并尽可能地接近最终的
打印版本。在以标记为中心的系统中，相对应地，主文本通常就是包含明确可见控制标
记的纯文本，跟期望的输出完全不同。标记的源文件可以由普通的文本编辑器修改，但
必须传入某个格式器程序来渲染输出以供打印或显示。
    界面可视的、WYSIWYG的风格对于早期的计算机硬件来说太昂贵了，直到1984年
Macintosh个人机问世前一直都很稀有。在当今非Unix的操作系统中，WYSIWYG的风格
完全占据了统治地位；而另一方面，Unix的原生文档工具，几乎都是以栎记为中心的。1971
年的Unix troff （1）就是个标记格式器，而且很可能是现在仍在使用的程序中最古老的一
个。
    以标记为中心的工具依然扮演着重要角色，因为实际上，WYSIWYG风格的实现往
往在很多情况下工作得并不好——有些是表面的，有些是深层次的。我们在第11章讨论
过GUI的一般问题，WYSIWYG的文档处理器也不可避免；任何事的结果都能看得到，
就意味着任何事都得看着做。所以，即使在屏幕和打印输出达到一致了，这个问题依然
存在——何况这两者从来没一致过。
    实话实说，WYSIWYG的文档处理器并不真正所见即所得。大多数程序的界面，并
没有真正消除屏幕显示和打印输出的差异，只是让你看不出来而已。这样做其实违反了
最小立异原则：界面的可视部分鼓励将程序作为打字机使用，但实际上并不能这么用，
而你的输入又时不时地产生无法预料或是非期望的结果。
    再实事求是点，WYSIWYG系统实际依赖的是标记码，只不过额外支付了巨大的努
力以期将此隐藏在一般使用中。这又违反了透明原则：因为无法了解所有的标记，就难
以标记位置错误的损坏文档。
www.pdf365.com
419
    尽管存在这些问题，但如果仅仅只是想把一张图片往右拖三个字宽，把它放到～
个四页小册子的封皮上，WYSIWYG的文档处理器可以干得非常漂亮。然而一旦需要
对三百页手稿的版面设计做出整体更改，便会有巨大的不便。WYSIWYG的用户面对
此类的挑战必须放弃，或是忍受要命的千百次鼠标点击的痛苦；在这样的情形中，编
辑明确标记的能力是无可替代的；此时，以标记为中心的Unix文档工具提供了更佳的
解决方案。
    今天，当全世界都受到了万维网和XML的影响，把表现方式和结构标记在文档中
区别开是再正常不过的了——前者是关于文档外观的指令，而后者是关于文档如何组织、
有何用意的指令。这种差异在早期的Unix工具中并没有得到清晰的理解和遵从，但是理
解这种设计差异非常重要，正是它导致了那些工具发展为如今的继承者。
    表现级标记在文档本身中携带所有的格式信息（例如希望的空白布局和字体变化）。
而在～个结构标记系统中，文档必须和～个样式单相结合，它告知格式器如何将文档中
的结构标记转换为物理的版面布置。最后两种标记一起控制打印和浏览文档的物理外观，
但是，如果希望既能为打印又能为网页生成良好的输出结构，结构标记有必要通过一个
更高级剐的间接层完成。
    大多数以标记为中心的文档系统都支持宏。宏是用户定义的命令，可以由文本替换
来扩展成内嵌的标记请求序列。通常，这些宏为标记语言增加了结构特征（例如声明小
节标题的能力）。
    troff宏集合（mm、me和我的ms包）实际上是设计来将人们从面向格式的
编辑推动到面向内容的编辑。这种思想就是将语义部分进行分类标记，以各种风
格包来确定在这种样式中标题是否应该大写或者居中等等。这样，一套宏可以尝
试模仿ACM刊物的风格，而另一套使用基本-ms标记的宏则模仿Physical Review
（物理评论）刊物的风格。然而对于既要集中精力构建文档内容，又要注意控制
外观，所有的宏都不好使，就如同网页陷入到底是读者还是作者应该控制外观的
争吵一样。我常常发现那些秘书仅仅为了产生斜体而使用.AU（作者名）命令，
因为发现它能产生斜体，该命令的附加效应将使他们无比烦恼。
-Mike Lesk
最后，我们注意到对于小文档（商务和私人信函、小册子以及时事通讯）和大文档
UN/X编腥艺l术
  www.pdf365.com
420
第1 8章文档：向网络世界阐释代码
（书籍、长文、技术论文以及手册）之间，作者所期望处理的事情存在重要差异。大文
档往往需要更多的结构，需要一部分一部分地结合在一起，而又能够单独改动，同时需
要一些自动生成功能，例如内容的目录；这些特点都倾向于以标记为中心的工具。
18.2 Unix风格
    Unix风格的文档（以及文档工具）具备几个技术和文化特征，使之有别于其它地方
的实现。首先熟悉这些鲜明的特征，便能够打下良好的背景基础，从而理解为何文档有
那样的实际外观，为何文档有那样的阅读方式。
18.2.1  大文档偏爱
    一直以来，Unix文档工具主要是为应对创作庞大复杂文档的挑战而设计的。最初
是专利申请和文书工作；后来是科技论文，以及各式各样的技术文档。结果，大多数
Unix开发者渐渐喜欢上了以标记为中心的文档工具。与时下的PC用户不同，尽管在
1980～1990年代早期，WYSIWYG的字处理器非常普遍，但在Unix文化中并没有留下
什么印记——即使在今天，年轻一辈的Unix玩家中，也很少发现有谁真正地喜欢那种
工具。
    对不透明二进制文档格式的厌烦情绪—～尤其是不透明的专有二进制格式——也在
拒绝WYSIWYG工具的过程申起到了一定作用。另一方面，PostScript（图像打印机的现
行控制语言标准）刚可以使用，Unix程序员就投入了极大的热情；这门语言整洁优美地
符合Unix传统的域专用语言。现代的开源Unix系统都有优秀的PostScript和可移植文档
格式（ Portable Document Format，PDF）工具。
    另一个历史结果就是，Unix的文档工具对于包含图像的支持往往相对较弱，但
是对图表、图形和数学方面排版的支持却很强——这些都是在技术论文中常常需要用
到的。
    Unix对于以标记为中心系统的依恋常常被讽刺为一种偏见或是顽固的特性，但是实
际上并不真的女日此。同Unix被公认为“原始”的CII风格在许多地方比GUI更能适应高
www.pdf365.com
18.2 Unix风格
421
级用户的需要一样，诸如troff（1）等以标记为中心设计的工具，比起WYSIWYG的程
序更能适应高级文档管理者的需要。
    偏爱大文档并不仅仅让Unix开发者继续对诸如troff程序等以标记为核心的格式器
保有依恋，也激发了对结构标记的兴趣。Unix文档工具的历史，是一场步履蹒跚、充满
困惑、左右摇摆的运动，虽然总方向是从表现性标记转到结构性标记。在2003年年中，
这个旅行仍未结束，但放眼放去，终点已不远。
    万维网的发展意味着在大概1993年以后，文档工具面临的主要挑战是提高描绘多媒
体文档（或者，至少是为了打印和HTML显示）的能力。同时，即使是普通的用户，在
HTML的影响下，也变得更加适应以标记语言为中心的系统。这直接导致了在结构性标
记上浓厚兴趣的爆发以及1996年后XML的发明。突然间，1日时代Unix对以标记为核
心系统的依恋开始变得不再是反动，而是具有先见之明的了。
    如今，在2003年年中，多数基于XML使用结构性标记文档工具的前沿开发正在
Unix下进行。但是同时，Unix文化并没有放弃古老的表现级标记系统的传统。HTML和
XML只在部分场合取代了嘎吱嘎吱作响的、穿若笨重铠甲大恐龙般的troff。
18.2.2文化风格
    绝大多数软件的文档都是由技术人员写给可能连最小公分母都不知道的普通大众的
——渊博者写给无知者。但是同Unix系统一起发布的文档传统地是由程序员写给程序员
的。即使不是写给同行的，但在风格和格式上，也往往受到大量同Unix系统一起发布的、
程序员写给程序员的文档所影响。
    这种思想产生的差异可以用一个观察来总结：Unix手册页传统上也包含一个叫做
BUGS的部分。在其它地方，技术作者为了让软件产品看起来更漂亮，常常省略或一笔
带过那些已知的bug o而在Unix文化中，同行彼此互相事无巨细地揭露软件的已知缺陷，
而用户也认为一个简单但详细的BUGS部分是高质量软件的表征。隐瞒了BUGS部分，
或是改头换面为诸如LIMITATIONS或ISSUES或APPLICATION USAGE等轻描淡写词
语、从而打破这个约定的商业Unix发布版本，无一例外地走上了不归之路。
    多数其它软件的文档往往总是在高深莫测和过度简化间摇摆，而经典的Unix文档则
简洁而完善。虽然并非手拿把教，但通常指明了正确的方向。这种风格设想的读者积极
UNIX编程艺．术
    www.pdf365.com
422
第1 8章文档：向网络世界阐释代码
而进取，愿意并能够举一反三。
    Unix程序员往往擅长于编写参考书籍，而大多数Unix文档也带点参考书籍或辅助
备忘录的味道，这是为那些能够象文档作者一样思考但对软件还称不上专家的人编写的。
答案看起来常常比实际上的隐秘和匮乏得多。然而，仔细逐字逐句地阅读，因为想知道
的一切就在那里，或者可以从那里推导。仔细逐字逐句地阅读，因为话很少会说两遍。
18.3各种Unix文档格式
    所有主要的Unix文档格式，除了最近的，都具有宏扩展包支持的表现级标记。我们
将按照从老到新的时间顺序讨论。
18.3.1    troff fo Documenter*s Workbench Tools
    在第8章，作为如何整合一个多微型语言系统的实例，我们讨论过Documenter's
Workbench的体系和工具。现在，我们转过来讨论这些工具用作排版系统的角色。
    troff格式器可看作是一个表示层的标记语言。最近的实现版本，诸如GNU项目groff
（1）之类，默认情况下生成PostScript输出，当然也可以通过选择适当的驱动来得到其
它格式的输出。参看实例18.1，是几行可能会在文档源文件中碰到的troff代玛。
例18.1  groff （1）标记实例
This is riinning text.//这是运行文本
．＼”Conunents begin with a backslash and doulole quota.//注解以反斜扛加双引号开始。
．ft B
This text will be in bold font.／／这里的文本字体为粗体。
．ftR
This text will be back in the default  （Roman）  font．／／这里的文本又回到默认的（Roman）
字体
These lines， going back to 'fThis is running text"， will
be formatted as a filled paragraph.//这几行，回溯到“This is running text”被格
式化为…‘个加载段。
．bp
The bp request forces a new page and a paragraph break.//bp请求生成新页结束段落。
This line will be part of the second filled paragraph.  ／／这一行属于第二加载段的
部分。
.sp 3
The .sp request emits the number。f blank lines given as argument//sp谙求生成
给定参数数量的空行。
www.pdf365.com
18.3各种Unix文档格式
423
．nf
The nf request switches off paragraph filling.//nf请求取消段落加载。
Until Lhe fi request switches it back on  ／／直到fi请求切换回来
whitespace and layout will be preserved.  ／／空白和版面继续保留
One word in this line will be in \fBbold\fR font.//该行的一个字将是＼fBbold\ fR
字体。
．fi
Paragraph filling is back on.//切换回段落加载。
troffl1）有很多其它的请求命令集，但是人们通常都不会去直接阅读它们。几乎没有
文档直接用troff编写。troff支持宏，通常都使用五六个宏命令包。在这些当中，压倒性
最普遍的是man（7）宏命令包，用来编写Unix手册页。例18.2作为一个样本供参考。
例18.2 man标记实例
. SH  SAMPLE  SECTION
The SH macro starts a section，  boldfacing  the  section  title. //SH宏标志一个部分
的开始，并使标题的字体为粗体。
.p
The p request starts a new paragraph.  TheIrequest sets its//pj青求开始一个新
的段落，工请求将字体设置为其后指定的参数
argumentln
．工i七alics.／／在该例中为斜体。
．IP  ★
This starts an indented paragraph with an asterisk label.//从此开始一个以星号为
前标的缩进段落。
More text for the first bulleted paragraph.//段落更多的文本，每行以星号为前标。
.TP
This first line will become a paragraph label/／这第一行成为新段落的标记
This will be t-he first line in the paragraph， further indented
relative to the label.／／这将是新段落的第一行，相对标记有更多的缩进。
The blank line just above this is treated almost exactly like a
paragraph break （actually， like the troff-level request .sp l）．／／知上的空行几
乎总是当作段落的结束（实际上，像troff层次的.sp 1请求）。
．SS A subsection
This  is  subsection text，／／这是子段文本，标题为“A subsection"
在历史上其它五六个rroff宏指令库中，ms （7）和mm （7）是仍在使用的两个。BSD
Unix含有自身精心制作的扩展宏指令集，mdoc （7）。它们在风格上与man宏集相似，
但更精致，并且倾向于生成排版输出。
www.pdf365.com
424
第1 8章文档：向网络世界阐释代码
    troff（1）是一个叫做nroff（1）的小变种，它为诸如行式打印机和字符元终端等只支持
定宽字体的设备生成输出。在终端窗口浏览的Unix手册页正是nroff程序提供的。
    Documenter's Workbench的工具被设计来完成技术文档工作，它在这方面做得相当
漂亮，这就是为什么尽管三十年间计算机能力提高了千倍，而它一直还被人们使用的原
因。这些工具在图像打印机上生成可靠质量的排版文本，也可以在屏幕上显示虽不完美
但可忍受的格式手册页。
    在好几个领域中，这些工具也做得很糟糕。可供选择的主要字体是有限的。图像处
理得不好。在页面里很难精确地控制文本、图像或图表的位置。多语言文档的支持也不
存在。还有不少其它问题，有些由来已久但不太重要，有些绝对是为了特殊目的而仓促
写就的。但大多数严重的问题都是因为标记仅仅处于表示层，所以不加修改的troff源文
件很难生成效果良好的网页。
    无论如何，在编写本书时，manpage仍旧是唯～虽重要的Unix文档形式。
18.3.2  TEX
    TEX（发音为/teH/，浊音h就像口含着水发音一样）是个威力强大的排版程序，如
同Emacs编辑器一祥，最初也来自Unix文化之外，但现在却在Unix文化中落地生根。
它是由著名的计算机科学家Donald Knuth在1970年代晚期发明的，那时的他腻烦了印
刷排版的——特别是数学方面的——排版质量。
    TEX，同troffll）一样，是以标记为中心的系统。TEX的请求语言比troff更具威力：
就其它而言，在处理图像，准确的内容页面定位，以及国际化方面都做得较好。TEX特
别擅长处理数学方面的排版，基本的字距调整，线填充以及连字符等问题也做得非常优
秀，难以超越。TEX已经成为了众多数学刊物的排板标准。现在实际上已作为开源软件，
由美国数学学会（ American Mathematical Society）维护。它也常被用于科学论文。
    同troffll）相似，人们通常也不需要手工编写大量原始的TEX宏；而是使用宏命令包
以及各式各样的辅助程序。一个特别的宏命令包，LATEX，几乎无所不能，而且大多数
人所谓在使用TEX创作时实际上几乎总是指用LATEX编写。与troff的宏命令包一样，
许多请求都是半结构性的。
www.pdf365.com
18.3各种Unix文档格式
425
    TEX -个通常用户不可见的重要用法就是，其它文档处理工具宁愿生成LATEX来
转换成PostScript，而不是尝试自己生成PostScript，因为那样做更困难。我们在第14章
作为shell编程而讨论的xmlto（1）前端使用的就是这个策略；我们稍后要讨论的
XML-DocBook工具链也如出一辙。
    TEX比trofj（1）有着更广的应用范围，而且在很多地方有更好的设计。在愈发倾向以
网络为中心的世界里；TEX存在同troff -样的基础性问题；其标记更接近表示层，而要
从TEX源文件中自动生成网页很困难，很难不出错。
    TEX从未被Unix的系统文档使用，也很少使用在应用程序的文档中；对于这些任
务，troff就足够了。但是一些源自Unix社区之外的学术界已经引入了TEX作为文档的
主要格式，例如Python语言就是个典型的例子。如上所述，它也大量地使用在数学和科
学论文中，而且还会在那个小环境中占据好几年的统治地位。
18.3.3  Texinfo
    Tcxinfo是由自由软件基金发明的文档标记，其目的是为了管理GUN项目文档——
包括诸如Emacs和GUN编译器集之类基本工具昀文档。
    Texinfo是第～个为既支持排版纸面输出又支持可供浏览的超文本输出而设计的标
记系统。尽管那种超文本格式并不是HTML，而是一种更原始的类型，叫做“info，，，
它最初是设计在Emacs中浏览的。在打印方面，Texinfo先转换成TEX宏然后再转换为
PostScript。
    Texinfo工具现在可以生成HTML。但并不能很好地完整地完成这项工作，而因为许
多Texinfo的标记都是处于表现级别，真有可能永远无法达成目标。在2003年年中，自
由软件基金正在开发从Texinfo到DocBook的启发式转换器。在一段时间里，Texinfo将
可能继续作为一个有用的格式而存在。
18.3.4  POD
    Plain Old Documentation是Perl支持者使用的标记系统。它生成手册页，具备所有表
示层标记的相似问题，包括不能生成良好HTML的顽疾。
UNIX编程艺术
  www.pdf365.com
426
第1 8章文档：向网络世界阐释代码
18.3.5  HTML
    自从万维网在九十年代早期进入主流社会以来，一小部分但比例越来越高的Unix项
目直接使用HTML来编写文档。这种方式的问题是难以从HTML中生成高质量的排版输
出。也存在特殊的索引问题：需要生成索引的信息在HTML中并不存在。
18.3.6  DocBook
    DocBook是为大规模、复杂技术文档而设计的SGML和XML文档类型定义。在Unix
社区中使用的标记格式中这是唯一的纯粹结构性的标记语言。在第14章讨论的xmlto（l）
工具，支持转换到HTML、XHTML、PostScript、PDF、Windows帮助以及其它几种次重
要的格式。
    几个主要的开源项目（包括Linux文档项目、FreeBSD、Apache、Samba、GNOME
和KDE）已经使用DocBook作为首要格式了。本书也是用XML-DocBook编写的。
DocBook是个大话题；我们将在总结Unix文档当前状态的问题之后再回来讨论。
18.4  当前的混乱和可能的出路
    Unix文档管理，目前，是一团乱麻。
    在现代的Unix系统中，文档的首要文件形式散布在man、ms、mm、TEX、Texinfo，
POD、HTML和DocBook之间。没有统一的方法来浏览所有的描绘版本。它们不能通过
网络访问，也不能交叉索引。
    Unix社区的许多人已经意识到这是个问题。在本书写作时，大多数朝着解决这个问
题方向的努力都来自于开源开发者，比起那些专业Unix的开发者来说，他们更积极地关
心是否能够赢得非技术终端用户的接受。自从2000年来，实践的方向转向使用
XML-DocBook来作为文档的交换格式。
    目标虽然可望，但需要许多的努力才可及，那就是在每个Unix系统上都装上软件作
为系统范围内的文档登记库。当系统管理员安装某个文档软件包时，需要有个步骤，将
该软件包的XML-DocBook文档注册到登记库中去，并被转换成一个通用的HTML文档
树，并且交叉链接到已经存在的文档上。
www.pdf365.com
18.5  DocBook
427
    文档登记库软件的早期版本已经可以运行。但从其它格式到XML-DocBook的转换
是个巨大而繁杂的步骤，当然转换工具将很快就位。其它的行政和技术问题有待解决，
但这是可以解决的。而在2003年年中，旧格式是否必须被抛弃，并没有一个全社区的一
致意见，其实那似乎是最有可能的解决方式。
    相应地，我们接下来将详细讨论DocBook及其工具链。可以把它当作Unix下的XML
介绍，当作一个对实践的实用指导以及一个重要的实例分析来阅读。同时，也是在Unix
社区背景下，不同项目组开发者之间，如何围绕共享的标准进行合作的上佳实例。
18.5  DocBook
    许多重要的开源项目都趋于使用DocBook作为文档的标准格式。基于XML标记的
提倡者似乎已经赢得了理论上的胜利，支持结构层标记，反对表示层标记，并日．一条高
效的XML-DocBook工具链也有了开源实现。
    然而在DocBook以及支持它的程序中依然被很多问题缠身。其支持者满口甚至被计
算机科学标准禁止的暗语，弄出许多缩写词，而都跟编写标记以及从中生成HTML或
PostScript所需要做的事并没有明显的关系。XML标准和技术文章声名狼藉她晦涩不清。
在余下的部分，我们将试图驱散笼罩在暗语行话上的这层迷雾。
．1 Q只1 tT赴址米并II，{，W
 I o.J．I）0，IIj犬刍芭人匕）0
    （注：为了叙述上的简便，这部分叙述有些偏颇，主要是省略了大部分的历史。在
下一个部分会侧回来完整地讨论。）
    DocBook是个结构级标记语言。特别地，是XML的一种方言。一份DocBook文档
其实也是XML文档，使用了XML标签作为结构标记。
    对于一个文档格式器，如果需要将样式单应用到文档，并让它美观大方，就必须知
道文档的整个结构。例如，为了能够正确地格式化章节标题，就需要知道书稿通常包含
哪些前言、章节和附录。为了让格式器知道这些东西，就需要指定一个文档类型定义或
DTDo DTD告诉文档格式器文档结构中有哪些元素，以什么样的次序出现。
UNIX编曜艺术
  www.pdf365.com
428
第1 8章文档：向网络世界阐释代码
    DocBook被称作XML方言，这句话的含义是，DocBook实际上是个DTD--个
相当庞大的DTD，大概有400个左右的标签。1
    隐藏在DocBook后的一类程序叫做验证解析器。如果格式化一个DocBook文档，第
一步就是将其传递给一个验证解析器（DocBook格式器的前端）。这个程序检查文档是
否符合DocBook DTD以确保没有违反任何DTD的结构规则（否则，格式器的后端，应
用样式单的部分，会变得无所适从）。
    验证解析器要么抛出错误并给出文档哪处结构违反了规则，要么将文档转变成XML
元素和文本流，并由解析器后端将样式单的信息整合在一起产生格式化后的输出。
    图18.1揭示了整个过程。
格式器
图18.1  结构化文档处理过程
    图中虚线框内的部分就是格式化软件或工具链。除了明显可见的输入以外（待格式
化的文档原件），请牢记：格式器还需要两个隐含的输入（DTD和样式单），这样才能
理解随后的过程。
18.5.2  其它DTD
    先扯远一点，说说其它的DTD，这样可能有助于澄清上一节中哪些部分是DocBook
独有的，哪些部分是所有结构性标记语言‘所通用的。
1用XML的话来说，我们斫谓的“方言”其实应该叫做“应用”；我们避免这种用法，是因为跟这
个词另一个更常用的意思有些混淆。
www.pdf365.com
18.5  DocBook
429
    TEkhttp：／／www. tei-c．org／>（Text Encoding Initiative）是个大型精细的DTD，
主要使用在学术界书稿文本的计算机电子稿件。TEI基于Unix的工具链，使用了许多类
似于DocBook中的工具，但是样式单（理所当然）和DTD截然不同。
    XHTML，最新版的HTML，也是由DTD描述的一个XML应用，阐明了XHTML
和DocBook标记之间的家族相似性。XHTML工具链包含可以将HTML格式化成纯ASCII
文本的网页浏览器，也整合了许多专用的HTML打印功能程序。
    许多其它的XML DTD在维护着，它们是用来在诸如信息生物和银行等领域进行结
构化信息交换的。可以参阅<http：／/www．xml．com/pub/rg/DTD_Repositories>
的列表，以对这些有个概念。
18.5.3  DocBook工具链
    通常要从DocBook源文件生成XHTML，需要使用xmlto（l）前端。命令看起来像这
样：
    本例将把具有三个主体部分的XML-DocBook文档foo.xml转换成目录页和内容页两
部分。生成一个长页面只需：
最后，可以这样生成PostScript卧各打印：
bash$  xmlto ps  foo.xml           #  To  make  Pos七Script  #生成 PostScript
bash$ Is *.ps
foo.ps
    将文档转换成HTML或者PostScript，需要一个引擎，将DocBook DTD和针对文档
的恰当样式单组合起来，应用到你的文档上。图18.2说明了开源工具是如何完成协作过
程的。
    有三个程序可以解析文档并应用样式单进行转换。最常用的是xsltproc，同Red Hat
Linux -起发布的解析器。剩下的两个是Java程序，．Saxon和Xalan。
UNIX编腥艺：术
    www.pdf365.com
           ><
            r0
                         . rl
           rJ
               o
                H
               o
       ' r0
i-l    l
 x    七
 .     J:
 o     .
f       O
七  r-l  r
><  七
      J::  i-l
 o  .  m
 {11  a  r
b n  rlj
r-l
 ><
 o
 o
rn
-1t:
 o
  I
N-I
U  i+
><  t
 o  .
七  +:
m  cn ~-i
><  :-i  m
$$ J:
rn  {n  o
 a  a  0
n b  q-l
430
第1 8章文档：向网络世界阐释代码
┏━━━━┓
┃DocBook ┃
┗━━━━┛
    图18.2  如今的XML-DocBook工具链
    从DocBook生成高质量的XHTML相对容易；事实上XHTML只不过是另外一种
XML DTD，这一点当然有益于转换。对文档施用相当简单的样式单就可以完成HTML
转换，这也是整个过程的结束。按照这种方式，RTF的生成也很简单，而在XHTML或
RTF基础上，必要时生成近似的纯ASCII文本也就是轻而易举的了。
    麻烦的是打印。生成高质量的打印输出一一实际上是Adobe的PDF（Portable
 Document Format，可移植文档格式）——是困难的。需要从算法上重现人工排版中区分
内容和表现精准判断。
    因此，首先，样式单将DcoBook的结构性标记转换成另一种XML方言-FO
（Formatting Objects，带格式对象）。FO标记是完全表示层的；可以认为等同于troff的XML
功能。之后，FO标记会被转换成PostScript，然后包装成PDF。
    在同Red Hat Linux -起发布的工具链中，这项工作由TEX的一个叫做Pas siveTeX
的宏命令包完成。它将xsltproc生成的格式化对象转换成Donald Knuth昀TEX语言。TEX
的输出是熟知的DVI（设备独立）格式，于是便可制成PDF。
    从XML到TEX宏，再到DVI，最后到PDF，这工具链简直就像老牛拉的杂牌老破
车，如果这么认为，确不为过。嘎吱嘎吱，呼哧呼哧，一无是处。字体是个严重的问题，
因为XML、TEX和PDF字体的工作模型都不尽相同：同样，国际化和本地化也是一场
恶梦。按这种方式走到头，真是自寻烦恼。
    FOP（FO-to-PostScript）会优雅得多，这是由Apache项目开发的从FO直接到
PostScript的转换器。在FOP中，国际化问题，如果不算解决的话，至少很好地限制住
了；XML工具总是通过FOP处理Unicode。从Unicode字形到Postscipt字体的映射也绝
www.pdf365.com
18.5  DocBook
431
对是个问题。最麻烦的是这种方法尚无法工作：到2003年中，FOP还处于未完成的alpha
状态——可用，但粗糙不堪且功能不足。
    图18.3展示了FOP工具链的模样
    图18.3  XML-DocBook未来的FOP工具链
    也存在同FOP的竞争者。另一个叫做xmlroff2项目的目标同FOP -样，但以c++
完成（因此速度较Java快也无需依赖Java环境）。在2003年年中，xmlroff也处于未完
成的alpha状态。
18.5.4移植工具
    DocBook第二严重的问题是，需要大量努力将旧风格的表示层标记转换为DocBook
标记。人们通常可以自动地将文本的表示解析成逻辑结构，因为（例如）可以从上下文
中判断一个斜体部分是“强调”还是“外来词”或别的什么。
    无论如何，将文本转换成DocBook的过程中，这种区别需要明确化。有时它们出现
在旧的标记中；有时又不出现，而缺失的结构性信息必须由聪明的算法推演或是人为补
足。
UNIX编翟艺术
  www.pdf365.com
432
第1 8章文档：向网络世界阐释代码
    下面总结了从其它格式到DocBook的转换工具。所有这些工具都不是彻底完美的；
在转换后需要检查，甚至需要人工编辑。
GNU Texinfo
    自由软件基金尝试将DocBook作为交换格式来支持。Texlnfo具有足够的结构标记
来进行良好的自动转换（人T编辑仍然需要，但不会太多），4.x版本的makeinfo有个功
能开关-docbook，可以生成DocBook。更多的信息参见makeinfo项目主页
<http:／/www. gnu. org/directory/texinfo. html>a
POD
    POD::DocBook<ht tp:／/www. cpan. org/mo dule s/by -module/Pod/>将Plain
Old Documentation标记转换为DocBook。它宣称除了L<>斜体标签，可以将所有的POD
标签都转换成DocBook。手册又说“嵌套的=over/=back列表在DocBook中不支持”，
但注意这个模块是经过大量测试的。
LATEX
    一／卜日Lf做TeX4ht<http：／／www - irz -muenchen．de/services/ software/
sonstiges/tex4ht/ mn，html>的项目，按照PassiveTEX作者的说法，可以从LATEX
生成DocBook。
man pages和其它基于troff的标记方式
    这通常被认为是最大最令人厌烦的转换问题。的确，基本troff（1）标记的表示层太
低，自动完成转换的工具简直就是吃力不讨好。然而如果我们考虑从使用man（7）之类宏
命令包编写的文档源进行转换，前景就光明了许多。这些宏具备足够的结构性特征以利
于自动转换。
    我自己编写了～个我称之为doclifer的工具来做troff到DocBook的转换，因为我找不
到什么软件的转换结果可以容忍。<http：／/www- catb. org／—esr／doclifter/>。支
持从，nan（7）、mdoc（7）、ms（7）、以及me（7）宏转换到SGML或者XML DocBook。详情请参
考项目文档。
18.5.5编辑工具
在2003年年中还缺乏的就是～款优秀的开源SGML/XML结构编辑器。
www.pdf365.com
18.5  DocBook
433
    LyX<http: //www．lyx．org/>是个GUJ的字处理器，使用LATEX进行打印并支
持LATEX标记的结构化编辑。有可以生成DocBook的LATEX包，以及描述在LyX界
面中如何撰写SGML和XML的how-to文档<http：//bgu．chez．tiscali．fr/doc/
db4lyx/>。
    GNU TeXMacs  项  目  <http://www.math.u-psud.fr/—anh/TeXmacs/
TeXmac g．html>，其目标是生成一个擅长于技术及数学材料的编辑器，包括公式的显
示。1.0版已经在2002年四月发布。开发者计划在未来加入XML支持，但目前还没有。
    许多人仍然使用Vl或者emacs来手工编写DocBook标签。
18.5.6相关标准和实践
    慢慢地可以凑起许多工具来编辑和格式化DocBook标记。但是DocBook本身只是个
手段，而不是最终目的。除了DocBook本身之外，我们需要其它标准来达成“可搜索文
档数据库”这个目标。这存在两大问题：文档编目和元数据。
    ScroIIKeeper  <ht tp：//scrollkeeper．sourceforge。net／>直接瞄准这种需
求。它提供一套简单的脚本钩子（ script hook），可以使用在软件包的安装和卸载过程中，
以登记和注销它们的文档。
    ScroIIKeeper  使用开放元数据格式  （Open  Metadata  Format）
<http：／/www. ibiblio．org/osrt/omf/>。这是为开源文档制作索引的标准，类似
于图书馆的卡片式目录系统。该创意支持丰富的搜索功能，可通过使用卡片式目录元数
据或是源文本本身。
18.5.7  SGML
    先前，我们有意地忽略了DocBook的历史。在XML之前，还有个标准通用标记语
言（SGML， Standard Generalized Markup Language）。
    直到2002年年中，DocBook的讨论必然深入到SGML中，包括SGML和XML的
不同，包括SGML DocBook工具链的具体描述。现在简单了：存在XML DocBook的开
源工具链，它甚至比SGML工具链工作得还好，也更容易使用。
18.5.8  XML-DocBook参考书籍
学习DocBook比较困难，与之相关的站点总是堆砌长长的W3C标准列表，大量
www.pdf365.com
434
第18章文档：向网络世界阐释代码
SGML理论知识以及一大堆复杂的抽象术语，这往往会吓退初学者。XML in a
NutsheIl（XML技术手册》  [Harold-Means]是本详细的优秀入门书。
    Norman Walsh的DocBook: The Definitive Guide （DocBook权威指南》的印刷版本在
<http：／/www，oreilly．com/caLalog/docbook/>，  电子版本在<http：／/www.
docbook．org/tdg/   en/html/docbook．html>，但它作为入门指导对读者而言简
直就是灾难。我们建议阅读：
    Writing Documents Using DocBook（使用DocBook编写文档）<http：／/xml .web．
cern．ch/XML/goossens/dbatcern/》。这是本优秀的入门指导书。
    同样优秀的DocBook常见问题解答<http：／/www．dpawson．co．uk/docbook/>中，
有许多关于  HTML  输出风格化的资料。  还有一个  DocBook wiki
<ht tp: //docbook. org/wiki/moin. cgi>。
    晟后，The XML Cover Pages<ht t-p：／／xml．coverpages．org/>，将会带你进入
XML标准的世界，如果有此愿望，不妨去看看。
18.6编写Unix文档的最佳实践
    本章早些时候关于阅读Unix文档的建议正好可以反过来。在Unix文化环境中为他
人编写文档时，别自降身价。愚弄读者，就是承认自己也是傻瓜。愚弄读者的文档同真
正易于理解的文档大相径庭；前者偷懒而忽略了重要的东西，后者则要求深思熟虑以及
不留情面的修订。
    数量多不会被认为是质量高。尤其是，决不要因为害怕别人看不懂而省略功能细节，
决不要为了面子而不对存在的问题提出警示。不愿坦露问题才会损害信誉和用户，坦白
了的问题则不会。
    信息密度要适中。过低过高都不好。少用屏幕截图；它们除了界面风格和观感之外
往往很少带有其它信息。它们从来无法代替清晰的文字描述。
    如果项目规模比较大，应该发布三种不同的文档：手册页作为参考资料，教程手册
和常见问题解答列表。应该有个网站，作为发布中心（参考第19章关于交流的指导）。
    没人喜欢庞大的手册；在其中浏览比较困难；如果确有此虞，考虑编写参考手册，
手册页提供快速的摘要，并指向参考手册，以殁程序如何调用的细节。
www.pdf365.com
18.6编写Unix文档的最佳实践
435
    在源码中，需要包含第19章关于开源发布惯例部分阐述的标准维护文件，例如
README。即使是专有代码，也请遵守Unix的约定俗成，具备Unix背景的未来维护者
将会很快上手。
    手册页应该为传统的UfliX用户以传统风格的命令引用形式呈现。考虑非技术用户，
入门手册应该多用全称，少用缩写。而FAQ应该随着软件支持群体对软件常用问题及如
何回答的深入了解而不断改进。
    2003年年中，最前沿的实践中，还有几个重要的习惯应该养成：
    1．使用XML-DocBook维护主文档。即使手册页是DocBook RefEntry文档。关于
    如何编写用户期望看到的手册页来解释内容和组织，这里有个非常有用的
    HOWTO<http:／/www. linuxdoc. org/HOWTO/mini/Man- Page. htrn]>。
    2．发布XML主文档。同时，需要发布troff源码，对主文档运行xmlto man就可
    以得到它，以备用户的系统上没有装载xmlto（1）。软件的安装程序应该以常规方式
    进行，如果有人需要编写或者编辑文档，请引导他们使用XML文件。
    3．让项目的安装包支持ScroIIKeeper，
    4．从主文档生成XHTML（使用命令xmlto xhtml）并放到项目的网页上以供访问。
    无论是否使用XML-DocBook作为主格式，都应该找到某个方法将文档转换为
HTML。无论软件是开源的还是专用的，用户越来越愿意通过网络找到它。将文档放在
网上，其直接效应就是能够让知道软件的潜在用户和消费者更容易阅读，更容易了解软
件。而其间接效应就是软件被网络搜索找到的机会更多。
UNIX编-程艺术
    www.pdf365.com
www.pdf365.com
1 9
开放源码：在Unix新社区
中编程
Open Source: Programming in the
New Unix Community
Software is like sex-it's better when it'sfree.
    软件和性一样——越自由越好。
    -Linus Torvalds
    在第2章，作为总结，我们评述了Unix历史中最大规模的模式；当Unix实践最接
近开放源码时，就欣欣向荣，反之则停滞不前。然后在第16章，我们又断言开源开发工
具往往具备高等级质量。至于本章，我们将以简要说明开源开发怎样工作且为何这样工
作作为开始。实际上，其大多数行为都只不过是Unix传统长期实践的强化而已。
    随后我们将从抽象领域下到具体，转而描述一些Unix从开源社区借鉴而来的最重要
的大众习惯的——特别是由社区发展的、关于如何成为良好源码发布的指导原则。其它
现代操作系统的开发者同样可以沿袭大多数这些习惯并从中受益。
    我们将假设你用开放源码进行开发而描述这些习惯；当然，即使是编写专有软件，
多数习惯仍不失价值。基于开放源码的设想在历史上也是有用的，许多习惯在专有Unix
中都能找到痕迹，像无处不在的工具例如patch （1）、Emacs和GCC筹等都是。
UNIX编程艺术
    www.pdf365.com
438
第1 9章开放源码：在Unix新社区中编程
19.1  Uni×和开放源码
    开源开发利用了这样的事实，甄别和修改bug的任务适合分解成多个并行的子任务
——这和实现某个特殊算法不一样。围绕某个原型设计进行邻域开发，也很适合并行处
理。所以，随着正确技术和社会机制的到位，通过网络松散连接的庞大开发团队可以把
工作做到出色得让你吃惊。
    是的，这会让你吃惊，如果还抱守那种把秘密开发和专有控制视为必然的话。从《人
月神话》[Brooks]直到Linux的兴起，软件工程的正统观念都是关于如何在重量级组织，
例如企业和政府中，构建小型而管理紧密的团队。而实践却是紧密管理的大型团队。
    在AT&T拆分以前的早期Unix社区的运作实际就是开源的典型例子。尽管拆分前
的Unix代码在技术上和法律上是专有的，但在用户和开发者社区中，却被视作共享的。
那些人们的自愿努力，受到解决问题强烈愿望的推动而自觉迸发出来。而在这些努力之
中，优秀者层出不穷。的确，开源开发的方法和技术在Unix社区作为一种无意识的群众
实践而发展，其实在1990后期被分析和标记之前，就已经持续了四分之～个世纪。（参
考《The Cathedral and the Bazaar<大教堂和集市）》[Raymond01]和《Understanding Open
Source Software Development（理解开源软件开发）》[Feller-Fitzgerald]）。
    回顾过去，令人惊讶的是我们对自己的行为意味着什么是多么茫然无知。有些人的
理解却很透彻；Richard Garbiel在文章“差即是好”中表达的思想是其中最著名的，在
Brooks【Brooks] （1975）也可以找到预示，甚至远到Vyssotsky和Corbato在Multics的设
计中的思考（1965）。在1990年代中期被Linux唤醒之前，多达20年的软件开发观察中，
我也没有意识到这～点。这样的经历应该让任何有见解而谦逊的人知道，是不是还有其
它什么重要的统一理念依旧暗含在我们的行为中，潜藏在我们集体的眼皮底下未被发掘，
不是因为复杂而是因为太简单。
    开源开发的规则很简单：
    1．源码公开。别隐藏秘密。公开代码以及产生代码的过程。鼓励第三方的同行复审。
确保其他人能够自由地修改和重新发布代码。尽可能地发展合作开发者。
www.pdf365.com
19.1  Unix和开放源码
439
    2．尽早发布，经常发布。快速的发布节奏意味着反馈迅速而有效。每次递进发布间
隔越小，回应真实世界反馈的修改过程就越容易。
    确保第一次的发布能够编译和运行，所有允诺的功能都可运作。通常，一个开源程
序的启动版本通过至少完成最终目标的某个部分来展示项目的前景，这充分表明发起人
确实可以继续这个项目。例如，字处理器的启动版本应该支持文本的输入以及文本在屏
幕上的显示。
    不能编译或是运行的第一次启动发布会毁掉整个项目（例如大家都知道，这差点就
在Mozilla浏览器身上发生）。不能编译的发布表明项目开发者不能够完成项目，同样地，
不能运行的程序也难以吸引其他开发者的参与，因为任何改动对程序是好是坏都不确定。
    3．给贡献以表扬。如果不能够给合作开发者以物质奖励，就给予精神表扬。即使可
以给予物质的奖励，也不要忘记人们往往是为展示才华而不是为钱努力工作。
    规则2的必然推论就是，单一发布不应该视为重大的事件，无需伴随太多的
  附带许诺和准备。将发布过程无情地精简非常重要，这样就不再为经常发布而感
  到痛苦。在发布准备期，其余工作都必须停止的安排是个可怕的错误（值得一提
  的是，如果使用CVS或者类似酌版本控制，处于准备期的发布应该同主干开发线
  分开，这样就不至于阻塞主线开发过程。）总的来说，不要把发布当作什么特别
  的大事；而应该当作是例行公事。
-Henry Spencer
    牢记：频繁发布的原因是为了缩短和加速同用户和开发者间的反馈循环。因此，精
工细作，等一切完美了才发布的想法是要不得的。不要许太多愿。一步一步地来，承认
和公布现有的bug，并有信心随着时间的推移，一定会达到完美。发布点多一点儿不是
坏事，不必为版本号的增加而烦恼。
    开源开发利用散布在互联网上，而且主要通过email和网络文档交流的大型程序员
团队。典型地，任何项目的多数贡献者都是为了提高软件对自身效用的回报以及声誉激
UN1×编程艺术
  www.pdf365.com
440
第1 9章开放源码：在Unix新社区中编程
励而自愿工作。一般由一个核心开发者或核心开发组来指导项目；其他贡献者可以零星
地加入或离去。为了鼓励志愿者，重要的是避免在他们和核心团队之间产生社会壁垒。
因此需要最小化核心团队的特权，努力模糊界限。
    开源项目遵循Unix传统尽可能自动化的建议。使用patch（l）工具分发递进更改。许
多项目（以及所有大型的）都拥有使用诸如CVS（回顾第15章的讨论）等版本控制系
统的网络访问代码库。Bug和补丁自动追踪系统的使用也很普遍。
    1997年，在黑客文化之外几乎没人能明白，这样管理大型项目并同样获得高质量的
开发结果是完全有可能的。在2003年，这已不再是新闻；诸如Linux、Apache和Mozilla
项目都已经获得了巨大的成功和非常高的公共上镜率。
    抛弃秘密开发的习惯，转而支持过程的透明化和同行复审是炼金术成为化学学科最
关键的一步。同样你也开始发现，开源开发标志着软件开发终于长成为一门学科。
19.2  与开源开发者协同工作的最佳实践
    开源社区最佳开发实践实际上便是对分布式开发自然而然的适应；在本章中可以了
解到许多行为准则，用来同其他开发者进行良好沟通。有些Unix绚定是偶然的（例如文
件的标准命名表达关于发布源的元信息），这常常可以上溯到1980年代早期的Usenet，
或者GNU项目的约定和标准。
19.2.1  良好的修补实践
    多数人在发布自己的项目之前，都是从修补他人的软件而开始接触开源软件开发的。
假定已经为某个基准源代码更改了一些代码，现在需要设身处地去想想，别人该怎样判
断是否可以采纳这个补丁呢？
    代码的质量很难判断，所以开发者往往通过提交的质量来评估补丁，在提交者的风
格和交流行为中寻找线索——该提交者是否设身处地为他们着想，是否知道评估和合并
新的补丁究竟该怎样。
    这是鉴定代码质量相当可靠的方法。在许多年处理来自数以百计陌生人补丁的过程
中，我很少看到一个考虑周全、尊重我的时间的补丁会是技术上的赝品。反过来看，经
www.pdf365.com
19.2与开源开发者协同工作的最佳实践
441
验告诉我们，看起来马马虎虎或是打包很疏懒的补丁往往实际上就是赝品。
    这里有一些怎样让补丁能够被接受的技巧：
19.2.1.1  发送补丁而不是完整档案包或文件
    如果改动包含了一个源代码中并不存在的新文件，当然就必须发送整个新文件。但
如果修改的只是已有文件，无须发送整个文件。只须发送diff就行：运行difi（1）命令，
将基准发布版本与修改版本进行比较，并提交输出。
    dif1）命令及其对偶命令patch（l），是开源开发最基本的工具。差异文件要比整个文件
好，因为自从获得旧拷贝之后，接受补丁的开发者可能已经更改了主干版本。呈送开发
者以一个diff文件，节省了别人将改动从其中分离出来的精力；也表示了对别人时间的
尊重。
19.2.1.2发送针对当前版本代码的补丁
    如果发送给维护者的补丁是针对好几个版本以前的，并期望维护者会判断补丁中哪
些改动已经完成，哪些是新颖独创，这样做既不能达到预期目标也有些粗鲁无礼。
    追踪源码状态以及把主线代码库需要做什么的最小化补丁提交给维护者，是补丁提
交者必须承担的责任。这也意味着应该发送针对当前版本的补丁。
19.2.1.3不要包含可生成文佯的补丁
    在发送补丁之前需通览一遍，对于一旦维护者采用补丁、重新make后就能重新生成
的文件，其补丁段应予删除。犯错的经典例子就是Bison或Flex产生的C文件。
    当今最常见的错误就是，发送的diff文件只包含有巨大的更改段来表明你的
configure脚本和维护者的差异。其实这个文件可以由autoconf产生。
    这是有欠考虑的。它把接收者置于麻烦之中，需要把补丁的真实内容从一大堆乌七
八糟的干扰里分离出来。当然它只是个次要的错误，同我们将要进一步探讨的内容相比，
并非那般严重——但也是不好的。
UNl×编l茬艺术
    www.pdf365.com
442
第1 9章开放源码：在Unix新社区中编程
19.2.1.4不要发送与只是优化RCS或者SCCS $-symbols的补丁段
    有些人喜欢在源码文件中放置一些特殊符号，在登入版本系统时会自动扩展：例如
RCS和CVS使用的$id$构造。
    如果使用自己本地的版本控制系统，更改可能会改变这些符号。这并非真正有害，
因为当接收者在采用补丁而登回代码时，特殊符号可以按照维护者版本控制系统的状态
设置重新扩展。但这些特殊的补丁段是干扰物，会让人分心。不发送它们更能体现考虑
的周全。
    这是另外一个次要的错误。如果别的大事没弄错，这是可以原谅的。但最好避免。
19.2.1.5使用-c或-u格式而不是缺省的（-e）格式
    difj（1）默认的（-e）格式非常脆弱。它不包含任何上下文，因此在得到用来修改的
拷贝之后，如果基准代码中插入或者删除了任何一行，patch工具无法得到正确结果。
    拿到-e格式的diff文件令人恼火，表明发送者如果不是位新手或马大哈，就是个菜
鸟。大多数这种补丁想都不用想便可抛弃掉。
19.2.1.6在补丁中包含文档
    这非常重要。如果补丁增加了用户可见的部分或者改变了软件的功能特征，请在补
丁中包含相应手册页和其宅文档文件。不要期望补丁接收者会乐于为此代码编写文档，
或是在代码中隐藏没有文档说明的功能特征。
    针对改动做好文档体现了一些好习惯。首先，已经为试图说服的维护者设身处地考
虑过了。其次，表明对改动后的效果了如指掌，可以向其余不能查看代码的人解释清楚。
第三，表示了对软件最终用户的关心。
    良好的文档常常是区分“可靠的贡献”和“匆忙而邋遢的改动”最显著的特征。如
果花费了足够的时间和心思来做好文档，最后就会发现让多数开发者接受补丁的道路已
经走完了85%。
www.pdf365.com
1 912与开源开发者协同工作的最佳实践
443
19.2.1.7在补丁中包含解释
    补丁应该包含一份说明，来解释为什么补丁是必须和有用的。这个说明并不直接给
软件用户而是给接受补丁的维护者。
    说明可以很短——实际上，我见过的一些最有效的说明仅仅是“请参看补丁中的文
档更新”。但必须表明正确的态度。
    正确的态度非常有帮助，是对维护者时间的尊重，也是从容而谦逊的自信。表现出
对所修补的代码充分理解，展示对维护者问题的认同，这些都是有益的。对于觉察到的
应用补丁风险预先说明同样大有裨益。下面是一些经验丰富的开发者所发送的各种解释
示例：
    “我已经发现代码中有两个问题，X和Y。我改掉了X，但是我并没有试图去解决
Y问题，因为我对牵涉到的代码还不理解。’’
    “修改了一个当输入过长时的coredump。我在修改的时候，试图寻找另外的溢出错
误。我发现有一个可能在blarg.c中，在第666行附近。你能确定在每个传输中发送端产
生的字节不会多于80?”
    “你是否已经考虑使用  Foonly  算法来解决这个问题？在
<ht tp：／/www．example．com/～j smith/f oonly．htm]>处有个好的实现。”
    “补丁解决了当前的问韪，但我意识到内存分配被不恰当地复杂化了。在我这里可
以工作，但在发布前你应该进行重负荷测试。”
    “这可能太过于花哨，但无论如何我还是提交了。也许你会知道一个实现这种功能
的更简洁的方法。”
19.2.1，8在代码中包含有用的注释
    在合并补丁之前维护者希望能够对更改有准确的理解确。当然，这并不是一成不变
的法则；如果确实同维护者存在很好的合作工作记录，他也许在半自动化地检查前就只
会随意地瞄上～眼。但是任何帮助维护者理解代码和降低不确定性的作为都会提高补丁
被接受的几率。
    代码中良好的注释可以帮助维护者理解代码。糟糕的则不然。
    以下是个糟糕的注释例子：
／★norman newbie fixed this 13 Aug 2001  ★／
UNIX编程艺-荩
  www.pdf365.com
第1 9章开放源码：在Unix新社区中编程
    这没有任何用处。只是在维护者的代码中间，无端地加入了践踏领土的泥泞靴印。
如果维护者接受了补丁（不太可能），他几乎肯定会抛弃这段注释。如果希望获得声望，
应该在工程的News或History文件中包含一个补丁段。这样维护者更可能接受。
    以下是良好的注释例子：
/*
  k This conditional naeds tObe guarded so七hat crunch_data（） never
  * gets passed a NULL pointer  <norman_newbie@foosite.com>
    这样的注释表明，不仅理解了维护者的代码，也理解了维护者对接受你的改动所需
要的信心。这种注释正好给予维护者对于更改的信心。
19.2.1.9如果补丁被拒绝，别往心里去
    存在许多理由，一个补丁可能会遭到拒绝，这并不存在怀疑和责备的意思。记住多
数软件维护者都处于相当沉重的时间压力之下，并很保守地接受补丁，生怕一不小心项
目代码就会崩溃。有时候重新提交改进后的补丁会有所帮助，有时候不会。大家都不容
易。
19.2.2  良好的项目、档案文件命名实践
    随着诸如ibiblio、SourceForge以及CPAN维扩者工作量的增加，一个不断发展的趋
势就是，项目提交部分或整体会由程序来处理（而不是完全由人来处理）。
    对于项目和档案文件的命名而言，更重要的是需要采用更适合计算机程序可以解析
和理解的规则模式。
19.2.2.1  使用GNU风格的命名法：主干加major.minor.patch的编
    三j
    !了．
    如果档案文件都是类似GNU风格的名称，主干前缀全小写且只包含字母和数字，后
接连字号，后再接版本号、扩展和其它后缀，对大家都有帮助。
具备这些部分的名称，其良好的通用形式顺序如下：
1．项目前缀
2．横杠
www.pdf365.com
19.2  与开源开发者协同工作的最佳实践
445
    3．版本号
    4．点
    5．“src”或”bin”（可选）
    6．点号或横线（更倾向点号）
    7．二进制类型和选项（町选）
    8．归档和压缩扩展名
    这种风格的名称主干可以包含连字号或下划线来分隔音节；横线实际上更常用些。
把相关的项目联合成组，给予一个通用的主干名前缀，并以连字符结束，也是个良好的
实践。
    假设正好有个叫做“foobar”的项目，主版本号为1，次版本号或发布号为2，补丁
级别为3。如果只有一个档案部分（假定为源代码），则文件名称看起来应该像这样：
foobar-1.2.3．tar．gz
源文件档案。
foobar．lsm
    LSM文件（假定提交到ibiblio）
    不要使用如下这样的命名方式：
    foobar123．tar．gz
    这让许多程序看起来像一个叫做“foobar123’’没有版本号的项目档案。
    foobarl.2.3．tar．gz
    这对许多程序而言像是“foobarl”项目版本2.3的档案。
    foobar-vl.2.3．tar．gz
    许多程序误认为这是称作“foobar-vl’’的项目。
    foo_bar-l.2.3．tar．gz
    下划线给人们带来发音、打字和记忆的困难。
    FOOBar-1.2.3。tar．gz
    除非喜欢看起来像出售的熏肠，否则不要这样。这也给人们带来发音、打字和记忆
的困难。
UNIX编程艺术
  www.pdf365.com
第1 9章开放源码：在Unix新社区中编程
    如果必须区分源码和二进制档案，或是区分不同的二进制码，或是表达某种文件名
的编译选项，请紧接在版本号之后加上文件扩展名。也就是，像这样做：
foobar-1.2 . 3 . src .tar _gz
源码。
foobar-1 2 _ 3 bin _ tar _ gz
二进制，类型没有指定。
foobar-l. 2 . 3 .bin. i386 _ tar. gz
f386二进制。
    foobar-l.2.3.bin. i386. static. tar. gz
    i386静态链接二进制。
    foobar-l.2.3.bin.SPARC.tar.gz
    SPARC二进制。
    请不要使用像“foobar-i386-1.2.3.tar.gz”之类的名字，因为程序难以从名字主干中识
别出类型的插入词（如“-i386”）。
    区分主要和次要发布的约定很简单：补丁号为修正错误和次要功能：次版本号为兼
容的新功能，而主版本号为不兼容的更改。
19.2.2.2尊重适当的本地约定
    有些项目和社区，对于命名和版本号有良好的约定，并不需要遵从以上的建议。例
如，Apache模块就像mod_foo -样命名，并配有自身的版本号以及协同工作的Apache
版本。同样地，Perl棋块的版本号可以像浮点数～样命名（例如，可能会发现1.303而不
是1.3.3的版本号），Foo::Bar模块的1.303发行版通常命名为Foo-Bar-I.303.tar.gz。（另
一方面，Perl自身，在1 999下半年转换回使用19.2.2.1中描述的约定。）
    查询和尊重特殊社区和开发者的约定；而对于一般的使用，遵守如上19.2.2.1中的
指导。
www.pdf365.com
19.2与开源开发者协同工作的最佳实践
447
19.2.2.3努力选择唯一且容易键入的名称前缀
    主干前缀应该适用于整个项目文件，并且应该容易读写和记忆。所以，不要使用下
划线。没有极特殊的理由，也不要大写或双大写——这会弄乱人眼自然的浏览顺序，并
且看起来像自作聪明的销售小花招。
    如果两个不同的项目存在相同的主干名称会让人们感到迷惑。因此在第一次发布前
就尝试检查是古存在冲突。两个地方可以完成此项检查任务，一个是ibiblio
<http：／/metalab．unc．edu/pub/Linux>的索引文件，  一个是Freshmeat
<http：／/www．freshmeat．net>的应用程序索引。另一个检查的好地方是
SourceForge<h七tp：／/www．sourceforge．net>;做  1个名称搜索。
19.2.3  良好的开发实践
    这里有些作法，可以让项目有别于不起眼而易于湮没的项目，能吸引众多奉献者，
从而成为成功项目。
19.2.3.1  不要依赖专有代码
    不要依赖专有语言、函数库或者其它代码。即使在最有利的情况下这样做都充满风
险；而在开源社区中，这是彻头彻尾的无礼行为。开源开发者不相信他们无法评审酌源
码。
19.2.3.2  使用GNU自动工具
    配置选择应该留到编译期。开源发布的一个巨大优势就是允许软件包适应编译期发
现的环境。这至关重要，因为这可以让软件包运行在连开发者都从未预见的平台上，并
且允许软件社区的用户定制自己的移植。只有最大规模的开发组才买得起所有硬件，以
及雇用足够的员工来支持种类有限的平台。
    因此：使用GNU自动化工具来处理移植性问题，进行系统配置探测，以及量身定制
makefile文件。今天，人们在编译源码时期望能够键入configure; make; make
install就可以得到一个简洁的编译——并且是正确的。关于这些工具的优秀指南可见
<http://seul.org/docs/autotut/>.
    autoconf和autoheader都是成熟的软件。automake如前所述，在2003年年中仍然
脆弱，到处是bug；可能必须维护自己的Makefile．in。幸运的是，它是自动化工具中
重要性最小的一个。
UNl×编程艺．术
    www.pdf365.com
448
第19章开放源码：在Unix．新社区中编程
    无论使用何种配置方法，编译时软件不应向用户咨询系统的信息。安装软件包的用
户并不一定知道问题的答案，这种方法从一开始就注定是失败的。在编译或安装时软件
必须能够自己决定所需的全部信息。
    但是autoconf不应该认为是对一团乱麻式设计的许可。如果可能，编程应遵循POSIX
标准以及尽可能少地向系统询问配置信息。应尽量保持最少的“ifdef" -或者，最好
根本不要有。
19.2.3.3先测试再发布代码
    良好的测试套件使得团队在发布前能够非常容易地执行回归测试。建立强大而便于
使用的测试框架，以便逐步把测试增加到软件之中，测试套件就不那么专用和错综复杂，
开发者也就无需培训了。
    测试套件的发布也使得，社区用户可以在将贡献发转回制作组之前能够测试他们的
代码片段。
    鼓励开发者在他们的桌面和测试机上使用迥异的平台，这样在日常开发中，代码的
移植性就可以不断得到检验。
    代码随着自己使用的测试套件一起发布，并且测试套件可以由make test来运行，
这是非常好的实践，并且可以增强对自己代码的信心。
19_2.3.4发布前对代码进行健全检查
    “健全检查（sanity check）”的意恩是：
类易犯的错误。使用工具捕捉到的错误越多，
使用可以获得的每一款工具来检查每个人
用户和自己需要对付的就越少。
    如果正用GCC编写C/C++，带-Wall选项测试编译，并且在每个发布之前清除掉所
有的警告信息。使用能够找到的每一款编译器编译代码——不同的编译器常常会发现不
同的问题。特别地，在一个真正的64位机器上编译软件。底层的数据类型在64位机器
上可能有所改变，所以常常会发现新的问题。寻找商业Unix系统并且对软件运行lirlt程
序以进行检查。
    使用查找内存泄漏和运行期错误的软件；Electric Fence和Valgrind就是其中两款可
以开源获得的优秀软件。
    对于  Python珂{目，  PyChecker  <http：／／sourceforge．net／projects／
pychecker>是个很有用的检查工具。它常常能捕捉到许多不平凡的错误。
    如果编写Perl程序，可使用perl -c（或是-T，如果可用的话）检查代码。并虔诚
地使用perl -w以激活警告以及“use strict”来限制不安全的结构和语句。  （进一步的讨
论参考Perl文档。）
www.pdf365.com
19.2  与开源开发者协同工作的最佳实践    449
 19.2.3.5发布前对文档和README进行拼写检查
    对软件的文档、README文件和软件中的错误信息进行拼写检查。马虎的代码，编
译时产生警告信息的代码以及README文件或报错信息里的拼写错误，都会让用户认
为软件加工草率、不负责任。
19.2.3.6推荐的C／C++移植性实践
    如果编写C程序，应完全使用ANSI功能特征。特别应使用函数原型，可以帮助发
现跨模块冲突。1日式风格的K&R编译器早就成为历史了。
    不要用编译器的专门特征，例如GCC的-pipe选项或支持嵌套函数的功能。这会导
致其他人在移植到非Linux、非GCC系统时遇到麻烦。
    需要移植的代码应被隔离在一个单独区域的一组源文件（例如，一个Os子目录）中。
涉及不I司编译器、库以及操作系统接口的移植码应该抽象到该目录的文件中。
    移植层是一个库（或者可能仅仅就是头文件中的一套宏），抽象了程序使用到的某
个操作系统的一些API。移植层使软件更容易被移植到新的平台。开发团队中往往没人
了解移植的目标平台（例如，存在成百上千种不同的嵌入式操作系统，没有人知道它们
之间的重要冲突）。通过创造一个分离的移植层，了觯平台的专家就有可能无需理解任
何移植层之外的事情而进行软件移植。
    移植层也简化了应用程序。软件很少需要全功能的、更为复杂的系统调用，例如
mmap（2）和stat（2），并且配置如此复杂的接口也往往让程序员错漏百出。一个具备抽象接
口的移植层（例如，某个叫做一file_exists的stat（2）调用替代物）使你可以从系统
导入有限的、必需的功能，从而简化了应用程序中的代码。
    基于所需功能而不是平台来编写移植层。尝试为每个支持的平台创建单独的移植层
会导致多重更新的维护梦魇。一个“平台”至少总是基于两方面来选择：编译器和库／操
作系统发布版本。在某些情况下，应该是三方面，就像当Linux商家选择一个独立于操
作系统发布版本的C语言库的时候。M个商家、N个编译器以及O个操作系统发布版本，
平台的数目很快就增大到任何最大开发团队都力所不及的地步。另一方面，通过利用语
UNIX编程艺．术
  www.pdf365.com
450
第1 9章开放源码：在Unix新社区中编程
言和系统标准，例如ANSI和POSIX 1003.1，功能特征集总是相对有限的。
    移植性的选择既可以基于代码行数也可以基于编译文件。在同一个平台上，真正的
实现是选择备选代码中的某几行，或是几个不同的文件中的某一个并没有本质区别。经
验原则是，当实现存在重大不同时（例如在Unix和Windows中的共享内存映射），应
把为不同平台的移植代码分离到不同的文件中，而当区别比较微小时（例如，是使用
gettimeofday. clock_gettime、f七ime还是time来获取当前时间），将移植代
码放在单一文件中。
    在移植层之外的任何地方，注意这条建议：
    #ifdef和#if是最后一招，这通常是思路不当、产品过度差异化，无理由
    “优化”或是无用垃圾聚集的先兆。在代码中，它们就是诅咒。GNU的
    /usr/include/   stdio．h就是典型的悲剧。
    ~Doug McIlroy
    在移植层#ifdef和#if的使用是允许的（如果控制得当）。在此之外，应该尽量
限制使用，只用于有条件地触发#include。
    决不要占用系统其它部分的命名空间，包括文件名、错误返回值以及函数名。若育
共享命名空间的地方，应做好文档说明。
    选择一个编码规范。有关规范选择的争论会永无休止地进行下去——但无论如何，
在编写软件过程中支持多重编码规范是太困难太昂贵了，难以达到，所以必须选择某个
通用的规范。严格地坚持编码规范，代码的一致和干净优先级最高；而编码规范自身的
细节倒远在其次。
19.2.4  良好的发行制作实践
    这些指导描述了软件的发行应该如何去做，以供他人更好地下载、获取以及解包。
19.2.4.1  确保打包文件总是解包到单一的新目录下
    初出茅庐的奉献者最要避免的错误就是编制的打包文件，在解包时往往将发行版本
中的文件和目录解包到当前目录中，这很可能会覆盖已经存在的文件。决不要这样做。
www.pdf365.com
19.2与开源开发者协同工作的最佳实践
451
    相反地，应确保所有的档案文件都有一个共同的、以项目名命名的目录部分，如此
一来它们可以解包到一个直接位于当前目录下的顶级目录。为了方便，该目录名应该同
tarball的主干名相同。这样，例如，一个叫做foo-0. 23．tar.gz的文件包，希望能够
解压到一个叫做foo-0. 23的予目录中。
    例19.1展示了一个makefile技巧，假设发行的目录名为“foobar"，而SRC包含一
系列发布文件，可以这样来完成：
例19.1  tar文件包制作过程
foobar-$ {VERS） .targz :
 @ls  $ （SRC）   I  sed  s : ^ : foobar-$ {VERS） / :  >MANIFEST
 @ （cd  . . ;  In -s  foobar  foobar-$ （VERS》
 {cd  . . ;  七ar -czvf foobar/foobar-$（VERS） tar.gz  'cat  foobar/MANIFEST'
 @ （cd  . _ ;  rm foobar-$ （VERS》
19.2.4.2包含README文件
    在源码发行版本中包含一个路标文件README。按照古老的习俗（从1980年以前
发端于Dinnis Ritchie本人，而80年伐早期在Usenet上传播开来），这是勇敢的开拓者
在解包源码之后阅读的第一个文件。
    README文件应该短小精简容易阅读。确保只是一份介绍，而不是长篇累牍。在
README文件中应该包括如下的良好内容：
    1．项目的简短描述。
2．指向项目站点的链接（如果存在）。
3．开发者编译环境的注意事项以及潜在的移植性问题。
4．描述重要文件和子目录的路标。
5．编译及安装的指令或者指向同样内容的文件（通常是INSTALL文件）。
6．维护者光荣榜列表或者指向同样内容的文件（通常是CREDITS文件）。
7．项目的最近新闻或者指向同样内容的文件（通常是NEWS文件）。
8．项目邮件列表地址
UNIX编程艺．术
  www.pdf365.com
452
第1 9章开放源码：在Unix新社区中编程
    曾经有段时问，该文件通常命名为READ .ME，然而这与浏览器存在严重的不兼容问
    题，所有的浏览器往往都假定.ME后缀表示该文件并非文本，只能下载而不能浏览。这
    种做法已被废除。
    19.2.4.3尊重和遵从标准文件命名实践
    甚至在阅读README文件之前，勇敢的开拓者可能已经快速浏览了软件解包后顶级
    目录中的文件名。这些文件名本身也承载了信息。坚持一定标准的命名习惯，可以让开
    拓者得到有价值的线索，以得知接下来该浏览什么样的文件。
    这里是些标准的顶级文件名及其含义。当然，并不是每个发行版本都需要所有文件。
    README
    最先被阅读的路标文件。
    INSTALL
    配置、编译和安装指导。
    AUTHORS
    项目贡献者列表（GNU惯例）。
    NEWS
    最近的项目新闻。
    HISTORY
    项目历史。
    CHANGES
    修订版本之间重大更改的日志。
    COPYING
    项目许可证条款（GNU惯例）。
    LICENSE
    项目许可证条款。
    FAQ
    项目常见问题解答的纯文本文档。
    注意整体上的习惯，文件名一律大写表明是关于软件包的供人阅读的元信息，而不
    是关于编译构件的。README文件源自早期自由软件基金的开发经验。
UNIX缟程艺术
    www.pdf365.com
19.2与开源开发者协同工作的最佳实践
453
    拥有FAQ文件可以让你省很多力气。当关于项目的某个问题经常出现时，就加到
FAQ文件中；然后引导用户在发送问题或者错误报告之前首先阅读FAQ文件。一个发
展良好的FAQ可以减少项目维护者一个数量级的负担，甚至更多。
    为每个发布编写一份标有时间戳的HISTORY或NEWS文件是非常有价值的。别的不
说，这可以帮助确定在专利侵犯诉讼案中的先前证明（虽然还未在任何人身上发生，但
最好先预备着）。
19.2.4.4为可升级性设计
    随着新版本的不断发布，软件也不断变化着。有些更改无法向后兼容。相应地，设
计软件的安装布局时，应认真考虑，以确保多个软件版本能在同一系统中共存。对于库
来说这尤其重要——不能强求所有的客户端程序都同API的更改保持同步的升级速度。
    Emacs、Python以及Qt项目对此有个良好的实践：以版本号来命名目录（另一项被
FSF作为惯例的实践）。Qt库安装后的层次类似这样（$（ver）是版本号）：
# Where you find moc
# Where you find .so
 # Where you find header files
    正是由于这种组织，多重版本才可共存。客户端程摩必须指定其需要的版本，当然，
需要付出点小的开销，不要弄乱相关接口。这个良好实践避免了象Windows臭名昭著的
“DLL地狱’’的失败模式。
19.2.4.5  在Linux  提供RPM
    在Linux下可安装二进制软件包的事实标准格式是Red Hat Package Manager，即
RPM。在多数流行的Linux发行中均得到支持，其它所有的Linux的发行版本实际也有
支持（除了Debian和Slackware；Debian可以从RPM安装软件）。相应地，在项目站点
同时提供可安装的RPM和源码包是个绝佳的主意。
    在源码包文件中包含RPM的spec文件，并设置～个选项可以从makefile生成
RPM，这也是个好主意。spec文件应该具备．spec扩展名；这样才能让rmp一t选项在
压缩包中找到它。
UNIX编l程艺-术
    www.pdf365.com
                           r0
                -rl  -r-l  n
    r  S-l  r  r
    V      r-     r  V
            \-J，L rt rt
          IIII
七  LJ  JJ  _U  U
U q U  q  q
rl  -H  rl  .+  r+
r+  r-l  -l  r+  -l
r  1-1  r  u  s-l
rn  S  S   rn   cn
:j  :j  :j  o  U
454
第1 9章开放源码：在Unix新社区中编程
    额外的风格要点，编写可以自动生成spec文件的shell脚本，自动分析项目的
makef ile或version．h文件而插入正确的版本号。
    注意：如果应用源码RPM，应使用BuildRoot让程序在/tmp或/var／tmp下编译。
如果不这样，在运行make install的过程中，安装过程将会把文件安装到最终的位置。即
使文件有冲突或是并未想要实际安装时，这个过程也会发生。在完成以后，文件已经安
装而系统的RPM数据库却毫不知晓。此类糟糕的SRPM行为，是个雷区，应该远离。
19.2.4.6提供校验和
    提供二进制文件的校验和（压缩包、RPM等等）。这将允许人们验证文件是否损坏
或是否被木马程序侵入。
    尽管有好几个命令来干这个（例如sum以及cksum），但最好还是使用一个密码安
全的哈希函数。GPG软件包的-detach-sign选项提供这种能力：也可以使用GNU命令
md5 sum。
    对于发布的每个二进制文件，项目网页应该列出校验和及其生成命令。
19.2.5  良好的交流实践
    软件和文档，如果除自己之外无人知晓它们的存在，那将毫无益处。要是将项目放
到互联网上，则可以蒂助招揽用户和合作开发者。这里是一些标准的做法。
19.2.5.1  在Freshmeat上发布通告
    可以在Freshmeat<ht tp：／/www．freshmeat．net>上发布通告。这个组织的读者
群众多，也是网络技术新闻的主要提供者。
    不要设想用户从头一直阅读自己的通告。所以在通告中应该一直保留至少一句关于
软件目的的说明。糟糕的说法像这样：“宣告FooEditor最新的发布版，现在速度快了十
倍。”优秀的例子是：“宣告最新的FooEditor发布版，为盲打者设计的文本编辑器，现
在速度快了十倍。”
www.pdf365.com
19.2  与开源开发者协同工作的最佳实践
455
19.2.5.2在相关的主题新闻组上发布通告
    找到～个直接与应用程序相关的Usenet主题组，然后在那儿发布通告。但应该克制，
只在与代码实现功能相关的地方张贴。
    如果（例如）正发布使用Perl语言编写的IMAP服务器查询程序，就一定应该张贴
到cornp．mail．imap。而不应该张贴到comp．lang．perl上，除非程序也同样是Perl
前沿技术的启发实例。
    通告应包含项目网站的URL。
19.2.5.3建立一个网站
    如果试图围绕项目建立坚实的用户和开发者社区，那应该拥有一个项目网站。网站
上需要包含如下一些标准的东西：
●  项目说明（项目存在的理由、项目受众等等）。
●  项目源码的下载链接。
●  如何加入项目邮件列表的指导。
●  常见问题回答列表（FAQ）。
●  项目文档的HTML版本。
●  相关或竞争项目的链接。
优秀项目网站的实例请参考第16章。
    建立网站的一个简单方法就是将项目放到那种专门提供免费主机服务的站点上。在
2003年年中，晟重要的两个站点是SourceForge（这是专有合作工具的展示和测试站点）
以及Savannah（作为一种意识形态的声明，它存放了很多开源顼目）。
19.2.5.4提供项目邮件列表
    私有的开发用途的邮件列表可以让项目合作者以此交流和交换补_J’，这是个标准的
惯例。一些人希望能尽早得到项目进展信息，你应该为他们准备一个通告列表。
    如果正在管理一个名为“foo"的项目，开发者列表应该是foo-dev或
foo- friends;通告列表应该是foo -announce。
    ～个非常重要的决策是“私有”开发列表到底应该有多私有。在设计讨论中更广泛的
参与常常是件好事，但是如果列表相对开放，迟早就会有些用户在其上询问一些初级问
UNIX编茬艺术
  www.pdf365.com
456
第1 9章开放源码：在Unix新社区中编程
题。如何最好地解决这个问题的答案各种各样。仅有文档告知新用户不要在开发列表中
询问初级问题不是个办法；必须以某种方式加以强调。
    通告列表应严格控制。通信量最多一月几条；这个列表的整体目标是，向希望知道
某些重要事情何时发生的人们提供信息，但并不需要知道日常繁冗的细节。如果这个列
表在他们的邮箱中开始带来严重的混乱，许多人会立刻取消订阅。
19.2.5.5发布到主要的档案站点
    关于主要开源存档站点的详细说明参考第16章“何处找”部分。应该将软件包发布
到这些站点上。
    其它重要的站点包括：
O    The Python  Software Activity  <http : / /www . py七hon . org> site （for software
     written in Python）.
O    The CPAN <h七tp : //www . language .perl . com/CPAN>， the Comprehensive
     Perl Archive Network （for software written in Perl）.
o     The Python Software Activity<http : //www _ py七hon . org>  （ Python裎序）   。
O    The CPAN <ht七p : //www. language .perl . com/CPAN>， the Comprehensive
     Perl Archive Network  （ Perl程序）  。
19.3许可证的逻辑：如何挑选
    许可证条款的选择涉及这样的决定，软件作者是否希望对人们怎样处理软件施加某
些限制。
    如果根本就不想做任何限制，应该把软件放到公共域里去。在每个文件头都包含如
下的文本是很恰当的做法：
Placed in public domain by J. Ramdom Hacker， 2003. Share and enjoy!
    这样做就等于放弃了版权。任何人都可以对代码的任何地方做任意改动。再也没有
比这更自由的了。
    但是很少有开源软件是真正像这样发布在公共域的。一些开源开发者希望能够使用
他们对代码的所有权来确保代码可以保持开放的状态（这往往采取GPL）。而另外～些
仅仅期望控制代码的合法公开；所有开源许可证共通的一点就是对软件不作任何担保。
www.pdf365.com
19.5各种开源许可证
457
19.4为什么应使用某个标准许可证
    同开放源码定义保持一致并广泛为人所知的许可证，已经具备长期建立的传统默认
解释。开发者（以及他们关心的用户）知道这些许可证究竟意味着什么，并且理性地承
担所涉及的风险和折衷。因此，如果可能，应使用oSI站点所载的许可证之一。
    如果必须编写自己的许可证，请确保得到OSI的认证。这可以避免许多的争论和额
外开销。除非曾经亲身经历过，不然你无法想象Usenet上许可证谴责战的激烈程度；许
可证被认为是涉及开源社区核心价值近似神圣的盟约，人们的情绪都变得非常激动。
    更进一步，如果许可证在法庭上当作证词，已经确立的传统解释的存在或许就非常
重要。到本书写作时（2003年年中）还没有案例支持或反对任何开源许可证。然而，法
律原则是（至少是在美国，并且或许其它存在习惯法的国家，例如英国和其余的英联邦
国家），法庭应按照产生许可证和契约的社区所能预料的行为和实践来解读许可证和契
约。这样，就有充分的理由相信，当最后不得不由法庭系统来处理的时候，开源社区的
实践将有决定意义。
19.5各种开源许可证
19.5.1  MIT或者×Consortium许可证
    最宽松的自由软件讦可证是这样的，授予无限权利的拷贝、使用、修改和对修改拷
贝的再发行，只要在所有修改的版本中保留版权和许可证条款。接受这种许可证就意味
着放弃控告维护者的权利。
    可  以  在  OSI  站  点  <hL Lp：／/www．opensource．org／licenses／mit
-license．htrnl>找到标准X Consortium许可证的模板。
19.5.2  经典BSD许可证
    比上面稍严一点的许可证，授予无限权利的拷贝、使用、修改，以及对修改拷贝的
再发行，只要在所有修改的版本中保留版权和许可证条款，并且在广告和软件包相关的
文档中包含致谢。受让者也必须放弃控告维护者的权利。
UNIX编程艺_术
  www.pdf365.com
458
第1 9章开放源码：在Unix新社区中编程
    最初的BSD许可证是这类许可证最著名的。在血统上可以追溯回BSD Unix的自由
软件文化中，这个许可证甚至使用在离伯克利数千英里之外的地方编写的自由软件上。
    BSD许可证的次要变种更改了版权所有人和删除了对广告的要求（实际上等价于
MIT许可证），也并非不常见。注意在1999年年中，加州大学技术转让办公室（Office of
Technology Transfer of the University of California）废除了BSD许可证中的广告条款。所以
BSD软件中的许可证的限制已经更宽松了。如果选择BSD方式，我们强烈推荐使用新式
（没有广告条款的）而非1日式许可证。广告条款被废除了，因为这导致了确定授权广告
构成时，在法律和过程上的极端复杂性。
    可以召E OSI站点<http：／/www．opens ource．org/licenses/bsd  -license．html>
找到BSD许可证的模板。
19.5.3 Artistic许可证
    下一个稍严点的许可证授予无限的拷贝、使用和本地修改的权利。允许再发行修改
后的=I进制版本，但是限制修改源码的再发行以保护作者和自由轶件社区的利益。
    Artistic许可证为Perl而设计，广泛使用在Perl开发者社区，它就是此类许可证。它
要求被修改的文件包含“显著声明”，表示已经被修改过。也要求发布更改者让更改可
以自由获取，并努力将其传播回自由软件社区。
    可以在  OSI  站点<http：／／WWW，opensource．org／licenses／artistic
-license．html>找到Artistic许可证的拷贝。
19.5.4通用公共许可证
    GNU通用公共许可证（及其派生，Library或“Less”GPL）是最广泛使用的单一自
由软件许可证。如同Artistic许可证～样，若修改后的文件带有“显著声明（ prominent
notice）’’则允许修改源码再发布。
    GPL要求，如果程序包含了任何处于GPL涵盖下的部分，则整个程序都处于GPL
涵盖之下。  （触发这项要求的确切情况并不会让每个人都能清晰理解）。
    实际上这些特殊的要求使得GPL比其它常用的许可证都要严格。（在针对同样的目
标问题时，Larry Wall编写的Artistic许可证回避了这个问题。）
www.pdf365.com
19.5各种开源许可证
459
    可以在FSF的copyleft站点<ht tp：／/www．gnu．org/copyleft．html>找到指向
GPL的链接以及如何应用的指导。
19.5.5  Mozilla公共许可证
    Mozilla公共许可证支持开源软件，但是可以链接闭源的模块和扩展。它要求发行的
软件（被涵盖代码，Covered Code）仍然保持开源，但附加软件，如果通过良好定义的API
来调用，允许保持闭源。
    可以在  OSI  站点<http：／／www，opensource．org／licenses／MPL-I. 1.
html>找到MPL许可证的模板。
UNIX编腥艺-术
  www.pdf365.com
www.pdf365.com
函
  来：  【机与机遇
Futures:
Dangers and Opportunities
The best way to predict thefuture is to invent以，
    预测未来最好的方法就是去创造未来。
    /97/年XEROX PARC会议上的发言
    -Alan Kay
    历史远未结束。Unix将继续成长变化。围绕Unix的社区和传统也将继续演进。试
图预见未来有些投机，但我们也许可以从两个方面预测：首先，看看Unix是如何应对过
去的设计挑战的：其次，确定需要解决的问题和有待开拓的机会。
20.1  Uni×传统中的平质和偶然
    为了理解Unix的设计在未来会如何变革，我们可以先看看Unix编程风格在过去的
日子里是如何随时间而变化的。这种努力将我们直接引领到理解Unix风格的一个挑战面
前——区分平质属性和偶然属性。也就是说，分辨出哪些特征是从暂时的技术中发展而
来的，而哪些又是紧密联系于核心的Unix设计挑战——如何正确地模块化和抽象化的同
时而保持系统的透明和简洁的。
    这种区分可能是困难的，因为那些偶然发展而来的特征有时会变成平质功用。作为
UNIX编程艺术
  www.pdf365.com
462
第20章未来：危机与机遇
实例，考虑我们在第1 1章讨论过的“沉默是金”的Unix接口设计原则；该原则最初是
为了适应缓慢的电传打字机，但因为输出简明扼要的程序更容易跟脚本组合而流传至今。
今天，在大多数程序都通过GUI可视运行的普遍环境下，又有了第三个用处：寡言的程
序不会分散或浪费用户的注意力。
    另一方面，一些曾经是Unix本质的特征由于特定成本比例的变化而成为了偶然属
性。例如，旧学派Unix偏爱的程序设计．（以及像awk （1）的微型语言），逐行处理输
入流或者逐条记录地处理二进制文件，并需要在块与块之间维护上下文，由精心制作的
状态机代码实现。另一方面，新学派Unix的设计就幸福多了，可以假定程序把全部输入
读进内存而可以在需要时随机访问。实际上，现代各种Unix提供mmap （2）操作允许
程序员将整个文件映射到虚拟内存中，而J/O序列化操作的读盘写盘操作则完全被隐藏
了。
    这种变革以存储操作的经济性换取更简单透明的代码。这是出于内存成本比程序员
时间廉价的调整。1970-1980年代旧学派Unix设计同1990年后新学派Unix设计之间
的许多差别都可以回溯到相对成本的巨大转变上，今天，所有的机器赘源相对于程序员
时间来说，比起1969年要廉价好几个数量级。
    回顾过去，我们可以甄别出三个特殊的技术变化驱动了Unix设计风格中的重大变
革：网络互联、位图图形显示以及个人计算机。在每场革新中，Unix传统都通过抛弃不
再合适的偶然属性、寻找新方法来适应新技术的核心观念，从而成功战胜了挑战。生物
进化也以同样的方式。进化生物学家有个法则：  “不要以为历史起源确定了当前效用，
反之亦然”。概要地看看Unix是如何适应这些变化的，或许会提供一些线索，让我们认
识到Unix将如何适应未来我们预测不到的技术变迁。
    第2章描述了第一个变化：互联网的兴起，并从历史文化的角度，讲述了在1980年
后TCP，IP如何将最初的Unix和ARPANET文化融合为一体。在第7章，有关诸如System
V STREAMS之类的过时IPC和网络互连方法的材料，表明在接下来的十年里，许多错
误的开始、失足以及死胡同迷惑了Unix开发者。关于协议、关于不同机器间的网络互连
与同一机器上不同进程的通讯之间到底是什么样的关系，那时有太多混乱。t
1有好几年似乎ISO的七层互联网标准可能战胜TCP/IPo ISO标准由欧洲标准委员会提出，他们在政
治上言怕采用任何诞生自五角大楼的技术。唉，意气用事盖过了技术的敏锐。结果证明是过度复杂
和十分无用的，请细节有关参考[Padlipsky]。
UNIX编鹱；艺术
    www.pdf365.com
20.1  Unix传统中的平质和偶然
463
    最后当TCP/IP胜出以及BSD套接字重申Unix本质上～切都是字节流的隐喻时，迷
惑便～扫而空。IPC和网络互联都普遍使用BSD套接字，而两者的老方法大部分弃而不
用，同时，通信双方是否位于同一主机对Unix软件来说也就更无关紧要了。1990～1991
年间万维网的发明便是合乎逻辑的结果。
    1984年，TCPfIP出现的几年之后，位图图形以及Macintosh机登场时，带来了～个
更加困难的挑战。最初来自Xerox PARC和苹果公司的GUI非常漂亮，但是系统的太多
层次都捆绑在一起，让Unix程序员对这种设计感到很不舒服。Unix程序员当下的反应
就是让分离机制与策略成为一个明确准则；到1988年，X窗口系统将其确立下来。通
过将X窗口构件与完成底层图形操作的显示管理器分离，他们创造了一种架构，按Unix
的标准是模块化的、清晰的，并且随着时间，可以很容易在此基础上发展出更好的策略
来。
    但那只是问题较为容易的部分。困难部分在于决定Unix是否应该拥有统一的界面策
略；而如果是，又是什么。通过专有工具包（例如Motif）来建立统一界面策略的几个不
同努力已经宣告失败。知今，在2003年里，GTK和Qt彼此争当这个角色。而在2003
年这个问题的争论也还没有结束，我们在第II章讨论过的各种UI风格同时并存的持续
状态似乎很明显。新学派Unix设计保留命令行方式，并通过编写许多在两种风格都可以
使用的CLI引擎+GUI界面组合，来解决GUI和CLI方式之间的冲突。
    个人计算机作为技术本身并没有带来什么主要的设计挑战。386以及后来的芯片，
性能足够强大，所以围绕其设计的系统在成本比例上同Unix非常成熟的小型机、工作站
和服务器相似。真正的挑战是Unix潜在市场的变化：硬件价格的全面走低，让个人计算
机吸引了更广泛的、不太懂技术的用户群。
    专有Unix软件商习惯了把更强大系统卖给高深技术买家的丰厚利润，从未对这个实
际上更广泛的市场表示出兴趣。理所当然，朝终端用户桌面系统努力的第一次重大启动
产生于开源社区，并由于本质的意识形态原因而不断增加。到了2003年年中，市场调查
显示Linux已经占到大约40-/0～5%的份额，接近了苹果分司的Macintosh。
    无论Linux是否会充分地做得更好，Unix社区反应的本质已经很清楚。我们在第
三章Linux的分析中检视了这一点。这包捂采取一些取自别处的新技术（例如XML），
并且付出了许多努力将GUI移植到Unix世界。但是在主题GUI和安装包之下，主要
www.pdf365.com
第20章未来：危机与机遇
的重心依然是模块化和清晰的代码一一为严肃、高度可靠的计算和通信提供正确的基
础设施。
    诸如Mozilla和OpenOffice.org的大规模桌面开发始于1990年代末，其发展历史很
好地展示了我们所说的重点。在上述两个开发例子中，社区反馈中最重要的议题并不是
要求增加新特征，也不是安排发布日期——而是对巨大的单体程序的厌恶以及一致感觉
在那些巨大程序成为障碍之前，必须瘦身、重构、分解成块。
    尽管伴随着许多创新，但所有对这三个技术的响应都保持着Unix的设计准则——模
块化、透明性、机制同策略分离及其它我们在本书早前描绘的品质。Unix程序员在30
年风雨中学到最有经验的回应，就是回到最初的准则——优先从流、命名空间、进程等
Unix基本抽象中得到更多效用，而不是增加新的东西。
20.2  Plan 9：未来之路
    我们知道Unix的未来看起来会怎样。
在贝尔实验室编制了Unix的研究组设计。
它被称作“来自贝尔实验室的Plan 9”2，由
Plan 9尝试重做Unix，做更好的Unix。
    设计者在Plan 9中尝试应对的核心设计挑战是整合图形和无处不在的网络互联，使
它们成为好用的Unix式框架。他们保曰了Unix的选择，尽可能多地通过单一大型文件
层次命名空间来访问系统服务。实际上，他们是在此基础上改进；许多在Unix中需要通
过不同专用接口的功能，比如BSD套接字、fcntl （2）以及ioctl（2），在Plan 9中都可通
过在类似设备的专用文件上使用最普通的读写操作来完成。为了可移植性和易访问性，
几乎所有设备接口都是文本的而非二进制的。许多系统服务（包括视窗系统在内）都是
文件服务器，以特殊文件或目录树来表示服务资源。通过将所有的资源都表示成文件，
Plan 9把访问不同服务器资源的问题转变成访问不同服务器文件的问题。
2名字来源于1958年的电影，《Plan 9from Outer Space））（外层空间第九计划），该片被当作“最糟
糕的”而写进历史。（不幸的是，榜单似乎并不正确，1966年有部甚至更糟的影片叫做《Manos: The
Hands of Fate》（Manos:命运之手），少数看过的人可以作证）。文档，包括描述架构的技术文件，
以及可以安装在PC机上的完整源码和发布包，都可以通过搜索短语“Plan 9 from Bell Labs”得到。
UNI×编程艺术
www.pdf365.com
20.2  Ptan 9：未来之路
465
    Plan 9将这种“比Unix更Unix’’的文件模式和一个全新的概念整合在一起：私有命
名空间（ private namespace）。每个用户（实际上，每个进程）都可以拥有自己的系统服
务视图，通过创建自己的文件服务器装配树（ mount tree）。有些文件服务器的装配树将
由用户手动设置，其它的在登录时自动建立。这样（如同Plan 9from Bell Labs的技术资
料指出的一样）“/dev/cons总是指终端设备，而/bin/date则指date命令正确的运
行版本，但是这些名字代表的文件依赖于环境，例如执行date机器的架构等等”。
    Plan 9最重要的特征是，无论何种实现，所有挂载的文件服务器都具备相同的类文
件系统接口。有些可能相对于本地文件系统，有些相对于通过网络访问的远程文件系统，
有些相对于在用户空间运行的系统服务器实例（比如窗口系统或另～种网络栈），还有
些相对于内核接口。对于用户和客户端程序而言，它们没有区别。
    Plan 9技术资料中的有个例子就是实现FTP访问远程站点。在Plan 9下并没有ftp（l）
命令，而存在一个ftpfs文件服务器，每个FTP连接看起来兢像是挂载一个文件系统。在
挂载点下，对于文件和目录的open、read以及write命令，都由ftpfs自动地转换为FTP
协议事务。这样，所有普通的文件处理工具，例如/s（1）、  mv（l）以及cp（l）都可以正常
工作：无论是在vrP装配点下，还是跨越到其它用户眼中的命名空间。用户（或是脚本
和程序）能够注意到的唯一不同就是不尽一致的检索速度。
    PJan 9还有许多其它值得推荐的地方，包括一些问题重重Unix系统调用接口的再造、
摒弃了超级用户概念的，以及许多其它有趣的再思考。它的血统没有污点，设计优雅，
而且揭露了Unix设计中的一些严重错误。
    同大多数二次系统不同，在许多地方Plan 9都创造了比其前身更简洁更优美的体系。
但它为什么没有统治世界呢？
    有人会提出许多特殊的理由——缺乏重大的市场努力、文档的稀少、许可证和费用
的困惑和阻碍。对于那些不熟悉Plan 9的人，似乎它的主要功能就是作为关于操作系统
研究有趣论文的题材。但在先前，Unix自身已经就超越了各种障碍吸引了无数为之献身
的追随者，最后遍布全球。但为什么P1an 9没有昵？
    深入到历史长河的调查也许会揭开一个不同的故事，但是在2003年，看起来Plan
9昀失败仅仅是它的改进尚不足以取代它的前任。对比Plan 9，Unix似乎明显嘎吱作
响，锈迹斑斑，但是Unix的工作完成得很棒足以保持它的地位。这是个教训，提示
UNIX编程艺_术
  www.pdf365.com
466
第20章未来：危机与机遇
雄心勃勃的系统架构师：更优秀解决方案的最危险敌人，就是一个现存的、足够优秀
的代码库。
    一些Plan 9的思想已被吸收进现代的Unix，尤其是在更革新的开源版本中。FreeBSD
具备—个/proc文件系统，几乎完全借Plan 9的模型，可以用来查询或控制运行的进程。
FreeBSD的rfork（2）以及Linux的clone（2）系统调用也借自Plan 9的ork（2）。Linux的
/proc文件系统，除了当前进程信息，也附加保存了许多类Plan 9设备文件的综合信息，
几乎全部使用文本接口来查询和控制内核。Linux 2003年的实验性版本也实现了逐进程
的装配点，这是迈向Plan 9私有命名空间的一大步。不同的开源Unix版本现在朝着系统
范围内支持UTF-8的方向努力，而UTF-8正是一种实际上为Plan 9而发明的编码。3
    随着时间的推移，可能就会那样，随着Unix内部架构某些部分的渐渐老化，越来越
多的Plan 9思想将整合进Unix中。这是Unix未来一个可能的发展路线。
20.3 Unix设计中的问题
    Plan 9洗涤了Unix;但在Unix的基础设计概念集上真正所加的全新的概念足有一
个（私有命名空间）。但是还有别的基本设计概念存在严重问题吗？在第1章，我们接
触了几个Unix存在争论的失败之处。既然开源运动已经将Unix的未来设计交回到程序
员和技术员手中，那些问题就不再是我们必须永远忍受的定局了。我们将重新检视它们
以更好应对Unix未来应该如何发展的问题。
20.3.1  Uni×文件就是一大袋字节
    Unix文件仅仅是个字节大袋子，而没有其它文件属性。特别是没有能力存储有关文
件类型的信息，以及指向文件实际数据之外相关应用程序的指针。
    更普遍地，一切都是字节流，甚至包括硬件设备也是字节流。这种隐喻在早期的Unix
中取得了巨大的成功，而且，在某些地方，例如，被编译的程序不能够产生传递回编译
器的输出，的的确确是个真正的进步。管道和shell编程也正是从这个隐喻上发轫的。
3 UTF_8如何诞生的传说涉及Ken Thompson.  Rob Pike、一次新泽西的午餐以及彻夜疯狂的编程
<ht t_p：／／www.cl.cam.ac.uk／-mgk2 5/ucs／utf -8-history.txt>.
www.pdf365.com
20.3 Unix设计中的问题
467
    但是Unix的字节流隐喻太过重要，以至于如果软件对象的某些操作不是特别适合字
节流或是文件操作（创建、打开、读写删除）的话，那么Unix就存在整合的困难。GUI
对象尤其是个问题，例如图标，窗口，以及正在操作的文档。在Unix世界经典的模型中，
“一切都是字节流’’这个隐喻的唯一扩展方式就是ioctl调用，使用内核空间声名狼藉
的后门。
    Macintosh系列操作系统的发烧友往往对此咆哮不已。他们提倡～种模型，其中，单
一文件名可以既有数据“分支”又有资源“分支”。数据分支对应于Unix的字节流，而
资源分支则是名／值对的集合。而Unix支持者更喜欢文件数据自描述的方式，这样，同
种类的元数据都有效地存放在该文件中。
    Unix方法的问题在于写文件的每个程序都必须清楚自描述的方式。这样，例如，如
果我们需要文件携带类型信息在其中，涉及该文件的每个工具都得小心，要么原封不动
地保留该类型域，要么解析之后重写。尽管这在理论上可以实现，但在实践中太脆弱了。
    另一方面，支持文件属性会产生难以应付的问题，什么样的文件操作应该保留文件
属性。很明显，具名文件的复制应该拷贝源文件的数据及属性．但是如果我们cat（1）文件，
将其输出重定向到一个新的名字又该如何？
    答案依赖于属性实际上是否真是文件特性，还是以某种特殊方式作为不可见的前编
码或后编码与文件数据捆绑在一起。这样问题又变为：属性对何种操作可见？
    远在七十年代，Xerox PARC文件系统设计就在这个问题中不断挣扎。它们创造了一
个序列化打开（open serialized）调用，返回同时包含内容和属性的字节流。如果应用在目
录上，就返回目录属性和目录中所有文件的序列化结果。这种方法是不是一直都有改善，
并不清楚。
    Linux 2.5已经支持附带任意名／值对来作为文件特性，但在写作本书时，并没有为太
多的应用程序所用。Solaris最近的版本也有几乎等价的特征。
20.3.2  Unix对GUI的支持孱弱
    Unix的经历证明了使用众多隐喻作为框架的基础是个威力巨大的策略（回忆我们在
第13章关于框架和共享上下文的讨论）。现代GUI核心的可视隐喻（文件由图标表示，
打开靠点击，点击会激发某个设计好的处理程序，通常能够创建和编辑这些文件）也证
UNIX编程艺求
  www.pdf365.com
468
第20章未来：危机与机遇
明了是成功而持久的。自从Xerox PARC在七十年代先驱性开拓以来，这些就紧紧地抓
住了用户和界面设计者。
    尽管最近做出了相当多的努力，在2003年，Unix仍然只是蹩脚地、勉强地支持这
种隐喻——层次太多，约定太少，构建程序太过于简陋。Unix老手典型的反应就是怀疑
这折射出GUI隐喻本身更深层次的问题。
    我认为产生这样的问题部分是由于我们仍未正确理解隐喻。例如，在Mac上，
  把一个文件拖到垃圾桶去是删除，但把文件拖到某个磁盘上却又是复制，而打印
  时却又不能把文件拖到打印机的图标上去，那需要通过菜单才能完成。我还能够
  继续举例下去。它像OS/360上的文件操作，那会儿还没有Unix简单（但不简陋）
  的文件思想。
-Steve Johnson
    对于类似的效应，在第Il章我们引用了Brain Kernighan和Mike Lesk的话。但是这
个疑问并不能简单归罪于GUI就停止了，因为尽管GUI存在许多缺点，但终端用户却有
巨大的需要。设想，如果我们能够在设计用户交互层面上，把隐喻弄正确明白，Unix就
能够优雅地支持它了？
    答案是：也许不能。我们在思考字节袋子模型是否先天不足时就接触到这个间题。
Macintosh风格的文件属性或许可以帮助提供一种机制，支持更为丰富的GUI。然而这
似乎并不是完整的答案。我们需要仔细思考，才能得出结论，一个真正强大的GUI框
架究竟是什么样的一一而且，同样重要地，又如何同现存的Unix框架整合在一起。这
是个难题，需要基础性的顿悟，但在喧闹而令人困惑的大众软件工程或学术研究巾还
未出现。
20.3.3文件删除不可撤销
    有过VMS经验的人，或是还记得TOPS-20的人，往往怀念这些系统的文件版本功
能。删除或打开并修改现存文件，实际上只是以一种包含版本号的可预知方式重命名文
件，只有对版本文件明确的删除操作才会真正地删除数据。
    Unix没有这种功能，其小小代价是，在因打字疏忽或shell通配符结果不符而错误删
除文件，把用户惹怒。
    这个问题好像并没什么可预见的前景，会在操作系统级别上得到更改。Unix开发者
www.pdf365.com
20.3 Unix设计中的问题
469
喜欢清晰、简单的操作，用户告诉什么他们就做什么，即使用户指令等于“向我开枪”
的命令。Unix开发者本能的辩解就是重申：保护用户免受自我损害，应该是GUI或应用
程序级别的事，而非操作系统。
20.3.4 Unix假定文件系统是静态的
    某种角度上，Unix世界的模型完全是静态的。程序的运行总被设想为暂时的，所以
文件和目录环境在整个执行中都可以当成静态的。如果某个指定的文件或目录发生了改
变，没有标准的、良好的方式来让系统通知应用程序。当编写长期运行的用户界面软件，
如果又希望知道环境的改变时，这就会成为重大的问题。
    Linux具有文件和目录更改通知功能4，有些BSD的版本也复制了这个功能，但尚无
法移植到其它Unix。
20.3.5作业控制设计拙劣
    除了挂起进程（在本身，微不足道地增加了调度程序负担，并不是那么令人讨厌）
的能力之外，作业控制就是在多重进程中切换终端。不幸地，操作系统只做了最简单的
部分——确定触发了哪个键——而把所有难题当皮球似地踢给了应用程序，例如保存和
恢复屏幕的状态。
    该功能真正良好的实现对于用户进程应该完全不可见：没有专用的信号，不需要保
存和恢复终端模式．不需要应用程序定时重绘屏幕。其模型应该是，虚拟的键盘必要时
连接到真正的键盘（如果没有连接，在请求输入时会遭到阻塞），以及一个虚拟屏幕，
必要时可以显示在真正的屏幕上（当没有显示时，无所谓阻塞不阻塞输出）：而以同样
的多路复用方式，系统应该可以多路复用磁盘、处理器等等，而用户程序根本就不受影
响。5
    正确的做法要求Unix tty驱动跟踪整个当前屏幕的状态，而不仅仅只是支持行缓存
区，并且当一个挂起的进程恢复到前台运行时，需要在内核级知道终端的类型（可以求
4在fcntl（2）下查找F—NOTIFY。
5本段基于Henry Spencer在1984年的分析。他继续注意到作业控制对于POSIX及后来的Unix标准
是需要和适合认真考虑的，因为它渗透到了每个程序，所以在任何应用程序到系统的接口都必须考
虑。因此，POSIX认可了这个错误设计，而正确的解决方案却因“不在讨论范围”而甚至没有考虑
过。
UNIX编程艺术
  www.pdf365.com
470
助于一个后台进程）才可以正确地恢复。
离某个对话，例如xterm或Emacs作业，
型的）。
如果没有做好，Unix内核不能够从一个终端分
然后又将其配接到另一个终端（可能是不同类
    随着Unix的使用已经转向X显示和终端模拟器，作业控制就变得相对不那么重要
了，而也就没有曾经那样的破坏力了。然而，仍然讨厌的是没有suspend/attach/detach等
操作，这种功能对于在不同登录中保留终端对话的状态非常有用。
    叫做screen（1）的通用开源程序解决了这些问题中的好几个6。然而，必须显式地
由用户调用，既然这样，就不能保证在每个终端对话都拥有其功能；同时，在功能上与
之重叠的内核级代码也还没有移除掉。
20.3.6  Unix API没有使用异常
    C语言缺乏抛出附带数据的命名异常的机制。因此，Unix API中的C函数用与众不
同的的返回值（通常是。l或NULL）并设置全局变量ermo来报告错误。7
    回顾过去，这的确是许多微妙错误的发源之地。匆匆忙忙的程序员常常忽略返回值
检查。因为没有异常抛出，补救原则也被破坏了；程序流程继续进行，直到错误情形在
后来的执行中表征出某种失败或数据损失。
    异常的缺失也意味着某些理虚简单的任务——例如在具备Berkelev风格信号的Unix
版本上，从信号处理程序中退出——不得不由复杂的代码来实现，从而成为移植的障碍，
和众多错误的渊薮。
    这个问题也可能（且通常是）隐藏在Unix API对诸如Python和Java之类具备异常
的语言的接口中。
    异常机制的缺乏实际上也牵连出一个更大的问题：由于C语言是弱类型语言，所以
使用C语言实现的高级语言之间，其通信也是问题多多。多数现代的语言都将诸如链表
和字典作为基本数据类型——但是，因为这些在通用C语言中没有规范的表示，所以在
类似Perl和Python之间尝试传递链表就是一个非自然的行为，需要许多胶合代码。
存在解决更大规模问题的技术，例如CORBA，但是却往往涉及运行期的转换，并且
6 <http：／／www - math．fu-berlin．de／～guckes/screen/>是screen（1）的项目站点。
7对于非程序员，异常抛出是程序从函数过程中间跳出的一种方法。它并不是真正的退出，因为在某
个封装的过程中，抛出的异常可以被捕获代码中途拦截。异常往往用来表示错误或是不希望的情
形，意味着试图继续正常处理逻辑是毫无意义的。
www.pdf365.com
20.3  Unix设计中的问题
471
太过重量级，令人不舒服。
20.3.7  ioctl（2）和纪几t/（2）是个尴尬
    ioctl（2）和fcntl（2）机制提供一种在设备驱动中插入钩子的方法。原始的、历史的ioctl（2）
用法，就是设置波特率以及设置串行通信驱动中的帧比特，所以就产生了这个名字（“I/O
控制”）。后来，其它驱动函数可以使用ioctl调用，而fcntl（2）作为一个钩子函数增加到
了文件系统中。
    年复一年，ioctl和fc:ntl调用不断增加新的用法。但常常缺乏文档，也常常产
生移植性问题。每一个都带来一大堆繁杂的宏定义来描述操作类型和特殊的参数值。
    根本的问题同“字节大袋子”一样；Unix的对象模型孱弱不堪，没有留下自然的空
间放置太多增加的辅助操作。设计者不得不在不满意的解决方案中胡乱选择：
fcntl／ioctl在／dev中检查设备、新的专用系统调用、或是通过特殊用途虚拟文件系
统钩子加载进内核里去（例如，在Linux以及别的地方的／proc）。
    还不清楚在未来，Unix的对象模型是否会得到加强或如何加强。如果类MacOS的
文件属性成为Unix的通用特征，在设备驱动上调节各式具名属性就可卧接替
ioctl／fcntl现在的作用（这样至少不需要在接口可以使用前定义一堆宏）。我们已
经看到Plan 9使用具名文件服务器或文件系统作为基础对象，而不是文件／字节流，这提
供了另外的可能方法。
20.3.8  Unix安全模型可能太过原始
    或许root用户权限太大，对于系统管理功能，Unix应该具备粒度更细的能力或是
ACL（Access Control Lists，访问控制列表），而不是只有一个什么都能做的超级用户。
站在这一边的人们或许会辩解，许多系统程序通过set-user-ID就会拥有永久的root用户
权限；一处被攻破，就意味着全面沦陷。
    然而论据是小充分的。现代Unix允许指定用户帐户分属多个安全权限组。通过使用
执行许可以及在程序可执行时set-group-ID，每个组的作用就可以像文件程序的ACL。
UNIX编程艺-术
  www.pdf365.com
472
理论可行，却很少使用，可以这样认为，对ACL的需求在实践上远比理论少。
20.3.9  Unix名字种类太多
    Unix统一了文件和本地设备——都是字节流。但是通过套接字访问的网络设备在不
同的命名空间却具有不同的语义。而Plan 9展示了文件同本地及远程（网络）设备可以
平滑地统一在一起，并且所有这些事情都可以通过一个命名空间来管理，当然，命名空
间可以根据每个用户甚至是每个程序动态地调整。
20.3.10文件系统可能有害论
    拥有文件系统根本就是个错误？自从1970年代晚期起就一直存在有趣的研究，研究
持续对象存储，研究根本没有全局共享文件系统，而将磁盘存储当作巨大交换区，做任
何事情都通过虚拟对象指针来完成的操作系统。
    这条阵线上现代的努力（例如EROS8）提示这样的设计可以提供大量的好处，包括
被证实的安全策略一致性以及更高的性能。然而必须注意到，如果Unix是个失败，它所
有的竞争者都同样是失败；没有作为主要产品的操作系统都跟随EROS的领导。9
20.3.11  朝向全局互联网地址空间
也许URL扬名得还不够。关于Unix未来的方向，我们把最后的话留给Unix的发明者；
    我未来的理想就是开发一个文件系统的远程按口（也就是Plan 9），然后使
其在互联网成为标准实现，取代现在的HTML。那实在是酷毙了。
-Ken Thompson
8 http：／／www - eros-.s .org／
9 Apple Newton、AS/400小型机以及Palm手持设备上的操作系统可以认为是例外。
www.pdf365.com
20.4 Unix的环境问题
473
20.4  Unix的环境问题
    Unix旧有的文化在开源运动中大部分进行了自我再造，在灭亡的边缘挽救了我们，
但这也意味着开放源码的问题现在就是我们自己的问题。
    问题之一就是如何让开源开发获得持续的经济支持。我们重新植根于Unix早期的
合作开放进程。我们已经在很大程度上，在抛弃私用专有系统的技术争论上取得胜利。
我们已经想出了许多方法，在比1970～1980年代更平等的地位上，同市场和管理人员
合作，并且在许多地方我们的革新都获得了成功。在2003年，开源Unix和它的核心
开发组，达到了如大型机般受人尊敬和权威的地位，这在1990年代中期是不敢想象的。
    我们已经走过了很长的路，但是我们还有更长的路要走。我们知道哪种商业模式
在理论上管用，而且我们现在甚至可以指出一些零星的成功，展示了那些商业模式在
实践中也确实运营良好；当然，现在我们必须显示那种模式可以可靠地运营更长的时
间。
    这并不一定是个容易的转变。开放源码将软件业转变成服务业。服务提供商（想
想医疗和法律行业）并不会注入更多资本的比例来扩张；那些仅仅尝试追加固定成本，
就期望得到高产出的做法，注定会被饿死。合理的选择可以归纬为卖唱（通过小费或
捐款），经营街角小店（一种小型的、低开销的服务商务），或是找到一个富有的赞
助人（某些大商家为其商业目的而需要使用及修改开源软件）。
    总而言之，技工的小时工资随着汽车的降价而上升10，同样的原因，雇用软件开发
者的费用也会如预料中地提高。而个人和商家也越来越难以获得投资。会有许多程序
员富裕起来，但是仅有少数几个能成为百万富翁。这实际上是进步的标志，无能的就
被竞争出局。但这也将表示整个软件环境气候的一大变化，可能意味着投资者将失去
他们仅存的、在赞助软件启动中很少的利益。
io~-完整的讨论，参见《The Magic Cauldron》 [Raymond01]。
UNIX编程艺术
  www.pdf365.com
474
第20章未来：危机与机遇
    一个有关真正大型软件商维护越来越困难的子问题是如何组织终端用户测试。历
史上，Unix文化首要关注内部架构，这意味着，能够提供最终用户舒适界面的价值，
从未被我们当作程序构建的基础。如今，尤其是把在目标瞄准同微软和Apple竞争的
开源Unix中，这一点正在改变。但是最终用户界面需要实际用户系统地测试一一这存
在～些挑战。
    实际最终用户测试需要机构、专家以及一定水准的管理，然而以分布自愿团体为
特征的开源开发却难以部署这些。也许因此，开源的字处理器、电子表格以及其它生
产型应用程序不得不留在由大商家赞助的研究计划手中，例如OpenOffice.org，只有它
们才能提供那种开销。开源开发者往往认为单…商家就意味着单点失败，并且非常担
心这种依赖，但更好的解决方案还没有发展出来。
    这些是经济问题。我们还有其它更政治化的问题，因为成功招徕敌人。
    有些是老对头啦。微软要成为计算机世界不可动摇垄断者的野心，使得在我们知
道我们卷入战争的五年前，就把打败Unix作1980年代中期该公司的战略目标。在2003
年年中，尽管好几个成长性市场遭到Linux大范围的侵占，微软仍然是世界上最富有
和最疆大的软件公司。微软很清楚地知道必须打败新学派的开源Unix以求生存。而为
了获胜，必须毁灭或是羞辱产生它的文化。
    Unix借开源社区之手回来了，而同互联网自由文化的结合，也带来了新的敌人。
  好莱坞和媒体巨头感到了互联网深深的威胁，对不受控制的软件开发发起了多重攻击。
’  现存的法案，例如Digital Millennium Copyright Act已经被用来起诉那些为媒体权势不
  喜的软件开发者（最臭名昭著的案件就是针对能够复制加密DVD的DeCSS软件）。
  预期的计划例如所谓的可信计算甲台联盟（ Trusted Computlng Platform Alliance）和微
  软的Palladium威胁11要让开源开发成为非法活动一一而如果开放源码消亡了，Unix也
  很可能随之消亡．
    Unix、黑客以及互联网～起反对微软和好莱坞及媒体巨头。这是我们需要获胜的
斗争，不仅是出于我们传统的专业主义、我们对技艺的热爱，以及共有的部族忠贞，
还有更重要的原因使这个斗争如此重要。政治可能性渐渐成形于通信技术一一谁可以
使用、谁应该检查以及谁可以控制。政府和法人对网络内容的控制，对什么人可以利
用计算机的控制，都是对政治自由一个长期严重的咸胁。恶梦般的场景就是这样，垄
断商家和中央独裁，永远的自然同盟者，相互勾结并炮制理论，越来越多地制订规章、
2 1参考TCPA FAQ<http：／／WWW - cl．cam. ac．uk／～rj aj 4/tcpa- faq．html>，由一个著名安全
专家所做的一个相当毛骨悚然的可能性分析摘要。
www.pdf365.com
20.5 Unix文化中的问题
475
无情镇压以及罗织电子言论罪名。在反对这一切的斗争中，我们是自由的战士一一不
仅仅是为了我们自己的自由，也同样是为了所有人的自由。
20.5  Uni×文化中的问题
    围绕在Unix社区的文化问题，同Unix自身的技术问题以及伴随成功而来的挑战
同样重要。至少存在两个重大的问题：小挑战是内部转型，大挑战是我们要克服历史
上的优越感。
    小挑战是老学究与新派开源大众之间的摩擦。Linux的成功，特别地，对许多老一
辈的Unix程序员来说并不完全舒服。部分是由于代沟的问题。Linux小子们吵闹活泼
天真愉悦的狂热行为激怒了老一辈，他们自从七十年代就接触Unix了，而且（常常公
正地）认为自己更有智慧。而小子们在老一辈失败的地方不断取得成功的事实更激化
了这种现象。
    在2000年，当花了三天时间参加了一个Macintosh开发者会议之后，我愈发清晰
地意识到了更大的心理问题。沉浸在一个同Unix世界假设基础完全相反的编程环境中
真是个给人启迪的经历。
    Macintosh程序员最为关心用户体验。他们是建筑设计师和装饰家。他们由外而内
进行设计，首先就问“我们需要支持哪种交互？”，然后构建隐藏其后的狸序逻辑来
满足用户界面设计的需求。这就会导致程序外观非常漂亮而内部结构脆弱摇摆。一个
声名狼藉的例子，在MacOs 9以前的发布版本中，内存管理器有时对于那些退出但仍
占用内存的程序，竟然要求用户手动回收内存。Unix支持者本能地反感这类病态设计：
他们不能理解Macintosh的人怎么能够忍受这些。
    比起来，Unix程序员先考虑基础设施。我们是水管工和砖瓦匠。我们的设计由里
而外，构建强大的引擎以解决抽象定义问题（例如“我们如何通过不可靠的链接和硬
件而获得从A点到B点的可靠信息包流交换”）。然而引擎外，我们的包装难看，甚
至接口常常相当丑陋。date（l）. find（l）和ed（l）就是臭名昭著的例子，但还有其它成百上
千的程序也是这样。Macintosh人也本能地反感这种病态设计；他们也不能理解Unix的
人怎么能够忍受这些。
    两种设计哲学都有正确的一面，但是两个阵营却难以理解彼此的立场。Unix开发者
典型的反应就是把Macintosh软件当作是给无知人的绣花枕头而抛弃，然后继续构建能
UNIX编}翟艺_术
  www.pdf365.com
476
第20章未来：危机与机遇
够吸引其它Unix开发者的软件。如果终端用户并不喜欢，那是终端用户的不对：他们了
解多了之后，会回来的。
    在许多地方，这种狭隘思想已经为我们工作得很好。我们是互联网和万维网的守护
者。我们的软件和我们的传统统治了重大计算，统治了必须是全天候可靠的、宕机时间
最少的应用程序。我们真正极端擅长构建坚实的内部结构；虽非完美，但无论如何没有
其它的软件技术文化能够在任何地方接近我们的纪录，这是非常值得骄傲的。
    问题是我们愈发必须直面的挑战，是需要更多丰富视图的挑战。世界上大多数的计
算机都不是放在服务器机房里，而是在那些终端用户手中。在Unix早期的日子里，在个
人计算机之前，我们的文化把自身部分定位为大型机神父，那个大铁玩意管家的反叛者。
后来，我们吸收了早期小型机狂热者给人们以力量的理想。但是今天，我们成为了神父；
成为了网络和大铁块的守护者。我们潜在的要求是，如果想使用我们的软件，就必须
学会像我们一样思考。
    在2003年，在我们的态度中存在深深的矛盾一一精英和大众之间的摩擦。我们希
望影响和改变这世界92%的人，对他们来说，计算机就意味着游戏、多媒体、漂亮的
GUI界面、  （对他们来谠最技术的）邮件软件、字处理器以及电子数据表。我们正花
费主要努力在诸如GNOME以及KDE等设计来给予Unix美妙外观的项目。但在内心
深处，我们仍旧认为自己是精英，不能或不想去甄别或是倾听以王大婶为代表的普通
用户需求。
    对于非技术最终用户，我们构建的软件往往不是令人迷惑无法理解，就是样子难
看故意屈尊似的，又或两者兼有。即使我们怀着尽可能高的热情尝试去做对用户友好
的事，却可悲地前后矛盾。对于完成这份工作，我们从旧学派Unix继承的许多态度和
反应都是不恰当的。即使我们想要倾听或帮助王大婶，我们也不知道如何去做一一我
们设计了我们的服务类目、关心她并提供“解决方案”，但她却发现这同她存在的问
题一样可怕。
    我们在文化上面临的巨大挑战是，我们是否能够不再过分依赖那些已经很好地为
我们工作过的设想——我们是否能够承认，不仅是在思想上，也是在日常实践的施行上，
承认Macintosh支持者也抓住了要点。他们的要点也是基于普遍实际，而非Mac专用方
式，在“The Inmates Are Running the Asylum[CooperJ”，一部具有深刻见解和充分论证
的书籍中，其作者称（别管偶尔的一些奇谈怪论），交互设计乜包含了大量坚实的真理，
需要为每个Unix程序员所知道。
    我们可以避开这～点：我们可以保留教父地位，祈求碰到最好最聪明的少数人——
一小撮关注我们历史作用的知识精英——作为软件内部架构和网络的守护者。但如果我
www.pdf365.com
20.6信任的理由
477
们这样做，就很可能走向衰落，直到最后失去几十年来一直支持我们的动力。自有别
的东西去服务人们；自有别的东西会赢得动力和金钱并拥有未来92%比例的软件。而
这个可能成功的机会，无论是不是属于微软，都将使用我们所不喜欢的软件和实践来
完成。
    或者我们真正接受这个挑战。开源运动正努力这样去做。但在过去用来解决其它问
题的相同工作和思想是不够的。我们的态度必须在根本上有所转变，虽然困难。
    在第4章，我们讨论了抛弃设想限制以及在解决技术问题上“抛弃过去”的重要性，
建议同禅宗思想类似的超然和“初衷”。我们拥有～个需要更多种类的分离工作。我们
必须学会在王大婶面前虚心，并且放弃某些我们长期坚持的、曾使我们如此成功的偏见。
    明显地，Macintosh文化已经开始同我们的文化相融合-MacOS X拥有Unix的底
层架构，并且在2004年Mac开发者（虽然在某些方面有所斗争）进行了思想上的调整
来学习注重内部架构的Unix美德。我们的挑战将是，相互地，吸纳Macintosh以用户为
中心的美德。
    还有几个表明Unix文化摆脱其狭隘性的迹象。其中之一就是Unix开源社区似乎开
始融入被称为“敏捷编程”12的远动。我们在第4章注意到，Unix程序员已经愉快地抓
住了重构的概念，那就是敏捷编程思想的重点之一。
    重构，以及其它的敏捷编程概念，例如单元测试和围绕情景设计，似乎清晰地说明
和突出了那些迄今已经在Unix传统广泛但隐性流传的实践。另一方面，Unix传统可以
给敏捷编程带来长期经验的积累和教训。随着开源软件不断获得市场份额，可以想象这
些文化将会融合在一起，如同过去互联网和早期Unix文化在1980年后的融合一样。
20.6信任的理由
    Unix的未来充满难题。我们确实想让它走好吗？
    三十多年来，我们在应对挑战中兴盛起来。我们开拓了软件工程中最好的实践。我
们创造了今天的互联网和万维网。我们编制了有史以来最庞大、最复杂、最可靠的软件
系统。我们打破了IBM的垄断，我们正在开展反对微软霸权的运动，并且已经深深地震
慑了它。
12更详细的敏捷编程介绍，参考《Agile Manif est。》（敏捷宣言）<http：／／agilemanifest。，。rg／>
    UNI×编rkc:艺术
    www.pdf365.com
478
第20章未来：危机与机遇
    而无论如何，胜利并不是全面的。在1980年代，我们同意专有权对Unix的占领，
这几乎毁了我们自己。长期以来，我们忽视了低端市场，忽视了非技术的终端用户，因
此让微软钻了空子，大幅度地降低了软件的质量标准。甚至精明的观察家多次断言我们
的技术、我们的社区、我们的价值死亡了。
    但我们总是可以重振旗鼓地王者归来。我们犯了错，但我们从错误中汲取了教训。
我们的文化薪火相传：我们已经从早期的学院黑客、ARPANET实验者、微机狂热者以
及其它许多文化中汲取了精华。而开源运动已经复兴了我们早年的激情和理想，今天，
我们的力量，我们的规模将远胜过去。
    迄今为止，打赌Unix玩家会输的人总是聪明一时糊涂一世。我们能赢——只要我们
想赢。
www.pdf365.com
附录A
缩写词表
Glossary of Abbreviations
API
The most important abbreviations and acronyms Uksed in the main text are defined here.
本书中最重要的简称和缩写定义如下。
Application Programming Interface（应用编程接口）。同可链接程序库或操作系统内
核或两者通信的过程调用集。
BSD
    Berkeley System Distribution;也作Berkeley Software Distribution;名字具体来源已不
可考。在1976到1994年之间，由加利福尼亚大学伯克利分校计算机科学研究组发布的
Unix版本统称为此，许多开源Unix都从此继承而来。
CLI
    Command Line Interface（命令行界面）。有些人认为太陈1日了，但在Unix世界仍然
很有用。
CPAN
    Comprehensive Perl Archive Network。<http：//cpan．org/>，Perl模块和扩展的
网络中心库。
GNU
    GNU's Not Unix （GNU不是Unix）!自由软件基金的项目，原意是开发一个Unix昀
克隆版本，但完全自由的软件；GNU是其递归的缩写名。这个项目并没有取得完全成功，
但是产生了许多现代Unix开发的基本工具，包括Emacs和GNU编译器集（GNU Compiler
Collection，GCC）。
www.pdf365.com
480
附录A缩写词表
GUI
    Graphical User Interface（图形用户界面）。应用程序界面的现代风格，与老式CLI
或roguelike风格不同，使用鼠标、窗口及图标，由Xerox PARC中心在1970年代创造。
IDE
    Integrated Development Environment（集成开发环境）。代码开发的GUI工作台，功
能包括符号调试器、版本控制以及数据结构浏览。在Unix下通常并不使用，原因在第
15章讨论过。
IETF
    Intemet Engineering Task Force（互联网工程任务组）。负责定义诸如TCP/IP之类互
联网协议的实体。一个松散平等的组织，主要由技术人员构成。
IPC
    Inter-Process Communication（进程间通信）。独立地址空间运行进程的数据传输方
法。
MIME
    Multipurpose Internet Mail Extensions（多用途互联网邮件扩展）。一系列的RFC，描
述了在RFC-822邮件中内嵌二进制和multipart信息的标准。除了使用在邮件传输之外，
MIME也被一些重要的应用协议（如HTTP和BEEP）作为基础使用。
00
    Object Oriented<面向对象）。一种编程风格，将处理的数据和处理数据的代码封装
在一种称作对象的闭合容器内。相比之下，非面向对象编程更容易暴露内部的数据结构
和代码。
OS
    Operating System（操作系统）。机器的基础软件；完成任务调度、分配存储空间以
及在应用程序之间提供默认的用户界面。操作系统提供的功能及其一般性的设计哲学，
强烈影响着围绕其宿主机而成长起来的编程风格和技术文化。
PDF
    Portable Document Format（可移植文档格式）。控制打印机和其它成像设备的
PostScript语言，设计来将数据流输出给打印机。而PDF是一系列的PostScript页，并包
入标记描述，可以方便作为显示格式使用。
www.pdf365.com
附录A缩写词表
481
PDP-11
    Programmable Data Processor l l（可编程数据处理器11）。可能是历史上最成功的单一
大型机设计；于1970年首次发布，1990年结束发布，并且是VAX的直接祖先。PDP-lI
是第一款主要的Unix平台。
PNG
    Portab】e Network Graphics（可移植网络图形）。万维网联盟（The World Wide Web
Consortium）的位图图形图像标准和推荐格式。这是二进制图像格式的一个优雅设计，
曾在第5章讨论。
RFC
    Request For Comment（请求评注）。一个互联网标准。当其文档作为提议被提交、
处于某种目前虽不存在但期望的正式承认过程时，就称为RFC。而正式的承认过程从未
实体化。
RPC
    Remote Procedure Call（远程过程调用）。使用IPC方法，试图创造～种错觉，进程
间互相交换数据就像是在同一地址空间，这样可以方便地（a）共享复杂的数据结构，和（b）
就像函数库互相调用一样，忽略时延和其它的性能考虑。想维持这种错觉异常困难。
TCP/IP
    Transmission Controj Protocol/lnternet Protocol（侍输控制协议／互联网协议）。自1983
年从NCP（网络控制协议）转变而来的互联网基本协议。提供可靠的数据流传输。
UDP/IP
    Universal Datagram Protocol/lnternet Protocol（通用数据报协议／互联网协议）。提供小
型数据包的不可靠低迟延传输。
UI
    用户接口（界面）。
VAX
    正式名称Virtual Address Extension（虚拟地址扩展）：由DEC（后来同Compaq合
并，再后来又与HP合并）开发的经典大型机设计。VAX第一次发布是在1977年。1980～
1990年间，VAX是最重要的Unix平台之一。针对微处理器的再实现正在开发中。


附录
贡献
Contributors
     Anyone who has attended a USENIX conference in a fancy hotel can tell you that a
sentence like "You're one of those computer people， aren't youl" is roughly equivalent to
"Look， another amazingly mobile form of slime mold.t" in the mouth of a hotel cocktail
waitress.
    只要在大饭店参加过会议的人就会跟你说这么一句：  “你是搞计算机的，不是吗？”
基本上等同于酒店鸡尾酒会女招待嘴里的“瞧，粘土人还能动呢！’’
- Elizabeth Zwicky
Ken Arnold是创造4BSD Unix发布版的成员之一。他编写了最初的curses（3）库，也
是最初的rogue（6）游戏作者之一。他也是Java Reference Manual （Java参考手册）的合作作
者之一，是Java和00技术的头牌专家之一。
Steven M. Bellovin于1979年在北卡罗莱纳大学创造了Usenet（]司Tom Truscott祁Jim
Ellis）。在1982年加入AT＆T贝尔实验室，在那里，他完成了安全领域、密码系统、以
及Unix系统和其它操作系统网络的前沿研究。他是互联网工程任务组的积极成员，以及
美国国家T程院（ National Academy of Engineering）的成员。
    Stuart Feldman是Bell实验室Unix开发组的成员之一。他编写了rnake（1）和f77（1），
他现在是IBM负责计算研究的副总裁。
Jim Gettys laJ Bob Scheifler、Keith Packard -起，是1 980年代晚期X窗口系统的主
要架构者之一。他编写了X库的相当部分，编写了X许可证，以及清晰地指出了“机制
而不是策略“的X设计中心信条。
www.pdf365.com
O  者
496
附录C贡献者
    Steve Johnson编写了yacc（1），并用它编写可移植C编译器（Portable C Compiler，
PCC），从而取代了最初的DMR C编译器，成为后来Unix C编译器的鼻祖。
    Brain Kernighan已经是Unix社区良好风格的最好诠释者。他已经编著或合著了好
几本不可或缺的、关于Unix传统的经典作品，包括《The Practice of Programming（编程
实践）》、《The C Programming Language （C编程语言）》、《The Unix Programming
Environment （Unix编程环境）》。在Bell实验室时，他合作开发了awk（l）语言，并在troff
系列工具的开发中发挥了主要的作用，包括eqn（l）（同Lorinda Cherry合编），pic（l），
以及grap（l） （Jon Bentlev）。
    David Kom编写了Korn shell，在风格上，是几乎所有现代Unix shell设计的先驱。
他创造了UWIN，为被迫使用Windows者设计的Unix模拟器。David也在文件系统和移
植工具的设计研究中有相当成就。
    Mike Lesk是Bell突验室最初Unix研究组的成员之一。除了许多其它的贡献以外，
他还编写了ms宏命令包，tbl（）和refer（l）字处理工具，lex（I）词法分析生成器，以及
UUCP  （Unix-to-Unix copy program）。
    Doug Mcllroy在贝尔实验室领导创造了Unix的研究组，发明了Unix管道。他编写
了spell（1）、diff/l）、sort（】）、join（1）、tr（1）以及其它经典的Unix工具，同时帮助定义了
Unix文档的传统风格。他也在存储分配算法、计算机安全以及数学定理自动证明方面做
出了开拓性的工作。
    Marshall Kirk McKusick实现了4.2BSD快速文件系统，并且是Berkeley Computer
Systems Research Group （CSRG）的计算机机研究科学家，亲历了4.3BSD和4.4BSD的开
发和发布。
    Keith Packard是最初XII代码的主要贡献者。在1999年开始的第二阶段开发中，
Keith重写了X的渲染代码，使其性能更强而体积大幅减少，从而可用于手持电脑和PDA
中。
    Eric S．Raymond自从1982年就一直在编写Unix软件；在1991年，编辑了《The New
Hacker's Dictionary（新黑客字典）》，并一直从历史和人类学角度研究Unix社区和互联网
黑客文化。在1997年，这个研究产生了《The Cathedral and the Bazaar（大教堂和集市）》，
帮助定义（或重新定义）和激发了开源运动。他现在维护着三十多个开源软件项目以及
十几个关键的FAQ文档。
www.pdf365.com
附录C贡献者
497
    Henry Spencer是1970年代Unix走出Bell实验室时第一次拥抱Unix浪潮中程序员
的领袖。他的贡献包括公共域的getopt（3），第一款开源的字符串处理函数库，以及使用
在4.4BSD、后来作为POSIX标准参考的开源正则表达式引擎。他也是著名的C语言专
家。他是C News的合作者，而且多年来都一直是Usenet的理性之声以及最受尊敬的老
常客。
Ken Thompson发明了Unix。
UNIX编程艺：术
  www.pdf365.com
www.pdf365.com
附录D
无根的根：无名师的Unix心传
Rootless Root: The Unix Koans of
Master Foo
编者导言
    《无根的根》这部心传的收录集在西山纯净的空气中得以保存数十年，它的发现在
学术圈中掀起轩然大波。这些出土文稿是否为早期Unix教义的新发现？抑或仅是后世高
明的赝品？那些半神秘的人物，像尊者Thompson、Ritchie和Mcllroy，是否以此发展出
我们所处时代的教义？
    答案无法确知。各方争论均被收入那本经典之作，  《编程之道》（The Tao of
Programming）.1但是《无根的根》在论调风格上都与那本James松散诗化的逸闻译作有显
著差异，所有一切都围绕着卓越而谜…般的无名师。
1  The Tao of Programming可查看网页<http：／/www．canonical．org/-kragen/tao-of -
programming．ht ml>.
UNIX编程艺：术
  www.pdf365.com
500
附录D无根的根：无名师的Unix心传
    把AI Koans（AI心传）与之相提并论颇为恰当；2在AI Koans中也可发现《无根的根》
作者的着笔痕迹。它和Loginataka（箴言剧）也有密切关联：3实际上，  《无根的根》和
Loginataka大有可能是出自一人之手笔，此人正是无名师。
    Tales of Zen Master Greg（禅祖Greg传说）也值得～说，4对“九寸钉”的引用已经使
人对其古老程度产生怀疑，它对《无根的根》影响微乎其微。
    毫无疑问，可以认为标题借鉴了Mumon的禅宗经典读物5《无门之门》（The Gateless
Gate）。数个心传都可看作是对Mumon的回应。
    无名师应该归于东派（New Jersey）还是西派（尊者Thompson往Berkeley的划时代之
旅）。如果不能回答这个问题，我们甚至也许无法宣称无名师确实存在。它也许只是一群
教师，也许是一批达摩尊者。
    即使把无名师的传说附会在单独的人身上，那他最看重的学生Nubi怎么办？Nubi
是个有血有肉的形象，是个完美的门徒。也许有人会想起佛祖最喜爱的追随者阿难达的
传说，但他的性格特质在神话传说中并没留下痕迹，而佛祖也是永恒的谜。
    最络，我们可做的便是讲述故事的本原，抽丝剥茧，挖掘其中真意。
    《无根的根》还在编写之中，素材的整理和解释都是难题。难题解开后，将被收录
到未来版本中。
2  AIKoans  可  查  看  网  页  <ht tp：／／www．catb. org/-esr/j argon/html/Some-AI
-Koans．html>.
3 The Loginataka可查看网页<http：／/www．catb. org/-esr/faqs/loginataka．html>.
4 Tales of Zen Master Greg可查看网页<http：／／www - gu．uwa．edu．au/users/greg/>．
5'IheGateless  Gate  可查看网页<hLtp：／／www．ibibli。，。rg/ zen/cgi-bin/koan
-index．pl>.
www.pdf365.com
附录D无根的根：无名师的Unix心传
501
无名师与万行码
无名师曾对来访的程序员说：“Unix传统上认为，一行shell脚本胜过万行C程序。”
这个程序员自以为对C极其精通，说：  “这不可能。Unix内核正是用C实现的。”
    无名师回道：  “确是如此。不过，Unix传统上认为，一行shell脚本胜过万行C程
序。”
    程序员颇为沮丧：“但是在C中我们可领会到尊者Ritchie的智慧。我们与操作系统
和机器合而为一，可以获取无与伦比的性能。”
    无名师回道：  “诚如你言。不过，Unix传统上认为，一行shell脚本胜过万行C程
序。”
    程序员冷笑着想愤然离去。无名师向学生Nubi颔首示意，Nubi在黑板上写下一行
shell脚本，问道：“尊敬的程序员，看看这行管道。用纯C实现，是不是要一万行C代
码？”
    程序员沉吟念诵。最终他承认如此。
    “你需要多长时间来实现和调试那个C程序？”Nubi问道。
    “很长”，来访程序员承认。“但傻子才会干这个而不去完成更有价值的任务。”
    “那么谁更了解Unix传统？”无名师问道。“是写一万行代码的，还是看到任务的
无谓而不去编码的？’’
    听到此，程序员眼中一亮。
UNIX编程艺术
  www.pdf365.com
502
附录D无根的根：无名师的Unix心传
无名师与脚本狂
    无名师和学生吃早饭时，从黑客大陆来了个陌生访客。
    “I hear y00 are very l33t，”他说。“PI33z teach m3 all y00 know”。（我听说你很牛，
请把你会的都教给我。）
    无名师的学生面面相觑，都没听懂这类粗鄙言语。无名师微笑道：“你想弄懂Unix?”
    “1 want to b3 a wizard haxOr"，陌生人回答，  ‘‘and Own ever30ne's bOxen。”（我想
当个顶尖黑客，能掌握所有人的机器。）
    “我不教这个’’，无名师答道。
    陌生人很激动。“DOOd，y00 r nothing but a pOser”，他说。“If y00 n00 anything，y00
wud t33ch m3。”（哥们儿，敢情你没真本事啊，你要知道点儿东西就教给我了。）
    “有条路，”无名师说，  “可以将你带入真知。’’他在纸上写了个IP地址。“黑掉
这台机器，这对你来说应该不费什么力气，它的管理员不称职。回来后告诉我你发现了
什么。”
    陌生人鞠了一躬就离开了。无名师把他的早饭吃完。
    几天过去了，几个月过去了。没人再想起陌生人。
    数年过去了，黑客大陆来的陌生人回来了。
    “你混蟹！”他说，  “我黑掉了那台机器，你说的没错，太容易了。但是我被FBI
抓起来扔进监狱了。”
    “好”，无名师说，“你可以继续下一课了。”他在另一张纸上写了个IP地址交给
陌生人。
    “你疯了？”陌生人喊道。  “经过这事，我再也不黑别人的机器了。”
    无名师脸现微笑。“这里就是”，他说，  “真知的开始。”
    听到此，陌生人眼中一亮。
www.pdf365.com
附录D无根的根：无名师的Unix心传
503
无名师的双路论
    无名师如是教导学生：
    “达摩教义有条准线，这在尊者Mcllroy的符咒“做一件事并做好”中得到体现。
它强调软件应当具有简单一致的行为，这符合Unix惯例，人和其它程序便都很容易想象
其心理模型。
    “但达摩教义还有另一条准线，体现在尊者Thompson的符咒“有怀疑，用穷举’’
中，很多经文都教导我们现在得到的90%，比等不来的100%更有价值。它强调实现的健
壮性和简单性。
    “现在告诉我：什么程序符合Unix传统？”
    想了一会儿后，Nubi沉思道：
    “老师，这些教义有冲突。”
    “简单的实现往往对边缘情况有欠考虑，比如资源耗竭、无法关闭竞争窗口以及在
未完成事务中超时等等。”
    “发生边缘情况时，软件行为往往不规律、难以猜测。这当然不是Unix传统。”
    无名师颔首同意。
    “另一方面，大家都知道精巧的程序很脆弱。更进一步说，每个对边缘情况的修正
往往牵扯到程序的核心算法，还牵扯处理其它边缘情况的代码。”
    “于是，对边缘情况防患于未然、确保描述的简单性，反而会使得代码过分复杂、
bug成堆、根本无法发售。这当然不是Unix传统。”
    无名师颔首同意。
    “那么，什么是正确的达库道？”Nubi问道。
UNI×编程艺．术
  www.pdf365.com
504
附录D无根的根：无名师的Unix心传
    无名师说：
    “当鹰飞翔时，它忘记爪子与地面相触？当虎捕食时，它忘记腾空的一刻？VAX只
重三斤！”
    听到此，Nubi眼中一亮。
www.pdf365.com
附录D无根的根：无名师的Unix心传
505
无名师与方法论
道。
无名师和学生Nubi在圣地行走，无名师习惯在晚间为城市和乡村的Unix新门徒布
一次，聆听者中混入了一名方法论者。
    “优化程序时不对热点进行反复衡量，就像渔夫把网撒入空湖中。”无名师说。
    “那么，”方法论者说，  “管理资源时不持续地衡量你的产能，不也像渔夫将网撒
入空湖中么？”
    “我一次碰到一个渔夫时，他正将网撒入船下的湖中，”无名师说，  “他摸了好一
会儿船底，像在寻找他的船。”
    “但是，’’方法论者说，  “如果他把网撒入湖中，为什么还要找船呢？”
    “因为他不会游泳。”无名师答道。
    听到此，方法论者眼中一亮。
UNIX编I程艺．术
www.pdf365.com
506
附录D无根的根：无名师的Unix心传
无名师的GUI论
    一晚，无名师和Nubi参加一个程序员的探讨会。有个程序员问Nubi和他的老师来
自哪所学校。当得知他们是Unix大道的追随者时，程序员颇为不屑。
    “Unix命令行工具太粗糙太落后”，他讥讽道。“现代的、设计得当的操作系统可
以在图形用户界面中做任何事情。”
    无名师一言不发，只是指着月亮。旁边的一条狗对着他的手狂吠。
    “我不明白。”程序员说。
  无名师依然缄默，指着一幅佛祖像，然后又指着一扇窗。
  “你想说什么？”程序员问。
  无名师指着程序员的头，接着指着一块大石。
  “请把话说清楚！’’程序员要求道。
  无名师深深蹙眉，轻拍程序员的鼻子两下，把他扔到旁边的垃圾箱中。
  程序员试图从垃圾堆挣扎出来之时，那条狗跑过来在他身上便溺。
  此时，程序员H艮中一亮。
www.pdf365.com
附录D无根的根：无名师的Unix心传
507
无名师与Unix狂
…个Unix狂热者听说无名师掌握Unix大道真知，便跑来求教。无名师对他说：
    “当尊者Thompson发明Unix时，他并不理解它。随后他理解了，受益了，不再发
明了。”
    “当尊者Mcllroy发明管道时，他只知道它将传递软件，并不知道它能传播思想。”
    “当尊者Ritchie发明C时，他将程序员放到缓冲溢出、堆损坏和烂指针bug的地域
中惩罚。”
    “说实话，这些尊者既瞎又蠢！”
    狂热者对无名师的用词极为愤怒。
    “这些智者”，他抗议道，“给了我们Uriix的大道。我们嘲笑他们，就是混淆是非，
比转世为牲畜和MCSE还不如。”
    “你的代码全无污点和缺陷？”无名师问。
    “不，”狂热者承认，  “没人不犯错。”
    “这些尊者之智，’’无名师说，  “就是J，解自身之愚。”
    听到此，狂热者眼中一亮。
UNIX编}程艺术
  www.pdf365.com
508
附录D无根的根：无名师的Unix心传
无名师的Unix传统论
一学生对无名师说：  “我们听说SCO公司把握着纯正的Unix。”
无名师领首。
学生继续说，  “我们还听说OpenGroup公司也把握着纯正的Unix。
无名师颔首。
“这怎么可能？”学生问。
无名师答道：
    “SCO确实把握着Unix源码，但是Unix的源码不是Unix。OpenGroup确实把握着
Unix的名称，但Unix的名称不是Unix。’’
“那么，什么是Unix传统？”学生问。
无名师答道：
“非源码。非名称。非思想。非实物。恒变，不变。”
“Unix传统是简单和空。正是简单，正是空，才使得它更强胜飓风。
    “以自然法则前行，‘在程序员手中，吸纳各种优良设计。与之竞争的软件最终必与
之相像；空，空，真空，虚无，万岁！’’
    听到此，学生眼中一亮。
www.pdf365.com
附录D无根的根：无名师的Unix心传
509
无名师与最终用户
    无名师又一次布道时，一个最终用户听说了他的智慧，跑来求教。
    他对无名师三鞠躬。“我欲学习Unix大道，”他说，  “但是弄不懂命令行。”
    一个旁观的新门徒开始嘲讽最终用户，说他脑子一锅粥，说只有经训练者、有智慧
者才配使用Unix。
    无名师抚手不语，命这个嘲笑最终用户的新门徒前坐，坐到最终用户身边。
    “告诉我，”他对新门徒说，  “你写过什么代码，有过什么突出设计。”
    新门徒嗫嚅了两句，然后沉默了。
    无名师转向最终用户。“告诉我”，他问，  “为何你要寻求大道？”
    “我用的软件并不能令我满意”，最终用户答，  “既不稳定，也不美观。听说Unix
之道尽管艰难，但超越一切，我愿抛去～切诱饵和虚像。”
    “那么，”无名师问，  “你为何想尽办法让软件帮你做事？”
    “我是个建筑工”，最终用户答道，  “这座城里的很多房屋都出自我手。”
    无名师转向新门徒。“家猫也能欺负老虎”，无名师说，  “但是猫叫永远比不过虎
吼。”
    听到此，新门徒眼中一亮。


    大多数译序是给作者说好话，顺便带动一下译本销量的，本篇是一个例外。
    《The  Art of UNIX Programming》，简称TAOUP，作者Eric S．Raymond，简称ESR。
这大概是计算机类书籍中很少见的一本课外读物。TCP/IP编程之类典型Unix编程书中
讲到的东西在这本书里面找不到，所以书里讲到的当然就是别的书里找不到的东西。读
者也许需要有相当的Unix背景、或者长期钻研某个专题，才能体会到作者的弦外之音。
ESR作为老牌黑客信手拈来的典故，如果不是在Unix里面长期浸淫，大概很难有所共鸣，
所以把这当作Unix的一部坊问史话倒也合适。
    本书总结了历史上Unix众多成功的经验和失败的教训、经时问考验和临时搭救的编
码策略、大众喜爱和小众受用的实用工具：一些被跨国界信仰地广泛接受，一些则在不
rIIJ环境中各有见地。被TAOUP总结为失败的，也许恰恰是某些工程的保命神药：总结
为成功的，也许正好是压垮另一些工程的最后一根稻草。情景各异而已。书是写给程序
员看的，因此很多观点都太过技术昧儿，比如所见即所得的编辑器不如手写标记的纯文
本更直接-90%的人会想：这怎么可能？！
    这本书是给读者增长见讽的，很多案例分析不管结论如何，读者都可以从中见到红
蓝两方的思维方式和行事方法，以及各方高手看待问题的角度。无论成功还是失败，都
只是一念之间，而读者只需要体味出这些对自己过去的、手头的、未来的项目可以有何
种借鉴，便已得其中三昧。
    网络上关于TAOUP的书评甚多，正负反响各有不少，负面评价大体集中在认为作
者视角较窄、对商业公司有偏见以及过分抬爱自己的fetchmail几方面。我个人的感觉，
Unix、尤其是开源Unix上有太多好用的丁具极欠雕琢，目标受众太过技术。ESR并未回
避这些，读者不妨多留意为数不多的痛切之笔。
UNIX编程艺_术
  www.pdf365.com
译序
    本书翻译经历～年多的时间，之前我曾经约略翻过纸版，偶尔见到一些合我胃口的
言论，于是心有灵犀认为这书不错；然而等到译到中途，便发现ESR实在是个美国愤青，
这便是课外读物和工本教程给读者的不同感受了。翻译的过程对译者是精读的过程，但
希望读者能用它打发堵车、候机、等人时的无聊时间，这书适合从任何一篇翻起。
    翻译过程颇为艰辛：何蔡两位初译，由我统稿。书中寻章摘句之处，我们尽力将其
还原。书名保持原文并给出译名，人名不译，专有名词给出原文，特意不加入任何译注。
相关背景常识、翻译感受以及付梓后的任何问题，可以在中译版网页上与我们交流。这
一年间，侯捷老师的推荐，周筠老师、方舟和兴璐两位编辑、何蔡二位给我的莫大帮助
和宽容使得本书最终面世；身边诸位好友同事也不同程度地在各个技术方面给予指导和
支持，尤其感谢bz、主任、delphij、kola几位。我的爱人王冰陪我加班，容忍我对程序
的沉迷，给我心灵的温暖，是我翻译这本书的力量源泉。
    KISS。
    姜  宏
2005年12月于北京
www.pdf365.com
序
Preface
Unix is not so much an operating system as an oral history.
与其说Unix是个操作系统，不如说是一部口述历史。
    -NeaJ Stephenson
    知识和专能差异巨大，凭借知识可以推断出该做什么，而专能让你甚至在无意之间，
条件反射似的把事情做好。
    这本书确实有关“知识”，但更着眼于“专能’’。你将学到那些Unix专家们都不自
知的Unix开发知识。少一点技术，多一些共享文化：显见和隐微的，直观和潜流的——
这是本书和大多数Unix书籍不同的地方——不止于方法，更重乎理念。
    理念于实用大有裨益，有太多设计不良的软件：体积臃肿，难于维护、移植和扩展
——这些都是蹩脚设计的症候。我们希望本书的读者能品出什么是Unix所教示的良好设
计。
    本书分为四部分：场景、设计、工具和社群。第一部分（场景）涉及哲学和历史，
为后续内容埋下伏笔。第二部分（设计）将Unix哲学的原理细分为有关设计与实现的、
更专门的建议。第三部分（工具）着眼于Unix所提供的工具，可助你解决问题。第四部
分（社群）则讲述人与人之间的事务与约定，而这正是Unix文化拥有高效能的原因。
    这本书是关于共享文他的，我从未想像过独自完成它。你会发现正剧中包含数位Unix
资深专家的客串演出，正是这些人塑造了Unix的习俗。本书曾有过公开大范围的审阅过
UNIX编腥艺．术
  www.pdf365.com
序
程，这期间我邀请这些明星人士对书稿进行评审与研论。这些意见没有湮没在本书定稿
中，而你可以在书中聆听到他们的真实声音：无论是为本书呐喊助阵、还是摇头反对。
    本书中用到人称“我们”时，我并不是虚张声势，仅以此说明这是整个社群都清楚
明了的事实。
    因为本书着力传递文化，因此加入了很多野史和坊间传说，这在技术书中并不多见。
希望你喜欢，这些东西其实是Unix程序员的教养。须弥不重，芥子不轻。我们希望以这
种方式更好地讲述故事。了解Unix的由来和变迁，会培养你对Unix风格的直觉。
    同样地，基于此，我们不打算使用回述历史的腔调。你会发现本书参考了众多时下
信息。我们不希望给你一种错觉：书里说的都是亘古不变的终极真理。参考时下的信息
这一做法，也提醒读者，三十年河东，三十年河西，眼前所见，也许过不了多久就会过
时，而需要重新检省。
    另外，本书不是C教程，不是Unix命令和API的手册，不是sed/yacc/Perl/Python
的语言参考，也不是网络编程入门，更不是巨细靡遗的令人费解的X指南。本书也不打
算带你巡游Unix内幕和体系。有很多其它的好书涵盖这些领域，本书会在适当的时候告
诉你该看哪些。
    在这些技术细节外．Unix文化有一个未见诸笔端的行工传统，以熟练工的考量，它
已经有几百万人年的发展1。本书即立足于这样一个信念：领会此传统，并将它的设计手
法应用到手边，你将成为更好的程序员和设计师。
    构成文化的是人，一直以来，获知文化的方式大约是口口相传、潜移默化。本书不
打算取代人际的文化传播，但可以促进这一过程，使你能俯耳倾听他人的心声。
1从1969到2003年，35年时间可不算短。以这期间Unix站点数量的年度曲线计算，人们在Unix
上耕作了约有5000万人年。
www.pdf365.com
序
谁应该看这本书
    如果你是个Unix编程老手，经常教导菜鸟，或者与人进行操作系统论战时无法阐明
使用Unix方案所带来的好处时，可以看看这本书。
    如果你是个C、C++或者Java程序员，有其它操作系统的开发经验，现在轮到你开
展一个Unix项目时，可以看看这本书。
    如果你是个初级或者中级水平的Unix用户，但是没什么开发经验，想学习在Unix
下如何高效地设计软件时，可以看看这本书。
    如果你不在Unix下编程却发觉Unix的传统给你带来某种启迪，那你就对了，Unix
哲学适用于其它的操作系统。因此我们会花比其它Unix书籍更多的篇幅关注非Unix环
境（特别是微软的操作系统）；当所用到工具或者案例可用于其它操作系统时，我们会
告诉你。
    如果你是一个系统架构师，正为通用市场或垂直应用准备平台方案或实现策略时可
以看看这本书。本书将帮助你了解Unix作为开发平台的强大功能，以及开放源码这个
Unix的传统所带来的开发方式。
    如果你想学到C编程的细节或者想知道怎么用Unix内核API，本书可能不适合你。
Advanced Programming in theUnix Envirortment[Stevens921是探究Unix API妁经典名著；
The Practice of Programming [Kernighan-Pike99]是每个C程序员的必读书目（任何语言的
程序员都该看看这本书）。
    这本书既重实践，更富理念：既包含警世格言，又不忘检点Unix开发中的特殊案例。
在每个警句前后，都有生动实例阐明其由来，这些例子绝不来自小儿科式的示例程序，
而均出自真实世界满眼所见的运行代码。
    我们着力避免以大量代码或者规范文件来胡乱凑数，当然这么做会让本书的写作轻
松许多（某些地方或许读起来也更轻松）。绝大多数编程书籍只授你以鱼，而本书避免
这种做法，力求培养读者“探求事情何以如此，，的感知力。
UN/X编腥艺：术
  www.pdf365.com
l∈j
坐咀
    正由于此，本书会时常请你阅读代码与规范文档，它们中极少量的内容会附在书中，
其余部分我们会在举例时告诉你如何从网上获取。
    从这些范例中汲取养分，将有助你将所学原则消化变为疱丁之技。如果你能就着一
部跑在Unix系统上的网页浏览器来读书，是再理想不过的了。任何Unix系统都适合，
但是我们将要研究的案例大多都会预装在、或者可以从Linux系统上获得，书中会提示
请你浏览或亲身感受它们。这些提示通常是按部就班的，跑开玩一会儿并不会打散整个
讲述过程的连续性。
    注意：我们虽力求，但无法给你打保票，声称我们所引用的URLs稳定可用。如果
你发现某个引用连接已陈旧过时，来点常识，用你喜爱的搜索引擎来个短语搜索。如有
可能，我们会在所引用的URLs附近给出如何搜索的提示。
    大多数缩写形式会在首次出现时伴随其全称。为方便起见，我们在附录中提供了名
词对照表。
    交叉索引通常以作者名字为主导词。带编号的脚注是那些可能会扰乱你阅读正文，
或者是易变的URLs;也可能是旁征博引的战争故事或者笑话2。
    为了使这本书不至于让非技术人员太过难读，我们邀请了一些非程序员试读，并指
出一些晦涩但起贯穿作用的词汇。我们把那些编程老手不太舍需要的名词解释也放在脚
注中。
相关引文
    一些Unix早期拓荒者的著名论文和书籍，比如Kernighan和Pike的《The Unix
Programming Environment》[Kemighan-Pike84]就是其中佼佼者，被世人尊为圭臬。而今
看来此书廉颇老矣，它没提到Intemet、万维网以及诸如Perl、Tcl和Python这些解释型
语言的新秀。
    写作本书的中途我们借鉴了Mike Gancarz的《The Unix Philosophy》 [Gancarz]。这
本书在它的覆盖范围内极其优秀，但是我们觉得需要更多内容才能反映出事情的全貌。
尽管如此我们仍对此书作者心存感激，他愈发使我们知道最简单的Unix设计手法就是最
持久耐用的。
2这个特别的脚注献给Terry Pratchett，他对脚注的用法简直是……绝了。
www.pdf365.com
l同
坐咀
《The Pragmatic Programmer》fHunt-Thomas]是一本关于良好设计的书，文风机智诙
谐，它与本书相比，倾向于软件设计工艺的另一个层面（更注重编码，而少着墨于高层
面的问题划分）。作者的哲学是其Unix领域耕耘的成果，也是本书内容极好的补充。
《The Practice of Programming》[Kernighan-Pike99]包含了一些与《The Pragmatic
Programmer》共通的内容，但更钻入Unix传统的深处。
    最后（明知道会激怒你），我们推荐《Zen Flesh，Zen Bones》 [Reps-Senzaki]，一部
重要的佛教禅宗本源的合集。对禅的引用书目遍布全书。我们将这些书目包含进来，是
因为禅为表达某种想法提供了丰富的语汇，而在软件设计中却很难烂熟于心。信奉宗教
的读者，请您不要把禅当成宗教，它是一种心灵鸡汤似的东西，纯净而没有神灵的干扰
——此即是禅。
本书的习俗约定
    术语“UNIX’’技术上和法律上讲，是The Open Group的商标，并且应该仅限于那
些通过The Open Group严格的“符合标准”认证的操作系统。奉书中我们使用其较宽松
的定义，印大多数程序员所指的，Bell实验室Unix代码的后裔或旁支。在这个意义下，
Linux（大多数例子都举自它）也算是一种Unix。
    本书也使用了Unix手册页（manual page）的传统，即以括号括起来的手册节号来标
记Unix设施。通常用于强调一个Unix命令首次出现。比如“munger（l）”可解读为“munger
程序加入存在于你的系统中，其文档位于Unix手册页的第1节”。第2节是C的系统调
用，第3节是c的库函数调用，第5节是文件格式与协议，第8节是系统管理工具。其
它节号本书未曾用到，其定义在各个Unix系统各有不同。在你的Unix外壳提示符下输
入man l man（老式的System VUnix系统可能要输入man -s l man）以获得更多信
息。
    有时我们会提及某个Unix程序（比如Emacs），后面没有手册节号而且首字母大写。
这意味这个名字代表一族Unix程序，其基本功能相同，而我们将讨论其通用特性。比如
Emacs，就包含了xemacs。
    本书很多地方我们同时给出了老式（old school）和新式（new school）解法。new-school
和rap音乐～样，开始于1990年前后。在这个含叉下，我们往往把它与脚本语言、图形
UNIX编喱；艺术
    www.pdf365.com
序
用户界面、开放源码的Unix和万维网联系起来。Old-school指代1990年以前（特别是
1985年以前）的世界：昂贵的共用计算机、专属的Unix，shell脚本和无所不在的C。值
得指出这些差异，机器越来越便宜，内存多了起来，这些有如暗流，渐渐影响着Unix编
程的风格。
所用案例
    很多编程书籍为证明某一观点而特地造出一个范例，你手中这本书不这么干。我们
的案例研究均来自真实世界，在生产环境中工作已久。下面是一些主要案例：
cdrtools/xcdroast
    这两个独立的项目通常被～并使用。cdrtools是一组刻盘工具（用关键字“cdrtools”
可以在网上找到）。xcdroast是cdrtools的图型界面前端，其项目网站为
<ht tp:／/www. xcdroast. org/>。
f etclunail
  fetchmail用于从远程邮件服务器上收信，支持POP3和IMAP邮箱协议。其主页为
<ht tp：／／www．catb．org/-esr/fetchmail>，也可以用关键字“fetchmail从网上
找到。
G工MP
    GIMP（GNU Image Manipulation Program，GNU图像处理程庠）是一个全特性的绘
画和图像处理程序，可对多种图像格式进行复杂处理。其源码可从GIMP主页
<http：／/www．gimp．org/>获得（也可以通过关键字“GIMP"从网上搜到）。
mutt
    mutt邮件客户端是目前各类基于文本的邮件客户端程序中的翘楚，提供对MIME
（Multipurpose Intemet Mail Extensions）、个人隐私辅助程序，如PGP（ Pretty Good Privacy）
和GPG （GNU Privacy Guard）等特性的绝佳支持。其源码和二进制可执行文件可以从
Mutt项目主页<http：／/www．mut七．org>获得。
xmlto
xmlto可将DocBook和其它XML文档以多种格式渲染输出，包括HTML、纯文本
www.pdf365.com
序
和PostScript。其源码和文档可在xmlto主页<http：／／cyberelk．net／tim/xmlto／>获得。
    为了将读者理解本书例子所要阅读的代码量降低到最小程度，我们尽量挑选那些可
重复使用、并能体现多种不同设计原理和设计实践的案例。出于同样原因，很多示例来
自于我本人的项目。我没想说这些例子最为恰当，只是我觉得它们对阐述我的观点非常
有用。

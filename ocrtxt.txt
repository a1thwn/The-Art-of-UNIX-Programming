
298
第1 3章复杂度：尽可能简单，但别简单过了头
    这就是复杂度的三个面孔，以及一些设计者有时往往为了规避反而掉进的陷阱。1本
章稍后我们在实例分析中将审视更多的例子。
13.1.2  接口复杂度和实现复杂度的折中
    一篇极透彻的关于Unix传统的观察来自Unix世界以外-Richard Gabriel的论文
《Lisp:好消息，坏消息以及如何获得大胜》（Lisp: Good News，Bad News，and How to Win
Big》> [Gabriel]。Gabriel是Lisp社区的长期领导者，此论文最初是作为Lisp独特设计风
格的一个论证，但是作者自己承认文章被人记得的主要原因是“The Rise of Worse Is
Better（‘差即是好’的兴起）”一节。
    文章认为：Unix和C语言有病毒般的特性；在软件设计发展过程的奋斗中，那些促
成快速传播（传染）的特征，如实现的简单性和可移植性等，比起设计的正确性和完备性更
为有效。Gabriel几乎预见了开源软件“多眼球”效应，而开源社区在1997年后的回顾
中，也将他视为他们中的一位理论家。
    较少为人所记的是，Gabriel的中心论点是关于实现和接口复杂度间的一个精准权衡，
宦正好就是我们在本章中检视的分类。Gabriel在更关注接口简单性的“MIT”哲学和更
重视实现简单性的“New Jersey’’哲学之间进行了比较，然后提出，尽管MIT哲学能够
引导软件在抽象上做到更好，但New Jersey模型（差者）更具传播特质。随着时间的推
移，人们更多的注意力都集中到了New Jersey风格，所以它提高得更快。差的变成了好
的。
    实际上，MIT和New Jersey哲学同Unix设计传统自身冲突的趋势有些相像。Unix
思想中的一个主题就是强调工具小巧锐利，设计从零开始，接口简单一致。这种观点最
著名的支持者是Doug Mcllroy。另一种思潮则强调创作简单的可工作实现，然后快速发
布，方法笨无所谓，边界情况不妨搁置。Ken Thompson的代码和他关于编程的信条常有
这种倾向。
    这两种方法间的平衡恰恰是因为有时可用复杂度换来更简单的接口，或者反之。
Gabriel最初的例子，耗时运算系统调用如何处理无法保留或屏蔽的中断，仍然是最好的
‘我们为这三个陷阱创造的名称，听起来虽然像，但是均非出自[Raymond96]中描述的已确定的黑客
行话。
www.pdf365.com
13.1谈谈复杂度
299
实例之一。在MIT哲学中，应该暂停系统调用，伺中断处理完成之后自动恢复之——这
较难实现，但接口更为简单；而在New Jersey哲学下，系统调用会返回一个错误表明已
被中断，用户必须重新执行——这实现起来非常简单，但编程接口却较难使用。
    两种方式都历经考验。Unix老手当会想起System V和BSD处理软件信号的风格，
后者追随MIT哲学，而前者来源于New Jersey思潮。在它们之间作出选择的根本迫切问
题与软件的感染性并无直接关系：如果目标是抑制整体复杂度，最愿意牺牲的是什么地
方？什么地方又最该被牺牲掉？
    一个Garbiel文章中没有提到的划时代实例来自于分布式超文本系统。早期的分布式
超文本工程，诸如NLS和Xanadu，严重局限于MIT哲学的假定：无被指物的链接在用
户界面上是一个不可接受的障碍；这就限制了系统要么只能在一个受控制的闭集文档中
浏览（例如在单个CD-ROM上），要么必须实现各种曰益复杂的复制、缓存、索引方法
来防止文档的随机丢失。Tim Bemers-Lee转而用经典的New Jersey方法解决了这个疑难
杂症。他所采用的简单实现就是允许“404: Not Found～可以作为一个响应，这使得万维
网非常轻便，并获得了广泛的传播和巨大的成功。
    Gabreil自己尽管坚持“坏的”更具感染性而往往能取得最后胜利，但关于其潜在复
杂度的相关问题是否确实是一件好事，他已经数次公开地改变了意见。他的不确定性恰
好反映了许多在Unix社区中正在进行的设计争论。
    我们并不能提供一个放之四海而皆准的答案。对于本章大多数的问题，良好品味和
工程判断力要求，情况不同，则答案不同。重要的是要培养斟酌每一个设计的习惯。正
如我们在讨论软件模块性之前的建议一样，复杂度的算盘必须打好。
13.1.3本质的、选择的和偶然的复杂度
    在理想世界，Unix程序员只愿意手工打造小巧完美的软件宝石，每个都那么小巧、
那么优雅、那么完美。然而现实中很不幸的是，太多复杂问题需要复杂的解决方案。仅
UNIX编腥艺l术
  www.pdf365.com
300
第13章复杂度：尽可能简单，但别简单过了头
仅十行的程序，再优雅也无法控制喷气客机。那儿有太多的装备、太多的通路和界面，
太多不同的处理机——太多不同操作人员定义的子系统，他们甚至连基本的约定都无法
统一。即使能够成功地将航空控制系统所有的个体软件部分都做得优雅，但拼装结果很
有可能是一堆庞大、复杂、糟糕的代码，当然（希望如此）也有个优点，就是确实能够
工作。
    喷气客机的复杂是必然的。过去有个相当尖锐的观点，不能为简单性而牺牲掉功能，
因为飞机必须要能飞。正是这个事实，航空控制系统并不会产生关于复杂度的圣战——
Unix程序员往往敬而远之。
    喷气客机当然不会对因过度复杂而导致的系统故障有免疫功能。但是在需求较灵活
的软件中，设计问题更容易辨别和考虑，也容易在预期的功能性和复杂度中做出权衡。
（此处，以及本章的剩余部分，我们从总体方面使用“功能”来包括诸如性能提升或是
接口整体修饰之类的东西。）
    为了看得更敏锐，我们需要从注意偶然复杂度和选择复杂度的区别开始。2偶然复杂
度的产生是因为没有找到实现规定功能集合的最简方法。偶然复杂度可以由良好的设计
或重新设计来去除。另一方面，选择复杂度，同某个期望的功能相关联．只能由改变工
程的目标来去除。
    当无法区分选择和偶然复杂度时，设计争论就会变得异常混乱。“什么是工程目标”
的夹杂着简单即美的问题，也会牵扯到人们是不是足够聪明。
13.1.4映射复杂度
    迄今为止，我们已经发展出考虑复杂度的两个不同等级。这些等级实际上彼此正交。
图13.1或许可以帮助澄清它们之间的关系。该图共有九个方框，每一个都列出了某种特
殊复杂度种类的常见来源。
2偶然和选择复杂度的差别意味着我们在此处讨论的分类跟Fred Brooks文章No Silver Bullet（没有银
-）[Brooks]中的本质和偶然有所不同，但是它们在哲学上都有同样的祖先。
www.pdf365.com
13.1谈谈复杂度
301
复杂度
种类
偶然复杂度
选择复杂度
本质复杂度
代码库规模    实现复杂度    接口复杂度
复杂度来源
图13.1  复杂度种类及其来源
    在本书的稍早部分我们已经接触过各类复杂度，特别是属于偶然复杂度的那种。在
第4章中，我们注意到偶然复杂度常常缘于接口设计并非正交——即没有仔细地分解接
口操作以使得每个操作只完成一件事情。偶然代码复杂度（比能够完成工作所需的更复
杂）常常来自于过早的优化。臃肿的偶然代码库往往缘于对SPOT原则的违背、重复的
代码或糟糕的组织，以至于重用机会渺茫。
    本质接口复杂度通常无法去除，除非调整软件的基本功能需求（在本章的实例分析
中我们会更多地展开这个主题）。代码库的本质大小同选择的开发工具有关，因为如果
功能清单固定不变，决定代码库规模大小最重要的因素可能就是实现语言的选择（正如
我们在第8章暗示的一样）。
    选择很难地有效的归纳可能复杂的来源，因为它们往往依赖于值得为何种功能付出
复杂度代价的精微判断。可能接口复杂度往往缘于让用户感觉更加好用、而非程序基本
功能的附加便利性。代码库规模大小的可能增涨（假设用户可视的功能和采用的算法固
定不变）通常来自于使其更具可维护性的不同实践——增加吏多注解，使用更长变量名
称等等。工程所涉及的任何方面均可产生可能实现复杂度。
    复杂度的不同来源必须以不同方法应对。代码库规模可以采用更好的工具来解决。
实现复杂度可以选择更好的算法来处理。接口复杂度必须着眼于更好的交互设计，一种
UNI×编腥艺术
  www.pdf365.com
302
第13章复杂度：尽可能简单，但别简单过了头
考虑了人类工程学和用户心理学在内的技能。这种技能，比编码能力更为少见（并可能
更加困难）。
    另～方面，处理各种复杂度，必然更仰赖于见识而非方法。通过发现更简单的方法，
可以去除偶然复杂度。依赖上下文环境判断哪些功能值得去做，可以去除选择复杂度。
而要去除本质复杂度，就只能通过对现实真谛的洞察和顿悟，从根本上重新定义所要解
决的问题。
13.1.5当简洁不能胜任
    对于Unix坚持简单的传统，往往伴随着一种错误的理解模式，Unix程序员常常认
为（有时甚至依此行事）似乎所有的可能复杂性都是偶然复杂性。更为甚者，在Unix传
统中存在一个强烈的偏好，宁可去掉功能，也不接受可能复杂性。
    这种态度的例子很容易产生（的确，本书大部分内容就是防止这个的）。干净的简约
主义让我们在多个层面上感觉良好，为此设计也是非常有价值的防范措施，能够防止软件
系统表面光鲜但内里功能不足的自然趋势。但是，计算资源以及人类的思考，同财富一样，
不是靠储藏而是靠消费来证明其价值的。同其它美学形式一样，我们需要注意何时设计上
的简约已经不再是有价值的自律形式，而开始成为一件伪装的苦行者外衣——一种实陈上
把美德作为借口来敷衍工作的纵容方式。
    这是一个危险的问题，确实太容易变成支持彻底抛弃良好设计准则的论据。Unix老
手常常羞于谈及，害怕防范复杂臃肿可能的最坚固阵线无法扼守，会将我们推向无情的
毁灭。但它避无可避。我们会在分析本章的研究实例中直接处理它。
13.2五个编辑器的故事
    现在我们将使用五个不同的Unix编辑器来作为案例。在检视这些设计时，在心中牢
记以下基准任务会非常有用：
●  纯文本编辑。即操作纯ASCII（在如今这个国际化的时代，也许是Unicode）文
  件，编辑器只知道其字节或者行结构。
www.pdf365.com
13.2五个编辑器的故事
303
●  富文本编辑。即编辑带有属性的文本：这些属性可以包括字体的变化，颜色或
    者其它类型的文本内属性（比如一个超链接）。具备这种能力的编辑器必须能
    够在某个用户界面的属性表示同磁盘上的数据表示之间进行转换（例如HTML、
    XML或其它富文本格式）。
●  句法感知。一个句法感知的编辑器知道输入事件存在语法，在识别出编程语言
    中一个范围块的开始或结束时能够自动更改缩进级别，或其它类似动作。一个
    句法感知的编辑器一般也能够以不同的颜色或特别的字体加亮文本。
●  批命令输出的输出解析。Unix世界最常见的情况就是从编辑器内运行一个C编
    译器，捕捉其错误信息，从而无需离开编辑器就能够跳至任何出错地点。
●  同辅助子进程交互。这些子进程在不同的编辑器命令间保留和维护状态。当具
    备这种能力时，会产生以下强大的结果：
    ●从编辑器内部可以驱动版本控制系统，无须离开编辑器到～个shell窗口或
    独立的公用程序就可以实施文件的检入检出（checkin/checkout）。
    ●编辑器可以作为符号调试器的前端，当发生那些诸如调试程序运行停止在
    某个断点上之类的情况时，编辑器可以自动访问恰当的文件及其文本行。
    ●通过识别指商另一个主机的文件名  （比如符合
    /us-er@host：/path/to- firle语法），可以在编辑器内编辑远程文件。
    假设拥有访问权，这类编辑器可以自动运行诸如scp （1）或ftp （l）的公
    用程序获取本地的一个拷贝，然后在保存文件时自动地将编辑后的版本传
    回远程位置。
    我们分析的所有实例都可以编辑纯文本。  （读者不应该把这种能力视作理所当然——
还有许多称之为编辑器的东西，比如“字处理器”，就太过于专用化而无法编辑纯文
本！）下面我们就开始来了解这些编辑器在处理更复杂任务时产生的不同程度的选择
复杂度。
UNIX编鼹艺-求
  www.pdf365.com
304
第13章复杂度：尽可能简单，但别简单过了头
13.2.1  ed
    ed （l）是真正Unix简约主义者编辑纯文本的方式。它自电传打字机时代就存在。3它
有一个简单俭朴的CLI:没有屏幕显示。在接下来列出的实例中，着重突出计算机输出。
ed sample．tx匕
sample. txL:  No  such  file  or directory
#这是注释行，不是命令。
抖上面的信息警告sample．txt是新创建的。
a
the quick lorown fox
jumped over the lazy dog
{}那是一个追加命令，表示向文件加入文本。
}}一个点号占据一行表示追加文本的结束。
1s/f[a-z] x/dragon/
#在第一行，用‘dragon’替换第～个匹配f后接任意a-z的小写字母再后接x的字符串。
样lowercase  alphabetic  followed  by x with  'dragon..  The
样substi七ute comrnand accepts baslc regular expressions.
}}替换命令接受基本的正则表达式。
l，$p
the quick brown dragon
jumped over the lazy dog
#从头到尾打印所育的行。
W
5 1
}}将文件写到磁盘上。‘q’命令结束编辑对话。
# editing session.
q
    对于现代读者来说这似乎难以置信，绝大多数Unix的最初代码都是用这个编辑器编
写的。有DOS经历的读者在这儿可能会辨认出这是行编辑器EDLIN的粗糙原型。
    如果把编辑器的工作定义为仅仅让用户创建和修改纯文本文件，那么ed （1）足堪
使用。从Unix设计有关正确性的观点来说，重要的是它不做别的任何事情。许多1日学派
的Unix程序员半认真地坚持所有功能比ed更多的编辑器都是臃肿的——并且少数仍然
～丝不苟的坚信这个观点。
实际上，ed是Ken Thompson对早期qedRitchieQEDl编辑器的有意简化，qed编辑
3年轻读者可能不会知道那些终端是打印的。在纸上打印。非常慢。
www.pdf365.com
13.2五个编辑器的故事
器——跟ed非常相似（而且是第一款以Unix特有方式使用正则表达式的编辑器）但具
备Ken故意放弃的多缓冲区能力。Ken认为它不值得付出更多复杂度。
    ed （1）及其所有衍生品最显著的特征就是命令的对象操作格式（上述对话实例展示
了’p’命令作用的明确指定行范围）。可以有相对强大的语法来指定行范围，或者以数字
形式，或者用正则表达式来模式匹配，或者用当前行和末行的简捷表示方式。多数编辑
操作都可以在任何范围起作作。这是一个良好的正交性实例。
    今天，耐（1）主要作为在脚本中由程序驱动的编辑工具来使用——具有更复杂交互
模式的编辑器并不适合此用。有～个很相似的称为e（1）的变种，增加了一些例如命令
提示之类的交互特性；在一些非常罕见的情况下，例如必须通过非常缓慢的串行线来完
成编辑，或者在某个不同寻常的崩溃恢复情况下，程序库支持需要运行的其它编辑器无
法访问，ed （1）就有用武之地了。正是这些原因，每个Unix版本都包含了一个ed的实
现，而多数Unix版本也同样包含了ex。
    sed（1），这个在第9章提到的流编辑器也与ed紧密相关；许多基本命令完全一样，
但sed设计为通过命令行开关调用，丽非读取标准输入。
    几乎所有的Unix程序员都已经偏离了苦行和简约主义的美德，通常使用至少拥有
roguelike这种面向屏幕界面的编辑器。4然而，坚持ed的虔诚道出了许多值得关注的Unix
思想。
13.2.2  vi
    最初的vi（1）编辑器是将可视的roguelike界面套到ed （l）命令集上的首次尝试。
与ed一样，它的命令通常是单键式，特别适合可以盲打的人使用。
    鼠标支持、编辑菜单、宏、指定键盘绑定，或是任何形式的用户定制在最初的VI中
都没有。追随ed的信仰，VI的信徒认为这些功能特性的缺乏恰恰是个优点。从这个角度
来说，Vl编辑器最重要的一个美德就是，在新的Unix系统上可以立刻开始编辑，而无须
转移原来的定制或担心默认的命令绑定会危险地与习惯相悖。
    Vi使初学者饱受挫折，这是由于其简明扼要、单键击发式命令所致。它有一个模式
界面——或者处于命令模式，或者处于文本插入模式。在文本插入模式，可用的命令仅
4著名的一个Usenet帖子就是ed信仰的例证之一，读者可以通过网络搜索“Ed is the standard editor”
找到这个a尽管都知道这是个调侃，但毫无疑问这决不是完全的玩笑话。多数黑客都会将此认作是
”Ha ha，only serious”的实例。
UNIX编，程之≥长
    www.pdf365.com
306
第13章复杂度：尽可能简单，但别简单过了头
仅只有使用ESC键退出该模式以及（在新版本中）光标移动键。在命令模式，键入的文
本会被解释成各种命令，而且还会给文本内容带来奇怪的（可能是毁灭性的）后果。
    另一方面，VI拥趸特别吹捧的一个命令集特性就是继承来自ed的对象操作格式。大
多数扩展的命令也可以自然地用于任何行范围。
    年复一年，vi已经相当庞大了。现代的版本加入了鼠标支持、编辑菜单、无限撤销
操作（最初的Vi仅仅只支持撤销最近的一次命令），独立缓冲区的多重文件，以及用运
行控制文件进行定制。然而，运行控制文件很少使用，与Emacs相比而言，内嵌通用脚
本的使用也不流行。相反的，通过加入C代码到编辑器本身，VI实现已经发展出独立完
成任务的能力，例如C代码的语法感知以及C编译器错误信息的输出解析。VI编辑器不
支持子进程的交互。
13.2.3 Sam
    Sam编辑器5在八十年代中期由Rob Pike在贝尔实验室编制而成。Sam是为我们将在
第20章讨论的Plan 9操作系统而设计的。虽然Sam编辑器在贝尔实验室外并不广泛为
人所知，但许多参与了最初Unix设计而后来又继续用Plan 9工作的开发者都很喜欢，包
括Ken Thompson奉人。
    Sam编辑器是ed -个相当直接的后裔，比VI更接近它们的父辈ed。Sam仅仅只加
入了两个新观念：curses风格的文本显示和能够用鼠标选中文本。
    每个Sam对话都只有一个命令窗口，以及一个或多个文本窗口。文本窗口编辑文本，
命令窗口接受ed风格的编辑命令。鼠标用来在两个窗口间进行切换，以及用来在文本窗
口内选择文本区域范围。这是个干净、正交、无模式的设计，避免了VI的大部分接口复
杂度。
    绝大多数命令操作默认地施用在一个可以由鼠标拖拽操作绘出的选中区域上。一个
命令的选中区域也可以用ed方式的行范围指定来设置，但Sam允许用户选择比行单位
更精确的粒度，这让Sam获得了相当可观的威力。因为可以通过鼠标选择和快速地在缓
冲区（包括命令缓冲区）间切换，所以Sam不需要和vi编辑器等价的默认（命令）模式。
许多VI的扩展命令都成为多余，而在Sam中被删除了。总之，Sam编辑器只在ed命令
5  ht t-p : / /plan9 . bell-labs _ com/ sys/doc/sam/ sam . h七ml
UNIX编I程艺：术
www.pdf365.com
13.2五个编辑器的故事
307
集的17个命令中增加了12个，总共加起来不超过30个。
    Sam编辑器的四个新命令加上两个继承自ed （1）和vi （l）的命令，作为应用正则
表达式的方法来完成施用在选定文件或文件区域上的任务。这些为命令语言提供了有限
的但是有效的循环和条件功能。然而没有方法可以命名或给命令语言过程加上参数。语
言同样不能交互控制一个子进程。
    Sam -个有趣的特点是它被分成了两个部分，将处理文件和搜索的后端从处理屏幕
界面的前端分离开来。这个“分离引擎和接口”的实例拥有立杆见影的实践收益，尽管
程序具有GUI部分，但仍然可以很容易地通过一个低带宽的连接就可以编辑远程服务器
上的文件。同样，前端和后端可以相对容易地重新改用。
    Sam编辑器，像Vl的最近版本一样，支持无限撤销操作。Sam编辑器被设计为既不
支持富文本编辑，也不支持输出解析，还不支持子进程交互。
13.2.4  Emacs
    Emacs无疑是现存最强大的程序员编辑器。它是一个庞大的、功能丰富的程序，具
有强大的灵活性和可定制能力。正如我们在第14章Emacs Lisp部分描述的一样，Emacs
拥有一个完整的编程语言，可以编写出任何强大的编辑器功能，
    与vi不同，Emacs没有各种界面模式；相反地，命令通常都是以控制字符或者ESC
在前引导。然而，在Emacs中，可以将任意的命令绑定到任何的按键序列，而且命令可
以是库中的或定制的Lisp程序。
    Emacs可以编辑多个文件，每个置于独立的缓冲区内，同时支持在这些不同的缓冲
区内移动文本。在X下的版本本身具有鼠标支持。
    绑定在Emacs按键上的Lisp程序可以在～个缓冲区里执行任意的文本变换。这种功
能频繁使用，尤其是在为许多不同语言和标记格式（正如从VI开始支持的C代码颜色加
亮，但并不仅限于此）定义语法感知和富文本编辑模式中。每种模式都是简单的Lisp代
码库文件，可以在需要时加载。
    Emacs Lisp程序也可以交互地控制任意子进程。这种能力的一些明显结果已经在早
些时候列出：可以作为版本控制系统、调试器等前端服务的能力。
UNIX编睡；艺术
  www.pdf365.com
308
第13章复杂度：尽可能简单，但别简单过了头
    Emacs的设计者建立了一个可编程的编辑器，6可以将与任务相关的知识定制进去，
以针对数以百计的不同类特殊编辑任务。设计者赋予了它可以驱动其它工具的能力。结
果就是Emacs支持在一个共享的上下文环境中处理所有的文本操作——文件、邮件、新
闻、调试符号。它可以用作任何拥有交互文本界面命令的定制前端。
    有个流行的笑话，Emacs的支持者和批评者都知道，在这个笑话中，Emacs被描绘
为伪装成编辑器的操作系统。这有些过于夸大，但Emacs当然完全成功扮演了非Unix
操作系统上集成开发环境（lDE，我们将在第15章回头讨论这个议题）的角色。
    这种强大来自于复杂度的代价。要使用一个定制化的Emacs，就必须携带定义个人
Emacs参数选项的Lisp文件。学习如何定制Emacs简直就是门学问。Emacs因此要比V1
更维学习。
13.2.5  Wily
    Wily编辑器7是Plan 9 acme编辑器的一个翻版8。它有些功能同Sam编辑器相似，但
目的是提供一个全然不同的用户体验。尽管Wily可能是所有这些编辑器使用范围晟小的
～个，但仍相当有趣，因为它展示了～种不同的、存在争议晌、更Unix的方式来实现类
似Emacs的可编程编辑器。
    Wily可以视作是满足最低要求的IDE，可以视作是Emacs风格可扩展性的～个实现，
而无伴随Emacs数十年之久的累赘。在Wily中，甚至作为Unix编辑器要素的全局搜索
和替换，都由外部程序提供。内建的命令几乎毫无例外地同窗口操作相关。Wjly设计之
初就完全支持尽可能多地使用鼠标。
    Wily并不仅仅试图取代常规的编辑器，同时试图取代诸如xterm（1）的终端窗口软
件。在Wily中，主窗口（其中包含多个不重叠Wily窗口）中的任何文本都可以是一个
行为或搜索表达式。使用鼠标左键来选择文本，使用中键将文本作为～个命令执行（内
6 Emacs的设计者是Richard M. Scallman. Bemie Greenberg和Richard M. Stallman。原始Emacs是
Stallman发明的，第一个拥有内嵌Lisp的版本出自Greenberg，而现在的权威版本是Stallman继承自
Greenbergo在2003年，t，macs的设计历史还没有完整的档案，但Greenberg的Multics Emacs: The
History， Design， and Implementation （Multics Emacs:厉史、设计和实现）有些说明，通过网络上的关键
字搜索可以很容易地找到。
7  http:／/www. cs .yorku. ca/~oz/wily
8  http:／/plan9. bell-labs. com/ sys/doc/acme/acme. ht ml
UNIX绸翻呈艺术
www.pdf365.com
13.3编辑器的适当规模
309
建的或者外部的），使用右键来在Wily的缓冲区或文件系统中搜索文本。不需要主菜单
或弹出菜单。
    在Wily中，键盘仅仅就是为输入文本而用的。快捷方式不使用键盘的特殊用法，而
是采用同时按下不止一个鼠标键的方式。这些快捷方式总是等价于使用鼠标中键激发某
个内建命令。
    Wily也可以作为C、Python和Perl程序的前端使用，无论何时一个窗口改变了，或
一个执行、搜索命令通过鼠标完成后，都可通知那些程序。这些插件功能很像Emacs的
模式，但和Wily并不运行在统一地址空间；相反地，它们通过一个非常简单的远程过程
调用集合同Wily通讯。Wily编辑器常常打包了一个类似xterm的程序并使用它作为编辑
前端的邮件工具。
    因为Wily太过于依赖鼠标，所以它不能使用在仅仅只支持字符阵列的控制台显示
上；也不能使用在没有X转发（X forwarding）的远程连接上。作为一个编辑器，Wily
是为编辑纯文本而设计的；它只有两种字体（一种比例字体和一种等宽字体），也没有
可以支持富文本编辑或语法感知的机制。
13.3编辑器的适当规模
现在让我们用本章开头展示的复杂度分类来研究这些案例。
13.3.1  鲰别复杂度问题
    每款文本编辑器都有一定量的本质复杂度。至少，它必须支持文件或多个文件的内
部缓冲区拷贝。最低要求是文件数据的导入导出功能（通常是磁盘存取，尽管流编辑器
sed（1）是个有趣的例外）。某种修改缓冲区的方法必须支持，但是没有功能描述的话，
我们无法指定用何种方法。而我们四个例子展示的各种可能偶然复杂度级别非常宽泛，
不限于此。
    在几个编辑器当中，ed （l）复杂度最低。在其命令集中，不正交的功能特性也就是
许多命令接受“p"或“l"的后缀来打印或是列出命令结果。即使这三十年来功能不断
增加，编辑命令还是少于三十个，而大多数用户常用的命令～般也少于十二个。编辑器
没有太多的选择复杂度可以去除，也根本难以确定任何偶然的复杂度。ed的用户接口非
常紧凑。
UNIX编程艺l术
  www.pdf365.com
310
第13章复杂度：尽可能简单，但别简单过了头
    另～方面，ed接口并不真正适合完成编辑任务，甚至包括快速翻看文本文件这样的
基本任务。对于交互编辑，要让ed作为可接受的解决方案，就不得不严格限制编辑目标。
    如果我们加入“支持可视化浏览／编辑多个文件’’的目的又如何昵？通过最小的ed
扩展而达到目标，Sam编辑器似乎与此需求很接近。显然，其设计者并未改变继承自ed
命令集的语义；他们保持了现有的、正交的命令集合，同时增加了一个相对较小、自身
也是正交的能力集合。
    复杂度的巨大增涨可能（实现）源于Sam编辑器的无限撤销能力。另一个显著的增
涨是命令语言中新增的基于正则表达式的循环和迭代功能。这些，加上鼠标能够作为选
取设备使用的事实，使得Sam编辑器同一个即使具备了鼠标和窗口界面的ed编辑器仍
有显著差别。
    任何Sam编辑器中的偶然复杂度，如果没有全盘的代码审计，都难以确认；而在设
计层面，也确实难以甄别。接口至少是半紧凑的，至于严格的紧凑则存有争议。这个编
辑器做到了最高级别的Unix设计标准——想想它的出身，这并不奇怪。
    比较而言，VI看起来相当臃肿而不紧凑。存在上百条命令，许多都是重复的。这些
复杂度充其量只足可能性或偶然性的。据推测，多数用户知道的命令集不会超过5%。由
于在我们面前有Sam的例子，当然会奇怪Vl的接口复杂度为什么会如此之高。
    在第1 1章我们讲述了早期roguelike程序由于缺乏标准箭头键所带来的后果：VI程
序正是这当中的一员。在编写Vl的时候，作者知道许多用户需要能够使用Unix“玻璃电
传打字机”上传统的光标移动键。这使得模式接口无法避免。一旦hjkl键在编辑缓冲区
中的意义依赖于模式，就实在太容易陷入以专用方式增加新命令的习惯。
    Sam编辑器，既然依赖于兼具箭头键和鼠标的位图显示，自然可以简洁得多。也确
实如此。
    但是VI命令的杂乱只是一个相对表面的问题。VI存在接口复杂度，没错，却是那种
多数用户确实可以忽略的（从第4章我们所述的角度来说，接口是半紧凑的）类型。深
层次的问题是个专用陷阱。历经多年，VI已经日益拴合了越来越多的C代码来执行某些
任务，而这些任务，Sam编辑器拒绝完成，Emacs编辑器以Lisp代码模块和子进程控制
来解决。在Vl中，扩展并不象Emacs中一样作为扩展库需要时才载入进来；用户始终必
须为随之而来的臃肿代码付出代价。结果，现代Vl和现代Emacs之间的规模差剐远非人
们想象的那般大；在2003年中期，在Intel体系的机器上，vim有1500KB，而GNU Emacs
是900KB。在这900KB中还有～大堆选择和偶然复杂度。
www.pdf365.com
13.3编辑器的适当规模
31 1
    对于vi信徒，没有一个内嵌的脚本语言——不是Emacs-已经成为一致性问题，
成为VI是个轻量级编辑器这个共享传奇的核心部分。虽然Vl发烧友喜欢讨论用外部程序
以及脚本过滤缓冲区来达到Emacs内嵌脚本所能完成的事情，但现实是Vl的“！”命令
不能够在比行范围更高级别的粒度上对选择的缓冲区进行区域过滤（Sam和Wily，尽管
并没有比V1更多的子进程控制，至少能够在文本的任意范围上进行过滤，而不仅仅只是
行范围）。所有在一个更小粒度上有所区别的文件格式和语法知识（大多都有区别），
如果V1编辑器需要能够访问，都必须编写进C代码中。这样在Emacs和V1代码库规模
大小的比例上，几乎没有希望能在V1方面得到改善：的确，这似乎可能更糟。
    Emacs十分庞大，其历史也十分夹杂不清，所以如果要将它的选择复杂度从偶然复
杂度中分离出来是一个相当大的挑战。但我们至少可以把Emacs设计中可有可无的偶然
复杂度从不可或缺的本质复杂度中分离出来作为起点。
    也许Emacs设计中最可有可无的部分就是Emacs Lisp。我们今天称之为内嵌脚本语
言的特性对Emacs而言是必要的，但如果那个语言是Python成Java或Perl的话，Emacs
在能力上也不会有什么不同。然而在1970年代进行tmacs设计的时候，Lisp是唯一拥
有某些特征（包括类型种类无限以及垃圾收集）、适合完成这项任务的语言。
    大部分Emacs事件处理以及位图显示器驱动（包括国际化支持）的特殊方式都属于
偶然复杂度。在其历史上最大的分裂（GNU Emacs和XEmacs分支）就涵盖了这个问题，
并且也展示了余下的设计并不是非优选或要求哪种事件驱动模式不可。
    另一方面，把任意事件序列绑定到任意内置或用户定义功能的能力是不可或缺的。
脚本语言可以换掉，事件模型也可以改变，但是如果不是任何对象都因连接方式不同而
呈现不l刊面貌，Emacs设计就不成气候也不成其为自身了。这样，扩展模式不得不为了
有限事件集的所有权而彼此斗争，而且激活同一缓冲区的多重协作模式也十分困难或者
根本就不可能。
    随着Emacs -道发布的巨大扩展模式库也同样属于偶然复杂度。构建这种扩展的能
力也许是必要的，然而某个专用集合却是历史和偶然的产物。全部扩展都可以不同或被
替换；Emacs结果还是Emacs，面貌依旧。
    但是子进程交互是不可替代的。没有它，Emacs模式就不能够怍为各种不同工具的
IDE环境或前端。
    一些小型的编辑器复制了默认的键盘绑定以及Emacs的外观，但没有模仿它的扩展
能力，这样的经验是很有意义的。已经有好几个这样的克隆，其中最著名的大概非
UNIX编程艺术
  www.pdf365.com
3 12
第13章复杂度：尽可能简单，但别简单过了头
MicroEmacs和pico莫属，但都没能获得大量的追随者。
    鉴别Emacs设计中哪些本质、哪些偶然，可以帮助我们理解它的复杂度哪些是可能
性、哪些是偶然性的。然而，更重要地，这帮助我们透过上述三个编辑器表面的不同，
而直达关键之处：事实上Emacs设计的目标非常宽泛。Emacs想要成为所有文本处理工
具的统一接口。
    Wily跟Emacs形成有趣的对比。同Sam -样，选择复杂度含量很低；Wily用户接
口仅用一页纸就可以简明扼要地描述清楚。
    但是优雅是有代价的；除了有限的鼠标组合动作之外不可能将功能绑定在任何的按
键或是输入手势。除了基本的文本插入和删除之外的任何编辑功能都必须以外部的程序
来代替实现：一个独立的脚本，或是一个可以侦听Wily输入事件的专用共生进程。（前
者技术上依赖于外部程序的启动必须非常迅速、不会产生可觉察的界面延迟，这在诞生
Emacs的环境中或是首次移植到的各种Unix下都绝对不成问题。）
    Emacs因采用Lisp扩展模式实现而导致的选择复杂度，在Wily中相应地分布在专
门化的共生体中；每个共生体都必须知晓Wily特殊的消息接口。这种有式的一个优点就
是这样的共生体可以由用户选择的任何语言来编写。另外，共生体（因为它们在外部运
行）不会彼此影响或危害Wily核心（Emacs的各种模式并非如此）。这种方式的一个缺
点是Wily自身不能直接与普通的Unix工具进行予进程交互。
    在这个或其它方式上，wily的分布式脚本机制并不如Emacs的内嵌脚本那样强大有
效。Wily的目标范围相对狭窄；作者放弃了在感知语法编辑或富文本编辑方面的功能，
例如，Wily以及它Plan 9的祖先acme都不处理这些事情。
    这里以一种更尖锐的方式来提出本章的中心问题：什么时候一个庞大程序的宏伟目
标是正当而有效的？
13.3.2折中无用
    Sam和VI的比较，显著昭示了至少在涉及编辑器方面，试图在简约主义的ed和无
所不能的Emacs之间进行折衷是达不到好效果的；Vl尝试这样去做，结果两头落空，而
掉进了过度专用的陷阱。Wily则规避了这个陷阱，但是威力无法跟Emacs相比，并且为
www.pdf365.com
13.3编辑器的适当规模
3 13
了无论在何处都能结合紧密，每个交互的共生体必须提供一个定制的进程接口。
    显然有关编辑器的某些方面往往将其推向更高复杂度。在vi的例子中，这不难甄别；
那就是对便利性的渴望。尽管ed或许在理论上是够用的，但是很少有人（也许除了Ken
Thompson自己）会为了声讨软件的臃肿而放弃面向屏幕的编辑。
    更普遍地，在用户和外部事务间调和的程序往往加入各种功能，这一点臭名昭著。
不仅是编辑器，网页浏览器、邮件和新闻组阅读器以及其它通讯程序，所有这些软件的
发展都遵循“软件信封定律”，即Zawinski定律：  “每个程序都试图扩展直到能够阅读
邮件。不能如此扩展者，将被能者取代。”
    Jamie Zawinski，定律的发明人（Netscape和Mozilla网页浏览器的主要作者之一），
主张更一般的情况：所有真正有用的程序都想变成瑞士军刀。在Unix世界外大型的成功
商业整合应用程序套件通常也证实了这～点，而且直接挑战了Unix的最简哲学。
    某种程度上，Zawinski定律是正确的。它表明有些程序需要小巧，有些程序需要庞
大，但中间道路是行不通的。V1编辑器的表面问题可以归咎于历史，然而更深层欢的问
题应该追溯到增加功能的压力同vj信徒，往往由此联系到过度规模，而拒绝增加与内嵌
脚本语言和子进程控制功能的结合。在～个不同的级别上，接受了接口中存在两种方式
（插入和特性运动），将会捅到马蜂窝——添加新功能很容易根本考虑不到对整体设计
的复杂度影响。
    Emacs和Wily的例子进一步表明，为什么有些程序需要做得如此庞大：这样几个相
关任务就可以共享环境。从实现者的角度，编辑和版本控制（或者编辑和邮件操作，编
辑和符号调试等等）是独立的——但是用户经常更愿意有一个大的环境让它们能够指向
文本部分，无需花费时间和精力在拥有相同文件名或是相同剪切内容的程序之间切来切
去。
    更普遍地，让我们假设整个Unix环境可以视作是社区的单一设计工作。那么“小巧
锐利工具”的教义，降低接口复杂度和代码库规模的压力，可能正好会导向过手工
（ manularity）陷阱——用户不得不自己维护所有共享的上下文环境，因为工具并不会为
他完成此项工作。
    返回编辑器的特定背景，Sam向我们展示了V1是个错误。Wily是避免巨大Emacs
的勇敢尝试，但却因功能不足不能感知语法。但是Wily，或者某个彻底卸掉了历史包袱
的Emacs设计思想实现舨本，也许是正确的。选择复杂度的价值依赖于对目标的选择，
UNIX编曜艺l宋
  www.pdf365.com
314    第13章复杂度：尽可能简单，但别简单过了头
而在所有与任务相关的面向文本工具间共享上下文环境的能力是非常有价值的。
13.3.3  Emacs是个反Uni×传统的论据吗
    传统的Unix世界观，极其依恋简约主义，所以并不擅长区分VI的专用陷阱问题和
Emacs的选择复杂度。
    Vi和Emcas在老派的Unix程序员中从不流行的原因是丑陋。这个抱怨也许
是“老Unix”的话语，但如果不是老Unix的单一风味，  “新Unix”就不会存在
-Doug Mctlroy
    VI用户对Emacs的攻击——同仍旧依恋ed的旧学派中坚分子对vj的攻击一道——
是一个更大争论的一段情节，～场富有和俭朴之间的品德角逐。这个争论同新老学派Unix
风格之间的冲突有关。
    “老Unix的单一品味”部分是同日本简约主义一样贫穷的结果——学会在无法获得
更多条件的情况下最有效地以少量资源完成更多任务。但是Emacs（以及在威力强大的
PC机和快速网络上重新发明的新学派Unix）却是财富之子。
    同旧学派的方式不一样。贝尔实验室资源丰富，所以Ken不会被受限去写一
个过时产品。想想Pascal因为没有足够的时间写封短信而抱歉信写长了。
    -Doug Mcilroy
肌那时起，Unix程序员就一直维持着在过度花费上追求一流的传统。
    另一方面，Emacs的庞大，并非源自Unix，而是由于Richard M. Stallman在一个不
同的文化中发明了它-1970年代繁荣的MIT的人工智能实验室。这个实验室是计算机
科学院校最富裕的地方之一；那里的人们学会了把计算资源当作廉价资源，并预测了一
种在别处直到十五年后才可行的态度。Stallman可不关心简约主义；他追求的是代码最
大功用和最广适用范围。
www.pdf365.com
13.3编辑器的适当规模
315
    少吃多干还是多吃多干，～直是Unix传统的主要冲突。这个冲突在许多不同的背景
下重现，往往在不断地挣扎在具备干净简约主义品性的设计和不惜以高昂复杂度代价而
选择表达力范围和威力的设计之间。自从1980年代初期Emacs第一次引入Unix之时起，
便有了支持与反对的冲突双方。
    诸如Emacs那样既有用又庞大的程序会使Unix程序员极不舒服，恰恰因为它们强迫
我们面对这种冲突。这些程序表明，旧学派Unix的简约主义作为一个原则虽然有其价值，
但我们可能已经陷入教条主义的错误之中。
    Unix程序员可以有两种方式解决这个问题。一种就是否认：大实际非大。另一种就
是发展出一种考虑复杂度的不是教条的方法。
    替换掉Lisp和扩展库的实验思想赋予我们一个新的角度，来看待对Emacs由于扩展
库庞大而臃肿的再三控诉。抱怨Emacs大，和把系统中所有shell脚本都算上而抱怨
／bin／sh大，同样是不公平的。Emacs可以视作是一个围绕在小巧锐利工具集合上的虚
拟机或框架，只不过这个工具集恰好是用Lisp编写罢了。
    从这个角度，shell和Emacs的主要区别就在于Unix发布者并没有把所有的shell踯
本都同shell -起发布。因为Emacs内置了感觉臃肿的通用语言而反对Emacs，就像因为
shelll具有条件和for循环而拒绝使用shell脚本一样无聊。如同并非必须学习shell脚本才
能使用shell -样，使用Emacs也不是非学习Lisp不可。如果Emacs存在设计问题，与
其说是Lisp解释器的问题，还不如说是模式库历史性增长成为一堆乱麻的问题——然而
这是一个用户可以忽略的复杂度来源，因为用不到的部分并没有影响。
    这种论证方式非常令人鼓舞。可以应用到其它的工具整合框架中，例如（令人不舒
服的庞大的）GNOME和KDE桌面项目。这种方式在那里也有效（说服力）。而且，同
样地，我们必须怀疑任何可以如此优美地解决所有疑问的“观点”；它只能是个合理原
则，而不是基本原则。
    因此，让我们避免否认或接受Emacs既有用又庞大——这其实是反对Unix简约主义
的论据。在我们对Emacs复杂度种类和动机的分析中，还有什么更意味深长的暗示？又
有什么理由相信那些从教训归纳出来的东西？
UNIX编程艺l宋
    www.pdf365.com
3 1 6
第13蕈复杂度：尽可能简单，但别简单过了头
13.4软件的适度规模
    小巧锐利工具的Unix教义隐藏着二重性；许多Unix从业者都没有注意到，一个十
分不明显的背景，就像鱼没有注意到它游着的水一样。这就是框架的存在。
    Unix风格的小巧锐利工具存在数据共享的困难，除非它们能生存在彼此之间通讯便
利的框架结构之中。Emacs就是这样一个框架，而对共享上下文环境的统一管理正是其
选择复杂度换来的。共享上下文统一管理的实际效果就是用户不需要负担底层的命名和
资源管理问题。
    在旧学派的Unix中，唯一的框架就是管道、重定向以及shell;整合工作由脚本完成，
而共享上下文环境（本质上）就是文件系统本身。但这并不是进化的终点。
    Emacs将非常多的文本缓冲区和援助进程同文件系统统一在～起，大大超越了shell
框架。Wily也有缓冲区和援助进程，但将shell框架也并进了自身。现代的桌面环境为
GUI提供了一个通讯框架，也大大超越了shell框架。每种框架都有自身的优点和缺点。
而框架成为了各种工具生态系统之家——例如shell之于脚本，Emacs之于Lisp模式，或
者桌面环境之于众多通过拖放以及诸如对象代理（object broker）乏类更为复杂的GUI
通信方式。
    最简原则暗示：选择需要管理的上下文环境，并且按照边界所允许的最小化方式构
建程序。这就是“尽可能简单，而不过于简单”，集中关注选择共享上下文环境。实际
上，这并不仪仅适用于框架，也适用于应用和程序系统。
    然而，究竟共享上下文环境该有多大实在很容易草率对待。隐藏在Zawinski定律后
的压力往往驱使应用程序需要为便利性而共享上下文环境。很容易因为负载太多任务、
太多需求设想而最终失败，也很容易就把程序编制得过于复杂、臃肿和庞大。上世纪九
十年代的例证是，“mailto:URL"导致了越来越多网页浏览器中内嵌了庞大的邮件客户
端。
    矫正这种趋势的方法直接来自于旧学派Unix的赞美诗集。这就是吝啬原则：只有实
证了其它方法行不通时才写庞大程序——也就是，已经尝试过分解问题但遭到失败。格
言表明了对待庞大程序的～种严谨怀疑态度以及一种谨慎的策略方法：首先寻找小巧程
序的解决方案。如果单个小程序无法完成这项工作，尝试在现有框架结构内构造一个协
作小程序工具包来解决问题。如果两者都失败了，才可以自由地构建一个巨型程序（或
一个新框架），而不会觉得已经完败于设计挑战。
www.pdf365.com
13.4软件的适度规模
3 17
    当编制一个框架时，牢记分离原则。框架是机制，尽可能少地包含策略。在多数情
况中，根本就不需要什么策略。尽可能多地将行为分解到使用框架的模块中去。编制或
重用框架的好处之一，是能够有益于将“不这样做会是大块策略”的东西分离到独立的
模块、模式或工具——可以有效地同其它程序重新组合起来的部分中去。
    这些准则是颇有价值和启发性的方法，但是Unix传统深处的这种矛盾冲突，并不能
将任何给定的工程划为合理的最佳规模，并分而治之。具体情况具体分析，而锻炼良好
的判断力和品味恰好是软件设计者所追求的。正如曹洞禅所说，行程才是目的；顿悟在
每日的实践中。
UNIX鳎翻星YaC
    www.pdf365.com
www.pdf365.com
PartⅢ
Implementation
www.pdf365.com
www.pdf365.com
1 4
  r  C还是非C
、五言．
口亡=I．
Languages: To C or Not To C
14.1  Unix下语言的丰饶
The limits of my language are the limits of my world.
    Tractatus Logico-Philosophicus 5.6， 1918
    我语言的极限便是我世界的极限。
    《逻辑哲学论》5.6， /9/8
    一路德维希-维特根斯坦
    Unix所支持的应用程序语言，其范围比当今其它任何一种操作系统的都要广泛：事
实上，Unix上运行的语言种类完全可能超过计算史上其它所有操作系统的总和1。
    至少有两个充分的理由造成了这种巨大的多样性。一是Unix广泛用于研究和教学平
台。另外一个事实（同程序员更加密切的）是，应用设计和实现语言的合理搭配对生产
力有极大促进。因此，Unix传统鼓励专门领域语言的设计（正如我们在第7章和第9章
所述）和现在…般称为“脚本语言”的东西——为了把其它应用程序和工具胶合起来而
专门设计的语言。
1详情参见  Free  Compiler and  Interpreter List  （自由编译器和解释器总表）
<f tp:／/f tp. idiom. com/pub/   compilers-list/free-compilers>。
UNIX缟程艺．术
  www.pdf365.com
322
夸占1』音0E言．广、节K量j-Fr、
，由l叶早k]口：  o Zl二天E_'卜U
    术语“脚本语言’’可能源自术语“脚本”，它用于为一个通常情况下的交互
程序提供简短输入，特别是sh或ed-这个术语比我们从Unix前辈CTSS那儿
继承下来的术语“runcom”更合适。  “脚本”最早出现在V7手册（1979年）中。
我不记得是谁造就了这个字。
    -Doug Mcllroy
    说实话，  “脚本语言”是个有点蹩脚的术语。很多通常这么称呼的主要语言（ Perl、
Tcl、Python等）都已经超越了最初意义的脚本用途，已经成为威力相当强大的独立通用
编程语言。一些语言，特别是Lisp和Java，在风格上与脚本语言非常相似，但是这个术
语模糊了两者间的区别。继续使用这个术语的唯一理由是还没人想出更好的。
    把所有这些语言都纳入“脚本语言”的部分原因在于，这些语言都具有非常～致的发
展历程。在运行期完成解释使得动态存储管理的自动化相对容易，而这几乎要求采用引
用（存储地址不透明且无法进行运算）而不是传值或显式指针。使用引用可使下一步更
容易实现运行期的多态性和00。瞧！这就是现代的脚本语言！
    要有效应用Unix哲学，在工具包中就不能只育C语言，必须学会使用Unix的其它
语言（特别是脚本语言），并且学会如何在大型程序系统中把担任各个专门角色的多个
语言轻松自在地融合在一起。
    本章我们要分析C语言及其最重要的替换语言，讨论各种语言的长处、不足以及它
们最适合的任务类型。涉及的语言包括C、C++、shell、Perl、Tcl、Python、Java和Emacs
Lispo每段分析将包括由该语言编写的应用实例，同时也引用了其它例子和指导材料。
所有使用这些语言实现的高质量开源实现都可以在Intemet上获得。
    警告：对应用程序语言的选择是InterneUUnix世界中应该认真考虑的原型问题之一。
人们太爱某些工具，有时会不顾～切维护它们。如果本章达到了目的，也许会冒犯各种
语言的狂热支持者，但其他所有人肯定都能从中受益。
www.pdf365.com
14.2为什么不是C
323
14.2  为什么不是C
    C是Unix的母语。自1980年代早期起，C语言几乎就垄断了计算机工业中所有的
系统编程。除了Fortran在科技和工程计算领域内不断缩小的空间和COBOL在银行和保
险公司大量外人无法得知的财务应用外，C和C的后代C++迄今为止（2003年）垄断应
用编程超过了整整10年。
    因此，作为对新应用程序开发工具的选择，现在断言C和C++几乎～定是蹩脚的似
乎理由不足。然而事实如此；C和C++以增加实现时间和（特别是）调试时间为代价来
优化效率。尽管以C或C++编写对时间要求极高的系统程序或应用程序内核似乎还有意
义，然而自从这些语言在1980年代崛起，世界已经发生了很大变化。在2003年，用几
乎同样的价钱能够买到的处理器快了1000倍，内存大了1000倍，而磁盘容龟也大了10000
倍2。
    急剧下降的成本从根本上改变了编程的经济含义。大多数情况下，和C-样节约机
器资源已经不再有任何意义。相反地，经济方面的最优选择已经变成尽可能减少调试时
间、尽可能延长人类对代码的长期可维护性。因此，用较新一代的解释语言和脚本语言，
能够更好地为绝大多数种类的应用实现（包括应用程序酌原型设计）服务。这种转变和
历史车轮中上一次C/C++崛起而汇编语言衰落的情况类似。
    C和C++的中心问题在于它们要求程序员自己完成内存管理——声明变量、显式管
理链表、设置缓冲大小、检测或防止缓冲溢出，以及分配和回收动态存储。这些任务部
分可以通过不自然的方法来自动化，例如，给C配备Boehm-Weiser实现之类的垃圾收
集器，但C本身的设计使它无法成为一个完整的解决方案。
    C的内存管理是复杂性和错误的渊薮。对于处理复杂数据结构的程序而言，有研究
（据（Boehml称）估计30%～40%的开发时间都用于存储管理。这个估计甚至还没有包
括对调试成本的影响。尽管缺乏确凿坚实的数据，但很多经验丰富的程序员都相信，内
2在Unix世界外，这种硬件性能三个数量级提升的效果很大程度上被软件性能的相应下降所掩盖。
    UNIX编陛艺：术
    www.pdf365.com
324
第1 4童语言：C还是非C
存管理产生的bug是真实代码持续产生错误的最大单体来源3。缓冲溢出是产生崩溃和安
全漏洞的常见原因。动态内存管理造成诸如内存泄漏、指针失效问题等阴险、难以跟踪
的bug，特别臭名昭著。
    就在不久前，手动内存管理还有意义。但现在再没有“小型系统”了，至少在主流应
用编程中没有了。在今天的条件下，自动化内存管理（并以使用更多的时钟周期和内存
为代价而减少一个数量级的bug）的实现语言更有意义。
    最近一篇论文[Prechelt】为一个观点收集了一系列惊人的统计数据，但在两个世界
都有经验的程序员可能会发现这个观点似是而非：同C或C++相比，使用脚本语言的
生产力可以提高1倍。这个观点完全和前面提到的30%～40%的损失估计加上调试开
销后一致。使用脚本语言的性能损失对真实世界的程序来说经常微不足道，因为真实
世界的程序往往受I／0事件等待、网络延迟以及缓存列填充等限制，而非CPU的自身
效率。
    Unix世界在实践中慢慢意识到了这个观点，尤其是在1990年前后，Perl和其它脚本
语言越来越流行。但是实践（到2003年中期）还没有发展为自觉地产生巨变；许多Unix
程序员仍然在汲取Perl，Python的经验。
    我们可以在Unix世界外看到同样的趋势，尽管速度更慢——例如，在Microsoft
Windows和NT的应用开发中从C++到Visual Basic的明显转变以及大型机世界中向Java
的转变。
    反对C和c++的论据同样适用于其它传统的编译语言，例如Pascal、Algol、PUI、
FORTRAN和编译Basic等。尽管偶有壮举，如Ada，但这些传统语言在基础设计时把内
存管理留给程序员，因此其间的差别几乎无关紧要。尽管绝大多数传统语言在Unix下都
有高质量的开源实现，但在Unix或Windows世界中应用很窄；这些语言都因为得到C
3这个问题的严重性可以通过Unix中描述各式各样问题所形成的大量行话来证明：“aliasing bug，，（别
名错误）、“arena corruption”（内存分配区无效）、“memory leak”（内存泄漏）、“buffer overflow”
（缓冲区溢出）、“stack smash”（堆栈崩溃）、“fandango on core”（内核混乱）、“stale pointer”（指
针失效）、“heap trashing”（堆破坏）以及可怕的“secondary damage“（二次损伤）等。具体说明参见
行话文件<http：//www_ catb．org／—esr／j argon>。
www.pdf365.com
14.4语言评估
325
和C++的好处而被废弃。因此，我们不在此分析这些语言。
14.3解释型语言混合略
    避免手工管理内存的语言通过在运行期可执行体中嵌入一个内存管理器来完成内存
管理。通常情况下，这些语言的运行环境分成程序部分（运行脚本本身）和解释器部分，
解释器管理动态存储。在Unix（以及其它现代操作系统）中解释器内核由多个程序部分
共享，减少了各个程序的实际开销。
    脚本在Unix世界中从不是新概念。早在1970年代中期，在机器能力弱得多的时代，
Unix shell（Unix控制台的输入命令解释器）就是作为一个完全解释型编程语言设计的。
即使在那时，这样的实践也很普通，完全用shell编写程序，或者用shell编写胶合逻辑、
把现有的公用程序同C编写的定制程序结合成比各部分总和更大的整体。对Unix环境的
经典介绍（如Unix Programming Environment （Unix编程环境）[Kernighan-Pike84]）非常
详细地描述了这个策略，理由就是：它是Unix最重要的创新之一。
    高级shell编程可自由混合语言编程，从数种或更多语言中为子任务开发二进制
和解释型组件。每种语言都完成自己最擅怅的任务，每个组件都是具有同其它组件间
狭窄接口的模块；整体的全局复杂度要比使用某个通用语言编制的单个的庞然大物低
得多。
  14语言t'
  混合语言足一种知识密集型（而不是编码密集型）的编程。要让它能够工作，我们
不仅应该具备相当数量的多种语言应用知识，并且还必须具备能够判断这些语言在什么
地方最适合、以及怎样把它们组合在一起的潜经验。本部分，我们将尽量帮助大家认识
各种语言，然后再纵览那些潜经验。对于每种语言的分析，我们都会用成功的程序实例
来说明这种语言的长处。
UNIX编程艺．术
    www.pdf365.com
326
第1 4章语言：C还是非C
14.4.1  C
    尽管存在内存管理问题，但C语言还有一些仍然可以在其中称王称霸的生态环境。
要求速度最快并且具有实时需求的程序，或者与OS内核紧密联系的程序非常适合用C
编写。
    必须在多个操作系统上移植的程序也非常适合用C编写。然而，以下将要讨论的某
些其它替代语言不断打入主流的非Unix操作系统；也许在不久的将来，C的可移植性优
势将不复存在。
    有时，从现有程序中，诸如可以生成C代码的词法分析生成器或GUI构建器之类，
可以获得相当大的借力；完全值得用C语言编写除此以外并无太多工作的小型应用程序。
    当然，已经证明了，对于所有C的替换语言开发者来说，C都是不可或缺的。此处
要分析的其它任何一种语言，透过实现层深究下去都可以发现用可移植纯C语言实现的
内核。这些语言继承了C语言的许多优点。
    在现代条件下，也许最好把C视作适用Unix虚拟机的高级汇编器（回顾一下第4
章作为实例分析的、对C成功之处的讨论）。C语言的标准已经把这个虚拟机的很多功
能，比如说标准I／0库，引出到其它操作系统之中。C语言就是既要尽量接近裸机又要
仍然保持稳定的最佳选择。
    即使更高级的语言能够满足编程的要求，我们仍然耍学习C，其中一个充分理由就是C
能帮助我们学会在硬件体系层次上考虑问题。对于已经是程序员的人来说，学习C的最好参
考和指导仍然是《The CProgramming Language》  （C编程语言）[Kemighan-Ritchie]。
    在Unix变种之间移植C代码几乎总是可行的，通常也很容易，但在一些特殊的变化
领域（例如信号和进程控制）可能非常需要技巧才能做对。我们将在第19章重点讨论这
些问题。尽管Windows NT至少在理论上支持符合ANSI/POSIX标准的C语言API，但
其它操作系统上C的不同约定肯定会导致一些移植问题。
    高质量的C编译器的开源软件可以在网上找到；其中最著名、使用最广泛的是自由
软件基金会的GNU c编译器（GCC （GNU Compiler Collection/GNU编译器集合）的组成
部分），GCC已经成为所有开源Unix系统、甚至很多闭源世界中Unix系统自带的C实
现。甚至Microsoft操作系统也有GCC。GCC的源码可在FSF的FTP站点
<ftp://ftp. gnu.org/pub/gnu>获得。
    总结：C语言最佳之处是资源效率和接近机器语言。而最糟糕的地方是其编程简直
就是赍源管理的炼狱。
www.pdf365.com
14.4语言评估
327
14.4.1.1  C实例分析：fetchmail
    C语言最好的案例分析是Unix内核本身，对于Unix内核而言，一个自然支持硬件
层操作的语言实际上就是～个巨大优点。但fetchmail是那种最适合使用C编写的用户态
实用程序范例。
    fetchmail只完成最简单类型的动态内存管理：它仅有的复杂数据结构是邮件服务器
控制块的单向链表，只在启动时创建，之后发生相当微小的变化。这避开了C的最大弱
点，从而大大削弱了并不适用C的情形。
    另一方面，这些控制块相当复杂（包括所有的字符串、标记和数字数据），在一个
缺乏C struct对应特征的实现语言中，很难将这些控制块作为一致的常规访问对象进行处
理。在这方面，绝大多数代用品都比C弱（Python和Java是明显的例外）。
    最后，fetchmail要求能够解析针对邮件服务器控制信息的、相当复杂的规格说明语
法。在Unix世界中，这类任务的经典解法是使用C代码生成器，C代码生成器从声明的
说明规格中为标记器（ tokenizer）和语法分析器生成源码。Vacc和lex的存在是使用C
语言编程的有力支持。
    fetchmail完全有理由使用Python编写，尽簪可能产生显著的性能损失。其规模大小
和复杂的数据结构可能马上就排除了shell和Tcl编程，Perl也非常不适合，其应用领域
也不在Emacs Lisp的自然范围内。Java实现本可以成为一个合理的方法，但Java面向对
象的风格和垃圾收集针在fetchmail的具体问题中并不会获得太多收益，简单的内存管理
用C就已经足够解决了。C++也没有办法可以更简化fetchmail相对简单的内部逻辑。
    然而，fetchmail成为C程序的真正原因是，fetchmail其实是从一个原本使用C编写
的前辈程序逐渐演化而来的。现有的实现已经在许多不同的平台和稀奇古怪的服务器上
进行了广泛的测试。把所有这些隐性的知识贯穿到用不同语言的重新实现中会非常棘手
和困难。更何况，fetchmail的一些功能（如NTLM认证）取决于外来代码，而这些代码
只在C版本才有。
  fetchmail的交互式配置器并没有C的遗留问题，所以使用Python编写；我们将在讨
论Python时分析该实例。
14.4.2  C++
当C++在1980年代中期首次公布于世时，面向对象（00）语言正被大肆吹捧为解
UNIX编震，艺术
    www.pdf365.com
328
第1 4章语言：C还是非C
决软件复杂度问题的“银弹”。C++面向对象的特性对于其前辈C而言是个压倒性的优点，
其拥趸期望C++能够迅速废掉更古老的C语言。
    这种情况当然并没有发生。部分可归因于C++本身的问题；对向后兼容C的要求迫
使C++在设计中做出了许多妥协。而且这个要求阻碍了C++完全自动化动态内存管理，
从而无法解决C语言最严重的问题。后来，薄弱、不成熟的标准化努力，并不能限制各
个不同编译器实现者之间的功能特征竞赛，C++变得过份精微复杂了。
    另外一部分原因必须归咎于00本身并没有达到期望值。我们已经在第4章分析了
这个问题，阐述了00方法往往导致厚重胶合层和维护问题。今天（2003年），对开源
文档（在这些文档中，语言的选择反映了开发者的判断而不是企业行政命令）的分析表
明C++的使用仍然大量集中于GUI、多媒体工具包和游戏（00设计的主要成功领域），
而在其它地方用得很少。
    也可能C++对00的实现特别容易产生问题。有证据表明C++程序比等价的C、
FORTRAN或Ada程序具有更高的生存期成本。这是00的问题还是C++特有的问题或
者是两者共同的问题，答案还不清楚，尽管有理由怀疑两者都牵涉萁中[Hatton98]。
    近年来，C++已经包含了一些重要的非00概念；它具有和Lisp类似的异常；也就
是说，在被处理程序捕捉之前可以沿调用栈向上抛出值或对象。STL（标准模板库）提
供了泛型编程；也就是说，可以编写独立于数据结构的算法并将其编译而在运行期完成
任务o  （只有执行编译期静态类型检验的语言需要它；更动态的语言只传递无类型的引
用，而在运行时支持类型识别。）
    高效的编译型语言；对C的向上兼容；面向对象的平台；STL和泛型等最前沿的技
术工具-C++试图满足所有人的所有要求，但代价是C++比任何一个程序员所能处理
的复杂度都要高。正如我们在第4章指出的～样，这个语言的主要设计者已经承认他不
指望任何一个程序员能够完全掌握C++。Unix黑客对此并没有很好的反应；一段匿名但
非常著名的评论这样描述“C++:狗被钉上软肢而变成的章鱼”。
    然而，说白了，C++最根本的问题还是在于它根本上只是另外一种传统语言。在标
准模板库发明后，C++的内存管理控制有所改善，比C好得多，但仍然十分脆弱；除非
代码仅使用对象，否则控制仍1日无用。对许多类型的应用而言，C++的00特性并不重要，
www.pdf365.com
14.4语言评估
329
没有带来多少优势，徒增复杂度而已。尽管存在不少开源的C++编译器；
确比C高级，那C++现在肯定占尽优势了。
    总结：C++的最佳之处是编译效率以及面向对象和泛型编程的结合。
非常怪异复杂，往往鼓励过分复杂的设计。
    如果现有的C++工具包或服务库为应用程序提供了强大有效的方法，
用领域正是上述00语言具有巨大优势的领域，可以考虑C++。
但如果C++的
最糟之处是它
或者所在的应
    C++的经典参考资料是Stroustrup的The C++ Programming Language （C++编程语言）
【Stroustrup]。有关C++和00基本方法的优秀入门指导是C++:A Dialog[Heller]。《C++
详注>  （C++ Annotations）[Brokken]则是针对C专家程序员的简明介绍。
    GCC包含一个C++编译器。因此这个语言广泛应用于Unix和Microsoft操作系统：
前面对C提出的有关说明在此处同样适用。非常强大的开源支持库可从
<http：／／www．boost．org／>获得。C++的ISO标准草案（到2003年中）正处于准
备期，而实际的C++实现往往遵循其相差甚大的子集．正是这个事实恰恰损害了C++
的可移植性4。
14.4.2.1  C++实例分析：Qt工具包
    Qt界面工具包是C++在当今丌源世界中最成功的故事之一。它提供了在X下编写图
形用户界面的窗口构件和API，是为了仿效Motif、MacOS Platinum或Microsoft Windows
界面的可视化观感而专门设计的。实际上，Qt不仅提供GUI服务；也提供了可移植应用
层，具备众多类库，可供完成XML、文件访问、套接字、线程、定时器、时间／日期处
理、数据库访问、各种抽象数据类型和Unicode处理。
    在开源世界中，有两项工作创造了有竞争能力的GUI和集成桌面生产工具包，KDE
是其中资格较老的一个，而Qt工具包则是KDE项目中关键的可视组成部分。
    Qt的C++实现展示了00语言在封装用户界面构件方面所具有的优势。在支持对
象的语言中，通过类实例的分层可在代码中清楚表达出界面窗口部件的可视化分层。
尽管这类任务在C中可以通过手动书写方法列表进行明确的转向调用来模拟，但用C++
编写的代码要干净得多。将此同C编写的、非常复杂的Motif API比较非常具有启发意
义。
4最近的一个C++标准从1998年开始，实现甚广，但仍旧根弱，特别是在代码库领域。
UNIX -4iO&-'2t肴
  www.pdf365.com
330
第14章语言：C还是非C
Qt的源码和参考文档可在Trolltech站点<http：／/www．trolltech．com/>获得。
14.4.3  Shell
    Unix版本7的“Bourne shelr'（ sh）是Unix第一个（而且在很多年中也是Unix唯
一的）可移植的解释型语言。今天，最先的Boume shell很大程度上已经被向上兼容的
Kom Shell （ksh）的各种变种所替代；其中最重要的一个变种是Boume Again Shell，
即bash。
    也存在其它一些shell、也可交互使用，但这些语言不足以作为编程语言：其中最著
名的恐怕就是C shell即csh了，csh以不适合编写脚本而出名5。
    简单shell程序的编写极其容易和自然。Unix使用解释型语言的快速原型设计传统就
始于shell。
    我用1 50行shell脚本编写了第一版netnews。它支持多个新闻组，可以交叉
  发贴；新闻组是目录，交叉发贴则以对文章的多个链接来实现。虽然用于实用太
  过缓慢，但其灵活性允许进行无穷的协议设计试验。
-Steven M. Betlovin
    然而，随着程序规模越来越大，这些程序往往变得非常专用。部分shell语法（特剔
是其引用和声明语法规则）变得十分混乱。为了shell作为交互式命令行解释器的实用性，
而在设计中对语言部分做了折中，这些缺点就是这么来的。
    即使程序不完全使用shell编写，但包含人量对sort“／）之类的C过滤器或sed （1）、
awk （1）之类的标准文本处理微型语言的使用，则也可称为“用shell”编写而成。然而，
这类程序在过去数年内逐渐式微，现在此类复杂的胶合层通常用Perl或Python编写，而
shell只是为最简单的包装器（那些语言使用在包装器上是大材小用）和系统启动时的初
始化脚本（不能假设已经安装了什么语言）而保留。
5参阅Tom Christiansen的文章Csh Programming Considered Harmful （Csh编程有害论），网上很容易
搜索到。
www.pdf365.com
14.4语言评估
331
    任何入门级Unix书籍都对此类基本的shell编程作了充分的说明。The Unix
Programming Environment （Unix编程环境）[Kernighan-Pike84]仍然是最好的中高级shell
编程参考书之～。每个Unix上都有Kom shell的实现或翻版。
    复杂的shell脚本经常产生可移植性问题，主要原因并不在于shell本身而在于shell
使用了某些它假定存在的程序。尽管偶尔可在非Unix操作系统中发现Bourne和Kom
shell变种，shell程序（实际上）根本无法移植到Unix之外。
    总结：shell的最佳之处在于书写小型脚本非常自然快捷。最糟之处在于大型shell
脚本必须依靠大量辅助命令，而这些辅助命令不一定在所有目标机器上都表现～致甚至
不一定存在。要在大型shell脚本中分析依赖关系并不容易。
    既然所有的Unix系统和Unix仿真器都配置了shell，因此几乎从来不需要编译或安
装shejl。在Linux和其它先进的Unix变种上的标准shell已经是bash了。
14.4.3.1  案例分析：xml七。
    xmlto是一个驱动脚本，调用所有必要的命今将XML-DocBook文件转换成HTML、
PostScript、纯文本或其它格式中的任何一种（我们将在第1 8章具体分析DocBook）。
它用bash编写而成。
    xmlto使用恰当的样式表处理XSLT引擎的调用细节，然后把结果传递给后续处理
器。对于HTML和XHTML，XSLT转换完成全部的工作。对于纯文本，XML也先处理
成HTML，然后传递给后续处理器——以- dump模式调用lynx（1），它把HTML转换
成纯文本。对于PostScript，XML转换成XML FO（formatting objects，带格式对象），
由后续处理器将其映射成TEX宏，通过tex（1）转换成DVI格式，最后由众所周知的
dvi2ps（1）工具转换成PostScript。
    xmlto是单体前端shell脚本。它调用某个根据目标格式命名的脚本插件。每个插件
都是一个shell脚本。根据调用方式的不同，xmlto提供一个样式表供前端使用，或者以
各种预置的参数调用适当的后续处理器。
    这种架构意味着特定输出格式的所有信息都存放在一处（相应的脚本插件），因此
根本无需涉及前端代码就可以增加新的输出类型。
    xmlto是中型shell虚用程序的范例。由于C或C++都难以编写脚本，因此不适用。
本章描述的其它脚本语言虽可以用于此，但由于它只是简单的命令分派，没有内部数据
结构或复杂的逻辑，因此shell就足够了。而使用shell的重要优势就是在预期的目标系
UNfX编程艺术
  www.pdf365.com
332
第1 4章语言：C还是非C
统中shell普遍存在。
    理论上这个脚本可在支持bash的任何系统上运行。真正的限制是系统必须存在某个
XSLT引擎以及所有后处理器。实际上，除了现代的开源Unix，这个脚本不大可能运行
在其它任何地方。
14.4.3.2  实例分析：Sorcery Linux
    Sorcerer GNU/Linux是一个Linux发布版本，作为一个小型可启动简单系统而安装，
但它足以运行bash （1）和其它一些下载程序。一旦代码就绪，就可以启用Sorcery，即
Sorcerer包系统。
    Sorcery处理各种软件包的安装、卸载和完整性检验。输入指令后，Sorcery下载源
代码，对其进行编译和安装并保存安装的文件（以及编译日志和所有校验文件）。安装
好的软件包可删除或卸载。也可以列举软件包和进行完整性检验。更多详情参见Sorcery
项目竭}点<hLtp：//sorcerer .wox - org>。
    Sorcery系统完全使用shell编写而成。安装程序往往是很小的简单程序，shell对此
最为合适。在这个具体应用中，因为Sorcery的作者可以确保需要的辅助程序都在这个简
单系统中，所以shell的主要缺蠃被抵消了。
14.4.4  Perl
    Perl是增强了的shell。它为代替awk （l）而专门设计，并扩展用来代替shell作为
混合语言脚本编程的“胶合剂”使用。Perl首次发布于1987年。
    Perl最强功能是其内置的对文本、面向行的数据格式进行模式导向的处理功能。比
起shell，Perl包含更加强大的数据结构，包括混合元素类型的动态数组和支持名一值对的、
查找方便迅捷的散列（字典）类型。
    此外，Perl还包括一个完备的、经过深思熟虑的全套Unix API的内部支持，显著减
少了对C的需求并使其非常适合完成简单的TCPfIP客户端甚至是服务器端的工作。Perl
的另外一个优势在于围绕Perl已经形成了一个强大的开源社团。社团在网络上的主页是
Perl综合典藏网（Comprehensive Perl Archive Network） <http：／/WWW - cpan．org>。
献身于Perl的黑客们已经编写了成百上千个自由重用的Perl模块，可完成多种不同的编
程任务，从目录的结构遍历树、用于GUI构件的X工具包，到HTTP机器人和CGI编
程。
www.pdf365.com
14.4语言评估
333
    Perl的主要缺点在于某些部分丑陋到无法补救，某些部分过于复杂，某些部分必须
谨慎地、～成不变地使用以防出错（Perl的函数参数传递约定就是所有这三个问题的典
型例子）。同shell相比，Perl较难起步。尽管使用Perl编写的小型程序能够特别有效，
但随着程序规模越来越大，要遵守严格约定才能保持模块性和设计的可控性。由于无法
推翻Perl历史上一些限制性的设计决定，许多更高级的功能都具有一种脆弱、拼凑的感
觉。
    Perl的权威参考是Programming Perl （Perl编程）[Wa112000]。该书几乎包含了需要了
解的一切内容，但其结构出名的差；必须从中挖掘出要了解的知识。Leaming Perl（学习
Perl） [Schwartz-Christiansen]则提供了更有叙述技巧的入门级内容。
    Perl在Unix系统非常普遍。主版本相同的Perl脚本往往在各种Unix版本之间可以
直接移植（前提是这些Perl脚本不使用扩展模块）。Microsoft操作系统和MacOS上也
有Perl实现（甚至具备很好的文档）。而Perl/Tk提供了跨平台GUI能力。
    总结：Perl的最佳之处是作力强力工具以供大量涉及正则表达式匹配的小型胶合脚
本使用。最糟之处在于当程序很大时Perl会变得非常丑陋、刻板，几乎无法维护。
14.4.4.1  小型Perl程序案例分析：blq
    blq脚本是查询拒收列表（网站列表，已经确认为未经请求就大批量发送邮件，即
垃圾邮件的惯常发布源）  的工具。现行源码可在bla项目主页
<http：//www．unicom．com/ sw/blq/>上获得。
    blq是小型Perl脚本的范例，说明了Perl语言的优点和缺陷。它大量使用正则表达
式匹配。另一方面，Net::DNS Perl扩展模块可能需要额外安装，因为无法保证它在指定
的Perl安装上已经存在。
    blq和其它Perl代码一样特别干净和规范，因此我推荐其为良好风格（blq项目主
页引用的其它Perl工具也是好例子）的典范。但除非熟悉Per】具体的语法风格，否则有
部分代码是无法读懂的——代码的第一行，即$o=。8 1．★／！！j，就是个例子。尽管所
有的语言都有这类晦涩，但Perl是其中最晦涩的。
    Tcl和Python也非常适合编写这种类型的小脚本，但这两种语言都缺乏blq中大量
使用的正则表达式匹配，这在Perl中非常简便；采用任何～种语言来实现也许都有理由，
UNIX编罹艺I术
  www.pdf365.com
334
第1 4章语言：C还是非C
但可能都不如Perl紧凑和富有表达力。Emacs Lisp实现甚至可能比Perl实现编写更快、
更紧凑，但可能使用起来是令人痛苦不堪的慢。
14.4.4.2  大型PerI实例分析：keeper
    keeper是在ibiblio站点为大型Linux自由软件档案归档外来包并维护FTP和WWW
索引文件而使用的工具。可以在ibiblio档案站点<http：／/www．ibilolio．org>的搜索
工具子目录中找到源码和文档。
    keeper是大中型交互式Perl应用程序范例。命令行界面是面向行，并以专门的shell
或目录编辑器的面貌出现：内嵌的帮助功能值得注意。工作部分大量使用文件目录处理、
模式匹配和模式导向编辑。注意，keeper从程序模板生成网页和电子邮件通知非常便
利。也请注意，它使用白带的Perl模块来自动化在目录树不同功能之问的遍历。
    这个应用程序大约有3300行，町能提升了我们对~个Perl程序应有规模大小和复杂
度的期望极限。尽管如此，这个程序大部分在六天之内编写完成。如果使用C、C++或
Java，至少可能需要六周，而且完成之后特别难以调试或修改。这个程序对纯Tcl来谠过
大了。Python编写的版本可能在结构上更干净、更可读、而且可维护性也更好——但可
能也更冗长（特别是在模式匹配及相关部分）。Emacs Lisp模式也完全可以胜任编写工
作，但Emacs不太适合在telnet连接上使用，因为它经常因为服务器拥挤而速度慢得像
蜗牛。
14.4.5  Tcl
    Tcl（工具命令语言）是一个设计来连入C编译库的小型语言解释器，提供C代码的
脚本控制（扩展脚本）。Tcl的最初应用是控制电子仿真器所用的程序库（SPICE之类的
应用程序）o Tcl也适用于内嵌脚本——即从C程序内部调用脚本然后返回值。Tcl于1990
年首次发布。
    在Tcl之上构建的一些功能在Tcl社区以外得到了广泛的使用。其中最重要的两个功
能是：
●  Tk工具包，一种更亲切和更友好的X接口，便于快速构建按钮、对话框、菜单
    和滚动文本窗口并从这些构件中收集输入信息。
www.pdf365.com
14.4语言评估
335
    ●  Expect，一种更容易编写具有更多种响应纯交互程序的语言。
    Tk工具包如此重要，使得这个语言经常被称作为Tcl/Tk。Tk也频繁用于Perl和Python
中。
    Tcl自身的主要优势在于它特别灵活而且本质上非常简单。语法非常奇特（以位置分
析器（ positional parser）为基础），但整体上是统一的。没有保留字，在函数调用和内置
语言特性间也没有语法区别；这样，Tcl语言解释器本身就可以在Tcl内部有效地重新定
义（这就是象Expect之类程序的合理性所在）。
    Tcl的主要缺点在于纯Tcl语言只有十分薄弱的命名空间控制和模块性功能，而且如
果使用不当，其中两个（upvar和uplevel）相当危险。同时，除了关联列表以外，
Tcl也没有数据结构。因此，很难扩展Tcl-即使是中等大小（超过几百行）的纯Tcl
程序也很难在不绊倒自己的前提下进行组织和调试。在实践中，几乎所有大型的Tcl程
序都使用其00扩展。
    语法的怪异最初也是个问题：字符串引号和括号之间的区分可能让人头疼一阵，何
时使用引号、何时使用括号也需技巧。
    纯Tcl只提供对Unix API相对较小的常用部分的访问（基本上只是丈件处理、进程
生成和套接字）。实际上，Tcl具有～种实验的意味，看看一个脚本语言究竟变到多小还
依然有用。Tcl扩展（与Perl模块类似）提供了更为丰富的能力集，但（和CPAN模块
一样）不能保证处处都有安装。
    Tcl最早的参考资料是Tcl and the Tk Toolkit （Tcl和Tk工具包）[Ousterhout94]，但这
本书大部分已经被Practical Programming in Tcl and Tk （Tcl和Tk实用编程）[Welch]所替
代了o  Brian Kernighan对现实世界中的Tcl项目进行了一番描述[Kemighan95]，总结了
Tcl作为快速原型设计和开发工具的长处和不足；其中与Microsoft Visual Basic的对比非
常客观并具有指导意义。
    同Perl、Python不一样的是，Tcl世界并没有一个由核心团体管理的中央资料库，但
有几个优秀的网站互相链接并涵盖了大部分的Tcl工具和扩展开发。首先看以下的Tcl
Developer Xchange<ht tp：／／www. tcltk．com>;这个站点除了其它内容外，还提供了
一个交互式Tcl指导材料的来源。在SourceForge站点<ht七p：／／sourceforge．ne七
／foundry/tcl-f oundry/>上也有一个Tcl资料库。
    Tcl脚本也具有和shell脚本类似的可移植性问题；这个语言本身非常适于移植，但
它调用的组件未必如此。Microsoft操作系统、MacOs和许多其它平台也存在Tcl实现。
任何具有GUI能力的平台都可以运行Tcl/Tk脚本。
UNI×编翟艺术
  www.pdf365.com
336
第14章语言：C还是非C
    总结：Tcl的最佳之处在于它节俭、紧凑的设计和Tcl解释器的可扩展性。最糟之处
在于其古怪的位置分析器和孱弱的数据结构及命名空间控制——这个缺陷使其很难适用
于大型项目。
14.4.5.1实例分析：TkMan
    TkMan是Unix手册页和Texinfo文件使用的浏览器。这个程序大约1200行，使用
纯Tcl编写，应该说相当庞大，但代码出乎寻常地成熟和模块化。它使用Tk来提供GUI
界面，比原有公用程序man门j或xman（，，j支持的GUI界面更加友好。
    TkMan是个很好的研究实例，充分展示了Tcl的全套技法。突出表现在Tk集成、脚
本控制Unix的其它应用（如Glimpse搜索引擎），以及解析Texinfo标记的Tcl使用上。
    在其它任何一种语言中，都不可能用类似于它的代码产生如此直观的Tk GUI界面。
    在网络上查找关键字TkMan可以找到一些源码和文档。
14.4.5.2  Moodss:大型Tcl案例分析
    Moodss系统是一个系统管理员使用的图形界面监控应用程序。它可以监控系统日
志，为MySQL、Linux、SNMP网络和Apache等收集统计信息，并通过称为“dashboardw
的类似电子表格的GUI控制面板提供这些统计信息的摘要。监控模块也可象Tcl -样使
用Python、Perl等编写。这段代码非常精美、成熟，被视为Tcl社区中的典范。项目网
站为<http://j￡ontain.free.fr/moodss/>.
    Moodss内核包含18，000行Tcl代码。它使用了数个Tcl扩展，包括一个定制对象系
统：Moodss的作者承认，如果没有这些扩展的话，“编写如此巨大的一个应用程序是不
可能的”。
    再一次，在其它任何一种语言中，都不可能用类似于它的代码产生如此直观的Tk
GUI界面。
14.4.6  Python
    Python是一种脚本语言，设计本意是与C语言紧密集成。它既可以从动态载入的C
库程序中接收数据也可以向其传输数据，它也能够在C中作为嵌入脚本语言调用。Python
的语法介于C语言和Modula系列语言之间，但有个非常罕见的特征，即代码块结构实
www.pdf365.com
．-月月lE言{∞t七
I't．叶  匝口阡『口
337
际上用缩进来控制（没有明确的begin/end或C花括号之类的东西）。Python最早公开
发布于199 1年。
    Python语言的设计是非常干净优雅，具有非常出色的模块化特性。它提供了设计者
用面向对象风格编码的可能，但并不把这个选择强加于设计者（可以用更加经典的类C
方式编码）。它的类型系统，其表达力和Perl系统相当，包括动态容器存储对象和关联
列表（ association list），但并非那样怪异（实际上，Perl对象系统模仿了Python对象系
统是有案可查的）。它甚至因为具有匿名lambda对象（以函数为对象值，可在迭代器之
间传递并被迭代器使用）而迎合了Lisp黑客。同Python -起发布的一般还有Tk工具包，
可以非常方便地构建GUI界面。
    Python标准发布包括大多数重要网络协议（SMTP、FTP、POP3、IMAP和HTTP）
的客户类以及HTML生成器类。因此它非常适合构建协议机器人和网络管理工具。它也
非常适合Web CGI任务，并能在这个高复杂的领域中同Perl竞争，并取得一席之地。
    对于扩展需要协同开发的大型复杂项目，在我们描述的所有觯释型语言中，Python
和Java无疑是两个最佳的语言。在很多方面Python都比Java简单，并且它对快速原型
设计的亲和性，使它独立使用在那些既不太复杂又不要求速度致胜的应用程序中并优于
Java。Java实现的Python，其设计目的是为了促进这两种语言的混合使用，目前已面世
了并用于开发；称之为Jython。
    Python在纯执行速度方面无法同C或C++竞争（尽管在现今快速处理器上应用混合
语言策略使这点已经相对不那么重要）。实际上，人们通常认为Python是主要脚本语言
中效率最低、速度最慢的语言，这是它为运行期类型多态付出的代价。然而当心，别因
为这些原因而拒绝Python，Python能够提供的性能实际上已经满足人多数应用程序，即
使那些似乎需要更好性能的程序通常也受到网络等待或磁盘等待等外部延时的限制，从
而完全抵消了Python解释型开销产生的影响。作为补偿，Python特别容易和C结合起来，
因此性能关键的Python模块可以很方便地转换成C语言来显著提高速度。
    对于小型项目和大量依靠正则表达式能力的胶合脚本，Python不如Perl的表达力强。
对于太小的项目，Python是大材小用了．shell或Tcl也许更适合。
    同Perl -样，Python也形成了一个组织良好的开发社区，其核心站点
<http：／/www．pyt hon．org>包含大量有用的Python实现、工具和扩展模块。
    Python的权威参考是《Programnung Python》（Python编程）[Lutz]。Python网站上也
有关于Python扩展的大量在线文档。
    Python程序往往可在各种Unix之间移植，甚至可以移植到其它操作系统；标准库非
UNIX编瞬l艺．宋
    www.pdf365.com
338
第1 4章语言：C还是非C
常强大，显著减少了对不可移植的辅助程序的使用。Microsoft操作系统和MacOS上也
有Python实现。只要有Tk或其它两种工具包就可以跨平台实现GUI开发。Python/C应
用程序可以被“冻结”（frozen），准编译成纯C源码，这样就可以移植到没有安装Python
的系统上。
    总结：Python的最佳之处在于它鼓励清晰、易读的代码，易学易用，又能够扩展到
大型项目。最糟之处在于，不仅相对于编译语言，而且相对于其它脚本语言，它也是效
率低下、速度缓慢的。
14.4.6.1  小型Python案例分析：imgsizer
    imgsizer是一个改写www网页的公用程序，能够在图像标记中加入图像的正确尺
寸（这提升了在很多浏览器上的网页载入速度）。可以在ibiblio档案站点
<ht tp：／／mⅢ．ibiblio．org>的URL WWW工具子目录下找到源码和文档。
    imgsizer最初使用Perl编写，几乎是Perl擅长的那种小型、模式驱动的文本处理
工具的理想实例。后来为了利用Python对HTTP获取的库支持优势而转化成了Python；
这消除了对外部网页获取程序的依赖。注意宦使用了file（1）和ImageMagick identify（1）
作为提取图像像素大小的专用工具。
    动态字符串处理和复杂正则表达式匹配的需求让使用C或C++来编写imgsizer变
得异常痛苦；而且相应的版本也会更加庞大、更加难读。Java当然也可以解决隐含的内
存管理问题，但在文本模式匹配方面几乎不会比C或C++更有表达力。
14.4.6.2  中型Python案例分析：fetchmailconf
    在第II章，作为分离实现和接口的例子我们分析了fetchmaiUfetchmailconf程序对。
fetchmailconf很好地展示了Python的优势。
    fetchmailconf使用Tk工具包来实现多面板GUI配置编辑器（Python中也有GTK+
和其它工具包的，但每个发布Python解释器中都包含Tk工具包。）
    在专家（expert）模式，GUI支持编辑六十个左右的属性，分成三个面板。属性窗口
部件包括复选框、单选按钮、文本框和滚动列表栏。尽管这样复杂，但配置器的第一个
全功能版本只花了我不到一周的时间就完成了设计和编码，其中还包括学习Python和
Tk的四天时间。
www.pdf365.com
339
    Python擅长GUI界面的快速原型设计，而且（正如fetchmailconf所示）此类原型通
常也是可交付的。Perl和Tcl在此领域也有类似的优势（包括为Tcl编写的Tk工具包），
但很难控制到fetchmailconf的复杂度（大约1400行）级别上。Emacs Lisp不适合GUI
编程。而选择Java会提高复杂度开销，且不会为这个非速度致胜型程序带来显著收益。
14.4.6.3  大型Python案例分析：PIL
    PIL，即Python Imaging Library （Python图像库），支持位图图像处理。它支持许多流
行的格式，包括PNG、JPEG、BMP、TIFF、PPM、XBM和GIF。Python程序可用它来
转换图像；支持的变换包括裁剪、旋转、缩放和切变：也支持像素编辑、图像卷积和色
彩空间转换。PIL发布包括从命令行运行这些功能的Python程序。这样，PIL可用于批
处理模式的图像转换或作为一个强力工具包执行由程序驱动的位图图像处理。
    PIL的实现表明Python能够直接使用可装载的目标码扩展模块增强Python解释器。
为了提高速度，在位图对象上执行基本操作的库内核是用C编写的。上屡和前后逻辑则
是用Python编写的，速度慢，但更容易阅读、修改和扩展。
    使用Emacs Lisp或shell编写类似的工具包会非常困难，甚至不可能。因此Emacs Lisp
或shell根本没有C扩展接口，而如果用Tcl编写的话，PIL会大得令人不舒服。Perl具
有类似的功能（Perl XS），但同Python相比，它过于专用，文档不全，十分复杂，也不
稳定，因此使用得少之又少。Java的本地方法接口（Native Method Interface）似乎能够
提供和Python大致相当的功能；PIL可能成为～个相当合理的Java项目。
    在项目站点<http：／/www．pythonware．com/produc tS /pil/>可获得PIL的
代码和文档。
14.4.7  Java
    Java编程语言的设计目标是“wnte once，run anywhere（-次编写，到处运行），，，
并且支持网页中嵌入交互程序（即applets），可在任何一个浏览器中运行。由于其所
有者Sun Microsystems的一系列技术和战略失误，Java没有实现这两个最初的设计目
标。但它在系统编程和应用编程方面仍然十分强大，足以挑战c和C++c， Java岔布于
1995年。
UNIX编窿艺-术
    www.pdf365.com
340
第1 4章语言：C还是非C
    尽管远比C++小巧简单，但Java设计非常聪明地抓住了自动管理内存的巨大优势，
也抓住了支持00设计这一虽小却并非不重要的优点。Java保留了大量的类C语法，大
多数程序员对此感觉非常舒服。它也包括支持动态载入的C调用并支持在C中把Java
作为嵌入语言调用。Sun公司在网上提供良好Java文档的工作完成得非常出色，这一点
作用也不可小觑。
    Java的负面，我们可以说（例如，同Python相比较）有些部分显得过于复杂，而另
外一些部分则不够完善。Java中，类的可见／不可见区域的规定非常复杂。接口功能虽然
避免了多继承产生的复杂问题，但理解和使用并不会简单多少。内部类和匿名类等特征
可能会导致非常混乱的代码。而缺乏可靠的析构方法则意味着内存以外的其它资源，例
如互斥（ mutex）和文件锁定等，难以保证得到正确管理。Unix操作系统的重要功能也
无法从Java主体中访问，包括信号、poll和select等。尽管Java的1/0功能非常强大，
但文本文件的简单读取并不简单。
    Java库存在一个特别令人反感的问题，和Windows DLL hell问题非常相像。Java没
有管理不同库版本昀方法气这在应用服务器之类的环境中会产生巨大的问题，因为服务
器可能配置的是（比如说）某XML库版本，但应用程序却随另外（通常是较新的）版
本一起发布。对此类问题的唯一处理是使用CLASSPATH环境变量，但却是不断产生配
置问题的错误来源。
    更进一步，Sun公司对Java语言的处理无论在政策上还是在技术上都十分迟钝。Java
的第一个GUI工具包AWT一团糟，必须完全替换掉。而把该语言从ECMA/ISO标准中
撤出进～步激怒了早已为Sun Community Source License（SCSL）感到恼火的众多开发人
员。SCSL的限制还妨碍了Java l.2的开源实现和J2EE（Java 2 Enterprise Edition/Java 2
企业版）规格说明。这损害了Java普遍移植的初衷。
    悲哀的是，浏览器applets已经消亡了。Microsoft在IE中不支持Java l.2的决定实
际上绞杀了它们。然而，Java似乎在计算业中发现了一个安全的生存空间，让“servlets"
在网页应用服务器的内部运行。Java也经常用于不和数据库或网页服务器直接相连的企
业内部编程。它也已经成为Microsoft的ASP/COM乎台和Perl CGI的主要竞争者。最后，
作为初级编程（Java特别适合这个角色）的教学语言，Java的使用越来越广泛。
    总而言之，我们可以认为，对于除系统编程以及大多数速度关键的应用程序外的一
切编程而言t  Java比C++高级（C++复杂得多，而且没有为解决内存管理问题作出多少
努力）。经验似乎表明，和C++程序员相比，Java程序员掉进过度00分层这一陷阱的
可能性似乎要小一点，尽管这仍然是个大问题。
www.pdf365.com
14.4语言评估
341
    如何权衡Java和我们本章描述的其它语言，目前还不清楚，可能主要取决于项目
的规模。我们可以设想Java的正确使用范围和Python比较相近。同Python -样，Java
无法和C或C++在原始执行速度方面竞争，也无法和Perl在大量使用模式引导编辑的
小项目竞争。Java对小项目是大材小用（这一点比Python更确定）。我们可以认为，
Python在小一些的项目上具有优势，而Java在大一些的项目上具有优势，但这并非定
论。
    最好的参考书可能是Java In A Nutshell （Java技术手册）Flanaganjava】，但这不是最好
的入门级指导材料；最好的入门级指导可能是Thinking in Java Clava编程思想）[Eckel]。对
全球所有Java网站的链接始于Sun公司的Java站点<http：／／j ava．sun．com>，该站点
也具有可免费下载的完整HTML文档。开源目录Java网页（Open Directory Java Page）
<ht tp：／/dmoz．org/Computers/ Programming/Languages/Java/>也汇集了许
多有用的Java键接。
    所有的Unix操作系统、Microsoft操作系统、MacOS和其它很多平台都有Java实现。
    可在Kaffe项目站点<http：／/www．kaffe．org／>获得Kaffe（ -个开源Java实现，
类库符合大多数JDK l.1和部分JDK l.2的要求）的源码。
    GCC也有一个Java前端。GCJ可以把Java代码编译成Java bytecode或本机码，
也可以把Java bytecode编译成本机码。它配置了执行大部分JDK l.2要求的开源类库·
和一个称为gij的Java bytecode解释器。  详情参见GCJ项目网页
<http: //gcc. gnu. org/j ava/>。
在JDEE项目站点<ht tp：／／jdee．sunsite．dk/>有基于Emacs的Java IDE。
    Java语言本身的可移植性非常优秀。但不完整的库实现（特别是不支持新JDK l.2
的老JDK l.1库）是个问题。
    Java的最佳之处在于它非常接近“…次编写、到处运行”的目标，作为～个独立于
操作系统的环境非常有用。最糟之处在于Java l/Java 2的分裂令人沮丧地损害了这个目
标的实现。
UNIX编程艺_术
    www.pdf365.com
342
第1 4章语言：C还是非C
14.4.7.1  案例分析：FreeNet
    Freenet足一个对等网络项目，目的是创建没有审查和内容禁止的网站6。Freenet开
发者设想了以下应用：
    ●  争议信息的不审查分发：Freenet保护言论自由，范围从民间另类新闻到受禁曝
    光材料的林林总总，都可以不经审查地匿名发表。
    ●  高带宽高效内容发布：用Freenet的适应性高速缓存（adaptive caching）和镜像
    来发布Debian Linux更新软件。
    ●．通用个人发布：Freenet让任何人都能够拥有没有空间限制和强制性广告的网站，
    即使没有电脑而想成为网站管理员的人也能如愿以偿。
    Freenet通过提供一个虚拟空间来达到这些目标，在这个虚拟空间中发布的文档不与
任何具体的机器相关。发布信息和Freenet内部数据索引通过网络进行复制分发，即使是
Freenet管理员在任何给定时间里也不清楚所有的物理文档会在哪里。Freenet浏览者或信
息提交者的隐私通过强密码系统加以保护。
    Java作为这个项目的上上之选至少有两个理由。首先：项目目标非常重视最广泛的
实现兼容性，因此Java的高度可移植性成为一个主要优势。其次：这个顼目的本质促使
网络API变得非常重要，而Java恰好内置了一个强大的API。
    C通常用于对性能要求很高的基础项目上，但缺乏标准的网络API使移植变得非常
困难。C++也存在同样的困难。Tcl、Perl或Python可以减轻移植负担，但代价是牺牲太
大的性胄皂。Emacs Lisp速度缓慢得令人痛苦因而完全不适用。
14.4.8  Emacs Lisp
    Emacs Lisp是一种脚本语言，用于Emacs文本编辑器的行为编程。它首次发布于1984
年。
    从本章其它语言分析的相同角度来说，Emacs Lisp并不是一种通用语言：尽管它足
够强大，理论上可以作为通用语言使用，但传统上，它只用于为Emacs编辑器编写本身
的控制程序，并不像现代脚本语言那样能和其它软件顺畅通讯。
6 Freenet项目的网站：<http：//freenetproj ect .org>。
www.pdf365.com
14.4语言评估
343
    尽管如此，在相当范围的应用中，Emacs Lisp比其它语言更为有效。这些程序大多
都与为开发工具提供一个前端有关，包括C编译器和链接器、make （l）、版本控制系
统和符号调试器等等；我们将在第15章讨论这些内容。
    更一般的是，Emacs之于模式导向或语法导向的爻互编辑，就如同Perl之于模式导
向的批处理编辑一样。任何涉及交互编辑特定文件格式或文本数据库的应用程序，使用
Emacs模式（一种定制编辑器行为的Emacs Lisp程序）进行原型设计（甚或交付）都是
上佳的选择。
    Emacs Lisp也非常适合构建必须和文本编辑器紧密整合在～起的应用程序，或是主
要作为文本浏览器而兼具某些编辑功能的应用程序。email和Usenet新闻的用户代理就
属于此类。一些数据库前端也是如此。
    Emacs Lisp是一种Lisp语言。它自动进行内存管理，就像黑夜之后是白天一样自然，
因而比大多数传统语言更雅致、更有效，或者，确切地说，也比大多数新兴语言都更雅
致、更有效；在这个方面它可以同Java或Python竞争，更远超C/C++、Perl、shell或
Tclo Lisp缺少标准的可移植OS规范，这个老毛瘸已由Emacs内核解决，实际上Emacs
内核就是其OS规范。
    Lisp另外一个老毛病——狂吃资源一一在现代机器上也不再是个问题。  “Emacs
Makes A Computer Slow"  （Emacs让计算机变慢）和“Eventuallv Munches All Computer
Storage"（最终吃光所有计算机内存）之类的调侃曾经非常流行（实际上Emacs发布本
身就包含这样的一个笑话列表）。但现在其它许多经常使用的程序（如网页浏览器）都
比Emacs更大、更复杂，所以比较而言，反而Emacs似乎变得比较适中了。
    Emacs Lisp的权威参考是The GNU Emacs Lisp Reference Manual （GNU Emacs Lisp
参考手册），可在Emacs的"info"帮助系统中浏览。如果没有，可从FSF的FTP站点
<ftp：／／ftp．gnu．org/pub/gnu>下载。如果觉得太深，《Writing GNU Emacs
Extensions》（编写GNU Emacs扩展编写）[Glickstein]可能会有帮助。
    Emacs Lisp程序的可移植性非常卓越。所有的Unix操作系统、Microsoft操作系统和
Mac搡作系统都有Emacs实现。
    总结：Emacs Lisp的最佳之处在于结合了非常优秀的基础语言Lisp，其域原语对文
本操作非常有效。最糟之处在于性能较差，难以和其它程序通讯。
更多详情参阅后续章节“选择编辑器”中对Emacs的讨论。
UNIX编霜已艺：习}
    www.pdf365.com
344
第1 4章语言：C还是非C
14.5未来趋势
    表14.1大致表明了当今语法使用的分布情况。我们给出了来自SourceForge7和
Freshmeat的数据8，这是到2003年3月为止两个最重要的新软件发布站点。
    SourceForge的数字在几个方面有所欠缺：最明显的，SourceForge的查询界面不允
许同时将OS和语言作为过滤条件，所以其中部分数字代表的是MacOS和Windows项目。
其结果可能就是C++和Java的份额相对会放大一些。然而，基于Unix的项目充分地占
据了垄断地位（大概是3:1的比例），所以除了上述两个语言，其它语言的数据可能并
没有多大的变形。
    Freshmeat的样本数据较小，但是站点本身只发布基于Unix的项目——而且统计的
是确确实实的发布版本，不像SourceForge -样包括大量失败的、停顿的项目。有趣的是
同SourceForge相应统计相比，其比率几乎都是1:2，当然正好也要除去一些情况（C++
和Java），我们可以认为那不成比例，是因为Freshmeat缺少基于Windows的项目。
    本章最初在1997年起草；在2003年年中完成。这足一个相当长的时间段，趼以上
述我们检视的语言，自从第一次写作以来，其相对地位已经发生了改变，并显现出一种
采用趋势，而这趋势恰好昭示了其语言特征。  （对于这些最常使用语言的开源实现，其
提高和改善工作，社区规模就是一个重要的质量和数量因子；而其增长和衰落往往更增
加了说服力。）
    宽泛地说，C、C++以及Emacs Lisp在1997 - 2003时间段保持稳定，在2003年与
1997年一样，吸引着相同数量的支持者。C得到缓慢增长，占据了如FORTRAN更古老
传统语言的份额：另～方面，C++被Java夺取了些许阵地。
    Perl使用的增长非常可观，但语言本身在一段时间已停滞不前。Perl内部非常糟糕；
认识到语言实现需要推倒重来已经有好几个年头，但在1999年的努力却以失败告终，而
在2003年中的另一努力似乎也停滞了。不管怎样，Perl仍然还是八百磅巨型猩猩式的脚
本语言，并且在网页脚本和CGI方面占据主导地位。
    Tcl已经处于一个相对衰减的时代，或者至少是出镜次数逐渐减少的时代。在1996
7勿0计q次字来自<hLtp：／/sourcef orge．net/sof twaremap/Lrove_list．php?form_cat=160>，
8*TCj+4~~来自<ht tp：／／freshmeat.net/browse/160／?topic_id=160>.
www.pdf365.com
14.5未来趋势
345
年一个广泛流传的看似真实的估计中，就社区规模而言，每有一个Python使用者，对应
就有5个Tcl使用者，12个Perl使用者。今天，SourceForge的数据表明这个比率大概是
3:1:7。然而，据说Tcl被广泛使用在好几个工业领域的专门化脚本组件方面，包括电子
设计自动化（EDA），广播电视业以及电影业等。
表14.1  语言选择
┏━━━━━━━━┳━━━━━━┳━━━━━━━┓
┃    语言        ┃SourceForge ┃    Freshmeat ┃
┣━━━━━━━━╋━━━━━━╋━━━━━━━┫
┃    C           ┃    10296   ┃    4845      ┃
┣━━━━━━━━╋━━━━━━╋━━━━━━━┫
┃    C++         ┃    9880    ┃    2098      ┃
┣━━━━━━━━╋━━━━━━╋━━━━━━━┫
┃    Shell       ┃    1058    ┃    487       ┃
┣━━━━━━━━╋━━━━━━╋━━━━━━━┫
┃    Perl        ┃    4394    ┃    2508      ┃
┣━━━━━━━━╋━━━━━━╋━━━━━━━┫
┃    Tcl         ┃    649     ┃    328       ┃
┣━━━━━━━━╋━━━━━━╋━━━━━━━┫
┃    Python      ┃    2222    ┃    948       ┃
┣━━━━━━━━╋━━━━━━╋━━━━━━━┫
┃    Java        ┃    8032    ┃    1 900     ┃
┣━━━━━━━━╋━━━━━━╋━━━━━━━┫
┃    Emacs Lisp  ┃    '       ┃    3 1       ┃
┗━━━━━━━━┻━━━━━━┻━━━━━━━┛
    Python随着Tcl的衰落而迅速崛起。尽管Perl社区的规模仍然有Python的两倍大，
但一个明显的趋势是，最精明的Perl黑客都流向了Python，这对Perl语言是相当不利的
——尤其是根本就没有反向迁移。
    Java在已经投入Sun Microsvstem技术的站点中广泛使用，也作为大学生计算机科学
课程的指导性语言而广泛部署。然而在别的地方，只比1997年稍微流行一些。Sun -意
孤行的所有权许可模型妨碍了许多当年评论家预浏的主要突破；而在Linux和更广泛的
开源社区，Java对C并没有获得像在别处取得的那种进展。
    还没有出现新型的通用语言，对已经在此讨论的语言构成严重的挑战。PHP正在侵
蚀网络开发，挑战Perl CGI（以及ASP和服务器端Java），但是几乎从未使用在单机编
程中o Non-Emacs Lisp方言，一个曾经十分有前途的语言在上世纪九十年代似乎能够驶
向辉煌，但最终还是淡出了。最近的成果，例如Ruby（日本人开发的Python-Perl-Smalltalk
杂交体）和Squeak（～个开源的Smalltalk移植）看起来似乎很有前途，但至今既没有吸
引到除自身开发组之外的用户，也没有展示出持久力。
www.pdf365.com
346
第1 4章语言：C还是非C
14.6  选择X工具包
    同选择开发语言相关的问题是选择GUI编程工具包。回顾一下第一章中关于X如何
    分离机制和策略的讨论。每个可能选择的工具包都将带来些许不同的观感。
    X工具包的选择在两方面影响着同开发语言的选择：首先，有些语言的本身就绑定
    了某个偏爱的工具包，其次，一些工具包可以绑定进的语言是个有限的集合。
    当然，Java存在本身内建的跨平台工具包，所以选择只会落在AWT（普遍都有配置）
    和Swing（更强大、更复杂、更缓慢，仅仅在JDK l.2/Java 2中支持）之间。所以这部分
    余下的内容集中在我们已经讨论过的其它语言中。类似的，如果使用Tcl，Tk是捆绑而
    来的。没什么其它选择的余地了。
    曾经无处不在的Motif工具包实际上已宣告死亡。它已经跟不上无发布限制和无需
    许可费用的新兴工具包。这些新兴的工具包吸引了更多开发者的努力，无论在能力和特
    性方面都淹没了老旧的闭源工具包。现在，竞争全部来自开源阵营。
    在2003年，有四个工具包值得认真考虑，分别是Tk、GTK、Qt和wxWindows，  当
    然GTK和Qt无疑是领跑者。所有四个T具包都移植到了MacOS和Windows中，所以
    迭择其中任何一个都具备跨平台开发能力。
    Tk工具包是四个中最悠久的一个，优势当然是资历深厚；该工具包原生于Tcl，Python
    接口随Python本身一起发布。也有供C和C++程序库使用的Tk语言接口。不幸的是，
    Tk在其标准的窗体构件集方面也老态毕现，既有限又丑陋。另一方面，其它工具包要达
    到Tk中Canvas控件具备的能力还有些困难。
    GTK生来就是为了取代Motif，并且支持GIMP。现在是GNOME工程项目酷爱的
    工具包，为成百上千的GNOME应用程序所使用。原生API是C的；也有C++、Perl、
    Python接口，但并没有包含进语言的主发布。GTK是四个工具包中唯一的C原生接口。
    Qt工具包被KDE工程所使用，是原生的C++库，也有Python和Perl接口但并不同
    解释器本身一同发布。Qt获得了四个工具包中最佳设计和最具表达力API的声誉，然而
    早先许可授权版本的争论阻碍了它的广泛采用，C接口总是迟迟不予以发布的事实也进
    一步延缓了它的广泛采用。
    wxWindows是原生的C++库，同时可以获得Perl和Python接口。wxWindows开发
    者着重强调它们的跨平台开发，也以此作为工具包的主要卖虑。另一个卖点是
    wxWindows实际上是基于每个平台上原生（GTK、Windows和MacOS 9）窗体构件的包
UNIX编程艺术
    www.pdf365.com
14.6选择X工具包
347
装器，这样使用该工具包编写的应用程序保留了原味观感。
    在2003年年中，几乎没有各种工具包的详细对比说明，但是网络搜索“X toolkit
companson”或许能得到一些有用的采样数据。表14.2汇总了各种工具包的状态。
表14.2  X工具包总结
┏━━━━━━┳━━━━━━┳━━━━━━━┳━━━━━━━━━━━━━━━━━━━┓
┃    工具包  ┃  原生语言  ┃  发布对象    ┃    绑定接口                          ┃
┣━━━━━━╋━━━━━━╋━━━━━━━╋━━┳━━━┳━━━┳━━━┳━━━━┫
┃            ┃            ┃              ┃  C ┃ C++  ┃Perl  ┃ Tcl  ┃ Python ┃
┣━━━━━━╋━━━━━━╋━━━━━━━╋━━╋━━━╋━━━╋━━━╋━━━━┫
┃    Tk      ┃    Tcl     ┃  Tcl， Python ┃  Y ┃  Y   ┃  Y   ┃  Y   ┃    Y   ┃
┣━━━━━━╋━━━━━━╋━━━━━━━╋━━╋━━━╋━━━╋━━━╋━━━━┫
┃    GTK     ┃    c       ┃  Gnome       ┃  Y ┃  Y   ┃  Y   ┃  Y   ┃    Y   ┃
┣━━━━━━╋━━━━━━╋━━━━━━━╋━━╋━━━╋━━━╋━━━╋━━━━┫
┃    Qt      ┃    C++     ┃    KDE       ┃  Y ┃  Y   ┃  Y   ┃  Y   ┃    Y   ┃
┣━━━━━━╋━━━━━━╋━━━━━━━╋━━╋━━━╋━━━╋━━━╋━━━━┫
┃  wxWindows ┃    C++     ┃              ┃    ┃  Y   ┃  Y   ┃  Y   ┃    Y   ┃
┗━━━━━━┻━━━━━━┻━━━━━━━┻━━┻━━━┻━━━┻━━━┻━━━━┛
    架构方面，这些程序库都是在同一抽象层次上编写的。GTK和Qt都使用类似的接
收／发送信号的事件处理机制，所以移植起来据说几乎是小菜一碟。因此，在几个工具包
间选择，其它都没问题，最主要的局限是它们提供何种语言的接口。
UNIX编腥艺-术
  www.pdf365.com
www.pdf365.com
1 5
    I    _    ●
    l■I一．
    ●    _  ■  ●
    _—L_-●
．-—■．-．，、●
开发的战术
Tools: The Tactics of Development
Unix is  user-friendly-it rS just choosV about who  its friends are.
Unix对用户是友好的一只不过是挑剔的友好。
    一佚名
15.1  开发者友好的操作系统
    Unix作为一个良好的开发环境长期以来享有盛誉。许多程序员为程序员而写的工具
使它配备精良。这些工具自动完成了不少琐碎的工作，从而让人心无旁骛地专注于开发
中最重要（也是最享受）的部分——设计。
    尽管所需要的工具都是现成的，文档也做得很棒，但并没有通过一个集成开发环境
（IDE）结合在一起。所以往往需要花费相当的努力才能找到它们，装配起来，从而形成
～套适合需要的工具。
    也许读者过去习惯于一个完备的IDE-在Macintosh和Windows系统中常见的、
配备了编辑器、配置管理器、编译器和调试器的GUI系统——那么Unix的方法似乎显
得随意、含混、太过简陋。但那确实是Unix中的方法。
    IDE对于缺乏工具的单一语言编程非常有意义。如果所作所为仅限于机械地以手工
作坊式地研磨出C或C++代玛，IDE就相当适合。然而在Unix下，语言和实现的选择广
泛多样。所以同时使用多个代码生成器、定制配置器以及许多其它标准定制工具就是司
UNIX Sga艺-宋
  www.pdf365.com
350
第1 5章工具：开发的战术
空见惯的事情了。
    在Unix中也有IDE（有数个开源实现，包括Macintosh和Windows上主要IDE的模
拟器）。可是它们难以控制编程工具开放的多样性，因此并未广泛使用。Unix提倡一种
更灵活的风格，一种以编辑／编译／调试循环为中心、排它性更少的风格。
    在本章中我们将介绍Unix下的开发策略——编译代码、管理代码配置、性能分析、
调试以及自动完成各种脏活累活，而让人更专注于有趣的部分。同以往～样，说明更注
重整体结构、而不是具体做法。如果需要了解这方面的细节，本章介绍的大多数工具在
《Programming with GNU Software》（用GNU软件编程）[Loukides-Oram]中都有很好的
叙述。
    当然这些工具自动完成的许多事情都可以手工解决，但这只会更慢，错误率也只会
更高。攀爬学习曲线的～次性付出，得到的是更有效编写程序的能力；精力也可以更多
地放在设计层面而不是低层次的细节操作。
    传统上，Unix程序员就从其他程序员那里学习如何使用这些工具，潜移默化、悉心
钻研。如果你是位新手，请特别留意；我们将一开始就通过展示正确做法来让你完成Unix
学习曲线上最大的～跳。如果你是位忙碌的有经验的Unix程序员，可以跳过本章——但
也许不该如此。这儿的一些有用知识可能恰好你并不知道。
15.2编辑器选择
    首要和最基本的开发工具是一个适合修改和编写程序的文本编辑器。
    一一数来，在Unix下有十几种文本编辑器；编写一个文本编辑器似乎是入门级开源
玩家标准的练手程序之～。这些编辑器多数都暂如朝露，除了作者之外并不适合其他任
何人扩展使用。有些模拟了非Unix系统的编辑器，对于习惯其它操作系统的程序员，可
以作为转换的帮助。在SourceForge或ibiblio或其它主要的开源档案站点有种类繁多的
编辑器。
    对于严肃的编辑工作，两款编辑器完全统治了Unix编程界。两者都有几个次要的变
种实现，有一个标准版本，可以毫无疑问地在任何现代Unix系统上找到。它们是vf和
Emacs。我们在第13章关于软件的适当规模～节中讨论过。
www.pdf365.com
15.2编辑器选择
351
    正如我们在第13章注意到的一样，这两款编辑器在设计哲学上表现出尖锐的对立，
但两者都极端流行并且赢得了可观的核心用户群。Unix程序员民意调查～直表明两个阵
营大约对等，而其它所有的编辑器几乎都排不上号。
    在我们先前对vi和Emacs的检视中，主要关心的是可能复杂度以及相关的设计哲学
问题。此外值得去了解的，是它们蕴含的工程实用精神和Unix文化修养。
15.2.1  了解vi
    VI这个名字是“visual editor（可视编辑器）”的缩写，发音为/vee eVe/（不是/vie/并且
绝对不是/ iks/!）。
    Vf并不是最早的面向屏幕编辑器；那是Rand editor，即re的荣誉，它在1970年代
运行在Unix版本6上。但V1是最长寿的、仍在使用的、为Unix编写的面向屏幕编辑器，
而且已经成为Unix传统中的一个神圣部分。
    Vi的原始版本在1976年随最早的BSD软件发布；现在已经废弃了。替代的是随着
4.4BSD -起发布的“新VI”，也可以同时在一些现代的4.4BSD变种诸如BSD/OS、FreeBSD
和NetBSD系统中找到。还有几个具有扩展功能的变种，著名的有vzm、vile、elvis祁xvi;
在这些版本中，vim可能是最流行的，可以在许多Linux系统上找到它。所有的这些变种
都十分相似，并且共享～个从最初vi版本以来就没有变化过的核心命令集。
也有移植到Windows操作系统和MacOS上的Vl编辑器。
    多数介绍Unix的书籍都会用整整一章来描述基本的Vl用法。关于VI的常见问题解
答可以在Editor FAQ/vi<ht tp：／/WWW．faqs．org/faqs／editor- faq/vi/>处获得；
以包含“VI”和“FAQ”网页名称为关键字做WWW搜索，可以找到许多其它资料。
15.2.2  了解Emacs
    Emacs代表“Editing MACros”（宏编辑，发音为/eemaks/）。最初是在1970年代
作为一个叫做TECO编辑器的一套宏而编写的，随后又以不同的方式重新实现了好几次。
一个意想不到的有趣转变是，现代的Emacs实现包含有～个模拟TECO的模式。
    在早些时候讨论编辑器和可能复杂度时，我们注意到许多人都认为Emacs太过沉重。
然而，花时间学习它可以获得很大的生产力回报。Emacs支持许多威力强大的编辑模式，
能够为输入各种编程语言和标记语言提供语法上的帮助，我们在本章稍后部分可以看到
UNIX编程艺术
  www.pdf365.com
352
第1 5章工具：开发的战术
Emacs是如何同其它开发工具组合起来，从而获得并不逊于常规IDE（在许多方面甚至
超过）的能力。
    在现代Unix中普遍存在的标准Emacs是GNU Emacs;在Unix shell提示符下键入
emacs通常都会运行它。GNU Emacs源码和文档可以在自由软件基金的存档站点
<ftp：//gnu．org/pub/gnu>处获得。
    唯一的主要变种叫做XEmacs；它有着更好的X界面，但在功能上非常相似（它派
生自Emacs 19）。XEmac.s的主页是<http：／／www. xemacs．org>。Emacs（连同Emacs
Lisp）在现代的Unix中通常都可以获得。同时也已经移植到MS-DOS（那里工作得很差）
和Windows 95以及NT中（在那儿据说运行得相当好）。
    Emacs包含自带的交互教程以及非常完备的在线文档；可以在Emacs的默认启动屏
幕中找到调出它们的说明。《Leaming GNU Emacs》（学习Emacs）【Cameron]是一本优秀
的参考书。
    在Netscape/Mozilla的Unix版本和Internet Explorer的文本窗口（表单和邮件发送器]
中使用的键盘命令拷贝自Emacs中绑定的基本文本编辑命令。这些绑定最适合作为跨平
台编辑器的键盘命令标准。
15.2.3非虔诚的选择：两者兼用
透。
许多人经常规则地使用Vi和Emacs来做不同的事情，并且认为非常值得把两者都摸
    总的来说，V1最适合用来完成小型任务——邮件的快速回复、系统配置的简单调整
等。尤其是正在使用一个新系统（或者通过网络的远程系统）而自己的Emacs定制文件
又无法唾手可得时特别有用。
    在处理复杂任务、修改多个文件、需要使用其它程序结果扩展编辑时，Emacs开始
显现威力。对于在控制台使用X的程序员（这在现代Unix上非常典型），一登录通常
就启动一个Emacs窗n，并一直运行下去，然后可能会在多个Emacs子窗口访问十几个
文件甚至运行程序。
15.3专用代码生成器
Unix长期存在一个宿主工具的传统，这些工具明确设计来生成不同专门目的的代码。
www.pdf365.com
15.3专用代码生成器
353
这种值得尊敬的传统典范，需要追溯回到版本7甚至更早的日子-1970年代用来编写
原始可移植C编译器的lex（1）和Vacc （1），它们作为GNU工具包的一部分，今天仍
被大量使用，而它们向上兼容的现代后继者是flex （l）和bison（1）。这些程序已经树
立了一个榜样，并在诸如GNOME的Glade界面构建器项目中发扬光大。
1 5.3.1     yacc ~O lex
    vacc和lex是用来生成语言词法分析器的工具。我们在第8章叙述过，通常自己的
第一个微型语言可能确实是出于偶然而不是一个明确的设计。这个偶然很可能需要一个
手工编码的词法分析器，这会花费非常非常多的维护与调试时间——尤其是如果还没有
意识到它是个词法分析器，不能正确地将其从应用程序的其余部分独立出来时。词法分
析器的生成器是个工具，可以比偶然专用的实现做得更好；它们并不仅仅只是在一个更
高的层次上表达规格说明的语法，同时也能够将词法分析器的所有实现复杂度从其它代
码中隔离出来。
    如果有需要计划从头开始实现一门微型语言，而不是扩展和内嵌一个现有的脚本语
言或者解析XML，那么vacc和lex也许就成为仅次于C编译器的最重要工具，
    Lex和yacc两者分别为一种单一功能生成代码——“从输入流中获取标记符号”和
“解析一系列标记符号来检查是否符合某个语法”。通常地，yacc生成的语法分析功能
在每次需要得到另一个标记符号时会调用一个lex生成的tokenizer功能。如果yacc生成
的语法分析器中根本不存在用户编写的C回调函数，所做的一切就是语法检查：返回值
将告诉调用者输入是否匹配预期的语法。
    更通常地，在生成的词法分析器中内嵌的用户C代码，在解析输入时会附加地生成
～些运行期数据结构。如果微型语言是声明式的，应用程序可以直接使用这些运行期数
据结构。如果设计是命令式的，数据结构也许会包含一个分析树，传给某种求值函数。
    yacc的接口相当丑陋，通过前缀为yy-的形式导出全局变量名。这是因为yacc的产
生还在C struct之前；事实上，还在C语言产生之前；yacc的第一个实现是用C语言的
前任B语言编写的。yacc生成的词法分析器校正解析错误时的算法（直到一个显式的生
成错误得到匹配才弹出标记符），尽管有效但很粗糙，还会导致包括内存泄漏在内的一
些问题。
    如果正在构造分析树，并使用malloc分配节点，在勘误过程中如果开始将数
据出栈，兢不可能恢复（释放）内存。yacc不能完全知道栈中究竟有些什么，因
UNIX编程艺术
  www.pdf365.com
354
第1 5章工具：开发的战术
此它无法做到这一点。如果yacc用C++写成，可以设想值是某个类从而“析构’’
它们。而在“真正的”编译器中，分析树节点由使用基于分配区（ arena-based）
的分配器生成，所以节点不存在泄漏，但无论如何在工业强度的勘误时总有逻辑
的遗漏需要考虑。
-Steve Johnson
    lex是一个词法分析器的生成器。它是grep （l）和awk （1）功能族的一员，但是更
强大，因为它可以为每个匹配安排执行任意的C代码。它接受声明式微型语言作为输入
并且生成C语言代码骨架。
    对于lex生成的符号分析器究竟做些什么，有种粗略但有效的解释：把其视作grep
（1）程序的逆操作。grep （1）接受单个正则表达式、返回输入流中所有匹配的列表，
而每次调用lex生成的符号分析器则是接受一批表达式并标明在数据流中出现了哪～个。
    即使不用Yacc和Lex，并且所处理的“标记符号”同编译器的大不一样，将
  输入分析分解成符号化输入和解析符号流也是个十分有用的策略。不止一次地，
  我已经发现，尽管分解本身会增加复杂度，但将输入处理分解成两个层次确实可
  使代码更简单也更容易理解。
-Henry Spencer
    lex是缟写来为编译器自动生成词法分析器（tokenizer）的。但最后却令人惊讶地广
泛适用于其它种类的模式识别，并且从此被描述为“Unix编程的全能瑞士军刀”，。
    如果正在处理某类模式识别或状态机问题，并且可能的输入可用一个字节描述，lex
生成的代码比手工编制的状态机代码更为有效和可靠。
    Holmdel（AT&T的一个实验室）的Jahn Jarvis使用lex来寻找电路板中的疵
点，扫描电路板，使用链编码技术来表示电路板上的边界区域，然后使用Lex来
定义可以捕获一般制作错误的模式。
-Mike Lesk
    最重要地，lex规格微型语言比等价的手工C语言编码层次更高也更紧凑。Perl（网
上搜索“lex perl”）也有可以使用flex开源版本的模块，Python中作为PLY的一个部分，
也有类似的实现。
1后来Perl的“瑞士军链锯（Swiss-army chainsaw）”这个常见说法其实是个派生。
www.pdf365.com
15.3专用代码生成器
355
    lex生成的解析器一般比手工编码的解析器慢一个数量级。这并不就是采用手工编码
的好理由，相反，这是个明证，应该使用lex进行原型设计，然后只有当原型确实存在瓶
颈时再进行手工编码。
    yacc是一个词法分析生成器。当然，也是为了自动化编译器的部分编制工作而编写
的程序。同BNF（Backus-Naur Form，巴科斯一诺尔范式）类似，将输入作为一个说明
性微型语言的语法规格说明，而语法的每个元素都有相对应的C代码。它生成一个分析
器函数，调用时，从输入流中接受匹配语法的文本。一旦识别出任何一个语法元素，函
数就执行相应的C代码。
    lex和yacc的组合使用对编写任何种类的语言解析器都特别有效。尽管大多数Unix
程序员从不会写一个通用语言编译器（这两个工具的本来目的），但是将它们当作解析运行
控制文件语法和域专用微型语言的解析器也十分好用。
    lex生成的符号分析器在识别输入流中的低级模式相当快速，但是lex能够了解的正
则表达式微型语言却不擅长统计事物，或是识别递归嵌套结构。为了能够解析这些，就
需要yacc。另一方面，尽管理论上可以编写vacc语法来完成自身的符号收集解析，但其
说明面能非常臃肿并且解析速度非常缓慢。从输入中萃取符号标记需要lex。这两个工具
是相辅相成的。
    如果能够在比C语言更高的语言级别实现解析器（我们推荐如此：参见第14章的讨
论），那就参考其它等价的工具，例如Python的PLY（包含lex和yacc的功能）2或者
Perl的PY和Parse::Yapp模块，再或者Java的CUP3、Jack4或Yacc[M5模块包。
    同宏处理器一样，这些代码生成器以及前处理器的问题之～是编译时如果在生成码
中有错，其行号是生成代码的（并不想编辑这里）而不是生成器的输入代码（这才是需
要修正的）的。yacc和lex通过生成同C预处理器一样的#line结构来解决这个问题；
2 PLY可在<http：／／systems．cs .uchicago．edu/ply/>处下载。
3  CUP可在<http：／／www．cs．princet on．edu/-appel/modern/j ava/CUP／处出下载。
4 Jack可在<http：／／www.]avaworld. com/j avaworld/jw-12 -1996/jw-12 -j ack.html>
处下载。
5 YaccfM可k<ht tp：//david。tribble．com/yaccm_ html>处下载。
UNIX编暖；艺：术
    www.pdf365.com
356
第1 5章工具：开发的战术
该结构为错误报告设置当前行号，这样出来的行号就是正确的。任何生成C或C++代码
的程序都应该如此。
    更普遍地，良好设计的程序代码生成器，应该永不需要用户手动地改变甚至查看到
自动生成的部分。把这些做好，是代码生成器的本分。
15.3.2  实例分析：f etchmailrc的语法
    规范的示例似乎在曾经编写的每个lex和yacc教程中都有：玩具型交互式计算器，
用来解析和对用户输入的算术表达式求值。我们还是省省这个重复的老调吧；如果确有
兴趣，参考GNU项目中的bc （1）和dc （1）计算器的实现，或是[Kernighan-Pike84]中
的"hoc”范例6。
    为了取而代之，fetchmail运行控制文件的语法解析器提供了一个关于lex和yacc用
法的中等规模实例分析。有几点十分有趣。
    在rcfile_l.1中的lex规格说明，是非常典型的shell式语法实现。注意同时支持
单引号和双引号字符串的两个补充规则；这种做法普遍适用。接受（可能带符号的）字
面整数的规则和抛弃注释的规则也相当通用。
    在rcfile_y -y中的yacc规格说明，虽然有些见长但很直白。它并不进行任何
fetchmail昀动作，仅仅只是在内部控制块的列表中设置标记。启动之后，fetchmail的普
通模式操作仅仅就是反复遍历这个列表，对每个记录在其远程站点收取会话。
15.3.3实例分析：Glade
    我们在第8章将Glade作为一个说明性微型语言的范例审视过。我们也注意到它的
后端可以产生几种语言中任意一种的代码。
    Glade是应用程序代码生成器的当代范例。使它具备Unix精神的那些功能特征，绝
大多数的GUI构建器（特别是专有的GUI构建器）都没有，可以总结如下：
    ●  并不是胶合成一个大个单体，Glade的GUI和Glade代码生成器遵循分离原则
    （遵从“分离接口和引擎’’设计模式）。
6见http : / /cm . bell-labs . com/cm/cs/upe/>。
www.pdf365.com
15.4 make:自动化编译
357
●  GUI和代码生成器由（基于XML的）文本数据文件格式相连，可以由其它工
    具浏览和修改。
●  支持多个目标语言（相对仅支持C或C++而言）。要增加目标语言也很容易。
这种设计意味着，完全可以替换Glade GUI编辑器组件，而且决不会痛苦不堪。
15.4  ma始：自动化编译
    程序源码自身并不能形成一个应用。如何将它们装配在一起以及如何打包成发布版
本的方式才真正重要。Unix提供一个半自动化这些过程的工具；这就是make （l）。绝
大多数介绍Unix的书籍都涵盖了make。作为真正详尽的参考书，可以查阅《Managing
Projects with Make》（使用Make管理项目）[Oram-Talbot]。如果使用GNU的make（最先
进的make，通常伴随开源Unix -起发布），《Programming with GNU Software》  （用
GNU软件编程）[Loukides-Oram]在某些方面的处理可能会更好一些。多数预装GNU make
的各种Unix都同时支持GNU Emacs:如果你的Unix也是如此，那通过Emacs的信息文
档系统可能会找到完整的make在线手册。
GNU make豹DOS和Windows移植的版本可以从FSF获取。
15.4.1  make的基本理论
    如果使用C或C++进行开发，构建应用程序的一个重要部分是将源代码变成二进制
可运行文件的编译和链接命令集合。输入这些命令是枯燥乏味的细活，多数现代的开发
环境都包含有某个方法将它们放入命令文件或数据库中，可以自动地重复执行以编译应
用程序。
    Unix的make （1）程序，是所有这些程序的鼻祖，专门设计来帮助C程序员管理这
些命令。可以在一个或多个makefile中书写项目文件之间的依赖关系。每个makefile都
由一组“生成物’’构成；其中每项都告知make给定的某个目标文件会依赖哪些源文件集，
并且告知．malce如果那些源文件比目标文件更新时该做什么。实际上并非必须将所有的依
赖关系都写下来，make程序可以通过文件名和扩展名推导出一些显然的依赖关系。
    例如：如果需要在makefile中说明二进制可执行文件“myprog’’依赖三个目标文件
myprog．O、helper．o和stuff．。。如果确实存在文件myproq．c、helper．c和
stuff．c，不用说，make也会知道每个．。文件都依赖相应的．c丈件，并且应用它自己
UNl×编睡；艺．莱
    www.pdf365.com
358
第15．章工具：开发的战术
的标准解决方案将．c文件编译成，。文件。
    Make程序最初来源于Steve Johnson（yacc等程序的作者）的一个拜访，那天
他风风火火的闯进我的办公室，诅咒命运女神让他浪费了一个早上来调试一个正
确的程序（bug改了但是文件还没有编译，因此CC★．o无效）。而我也花了前
一晚上的部分时间在我参与的项目中解决同样的灾难，这样，编写一个工具来解
决这个问题的想法就诞生了。最开始是精细的依赖关系分析器，浓缩为更简单的
东西后，周末就出炉了Make。新兴工具的使用也是Unix文化的一个部分。Make
文件都是文本的，不是神秘的二进制编码，因为这就是Unix的精神：可打印、可
调试、可理解。
-Stuart Feldman
    如果在项目的目录中运行make，make程序会查看所有生成物及时间戳，然后做需
要的最少工作来确保派生出的文件能够更新。
    作为一个中等复杂的范例，可以读读fetchmail源文件中的makefile。在下面的部分，
我们还会引用到它。
    非常复杂的make文件，尤其当它们还要调用附加的make文件时，往往将编译过程
复杂化而不是简单化。一个当代的经典警示来自Recursive Make Considered Harmful【递
归Make有害论）7。这篇文章中的论证自从1997年问世以来已经广泛为人接受，而且几
乎颠覆了以前的社区实践。
    如果不认同make （1）中包含了Unix有史以来最糟糕的设计修补，那么我们的讨论
就不完整。Tab字符（制表符）作为关联生成物命令行的引导符使用，而它和空白符的
视觉区别无法令人觉察，这可能导致对makefile解释的灾难性不同。
    为什么在第一列需要tab? Yacc是新的，Lex更是崭新的。我两者都没有用过，
所以我认为这是个学习的好借口。在我跟Lex首次受挫的纠缠后，我就使用更简
单的换行+tab模式。它工作了，就那样了。而几个星期以后，make有了十几个用
户，大多数都是朋友，而我又不愿意纠正我的基本错误。余下的，很不幸，成为
了历史。
-Stuart Fefdman
 7可以访问网页<http：／/www．tip．net．au/-millerp/rmch/recu-make-cons -harm．html>
阅读本文。
www.pdf365.com
15.4 make：自动化编译
359
15.4.2  非C/C++开发中的make
    make并不仅仅只是对C/C++的有用。如同在第14章所述的一样，脚本语言可能并
不要求传统的编译和链接步骤，但是也常常有其它的依赖关系，make（l）正好可以有帮助。
    例如，假设使用第9章中的某个技法，确实从规格说明文件中生成了部分代码。就
能够使用make来将规格说明文件和生成的源码文件结合在一起。这会确保无论何时修改
规格说明之后重新make，生成码都会自动重新编译。
    和编程一样，使用makefile来完成制作文档的任务也非常普遍。经常会看到使用这
种方法从一个某标记语言编写的主文本（比如HTML或是我们将在第1 8章讨论的Unix
文档宏语言）来自动生成PostScript或其它派生文档。实际上，这种用法相当普遍，值得
我们用一个案例来演示。
15.4.2.1  案例分析：make用于文档转换
    在fetchmail的makefile中，例如，会发现三个生成文件，名为F'AQ、FEATURES和
NOTES，同HTML的源文件fet chmail- FAQ．html、fetchmail- features .html
和design-notes。html相关。
    HTML文件是从fetchmail的主页上阅读的，但是不使用网页浏览器浏览那些HTML
标记非常别扭。因此FAQ、FEATURES和NOTES纯文本文件在需要阅读fetchmail源码
本身（或者，可能在并不支持网页访问的FrP站点）时，可以通过编辑器或分页程序来
快速阅览。
    纯文本格式可以使用普通的开源hnx ci）程序从它们的HTML主文本生成；lynx
是只显示文本的网页浏览器，但是当以- dump选项调用时，同样可以作为HTML到ASCII
的格式转换器使用。
    当生成文件就位，开发者就可以编辑HTML的主文本，而不需要牢记事后必须人工
更新纯文本格式文件，就能够确保FAQ、FEATURES和NOTES都能够在任何需要的时候
得到更新。
15.4.3通用生成目标
很多常用的典型makefile中根本没有文件依赖关系。它们是将某些开发者想要自动
UNIX箱睡；艺术
  www.pdf365.com
360
第1 5童工具：开发的战术
化的小过程捆绑在一起的方法，例如制作一个发布包或者在编译源码时去除所有中间生
成的目标文件．
    生成目标非文件，这早已有之。  “make all"和“clean”是早些日子我自己的
    习惯。有一个老Unix笑话，输入“make love”，输出是“Don't know how to make
    love”  。
    -Stuart Feldman
    关于通用生成目标应该表示什么，以及它们该如何命名已经有了一组良好的约定。
遵从这些会让自己的makefile更容易理解和使用。
a//
    生成工程中所有可以执行者。通常全部产品并没有明确的定义；往往指工程中高阶
的目标文件（并且，并非偶然地，常常有文档说明会包括哪些）。它通常应该是makcfile
的第一个生成目标，因此它往往是开发者不带参数键入make就执行的那一个。
test
    运行程序的自动测试套件，典型地，包括一组单元测试（Unit Test）8来查找递归、
bug，或是其它在开发过程中偏离预期行为的误差。“test”目标也可以由软件的最终用
户来确保安装程序能够正常工作。
cZP以咒
    删除make all时产生的所有文件（例如二进制可执行文件和目标文件）。make
clean虚该将软件的编译过程重置到良好的初始状态。
dist
    制作源文件档案（通常使用tar （1）程序归档），它可以作为在另一台机器上重新
编译的单元。该目标应该同make all做同样的依赖关系检测，这样make dist可以
8单元测试就是同某个模块关联、用来验证执行是否正确的代码。使用术语“单元测试”表明测试是
由代码开发者并发编写的，也形成了模块发布必须附带测试码才算完整的纪律。术语和概念源自Kent
Beck大力推广的“极限编程（Extreme Programnung）”，但大概自从2001年来，也在Unix程序员
中得到了广泛的接受。
www.pdf365.com
15.4 make:自动化编译
361
在制作发布包之前自动重新编译整个工程——这是一个良好的避免最后一分钟困境的方
法（例如，在fetchmail中实际上是从HTML文件产生纯文本README文件）。
distclean
    删掉所有的文件，除了那些使用make dist打包时指定包含的文件。它和make
dist效果一样，它可能和make clean相同，但是需要独立存在，并以文档说明。当
与make clean不同时，通常是会删除make all编译过程部分之外的本地配置文件
（例如autoconf（1）生成的文件，关于autoconf（1），我们将在第17章讨论）。
reafCZ已髓n
    删除所有用makeile构建的文件。这有可能同make distclean的作用完全～样，
但无论如何，应该作为单独的目标，并且以文档说明。当与make distclean不同时，
它删除的文件往往可以用其它文件生成，但（因种种原因）又需要同工程源码一起发布。
install
    在系统目录中安装项目工程的可执行文件和文档（通常需要root用户权限）以让普
通用户访问。同时初始化或更新启动执行文件所需的任何数据库或库文件。
uninstall
    删除白make install安装在系统目录中的所有文件（一般要求root用户权限）。
这应该是make inatall彻底完美的逆过程。uninstall的存在显示了一种人性化的设置，
有经验的Unix用户常常认为是周到的设计；反之，如果没有uninstall，软件做得再好充
其量也是粗枝大叶的，  （例如，软件安装创建了庞大的数据库文件）甚至是考虑欠佳、
相当粗糙的。
    所有这些标准目标的可工作的范例在fetchmail的makefile中都可见到。作为整体研
究时，就会看到一个模式的出现，而且（并不是偶然地）会学到更多fetchmail的打包结
构。使用这些标准目标的好处之～就是其项目路线不言自明。
    但是不要局限在这些通用目标上。一旦掌握make，就会越来越频繁地使用makefile
机制来自动化那些依赖项目文件状态的小任务。makefile就是一个方便存放完成这些小
任务脚本的重要地方；而使用make可以在检视如何完成这些小任务时一目了然，并且避
免了小脚本将项目工作空间弄得凌乱不堪。
UNIX编健艺-术
  www.pdf365.com
362
第1 5章工具：开发的战术
15.4.4生成Makefile
    较之于许多内嵌从属数据库的IDE来说，Unix make明显的优势之一就是makefile
是简单的文本文件——可由大多数程序生成。
    在1980年代中期，对于庞大Unix程序的发布来说，包含一个精致的可以探测环境
并收集信息构建来定制makefile的用户shell脚本相当普遍。这些定制配置器的规模甚至
达到了荒唐的程度。我曾经编写了3000行shell脚本，几乎是它所配置程序任何单个模
块的两倍——而且这并不少见。
    社区最后说“够了！”，而许多人开始着手编写工具来自动维护makefile的部分或
全部过程。这些工具一般试图解决两个问题：
    一个问题是可移植性。Makefile生成器通常为不同的硬件平台和Unix变种编制。它
们往往试图推断出本地系统的信息（包括从机器字大小到机器可以获得的工具、语言、
服务库甚至文档格式化器等一切）。它们常常尝试使用这些信息编写makefile，以利用
本地系统的功能，或是补偿本地系统的欠缺。
    另一个问题是派生依赖关系。分析源文件本身可能推导出大量C源码文件间的依赖
关系（尤其是它们使用和共享了哪些包含文件）。许多makefile坐成器这样做就是为了
能够机械地生成make依赖关系。
    每种不同的makefile生成器以不同的方式来解决这些目标问题。可能有十几个或更
多的生成器，但大多数都被证明功能不足或难以使用或两者兼有，但是有些还在现实中
使用。我们将在这里研究其中几个主要的。所有这些工具都可以在互联网上获得其开源
版本。
15.4.4.1makedepend
    几个小工具都可以分别处理问题的规则自动化部分。这一个，随着MIT的X window
系统一起发布，是其中最快、最有用的。在所有现代的Unix下，包括所有的Linux下都
有预装。
    makedepend收集C源码集合，然后从它们的#include指令中为相应的．。文件生
成依赖关系。这些可以直接追加到makefile中，而实际上，makedepend也正是这样做的。
    makedepend只对C项目有效。它并不试图解决除了makefije生成以外的问题。但是
它做的事相当漂亮。
www.pdf365.com
15.4 make：自动化编译
363
    makedepend的手册页文档充分。在终端窗口键入man makedepend可以很快地了
解调用它所需要知道的一切。
15.4.4.2Imake
    Imake是为了X window系统机械化生成makefile而编写的。它基于makedepend并
且既可处理依赖派生，又可处理移植性问题。
    Imake系统有效地使用Imakefile代替了传统的makefile。Imakefile采用更紧凑更强
大并（有效地）以makefile的表示法编写。编译过程使用规则文件，该文件专门针对目
标系统并且包含了许多关于本地环境的信息。
    Imake非常适合X特有的移植性和配置困难，并且通常使用在X系统某个部件项目
中。然而，在X开发者社区之外它并不流行。它难以学习，难以使用，难以扩展，而且
产生的makefile生成文件，其复杂程度和庞大规模令人刚磴口呆。
    Imake工具可以在任何支持X的Unix上获得，包括Linux。有个创举[DuBois]尝试
让丰申秘的Imake能够为非X编程者所知。如果打算进行X编程，学习这些当然值得。
15.4.4.3  autoconf
    见识了Imake却又拒绝Imake万法之后，有人编写了autoconfo它为每个工程生成类
似旧有的客户脚本配置器的configure shell脚本。这些confiaure脚本能够生成
makefile（和其它的东西）。
    Autoconf着重于可移植性并且根本就没有内置派生依赖。尽管它可能同Imake般复
杂，但是它更灵活也更容易扩展。不是依赖每个系统的规则数据库，autoconf生成“配
置’’shell代码去搜索系统以获得信息。
    每个c。nfigure shell脚本来自于必须事先编写的项目模板，称为configure．in。
它一旦生成，c。nfigure脚本就是独立的，可以在任何本身并不存在日“toconf（1）程
序的系统上配置项目。
    au！toconf生成makefile的方法就像在imake中为项目开始编写一个makefile模板一
样。但是口“toconf的Makefile．in文件基本上就是makerile文件，只不过多了用于简
单文本置换的占位符；不需要学习另外的表示法。如果需要依赖派生，必须显式地调用
makedepend（1）或相类似的工具——或者使用automake（1）。
UNIX编程艺|术
  www.pdf365.com
364
第1 5章工具：开发的战术
    autoconf文档以GNU信息格式的在线手册存在。脚本源码可以从FSF存档站点获得，
但是在许多Unix和Linux版本上都有预装。应该可以通过自己的Emacs帮助系统浏览其
手册。
    尽管缺乏对依赖派生的直接支持，并且尽管它的方法很特殊，但在2003年年中，
autoconf毫无疑问地是最流行的makefile生成器，并且已经流行了数年。它已经蚕食了
Imake的份额，并至少废掉了一个主要竞争者（metaconfig）。
    参考书籍请阅《GNU Autoconf， Automake and Libtool [Vaughan]》。另外，我们将
在第17章从一个略微不同的角度讨论autoconf更多的细节。
15.4.4.4  automake
    automake尝试在autoconf（l）上增加一个fmake式的依赖派生关系。用广泛的Imake
式的表示法编写Makefile．am模板；automake（l）编译成Makefile．in文件，然后该
文件供autoconf的conf igure脚本操作。
    在2003年年中，automake仍然是一项相对较新的技术。好几个FSF项目使用了这
项技术，但足别的地方并没有广泛采用。尽管它的生成方式似乎很有前景，但还是相当
脆弱——按规则使用时能够工作，但如果想用来做点儿别的，就会失败得很惨。
    完整的在线文档随同automake -起发布，并可以在FSF档案站点处下载。
15.5版本控制系统
    代码在发展。项目从原型的第一笔到交付使用的过程中，要经过多个周期，其中新
问题的探索、调试、把已经完成的东西稳定化。这种发展历程在第一次发布产品时并不
会停止。绝大多数项目在1.0阶段后，都需要维护并增强，会存在多次再版。而追踪所
有那些细节恰恰是计算机而非人类所擅长的事情。
1 5。5.1  为什么需要版本控制
    代码的不断发展产生了好几个实际问题，可能成为主要的阻碍和难题来源——这当
然会严重耗费生产力。耗费在这些问题上的每～刻，都无法投入到项目设计和使功能正
确的工作中。
www.pdf365.com
15.5版本控制系统
365
    也许最重要的问题就是回归。如果改变了代码却发现并不可行，如何恢复到一个已
知的良好版本？如果回归是困难的或不可靠的，改变代码就太过冒险（有可能会崩掉整
个项目，或者为自己凭空增加许多小时的痛苦工作）。
    几乎同样重要的是变化追踪。知道代码已经发生了改变；但知道为什么吗？稍后再
看它们却很容易就忘记了改变的原因。如果项目存在合作者，又如何知道在自己不注意
时合作者改变了什么，另外，每个修改该由谁负责？
    常常令人惊奇地发现，即使没有合作者，问问自己从上一个已知的良好版本
  后改变了什么也非常有用。这也常常会揭露不必要的改变，例如被遗忘的调试码。
  我现在在检入（ check in）变化前，一般就会做这项工作。
-Henry Spencer
    另一个问题是bug追踪。在代码经历了相当的变化后得到一个新的bug报告相当普
遍。有时能够立即发现bug已经被解决了，但通常不能。假设在新版本中bug并没有显
现。但为了重现和理解bug，如何恢复到代码的旧版本？
    为了解决这些问题，需要能够保留项目历史，并且加上注释来解释它。如果项目不
止一个开发者，同时还需要一种机制能够确定开发者不会覆盖彼此的版本。
15.5.2手I版本控制
    最原始（但仍旧很普遍）的方法是全手工的操作。定期手工地将一切文件复到～个
备份以作为项目的快照。当然可以在源文件中包含历史评注。也可以通过口头的或邮件
的安排让其他开发者在自己修改时不要动那些文件。
    这种手动方式的隐性成本非常高，尤其（也常常发生）当时间不允许的时候。而整
个过程异常耗费时间和精力；容易出错，在压力之下或项目处于水深火热时又往往会被
遗忘——而这正是最需要版本控制的时候。
    如同多数的手动修改一样，这种方式很难用在大规模项目中。变化追踪的粒度也十
分有限，而且细节经常丢失：比如变化次序、谁做的、为什么等。恢复一大批变化的过
程极度乏味又耗费时间，而在尝试某些并不能很好工作的修改后，开发者往往不情愿地
继续回退到更老的版本。
UNIX编曜艺术
  www.pdf365.com
366
第1 5章工具：开发的战术
15.5，3自动化的版本控制
    为了避免上述问题，可以使用一个版本控制系统（ version-control system VCS），这是
一组程序套件，能够自动化保存项月的历史评注，并避免修改冲突。
    多数VCS共享同样的基本逻辑。使用时，一开始先注册源文件集合——也就是说，
告知VCS开始记载这些存档文件的变化史。因此，在需要编辑这些文件中的某一个时，
必须检出（ check out）这个文件——在其上声明一个排它锁。修改完成之后，检入（check
in）这个文件，把变化加入存档中，释放锁定，并且说明修改了什么东西。
    项目的历史变化不一一定是线性的。实际上所有常用的VCS允许维护不同版本的树型
结构（比如不同机器架构间的移植版本），并提供工具来将不同的分支合并回主要的“主
干”版本。随着开发小组规模和分散性的增长，这个功能特征会变得越来越重要。然而
需要谨慎使用；具有多重活动版本的代码库特别容易混淆（例如，仅仅将bug报告同正
确版本相关联就非易事），同时各分支的自动归并不能保证结合的代码就一定能够运行。
    VCS余下所做的一切比较容易：标注，并报告与这些基本操作的相关特征，提供工
具允许查着不同版本间的差别，或者将给定的各个版本文件聚合在一起作为统一命名发
布，以便任何时候在可以不丢失后续改动前提下，进行检查或恢复。
    VCS自身存在一些问题。最大的问题就是每次使用VCS编辑文件时都需要涉及额外
的步骤，这些步骤如果是手工操作的话，匆忙的开发者都想跳过它。本章接近结尾的地
方，我们会讨论解决这个问题的方法。
    另一个问题是，某些很自然的操作往往会弄乱VCS。文件改名就是～个臭名昭著的
问题源；当～个文件改名时要自动地确保文件的版本历史还能够随之而在，这并不容易。
特别当VCS支持分支版本时，这个问题尤其难以解决。
    尽管存在这些麻烦，VCS仍然在许多方面对生产力和代码质量都带来巨大的实惠，
甚至对于小型单开发者项目也是如此。它们自动化了许多乏味的过程。对从错误中恢复
过来大有帮助。而可能最重要的是，可以确保很容易地恢复到一个已知的良好状态版本，
解放了程序员，从而可以自由地不断实验与探索。
    （VCS，顺便提一下，并不仅仅针对程序代码有效；本书原稿在写作的过程中就是
作为RCS下的文件集来维护的。）
www.pdf365.com
15.5版本控制系统
367
15.5.4  Uni×的版本控制工具
    在历史上，Unix世界中，三个VCS占据了重要的地位，我们将在此检阅。对于更多
的介绍和指导，参考《Applying RCS and SCCS》（RCS和SCCS应用）[Bolinger-Bronson]。
15.5.4，Il  源码控制系统（Source Code Control System，SCCS）
    第一个这样的系统是SCCS，最初在1980年前后由贝尔实验室开发，并在System IIl
Unix中出现。SCCS似乎是第一个在统一源码控制系统的重大尝试；由它开拓的观念在
某些层次上仍然可以在后来所有的版本控制系统中见到，包括诸如ClearCase在内的Unix
和Windows商业产品。
    然而SCCS本身现在已被废弃；它是贝尔实验室的专有软件。更好的开源替代品已
经开发出来，而且Unix世界中的大多数都已经转而采用了它们。SCCS在一些商业公司
中仍然用于管理某些古老的项目，但新项目并不推荐使用。
    SCCS没有完整的开源版本实现。存在一个克隆产品，叫做CSSC（ Compatibly Stupid
Source Control）在FSF的赞助下进行开发。
15.5.4.2  停订控制系统（Revision Control System， RCS）
    更好的开源替代品从RCS（修订控制系统）开始，在SCCS的几年后在普渡（Purdue）
大学诞生，最初发布在4.3BSD Unix上。它在逻辑上与SCCS相似，但是具有更简洁的
命令接口，还可以通过符号名将整个项目发布组合在一起。
    RCS现在是Unix世界中使用得最为广泛的版本控制系统。一些其它Unix版本控制
系统则使用它作为后端或底层。它非常适用于单一开发者或小型团队。
    RCS源码由FSF维护和发布。也可以找到Microsoft操作系统和VAX VMS的免费
移植版本。
15.5.4.3  并发版本系统（Concurrent Version System， CVS）
    CVS（Concurrent Version System/并发版本系统）是作为一个RCS的前端开始其生
命的，在】990年代早期开始开发，然而其使用的版本控制模型与原版本大相径庭，所以
立即具备了成为一个新设计的资格。现代的实现版本并不依赖RCS。
    同RCS和SCCS不一样，CVS在检出（check out）时并不排它地锁定文件。相反，
在检入（check in）回来时，它尝试自动地调和雨相冲突的改动，同时让人来帮助仲裁冲
UN）×编程艺-术
    www.pdf365.com
368
第1 5章工具：开发的战术
突的变化。这种设计是有效的，因为修改中的冲突远比直觉想象中的要少得多。
    CVS的接口比RCS要复杂得多，也需要更多的磁盘空间。这些性质使其作为小项目
的选择并不明智。另～方面，cvs非常适合庞大的多开发者项目，开发者分布在由互联
网连接在一起的好几个开发站点。客户端机器上的CVS工具可以很容易地对另外主机上
的代码库进行操作。
    开源社区在项目中大量使用CVS，例如GNOME和Mozilla。典型地，这些CVS代
码库允许任何人从远端机检出源码。因此任何人都可以制作项目的一份本地拷贝并进行
修改，然后将改动补丁邮寄给项目的维护者。代码仓库的实际写访问权存在更多的限制，
必须明确得到项目维护者的授权。拥有这种权利的开发者可以选择直接从本地的修改拷
贝上实施提交，这样本地的改动会直接并入到远程代码库之中。
    在GNOME CVS站点<http：／／cvs．gnorne．org>可以看到一个运行良好的、通过
互联网访问的CVS代码库实例。这个站点说明了诸如Bonsai等支持CVS的浏览工具的
用法，这在帮助一个庞大分散组织中的开发者彼此协调工作时非常有用。
    伴随使用CVS产生的人文方法和哲学踉工具的细节同等重要。它们假定，项目将是
开放和分散的，而且代码主体需要经过同行的复审和检验，甚至由那些并非项目组正式
成员的开发者完成。
    同样重要地，CVS非锁定的哲学意味着如果一个程序员在改动的中途离去时，他的
锁定不致于阻塞整个工程。CVS因此能够让开发者免于“单点失败”的问题；反过来，
这也意味着项目的边界可以是流动的，随意贡献相对容易，并且项目不要求有一个精心
的控制层级。
CVS源代码由FSF维护和发布。
    cvs也存在某些重大问题。有些仅仅只是实现中的bug，但有一个基本问题：项目
的文件命名空间并不能像对文件本身的改动那样可以进行版本控制。这样，CVS很容易
就被文件的改名、删除和增加给弄混。同时，CVS的变化记录基于每个文件，而不是针
对多个文件的改动集。这就难以恢复到某个特殊的版本，也难以处理部分检入操作。幸
运地，这些问题并不是非锁定风格固有的问题，而且已经由新的版本控制系统成功解决
了。
15.5.4.4其它版本控制系统
    CVS存在的设计问题足够引发对更好开源VCS的需求。在2003年中，有数项工作
在进行中。其中最著名的是Aegis和Subversion。
www.pdf365.com
15.6运行期调试
369
    Aegis<http：／/WWW.pcug.org.au/-millerp/aegis/aegis.html>在这些
候选者中历史最长，自从1 991年就已经开始开发了，而现在是个成熟的产品系统。它的
特点是非常强调回归测试和合法性确认。
    Subversion<http：／/subversion．tigrls．org/>完全解决了已知的种种问题，
确定了“把CVS做对”的地位，而且在2003年看来，也许是近期最有希望取代CVS的
软件。
    BitKeeper<h七tp：／/www．bltkeeper．com>项目开拓性实验了某些有趣的设计思
想，如“改动集”以及多个分布式代码仓库。Linus Torvalds使用BitKeeper来开发Linux
内核源码。然而，BitKeeper的非开源许可，引起了争议，并且严重地延缓了接受该产品
的过程。
15.6  运行期调试
    只要拥有超过一星期编程经验的人都会知道，让程序符合正确的语法是调试中相对
容易的部分。凼难的是在这之后，需要r解为什么语法正确的程序并不如期望的那样运
行。
    Unix传统提倡开发者通过透明性设计先人一招地解决这个问题——特别在程序设计
对，考虑内部数据的流向容易被人眼和简单工具审视，并且易于建模。我们已经在第6
章详细地涵盖了这个议题。透明设计在防止bug和减轻运行期调试任务两方面都是非常
有价值的。
    然而，透明性设计本身还不够。当需要在运行期调试一个程序时，能够检查运行期
的程序状态、设置断点以及以一种可控的方式执行某个低至单～语句层次部分是极其有
用的。Unix存在一个提供工具来帮助完成这些任务的长期传统。多数开源Unix都拥有
威力巨大的gdb（也是一个FSF项目）支持C和C++调试。
    Perl、Python、Java和Emacs Lisp都支持设置断点、控制执行以及一般的运行期调试
操作的标准软件包或程序（包含在基本发布版本中）。Tcl，这个设计用来为小型项目开
发的小巧语言，没有这方面的功能（尽管它存在可以在运行期监视变量的跟踪功能）。
    牢记Unix哲学。将时间花费在设计质量上，而不是低层次的细节上，尽可能地自动
化一切——包括运行期调试的细节工作。
UNIX编程艺：术
    www.pdf365.com
370
第1 5章工具：开发的战术
15.7性能分析
    作为通用法则，程序90%的执行时间都耗费在lO%的代码上。性能分析软件（profilers）
可以帮助确定那10%抑制程序速度的区域。这可以让程序跑得更快。
    但在Unix传统中，profiler有个更为重要的功能。它能够让人不去优化其余90%的
代码。这很棒，并不仅仅由于这样节省了工作。其实不去优化余下90%代码真正有价值
的效应是降低了整体复杂度，减少了bug。
    有人可能会回忆起我们在第1章引用的Donald Knuth评论“过早优化乃万恶之源’’，
以及Rob Pike和Ken Thompson关于这个论题的尖锐观点。这是经验之谈。做好设计。
首先考虑什么是正确的。然后再调整效率。
    Profiler帮助完成这一切。如果养成使用它们的好习惯，可以改掉过早优化的坏习惯。
Profiler工具不仅改变工作的方式，也改变思考的方式。
    编译型语言的profiler工具依赖于度量对象代码，所以它们比编译器更依赖于平台。
另一方面，编译型语言的profiler并不关心其衡测程序的实现语言。所以在Unix下，一
个profiler程序gprof （1）就可以处理C、C++和其它所有韵编译型语言。
    Perl、Python和Emacs Lisp在它们的基本发布版本中都包含有自带的profiler程序；
这些程序都可以移植到其宿主语言可以运行的所有平台上。Java有内建的profiler。但Tcl
至今还没有profiling支持。
15.8  使用Emacs整合工具
    Emacs编辑器非常擅长的事之一就是作为其它开发工具的前端（我们在第13章已经
从～个哲学的角度讨论过这个问题）。实际上，几乎本章讨论的所有工具都可以在Emacs
编辑器对话中使用Emacs作为前端驱动，而相比这些工具单独运行来说，这个前端往往
更为易用。
    为了展示这一点，我们以典型的编译／测试／调试循环来一起审视Emacs与这些工具
的组合使用。但对于它们的细节，请参考Emacs本身的在线帮助系统：本部分仅仅只是
给出一个总揽以激发学习热情。
    读然后学——这并不仅仅针对Emacs，也是培养在程序之间寻找协作方法的思想习
惯，以及培养创造这些协作方法的思想习惯。尝试以哲学指导来看待这一节，而不局限
在技术层面。
www.pdf365.com
15.8使用Emacs整合工具
371
15.8.1   Emacs和 make
    输入Emacs命令ESC-x compile，回车后就可以启动Make。这将在当前目录运
行make（1），截获Emacs缓冲区的输出。
    这粗看用处不大。但是Emacs的make模式了解Unix C编译器和许多其它工具产生
的错误信息格式（均带有源文件名和行号）。
    如果任何由make运行的程序产生错误，命令Ctl-x、（control-X-backquote）将尝试
解释它们、依次定位每个错误，并弹开一个窗口载入错误文件并将光标定位至发生错误
的行上9。
这就可以很容易一步步浏览整个编译过程，并纠正任何自上次编译后的语法错误。
15.8.2  Emacs和运行期调试
    为了捕获运行错误，Emacs提供了类似的对符号调试器的集成——即可以使用某个
Emacs模式在程序中设置断点并检视程序运行时的状态。通过Emacs窗口传送命令就可
以运行调试器。无论何时调试器停止在断点上，Emacs将解析调试器回传的源码位置相
关信息，并在源码断点附近弹出窗口显示。
    Emacs的Grand Unified Debugger模式支持所有主流的C调试器：gdb（l）、  sdb（l），
dbx（1）和xdb（l）o使用perldb模块的话还可支持Perl符号调试，同时支持Java和Python
的标准调试器。内建于Emacs Lisp本身的功能也支持Emacs Lisp代码的交互调试。
    在本书创作（2003年年中）期间，Emacs还不支持Tcl的调试。Tcl的设计似乎决定
了这种特性不太可能加入到Emacs之中。
15.8.3  Emacs和版本控制
    - Ea完成了程序的语法错误修订和纠正了运行期bug之后，也许会要把改动保存到
版本控制文档中。如果只能从shell运行版本控制工具，就不好责备自己忘记了这个重要
的步骤。谁记得住每次编辑操作之后都必须运行checkouUcheckin命令昵？
9更多的信息以及编译控制命令可以参考Emacs help菜单下的p+processes->compile。
UNIX编腥艺：术
  www.pdf365.com
372
第1 5章工具：开发的战术
    幸好Emacs在这方面也提供了帮助。Emacs内建代码实现了SCCS、RCS、CVS或
Subversion的简易使用前端。单一命令Ctl-x v v在正访问的文件上进行下～步的逻辑
版本控制操作。这些操作包括注册～个文件，检出（check out）和锁定，以及将文件检
入（checkin）回去（同时允许在弹出窗口中加入修改注释）10。
    Emacs同时也帮助用户浏览受版本控制文件的变化历史，而且还可以撤销不想要的
改动。Emacs使得对整个文件集合或项目文件目录树进行版本控制也非常容易。总之，
Emacs做得非常好，让版本控制操作不再是件痛苦的事。
    除非用惯了，不然这些功能的意义要比你所能想象的深远得多。一旦习惯了快速方
便的版本控制，才会发现真正得到了自由。而正是因为知道总是可以恢复到已知良好的
状态，才可以更自由地以一种灵活的探索方式进行开发，才可以试验多种变化来查验它
们不同的效果。
15.8.4   Emacs和 Profiling
    令人惊奇……这也许是唯一一个开发周期中Emacs前端不能提供实质性帮助的阶
段。Profiling本质上是个批操作——衡测自己的程序，运行它，查看统计数据．用编辑
器对代码进行速度调整，然后重复整个过程。在整个开发周期中的专用于profiling的部
分并没有太多的余地留给Emacs来发挥作用。
    然而，对于我们思考Emacs和profiling之间的关系有个良好的指导性理由。如果发
现自己需要分析众多profiling报告，也许值得编写一个模式可以在profile报告某行上点
击鼠标或敲下键盘，就可以访问源文件的相关函数部分。其实使用Emacs的“tags”代
码，这相当容易实现。事实上，在阅读到本文的时候，也许某个读者已经编写了这样的
一个模式，并且把它贡献到了公共的代码库之中。
    这里所谓真正的要点同样是一个哲理。别蛮干——这会浪费时间和生产力。如果发
现在低层次的机械开发部分花费了太多时间的话，先站住。应该运用Unix哲学。使用工
具自动化或半自动化地完成任务。
    然后，作为对所有继承的回报，将自己的解决方案作为开源软件放置在互联网上。
帮助把程序员同行们从蛮干中解放出来。
10参考Emacs在线文档中标题为“版本控制”一小节，以获取这些相关命令更多的细节。
UNIX编程艺：求
www.pdf365.com
15.8使用Emacs整合工具
373
15.8.5像IDE一样，但更强
    本章稍早时，我们断言Emacs具备类似那些常规集成开发环境的能力，而且只会更
强。现在，已经有足够的事实证明所言非虚。可以在Emacs中运行整个的开发项目，敲
几下键盘就可以完成底层的技术性细节，从而减少了不断切换环境的脑力开销和那种不
连贯的感觉。
    Emacs带来开发风格舍弃了某些高级IDE的功能，例如像程序结构的图形视图。但
那些都是些虚饰。Emacs相应赋予的是灵活性和控制力。你不会被IDE设计者的想象局
限：使用Emacs Lisp，可以调整、定制以及增加与任务相关联的知识。同时，比起常规
的IDE来说，Emacs在支持混合语言开发上做得更好。
    最后，可以并不局限于某组IDE开发者所认为适合支持的事物。通过密切注意开源社
区，可以从千万的同行、以及面对同样挑战的Emacs使用开发者中受益。这更有效——也
更有趣。
UNIX编睡；艺术
    www.pdf365.com
www.pdf365.com
1 6
重用：论不要重新发明轮子
Reuse:
On Not Reinventing the Wheel
When  the superior man  refrainsfrom acting，  his force isfeltfor n thousand miles.
    不言之教，无为之益，天下希及之。
    -Tao Te Ching （as popularly mistranslated）
    一《道德经》
    不愿做不必要的工作是程序员的一大美德。如果中国圣人老子活到今天并仍然还
在传道的话，他可能会被错解为：不编之码，天下希及之。事实上，近来的译者已经
建议，传统上认为等价于“不作为”或是“节制行为”的中国专有名词“无为”，或
许应该解释成“最小行为’’、  “最有效行为”或是“按自然法则行为”，这更适合描
述良好的工程实践。
    牢记经济原则。每个新项目都从刀耕火种开始干起简直就是极端的浪费。请想想：
和其它耗在软件开发的花费比起来，时间无疑是最宝贵和最有价值的；所以相应地，应
该耗费在解决新问题，而不是对那些已存在确切解决方案的问题老调重弹。这种态度对
于开发投入来说，无论是在人员资本的“软”含义，还是在投资经济收益的“硬”含义，
都可以收到最好的回报。
UNI×编睡；艺-莱
  www.pdf365.com
376
第1 6章重用：论不要重新发明轮子
    重新发明轮子之所以糟糕不仅因为浪费时间，还因为它浪费的时间往往是平
方级。走捷径往往产生粗糙、未经思考的版本，长期而言这是假性节约，但通过
这种方式来节省重新发明时间的诱惑几乎总是无法抵抗的。
-Henry Spencer
    避免重新发明轮子的最有效方法是借用别人的设计和实现。换句话说，重用代码。
    下到单个库模块，上到整个程序，在各种级别上，Unix都支持重用，它帮你实现脚
本化和重组合。系统级的重用是Unix程序员区别于其他程序员的最重要行为特征；Unix
的经验是，养成良好的习惯，尝试通过最少的新发明，组合现有组件以形成原型，而非
匆忙地编写独立的、只能使用一次的代码。
    代码重用的品质是软件开发中如同苹果派和母爱般基本的主要美德。但是许多有其
它操作系统经历的开发者进入Unix社区后从未学会（或者从未学好）系统级重用的习惯。
浪费和重复工作相当普遍，尽管这种行为似乎既侵害代码生产者也侵害代码购买者的利
益。为什么这种病态行为会持续存在？知道了原因，就走出了改正的第一步。
16.1  猪小兵的故事
    程序员为什么会重新发明轮子？原闪很多，从狭隘的技术原因到程序员心理状态，
再到软件生严系统的经济学，方方面面都会导致如此行为，这种特有的顽疾正在肆虐。
    猪小兵是个刚走出大学的程序员，拿到了第一份正式工作。让我们假设他（或她）
已经知道了代码重用的价值并且满怀青春激情地准备大干一把。
    小兵的第～个项目是随团队编制一个大型应用。为了实例说明的方便，让我们认为
那是一个帮助终端用户能够智能构造查询和浏览庞大数据库的GUI。项目经理已经组合
了他们认为适合的工具和组件集，不仅包括开发语言，也包括许多程序库。
    那些程序库对于项目来说至关重要。它们包装了许多服务——下到窗口构件和网络
连接，上至诸如交互帮助的整个子系统——否则需要特别大量的额外编码，会严重影响
工程预算和发布时间。
www.pdf365.com
16.1猪小兵的故事
377
    小兵有些担心发布时间。他或许缺乏经验，但他看过Dilbert（呆伯特）漫画，还从
有经验的程序员那儿听过一些传说。他知道管理上有个趋势，说得好听点儿，进度上比
较“积极”。也许他已经读过Ed Yourdon的Death March（死亡之旅）【YourdonJ，那书
早在1996年就注意到，绝大多数项目的时间和资源预算都至少缩水了一半，并且会越缩
越厉害。
    然而小兵聪明伶俐，精力充沛。他想像出最可能成功的机会：学习分配到他手上的
工具和程序库，还得机灵点儿。他活动了～下打字的手指，一头猛扎进挑战之中……然
后就进了地狱。
    一切都要比他想的费时和痛苦。在程序库表面光鲜的示例程序下，正在重用的组件
似乎在一些边界情况下表现得无法预料或具有破坏性——而这些边界情况在他的代码中
常常遇到。小兵经常奇怪写程序库的家伙究竟是怎么想的。但他没法知道，因为组件的
文档不全——那些文档是技术文员写的，他们既不是程序员，想问题的方式也不像程序
员。他也不能通过阅读源码来了解程序库究竟是干什么的，因为程序库是处于专有许可
证下不透明的目标码。
    小兵不得不为组件问题不断地编写复杂的迂回代码，使用程序库已经到了得不偻失
的地步。迂回方法使得他的代码越变越糟。他碰到了程序库的软肋，库无法简单地像其
规格说明那样完成某些至关重要的任务。有时他也确信肯定有某种方法可以让这个黑盒
跑起来，但却无法断定究竟是什么方法。
    小兵发现，随着在程序库上花费的精力越多，他的调试时间就越成指数级地上升。
代码处于崩溃和内存泄漏的痛苦之中，追下来又往往发觉祸根就是那个程序库，或者是
某些他无法查看和修改的代码。小兵知道再追也许会追回到自己的代码，但是没有源代
码，就算想追回到自己代码也是不可能的。
    小兵开始沮丧了。大学里他曾经听说在业界，一个星期完成一百行代码就可以视为
是良好的业绩。那时他狂笑不已，因为在班级项目和写着玩的代码中，他的生产力是这
个的许多倍。现在这不再好笑。小兵不仅仅同自己的经验缺乏斗争，也同由别人的粗心
或者不胜任所制造的积压问题而斗争——这些问题他改不了，只能绕开。
    项目进度在变缓。梦想成为架构师的小兵发现，自己简直成了砖瓦匠，正在试图用
堆不起来的砖盖房，而且压力一大就会塌掉。而经理并不想听到新手的借口；大声地抱
怨组件质量太差，那些选择组件的经理和高级人员之间肯定会找他的麻烦。而且即使能
UNIX编程艺：术
  www.pdf365.com
378
第1 6章重用：论不要重新发明轮子
够成功说服他们，改换组件也将是一个复杂的提议，牵涉大群紧盯许可证法律条款的律
师。
    除非小兵非常、非常幸运，他不可能在项目的有生之年修正程序库的bug。在清醒
的时候，他也意识到库里面也有许多能工作的代码，他太注意那些bug和疏漏了。他
很愿意能够坐下来同组件的开发者好好谈谈，他们又不是白痴，从他们的代码能看出
来，他们一样是程序员，也工作在～个令人受挫的系统中。但是小兵甚至不知道他们
是谁——而且即使能知道，他们就职的软件商也多半不会让他们同他讨论这个问题。
    绝望中，小兵开始打造自己的砖块——用较稳定的库模拟不太稳定的库，并且开始
从零编写自己的实现。用来置换的代码是他自己的，思维模式他一清二楚，并且能够反
复阅读，更新认识，比起被替代的不透明组件和迂回方法所混合的代码，往往工作得相
对更好也更容易调试。
    小兵学到一个教训：越少用别人的代码，他的代码产量越高。这个经验满足了他的
自尊。像其他所有年轻的程序员一样，在思想深处都觉得自己比别人都聪明。他的经历
也似乎在表面上证实了这一点。所以小兵开始构建属于自己的工具包，一个自己用起来
更顺手的工具包。
    不幸的是，小兵此时获得的白己动手的习惯性思维，是一个短期的局部优化，会引
发长期的问题。他或许可以编写更多行的代码，但是如果不能重用，这些代码产生的实
际价值很可能会相当大幅度地降低。代码多并不等于代码好，至少在编写低层次代码和
大量重复投入时是如此。
    在换工作时，小兵至少还得准备经历～个挫折。他很可能发现带不走他的工具包。
如果他带着在公司编写的代码走出公司大门，其1日雇主就有理由认为他侵犯了知识产权。
如果承认重用了旧代码，新雇主如果知道了，也大有可能很不爽。
    即使小兵能够偷偷摸摸地在新工作中使用原先的代码，他也会发现自己的工具包用
处不大。新雇主也许使用一套不同的专有工具、语言和程序库。极有可能的是，在每个
新项目中，小兵都不得不学习一个稍微新～点的技术并重新发明一套轮子。
    这样，程序员重用代码（以及其它诸如模块性、透明性等随之而来的良好实践）便
是技术问题、知识产权壁垒、行政问题以及个人自我意识的综合。成千上万的小兵们，
年复一年地随着年龄的增长，变得越来越愤世嫉俗，也越来越习惯那种系统。对于多数
www.pdf365.com
16.2透明性是重用的关键
379
软件行业的现状，这就是巨大的时间、资本和人力资源浪费——这还没算上商家市场策
略、管理缺乏竞争、不可能期限以及所有其它阻碍工作的压力因素。
    小兵经历反映的职业文化可以折射出大部分的情况。软件公司有种“非自己做不可”
的强烈情结。他们对于代码重用是矛盾复杂的，一方面为了赶进度逼迫程序员使用功能
不足但很有市场的商业组件，同时又拒绝重用程序员自己经过良好测试的代码。这些软
件公司费力生产的是大量专用重复的软件，其实编制软件的程序员知道结果会是垃圾，
但除了自己的代码，别的哪儿也动不了。
    代码好不容易写出来了就决不能扔，只有不断地修修补补，即使所有的人都知道扔
掉重写会更好些，这个教条，就是在这种文化里形成的最接近代码重用的对等物。这种
文化产生的产品，即使其中涉及的每位人员都尽最大努力做好工作，随着时间的推移，
写出的程序还是会变得越来越臃肿，bug也越来越多。
16.2透明性是重用的关键
    我们埘许多有经验的程序员讲述了猪小兵的故事。如果读者本身正好是位程序员，
我们相信你会和他们一样有感同身受的无奈。如果你不是程序员却管理着一群程序员，
我们真诚地期望你能从中得到启发。这个故事试图谠明，反对重用的压力来自各个层面，
无法预料那一大堆问题究竟出自哪个原因。
    因此，对于大多数已习惯了软件行业背景的我们，常认为把这个问题的主要原因从
叙述的故事中提炼出来要花费相当大的努力。但最后，这些原因其实并不十分复杂。
    猪小兵的多数麻烦（也意味着大规模质量问题）归根结底是透明性——或者更确切
地说，是缺乏透明性。无法修正不通内情的东西。实际上，任何具有非平凡API的软件，
如果无法深入肌理，甚至无法正确使用。只有文档，不仅在实践上不足，在原则上同样
不够；文档并不能传达代码具现的所有细微差别之处。
    在第6章，我们评述了透明性对于优秀软件是何等的重要。只有目标码的组件破坏
了软件系统的透明性。如果在尝试重用时，其源码可以被阅读或修改，那么代码重用失
败的那种刺痛感要少得多。注释良好的代码本身就是良好的文档。源码中的bug也可以
UNtX编腥艺术
  www.pdf365.com
380
第1 6章重用：论不要重新发明轮子
改掉。有了源码，可以装备程序来进行衡测，可以通过编译来进行调试，这样在晦涩模
糊的情况下就更容易探询程序的行为。而如果需要改变程序的行为，当然也可以做到。
    需要源码还有另外一个重要的原因。Unix程序员在几十年中学到了“只有变化才是
永恒的”，经验是，源码可以永续，目标码则不行。硬件平台改变了，支持库的服务组
件改变了，操作系统发展了新的API并废弃旧的API。一切都变了——但是不透明的二
迸制执行码却无法适应变化。它们是脆弱的，不能够可靠地向前移植，不得不靠日益庞
大和错误百出的环境模拟代码层来支持。二进制可执行码将用户桎梏在编译构建者的设
想中。源码是必需的，因为即使不想或不需要改动软件，可能还得在新的环境中重新编
译以保证它能继续运行。
    透明性的重要，以及代码遗留问题，是要求重用代码开源以供检验和修改的两个理
由。但这并不是需要“开放源码”的完整论据；因为“开放源码”具有更深远的意义，
而不仅仅只是简单地要求代码是透明的和可见的。t
16.3从重用到开源
    在Unix的早期时代，操作系统组件、函数库以及相关实用程序都是随源码一起发布
的；这种开放性是Unix文化的生命力历在。在第2章我们描述了这种传统在1984年中
断以后，Unix是如何失去了它的原动力。我们也描述了再十年后，GNU工具包和Linux
是如何促使人们重新发现开放源码的价值。
    今天，开源代码又一次成为所有Unix程序员工具箱中最强大的工具之一。相应地，
尽管“开源”的明确观念以及最广泛使用的开源许可证要比Unix iS身晚数十年，但要在
如今的Unix文化中进行前沿开发，理解这两者是非常重要的。
    开放源码和代码重用的关系，在许多地方很像浪漫爱情和有性生殖的关系；你可以
用后者的术语来解释前者，但这样做就忽略了前者的趣味。开放源码并不能仅仅归纳为
一个在软件开发中支持重用的策略。它是一种自然而然发生的现象，是开发者以及用户
1  NASA（美国国家航空航天局）有意识地编制具有数十年服务期的软件；它已经意识到，需要坚决
要求所有空间航空电子学软件的源码都可获取。
www.pdf365.com
16.4生命中最美好的就是“开放”
38 1
直谏，为了保护透明性相关优势的社会契约。同样地，存在好几种方法来促成这种理解。
    本书早些时候在相关历史的描述中，我们选定的视角，集中在Unix和开源之间随意
的文化上的关系。我们将在第19章讨论开源开发的规则和策略。在讨论代码重用的理论
和实践时，更明确地考虑开放源码，非常有助于直接回应猪小兵故事中戏剧性表现出来
的问题。
    软件开发者希望他们使用的代码是透明的。更进一步，他们在换工作时不希望失去
他们的工具包以及他们的专有经验。他们厌倦了成为受害者，腻烦了被生硬的工具和知
识产权壁垒弄得灰心丧气，受够了不断地重新发明轮子。
    这些就是开放源码的动力，从猪小兵痛苦的初步重用经历中产生的动力。这其中涉
及了自我意识：设计最好的实践需要情感的投入，而不是冷漠无聊的过程。软件开发者，
同其它任何类型的工匠和技师一样；他们想要成为艺术家，这并不是什么私密。他们有
艺术家的动力和需求，也有拥有听众的欲望。他们不仅仅希望重用代码，他们也希望自
己的代码得到重用。这种势在必行的意念驱动，超越和颠覆了任何短期经济目标的达成，
也不是闭源软件生产所能够满足的。
    开放源码是种从意识形态上解决这些历有问题的优先方法。如果猪小兵在重用过程
中的多数问题的根源都在于闭源代码的不透明性，那么生产这种闭源代码的体制构想就
应该被击个粉碎。如果还考虑商家的领域地位，就必须抨击或直接绕过，直到公司意识
到它们的领域性习惯思维应该自我毁灭。代码重用竖起大旗并得到拥护者之后，开放源
码就是接下来自然而然要发生的事。
    相应地，自从1990年代晚期，在介绍代码重用的策略和战术时，如果不讨论开放源
码、开源实践、开源许可证以及开源社区，就毫无意义。当然，尽管这些问题在别处可
以分开讨论，但是在Unix世界中，它们已经无法避免地要绑在一起。
    在本章的余下部分，我们会纵览有关重用开源代码的几个不同问题：评估、文档和
许可证。在第19章，我们将更广泛地讨论开放源码开发模型，并研究向他人发布代码时
所必须遵从的约定。
16.4生命中最美好的就是“开放”
    在Intemet上，可以利用的Unix源代码，包括各种系统软件、应用软件、服务程序
库、GUI工具包以及硬件驱动等等确切地需要以TB来计算。大多数都可以使用标准工
UNI×编程艺术
  www.pdf365.com
382
第1 6章重用：论不要重新发明轮子
具在几分钟内编译并运行起来。只要念个咒：，/configure; make; make install;
当然，通常情况下必须在root用户下才能做安装部分的操作。
    来自Unix世界以外的人们（特别是非技术人员）往往倾向于认为开源（或“自由”）
软件必然比商业软件差，是假冒伪劣的，不可靠的，带来的麻烦只会比所能免除的更多。
但这遗漏了重要一点：一般来说，编写开源软件的人都很在乎它，也需要它，自己使用
它，而且通过发布这个软件在同行中赢得个人声誉。他们的时间也往往更少地耗费在会
议、反馈设计更改或是各种官僚的开销中。他们也因此具有更强的动力和更好的立场来
完成卓越的工作，远远超过那些薪水的奴隶，他们只会在专有软件公司大厦的小隔断里
费力地做着呆伯特似的工作，来迎合无法达成的最终期限。
    此外，开源用户社区（那些同行）不会羞于抓bug，而且他们的标准很高。发布不
够格软件的作者会承受许多的社会压力来修正或撤回代码，如果需要的话还能得到许多
专家级的帮助。结果，成熟的开源软件包一般都是高质量的而且常常在功能上比任何专
有等价物都要高级。这些开源软件或许看起来并不漂亮，想看懂文档或许也下容易，但
其至关重要的部分通常都会工作得相当漂亮。
    在同行评审效应之外，另外一个可以推测出质量上佳的理由是：在开源世界的开发
者，从来不会受最终期限的压迫，不会一闭眼、一拍脑门就发布软件。因此开源实践同
其余地方的一个区别就是，l.0级别的版本实际上意味着软件可以使用了。事实上，0.90
或者更高的的版本号就相当可靠，表明代码已经是成品了，但是开发者还是不敢拿这个
软件来赌自己的声誉。
    如果是来自Unix世界以外的程序员，也许很难相信这种主张。如果是这样，想想看：
在当代各种Unix上，C编译器本身几乎总是开放源码的。自由软件基金的GCC （GNU
Compiler Collection，GNU编译器集）是如此的强大可靠，文档又是如此的完善，专有的
Unix编译器根本没有市场空间，所以Unix的某些商家将GCC移植到他们自己的平台而
不是自己开发内部的编译器就再正常不过。
    评估开源软件包的方法是阅读其文档和快速浏览它的部分代码。如果所见的代码编
写恰当，文档完备，那么鼓励使用。如果能够证明软件包已经有些年头并且存在实质具
体的用户反馈，就可以断定它是相当可靠的（无论如何还是测测为佳）。
www.pdf365.com
16.4生命中最美好的就是“开放”
383
    在README文件以及项目新闻或源码发布历史文件中，所提到的除原作者之外的人
数，是度量成熟度以及用户反馈量大小的好方法。很多人呈报修正和补丁本身就是良好
的表征，既表明存在一个相当重要的用户群保持着对软件作者的敦促和警醒，也表明软
件维护者是恪守职责的，能够对反馈作出响应并订正错误。当然，这也是一个暗示，如
果早先的代码是充满bug的雷区，不用等到最近的爆炸，早就有受惊的人群踩得响噼里
啪啦的了。
    如果软件拥有自己的网页，在线常见问题解答（FAQ，Frequently Asked Questions）
列表，以及相关的邮件列表或Usenet新闻组，也是良好软件的表征。这些都是一个鲜活、
充实、有兴趣的社区已经围绕这个软件而成长起来的标志。网页上，最近的更新以及扩
展的镜像站点列表也同样是可靠的标记，表明这个项目拥活跃的用户群体。荒废的软件
包不可能有这种持续的投入，因为不值得。
    已经移植到了多种平台上也是个有价值的表征，说明用户群体多种多样。项目主页
往往明确地大肆宣扬新的移植版本，因为这样表明了软件的可信度。
    这儿是～些有关高质量开源软件的网页的实例：
    ●  GIMP<h七tp：／/www. gimp.org/>
    ●  GNOME<ht tp：／／www.gnome.org>
    ●  KDE<http://www. kde.org>
    ●  Python<http:／/www .python. org>
    ●  The Linux kernel<ht tp:／／www. kernel. org>
    ●  PostgreSQL<http:／/www. postgresql. org>
    ●  XFree86<http:／/xfree86.org>
    ●  InfoZip<http: //www. info- zip. org/pub/infozip/>
    看看Linux的各种发布版本是另一个寻找高质量软件的妙法。Linux和其他各种开源
Unix的发布制造者都拥有许多专业经验，知道哪些项目是最好的——这正是他们的发行
版本中最大的亮点。如果已经在使用开源的Unix，那么需要检查的就是待评估的软件包
是不是已经包含在自己的操作系统版本中了。
UNIX缩程艺_术
  www.pdf365.com
384
第1 6章重用：论不要重新发明轮子
16.5何处找
    因为在Unix世界可以获取的开源软件非常丰富，找到可被重用代码的能力就成为巨
大资本——远远超过其它操作系统的情况。这些代码的来源形式多种多样——独立代码
的摘录和实例，代码库，可以在脚本中重用的公用程序。在Unix下，大多数的代码重用
当然不是在程序中拷贝粘贴——如果发觉自己在这样做，便可以肯定你遗忘了一个更优
雅的重用方式。相应地，在Unix下工作，最管用的技能之一就是熟练地掌握将代码粘合
在一起的各种方法，从而能够应用组合原则。
    寻找可重用的代码，应该从自己的眼皮底下开始。Unix总是以多种多样可重用公用
程序以及函数库的工具包为特征；现代的版本，比如任何当前的Linux系统，包含数以
千计可重用的程序、脚本以及函数库。简单的man -k加上一些关键字进行搜索常常可
以得到很有用的结果。
    要想在此之外看看令人吃惊的丰饶资源，可以浏览SourceForge、ibiblio和
Freshmeat.net。读到此书时，也可能会有类似的其它重要站点出现，但是这三个都在过去
很多年中显示出了持续的价值和声望，并且似乎很有可能维持下去。
    SourceForge<ht tp：／／www. sourceforge．net>是个软件的展示站点，这些软件明
确地设计来支持合作开发，并拥有相关的项目管理服务。SourceForge不仅仅是个存放软件
的地方，还提供自由的联合开发服务，在2003年中期，毫无疑问，是世界上最大的纯开
源活动中心。
    在SourceForge之前，最大的站点是ibiblio<http：／／www - ibiblio．org>的Linux
归档。ibiblio归档是被动的，仅仅是个发布软件包的地方。然而，它确实比起多数被动
站点的网页界面都要好得多（创造其网页外观的程序，是我们在第14章讨论Perl时的一
个实例分析）o这个站点也是Linux文档项目（Linux Documentation Project）的主页，
维护着许多供Unix用户和开发者使用的优秀资源。
    Freshmeat<ht tp：／／www．freshmeat．net>是个专注于提供新软件以及已有软件
新版本发布公告的系统。它允许用户和第三方给这些版本添加评审。
    这三个多用途站点包含许多语言的代码，但是多数是C或C++。还有一些站点专门
针对某些我们在第14章讨论过的解释型语言。
    CPAN archive是Perl话言自由有用代码的重要储存库。可以很容易地从Perl主页
<http：／/v，rww.perl.com/perl>访问。
    Python Software Activity是一个Python软件和文档的归档，可以从Python主页
<http：／/WWW .python．org>访问。
www.pdf365.com
16.6使用开源软件的问题
385
    Java  Applets  Page<ht tp：//j ava．sun．corn/applets/>可以找到许多Java小应
用程序以及指向自由Java软件的站点链接。
    作为Unix开发者，最有价值的时间投资方法之一就是，花时间在这些站点上去了解
可以获得什么东西来重用。节省下来的编码时间就是自己的。
    浏览软件包的元数据（ metadata）是个不错的主意，但别到此为止。也请试验一下代
码。这样能够对代码究竟做些什么会有个更好的领悟，从而更有效地使用。
    更一般地，阅读代码是为未来而投资。可以从中学到甚多——新技术、分解问题的
新方法、不同的风格和手段。使用代码和学习代码都能得到有价值的回报。即使并不使
用所研究代码中的方法，学习他人解决方案中改良的问题定义，也许能够帮助自己发现
一个更好的方法。
    写之前先读：培养阅读代码的习惯。很少有什么彻底全新的问题，所以几乎总是能
够发现非常接近的代码，成为自己需要的一个良好起点。即使当问题真正非常新颖时，
也很有可能与某人之前已经解决的问题相关，而解决方案也很可能是从某个已经存在的
方案发展而来。
16.6使用开源软件的问题
    使用或者重用开源软件存在三令主要问题；质量、文档以及许可证条款。正如我们
上面所看到的～样，如果花一点判断力挑选一下，一般都会发现一个或者更多的软件拥
有令人肃然起敬的上乘质量。
    文档通常是个更严重的问题，许多高质量的开源软件包的应用范围和它们在技术上
的领先不相协调，就是因为它们的文档很糟糕。Unix传统鼓励了太过专门的文档风格，
这种风格（尽管或许会在技术上涵盖软件包所有的功能特征）往往假设其阅读者也相当
熟悉应用程序的定义域，并且阅读得非常仔细。这样做也有很好的理由，我们会在第18
章进行讨论，但这种风格呈现出一种壁垒。幸运地，从这样的文档中提炼有价值的东西，
这个技能值得学习。
    用软件包名字或者主题关键字加上“HOWTO”或“FAQ”字符串，用它作为关键
字在网上搜索。对初学者来说，通常会发现比手册页更有用的资料。
    重用开源软件（特别是在任何商业产品中）最重要的问题是理解软件包的许可证，
如果存在许可证，你就会承担某些义务。在接下来的两个部分，我们将从细节上讨论这
个问题。
UNIX编程艺I术
    www.pdf365.com
386
第1 6章重用：论不要重新发明轮子
16.7许可证问题
    任何非公共领域的东西都有一个或更多版权。在美国联邦法律中，即使一件没有版
权声明的作品，其作者也拥有版权。
    在版权法下确定谁能够成为作品的作者可能非常复杂，尤其是经过多人之手形成的
软件。这就是为什么许可证非常重要的原因。许可证能够授权代码以某种方式使用，否
则在版权法之下是禁止或者需要付费的；许可证同时也保护用户免受版权所有者任意专
断行为的侵害。
    在专有软件世界里，许可证条款是设计来保护版权的。条款是在尽可能地为持有人
（版权所有者）保留领域范围利益，同时也授予用户某些权利的方法。版权所有者非常
重要，而许可证逻辑限制相当严格，所以许可证条款中确切的技术细节通常反而并不重
要。
    正如后面将要看到的那样，许可证可以使人们在版权所有者希望无限期存在的条款
下自由地获取代码，版权所有者多数情况下会使用版权来保护许可证。否则，仅有少数
权利得以保留而多数选择都交给了用户。特别地，对于别人已经拥有的拷贝，版权所有
者不能更改上面的条款。因此，在开源软件中，谁是版权所有者并不重要，但许可证条
款却至关重要。
    一般地，一个项目的版权所有者是该项目的领导者或赞助组织。项曰转让到～个新
领导者时，常常由版权所有者的变动显现出来。然而，这也并不是严格的准则；许多开
源软件都有多个版权所有者，并且这也没有导致法律问题的案例记录在案。一些项目选
择把版权指派给自由软件基金，理论上，自由软件基金确有为开放源码辩护的利益所在，
也有可以利用来进行辩护的律师资源。
16.7.1  开放源码的资格
    出于授权许可的目的，我们需要区分一个许可协议可能传达的几种不同权利。这些
权利包括重新分发权，使用权，供个人使用的修改权，以及修改版本的重新发布权。
    开放源码定义（Open Source Definition） <http：／/www，opensource．org/osd. html>
是思考什么让软件成为“开放源码”或（用旧术语）“自由，，的产物。在开源社区，
这作为开源开发者间社会契约的一个表述而广泛接受。其在许可证上的约束加有如下的
要求：
www.pdf365.com
16.7许可证问题
387
    ●  准予无限的复制权。
    ●  准予以无修改形式重新发布的无限权利。
    ●  准予供个人使用的无限修改权。
    这个方针禁止对二进制软件修改后的重新发布施加限制；这满足了软件发布者的需
求，他们希望能够毫无羁绊地转载可运行代码。这也允许作者要求修改的源码再发布时
以旧源码加补丁的形式发布，这样对于他人的修改，保证了原作者取舍和审查跟踪的权
利。
    OSD是“OS[ Cerifed  Open  Source"认证标志的法律定义，也是任何人所能提出的
最好的“自由软件’’定义。所有的标准许可证（MIT、BSD、Artistic、GPL/LGPL和MPL）
都满足它（尽管有些，例如GPL，具有其它的限制，在选择之前应该有所理解）。
    注意，只允许非商业使用的许可证并不等同于开源许可证，即使那些许可证往往基
于GPL或别的什么标准许可证。这样的许可证有区别地对待特别的行业、个人以及团体，
而这是OSD条款5明确禁止的。
    条款5是在几年的痛苦经历之后而加入的。仅供非商业性使用的许可证带来一个问
题，如何找到一种法律检验来确认某个再发布是“商业的”。将软件作为一个产品来
出售，这种情况当然毫无疑问。但如果以一种名义上的零价格同其它较件或数据一起
发布，而其实际价格以整体收费又该如何？而如果软件对于整体的功用是否关键又如
何区分？
    没人能够回答。仅供非商业使用许可证产生了再发布者认定的不确定性，事实上
恰好是个对它们自身严重的不利因素。OSD的目标之一就是确保处于符合OSD的软件
发布链中的人，不需要咨询知识产权律师来确定他们的权利到底是些什么。OSD禁止
将复杂的限制有区别地加诸于个人、团体以及行业，这样处理软件作品集的人就不需
要面对组合激增的爆炸式问题：这样或那样处理究竟有何微妙的不同（也许甚至是冲
突）。
    这种关心并非没有道理。开源发布链中重要的一环就是CD-ROM发布者，他们收集
许多非常有用的作品，从简单的软件集合CD到可启动的操作系统。如果那样限制，就
会让这些光碟发布商生活困顿窘迫，而其它试图商业传播软件源码的行为，也受到了禁
止。
    另一方面，OSD并没有讨论什么司法权法。有些国家的法律禁止出口某些限制技术
到所谓的“流氓国家”。OSD并不能反对这些，它只是说被许可人不能擅自增加自己的
UNIX编腥艺：术
  www.pdf365.com
388
第1 6章重用：论不要重新发明轮子
限制。
16.7.2标准开放源码许可证
这里是一些你可能碰上的标准开放源码许可证条款。～般而言都使用以下列出的缩写。
MIT <http:／/www. opensource. org/licenses/mit - licenBe. html>
MIT X联盟许可证（如同BSD -样，但是没有广告相关的条款。）
BSD <http:／/www. opensource. org/licenses/bsd- license .html>
版权属于加利福尼亚伯克利大学董事会（使用在BSD代码上）。
Artistic License <http:／/www. opensource. org/ licenses/artistic -
license．html>
同Perl技术许可证完全一样。
GPL <http:／/www. gnu .org/copyleft. html>
GNU通用公共许可证
LGPL  <http:／/www. gnu. org/copyleft. html>
库（或“弱”GPL）
MPL <http: //www* opensource. org/licenses/MPL-1. 1.html>
Mozijla公共许可证
    我们将在第19牵从一个开发者的角度来讨论这些许可证更多的细节问题。就本章目
的而言，它们之间唯一重要的区别就是他们是不是具有传递性。如果许可证要求许可证
软件任何的派生产品也同样置于许可证条款的限制之下，那该许可证就是传递的。
    在这些许可证下，对于使用开放源码唯一真正需要担心的问题就是专有产品结合自
由软件的情形（相对于仅仅使用开源开发工具制作的产品）。倘若许可证不是传递的，
即使是直接的合并，只要在产品的文档说明中准备和包含了对正确许可证的致谢以及所
使用文件的出处，就应该是安全的。
    GPL既是最广泛使用，又是最受争议的传递性许可证。它的条款2（b），要求任何
派生至GPL程序的作品本身也得遵从GPL，就是这引起了争议。  （条款3（b）要求许可
人必须让源码可以在物理媒介上按需索取，曾经也引起了部分争议，但是互联网的爆炸
发展使得按3 （a）要求的源码文件发布极其容易，所以没有人再担心这个要求了。）
www.pdf365.com
16.7许可证问题
389
    没有人能完全确定条款2 （b）中“包含或派生自”的意思，稍后几段关于什么样的
使用受到“纯聚合（mere aggregation）”保护的表述也是如此。有异议的问题包括链接
库以及包含遵从GPL许可的头文件。出现这种问题部分是因为美国的版权法并没有定义
什么是派生；这留给了法庭在判例法中推敲出定义来，而在计算机软件这个领域，这个
过程几乎还没有开始（到2003年中期止）。
    一方面，“纯聚合”确实保证将专有代码同GPL许可的软件一起在统一介质上发布
是安全的，只要它们彼此之间不互相调用和链接。它们甚至是可以处理同～种文件格式
或磁盘结构的工具；在这种情况下，依据版权法，不存在一个派生自另一个的关系。
    另一方面，将遵从GPL的代码摘出，插入在专有代码之中，或是链接遵从GPL的
目标码到专有目标码中，肯定让该代码成为一个衍生产品，从而需要遵从GPL许可。
    通常都认为一个程序将另一个程序作为子进程执行并不会导致其中任何一个程序成
为另一个程序的派生。
    产生争论的情形是动态链接共享库。自由软件基金的立场是，如果一个程序以共享
库方式调用另一个程序，那么这个程序就成为了该库的派生。有些程序员认为这个声朗
过了头。双方都有技术的、法律的以及行政的论据来支持己方的观点，我们在这儿并不
想老调重谈。既然自由基金组织编写并拥有许可证，就当FSF立场是正确的前提下谨慎
工作，直到另有法律条文。
    有些人认为条款2 （b）的表述是故意设计来感染那些商业软件的全部内容的，虽然
它们仅仅只摘用了一小部分遵从GPL的代码：这些人更愿把它称作GPV，或是“通用公
共病毒（General Public Virus）”。另外有些人认为“纯聚合”表述涵盖了所有没有将
GPL或非GPL代码混合在同一个编译或链接单元中的一切。
    这种不确定已经在开源社区造成了太多的不安，所以FSF不得不发展出特别的、稍
微缓和的“Library GPL’’（已经改名为“Lesser GPL”）来打消人们的疑虑以继续使用
随FSF GUN编译器集一起发布的运行库。
    条款2 （b）的解释需要你自己选择；绝大多数律师都不会理解所涉及的技术问题，
而且也没有什么判例法。事实上，经验告诉我们FSF从未（至少从1984年它创建起到
2005年年中）以GPL控告过任何人，但它确实以威胁提起诉讼来强迫实行GPL，且在
所有已知的案例中都获得了成功。同时，作为另外一个经验事实，网景（ Netscape）茌它
的商业Netscape Navigator浏览器中包含了遵从GPL的程序源码和目标码。
    MPL和LGPL具备的传递性比GPL更为有限。倘若GPL或非GPL代码之间所有的
通路都通过一个API或其它良好定义的接口来实现，那么链接进专有代码中并不会让该
    UNIX编l程艺术
    www.pdf365.com
390
第1 6章重用：论不要重新发明轮子
专有代码成为派生产品，这在MPL和LGPL中是明确允许的。
16.7.3何时需要律师
    本节内容专门为那些考虑把纳入以上许可证标准的软件整合进闭源码产品的商业开
发者而设。
    经历了这么多法律措词之后，在此，我们最希望的就是赶紧发表一个严肃的权利放
弃书，说明我们不是律师；如果对于利用开源软件在法律上有任何疑问，最好立即去咨
询律师。
    这是彻底的废话，尽管出于对法律职业的尊重。这些许可证使用的语言同法律术语
一样清晰——就是为了清晰才使用书面表达——而且如果仔细阅读的话应该根本就不难
理解。律师和法庭其实比你还困惑。软件版权法含混不清，在开源许可证上的判例法（在
2003年中期）还不存在；没有人曾经因为这个而被控告。
    这意味着一位律师并不太可能比一个细心阅读许可证的人拥有更好的见地。但律师
常常职业性地对他们不懂的东西患有妄想症。因此，如果咨询律师，他可能更会告诉你
不要随便靠近开源软件，尽管事实上他可能对技术方面根本一窍不通，或者并不见得比
你更能理解作者的意图。
    最后，将作品置于开源许可证之下的人们往往并不是什么大企业，没有那些鸡蛋里
面挑骨头的律师群照顾；他们只是一些个体或志屦群体，主要就是想发布他们的软件。
极少数的例外（那些既在开源许可证下发布软件又有钱雇佣律师的大公司）却常常在开
放源码上有投资，并且也不想挑起法律麻烦，与产生开放源码的开发者社区为敌。所以，
被以无辜的技术侵权罪名拖进法庭的可能性，大概会低于下星期遭雷劈的概率。
    这并不是说应该把这些许可证当作笑话来对待。那对凝结在软件中的创造力和血汗
未免有失敬意，而且官司轻重不说，你恐怕也不会把激怒作者、成为第一被告的经历当
作享受吧。但在缺少权威判例法的情况下，能做的99%就是明确承诺努力满足作者的要
求；另外的或许可以（或许不能）通过咨询律师来达到保护自己的1%的额外努力，而这
又有什么不同呢。
www.pdf365.com
PartⅣ
Community
www.pdf365.com
www.pdf365.com
1 7
可移植性：软件可移植性
与遵循标准
Portability: Software Portability and
Keeping Up Standards
     The realiZation that the operating systems of the target machines were as great an
obstacle to portability as their hardware architecture led us to a seemingly radical suggestion:
to evade thatpart of the problem altogether by moving the operating system itself.
    对于可移植性，目标机器的操作系统和其硬件结构都是障碍，意识到这一点，可能
会导致相当激进的意见：完全规避问题的方法，就是移植操作系统本身。
-Portability of C Programs and the UNIX System  （ 1978 ）
C程序的可移植性和Unix系统（1978）
Unix是第一款移植到不同系列处理器上的生产级操作系统（Unix版本6，1976-
1977）。现今，Unix可以被移植到每一款足够强大可以运行内存簪理单元的新机器上，
这已经毫不稀奇了。应用程序也常常在差异极大的不同硬件上运行的Unix间移来移去；
事实上，还没听说哪次移植失败过。
www.pdf365.com
394
第1 7章可移植性：软件可移植性与遵循标准
    移植性一直是Unix的主要优势。Unix程序员往往设想硬件是易变的，只有Unix API
才是稳定的，尽可能少地假定诸如字长、字节顺序和存储体系等机器的特殊细节。实际
上，在Unix圈中，以任何方式超出C的抽象机器模型而依赖于硬件的代码，都会被认定
为不良的形式，仅允许发生在诸如操作系统内核等极为特殊的情况下。
    Unix程序员已经了解到，一旦设想软件项目的生命期很短，就非常容易犯错。1所以，
Unix程序员往往尽量避免软件依赖于某种特殊易逝的技术，而严谨地遵循开放标准。这
种考虑可移植性的编码习惯在Unix传统中根深蒂固，甚至应用于那些一次性小型单用途
的代码中。这种习惯也始终贯穿于Unix开发工具的设计，以及例如Perl、Python和Tcl
之类在Unix下发展起来的语言中。
    可移植性最直接的效益是工具和应用程序无需每隔几年就重写，因为Unix软件比起
原生的硬件平台来得长久，这是再正常不过的。今天，最初为Unix版本7（1979）所编
写的应用程序，不仅用在其直系后裔中，也用在那些按照Unix规范编写操作系统API，
但并没有从Bell实验室源码树共享代码的交种中，如Linux。
    间接的益处并不明显但可能更为重要。可移植性的戒律往往在架构、接口和实现上
施加了一种简单化的影响。这既提高了项目成功的几率也降低了生命期的维护成本。
    本章概览Unix标准的范围和历史。我们将讨论哪些部分在今天仍然意义重大，并描
述Unix API中或多或少变化的部分。我们将检视某些Unix开发者用来保持代码可移植
性的工具和惯例，同时逐步展示出对良好实践的建议。
7．  C语言的演化
    C语言及其附带服务接口（挑明了，就是标准输入输出库函数及其友元）的稳定性
一直以来都是Unix编程经历的主要核心事。诞生于1973年的一门语言，在三十年来的
频繁使用中，只有很少的变动需求，这真是非常了不起：在计算机科学和工程领域中尚
无人出其右。
    在第4章，我们论述了C语言如此成功是因为它可以作为计算机硬件上的薄胶合层，
近似于【BlaauwBrooks]的“标准架构”。当然，成功的因素并不仅止于此。为了理解其余
的内幕，我们需要简要地回顾一下C语言的历史。
1  PDP-7 Unix和Linux都是持久性出乎意料的例子。Unix最初是作为一个研究玩具由几个研究者在
项目工程间编制而出，一半是为了实验文件系统的创意，一半悬为了运行一个游戏。而Linux则被其
创造者总结为“长了腿的终端模拟器”【Torvalds]。
www.pdf365.com
395
17.1.1  早期的C语言
    C语言诞生在在1971年，最初作为Unix移植到PDP-Il的系统编程语言，基于Ken
 Thompson早期的B语言解析器，脱胎于BCPL （Basic Common Programming Language），
于1966-1967在剑桥大学诞生2。
    Dennis M. Ritchie的原始C编译器（也常常以他名字的首字母称为“DMR”编译器）
在Unix版本5、6、7快速持续增长的社区中都有应用。版本6的C编译器派生了
Whitesmiths C编译器，这个重新的实现成为了第一款商业的C编译器，也是软件通用型
IDRIS的核心。但是多数现代的C语言实现都以Steven C．Johnson的“可移植C编译器
（PCC）"为模型，该编译器在版本7中首次亮相，并在System V和BSD 4.x的发布中
完全取代了DMR编译器。
    在1976年，版本6的C语言引入了typedef、union和unsigned int声明。带初值的
变量初始化语法和一些复合操作符也有改动。
    最初C语言的参考手册是Brian Kernighan和Dennis M. Ritchie原创的《The C
Programming Language》<C编程语言），即《白皮书》[Kernighan-Ritchie]。该书出版于
】978年，同年Whitesmiths C编译器问世。
    白皮书描述了增强的版本6C语言，包含一个涉及公用存储处理的重要例外。基于
任何能够处理FORTRAN语言的机器都可以立即处理C语言的理论，Rithie原意是仿造
FORTRAN语言中“COMMON”声明的规则。在公用块（common-block）模型中，公用
变量也许会被声明好几次；相同的声明由链接器合并。但是两个早期的C移植（ Honeywell
和IBM 360大型机）恰好是那种限制公用存储或链接器较为原始或两者兼有的机器。这
样，C编译器版本6采用了在白皮书中描述的、较为严格的定义引用模型（要求任何公
用变量至多只有一处声明，并在引用处使用关键字extern来标记）。
    许多现存源码都依赖较为宽松的规则，所以这个决定在随着版本7发布的C编译器
中被颠覆了。向后兼容的压力也阻碍了另一个转换尝试（1983年的System V Release l），
直到1988年ANSI标准草案才最终解决了定义引用原则。公用块公共存储依然是标准许
可的变体。
2C语言中的“C’’因此代表“Common[通用）”——或者，代表“Christopher”。BCPL最初表示
“Bootstrap CPL（引导性CPL）”-CPL的一个非常简化的版本，CPL是一种非常有趣但抱负过
大而从未实现的牛津剑桥通用编程语言，也被亲切地称之为“Christopher's Programming Language
（Christopher编程语言）”，以这门语言的主要贡献者，计算机科学的先驱Christopher Strachey命名。
UNIX编程艺术
  www.pdf365.com
396
第17章可移植性：软件可移植性与遵循标准
    C版本7引入了enum，并且将struct和union的值作为第一类对象，可被赋值，可
作为参数传递，也可作为函数的返回值（而不是靠地址传递）。
    V7中的另一个主要变化是Unix的数据结构写在了头文件中，并可以被包含。
原先的Unix将这些结构（如目录）打印在手册中，人们需要将其复制到代码中。毋
庸多言，这是个重要的移植性问题。
-Steve Johnson
    System III C版本的PCC编译器（也随BSD 4.lc -起发布）改变了struct声明的处
理，这样不同struct中的同名成员不会冲突。同时引入了void和unsigned char声
明。函数内的extern声明，其作用域也限制在函数体中，而不再覆盖所有位于声明以
后的代码。
    ANSI C草案提议标准（The ANSI C Draft Proposed Standard）加入了const（只读存
储）和volatile（表明在程序控制的线程中例如内存映射寄存器等需要异步修改的地
方）。unsigned类型修饰符泛化了，可以应用于任何类型，同时加入了一个对称的
signed修饰符。也加入了auto数组、结构初始化器以及union樊型的初始化语法。
最重要的，加入了函数原型。
    早期C语言最重要的变化就是，转型为定义引用和在ANSI C草案提议标准（Draft
Proposed ANSI C Standard）中引入的函数原犁。自从1985-1986年X3JI1委员会关于标
准草案的工作报告将委员会的意向传达给编译器的实现者之后，C语言在本质上一直都
很稳定。
早期C语言更详细的历史，可以参阅其设计者编写的《Ritchie93》。
17.1.2  C语言标准
    C语言标准的发展一直是个保守的过程，原始C语言的精髓得以小心留存，更认可
现存编译器中的实验技术而不是发明新的特征。C9X宪章（charter）3文档很好地表述了这
个任务。
3可- rXib-问网页<http：//anubis．dkuug．dk/JTCI/SC22 /WG14 /www/charter>。
UNIX霸葶醒芝易笊
www.pdf365.com
17.1  C语言的演化
397
    第一个官方C语言标准化工作在X3J1l ANSI委员会的赞助下始于1983年。主要的
功能增加在1986年末就已经解决，在这一点上，对于编程者来说，区别“K&R C”和“ANSI
C”变得很普遍。
    许多人都没有意识到C语言标准化努力的工作是多么的不同寻常，尤其是最
  初的ANSIC工作，它坚持只将经过测试的特征列入标准。很多语言的标准委员会
  把大量时间花在新的语言特性上，而几乎不考虑应该如何实现。确实，极少数凭
  空产生的ANSIC特征——例如，臭名昭著的“三字母操作符（Lrigraphs）”——就
  是C89中最讨厌最不成功的特征。
    -Hen哼Spencer
    标准化努力的部分结果是发明了void指针，并且成为赢家。但是Henry的观
点也被很好地接受了。
-Steve Johnson
    尽管ANSI C的核心早就确定了下来，关于标准库内容的争论还是拖延了好几年。
正式的标准直到1989年末才发布，那是在许多编译器都已经实现了1985年的建议之后。
该标准最初称为ANSI X3.159，但在1990年国际标准组织（ISO）成为新的赞助方后重新设
计为ISO/IEC 9899:1990。该标准描述的语言变体通带称为C89或C90。
    第一本关于C语言和Unix可移植性的书籍，《Portable c and Unix Svstems
Programming》（可移植的C语言和Unix系统编程）[Lapin]，于1987年出版（在那时追
于雇主压力，此书以公司笔名出版）。第二版的《Kernighan-Ritchie》于1 988年出版。
    C89 -个次要的修订，称作修订l/AMI/C93，在1993年付诸实施。该修正增加了对
宽字符集和Unicode更多的支持。这就是ISOfIEC 9899-1:1994。
    C89标准的修订始于1993年。在1999年，ISO/IEC 9899（通常称作C99）为ISO
所采用。该协议集成了修订1并增加了许多次要的特征。其中也许对大多数编程者最重
要的一个就是，具备了像C++一样可以在代码块任意点，而不是仅仅只能在开始处声明
变量。同时也加入了参数个数可变的宏。
    C9X  工作组的网页是<http：／／anubis．dkuug．dk／JTC1／SC22/WG14/
www/proj ects>，但是在2003年中期还没有第三个标准化工作列入计划。正在为嵌入
式系统发展一个C语言的补遗。
    在c语言标准化工作开始烈前，可工作的兼容实现已经运行在广泛的不同系统上，
这个事实极大地协助了c语言的标准化工作。但这也更难以论证究竟哪种特征应该加入
UNIX编翟艺术
    www.pdf365.com
398
第17章可移植性：软件可移植性与遵循标准
到标准之中。
17.2 Uni×标准
    1973年用C语言重写后，Unix史无前例地容易移植和修改。结果，始祖的Unix分
别发展出了一系列早期操作系统。发展Unix标准最初就是为统- Unix系列不同分支的
API。
    在1985年后发展的Unix标准在这方面相当成功——因此而成为了现代Unix实现极
具价值的API文档。实际上，现实世界的诸多Unix都紧密地遵循公开标准，所以开发者
能够（也常常这样做）更依赖诸如POSIX规格说明的文档，而不是手头使用中的变种
Unix官方手册页。
    实际上，在新近的开源Unix（例如Linux）中，就往往使用公开标准作为其操作系
统功能特征的规格说明。我们在本章稍后审视RFC标准化过程时还会回到这一点来。
17.2.1  标准和Unix之战
Unix标准发展的原动力是第2章叙述过的AT&T和Berkeley阵线在发展上的分裂。
    4.x BSD Unix源自1979年的版本7。在1980年4.IBSD发布后，BSD阵线很快赢得
了Unix发展前沿的好名声。重要的新特性包括V1可视编辑器，从单一控制台管理多重
前后台任务的作业控制功能，以及信号的改进[参见第7章）。迄今为止最重要的增加
是TCPfIP网络，但是尽管Berkeley在1980年就获得了该合同，’rCPIP三年内都没能随
对外发布的版本一起交付。
    但是另一个版本，1981年的System III，成为了AT&T后来发展的基础。System III
重编了版本7的终端接口，使之更简洁，更优雅，但同Berkeley的改进完全不兼容。它
保留了老的（无重置）信号语义（也请参考第7章关于这点的讨论）。1983年1月发布
的System V Release 1整合了某些BSD实用程序（如vi（1））。
    在1983年2月，UniForum进行了架通两者的第一次尝试，这是一个很有影响的Unix
用户组。它们的Uniforum 1983年标准草案（UDS 1983）描述了一个“核心Unix系统”，
由System III核心的一个子集和函数库加上文件锁定原语构成。AT&T宣布支持USD 83，
www.pdf365.com
17.2 Unix标准
399
但是标准只是基于4.IBSD的发展实践的不完全子集。在1 983年4.2BSD发布的时候，
这个问题加重了，它为该版本增加了许多功能（包括TCPfIP网络），也引入了许多跟原
先版本7并不兼容的东西。
    1984年Bell运营公司的剥离以及Unix战争的开始（参考第2章）使问题更加复杂。
Sun Microsystems朝BSD方向领导着工作站产业；AT&T甚至一边继续向诸如SUfl的竞
争对手授权操作系统，一边利用对Unix的控制作为战略武器并试图进入商务领域。为了
保持竞争优势，所有商家作出的商业决策都是差异化他们的Unix版本。
    在Unix内战中，在某种意义上，技术标准成为相互合作技术人员奋力推动的东西，
而产品经理不是勉强接受就是积极反对。重大而重要的例外是AT&T，当它在1984年1
月发布System V Release 2（SVr2）时，宣布了同用户组在标准设立上的合作计划。1984
年的UniForum草案标准第二次修订版，追踪和影响了SVr2的APJ。后来的Unix标准中，
除了某些BSD功能在效用上特别领先的领域，均倾向遵从System V（例如，现代Unix
标准描述了System V晌终端控制而不是BSD同样功能的接口，就是这个原因）。
    在1985年，AT＆T发布了System V接口定义（System V Interface Definition，SVID）。
SVID结合UDS84为SVr2 API提供了一个更为正式的说明。后来的版本，SVID2以及
SVID3遵从了System V release 3和4的接口。SVID成为了POSIX标准的基础，而POSIX
最后在系统和C函数库上Berkeley/AT&T的分歧中，大多数都偏向了AT&T。
    但趋势在好几年内都仍不明显；其间，Unix之争仍战事频繁。例如，1985年，网络
共享文件系统就发布了两个竞争的API标准：Sun的网络文件系统（Network File System，
NFS）以及AT&T的远程文件系统（Remote File System，RFS）。Sun的NFS更流行一些，
因为Sun公司不仅愿意共享规格说明还愿意将代码公开。
    这个成功的经验其实更应该值得指出，因为纯粹基于逻辑判断来说，RFS远远更加
优秀。它支持更好的文件锁定语义以及在不同系统用户身份更好的映射，并且总的来说，
作出了相当的努力以期获得Unix文件系统语义更好更淮确的细节，而不像NFS。然而这
个成功的经验却往往被忽略，甚至在1987年，开源X window系统战胜了Sun专有网络
视窗系统（ Networked Window System （NeWS》时，也不例外。
    1985年后，主要的Unix标准化推进传递给了美国的电气电子工程协会（lnstitute of
Electrical and Electronic Engineers，IEEE）。IEEE的1003委员会发展了一系列的标准，
UNIX编程艺-术
  www.pdf365.com
第1 7章可移植性：软件可移植性与遵循标准
通常称作POSIX4。这些标准不仅描述系统调用和C函数库功能，还说明了具体的shell
语义和最小命令集，并具体化了各种非C编程语言的接口。它首次发布于1990年，1996
年发布了第二版。国际标准组织采用其作为ISOfIEC 9945。
    关键的POSIX标准包括：
1003.1 （1990年颁布）
    函数程序库。描述了C系统调用API，大部分同版本7相同，除了信号机制与终端
控制接口。
1003.2 （1992年颁布）
    标准shell和实用程序。Shell语义几乎同System V的Boume shell -模一样。
1003.4 （1993年颁布）
    实时Unix。二元信号量、进程内存锁、内存映射文件、共享内存、优先调度、实时
信号、时钟和定时器、IPC消息传递、同步I/O、异步1/0、实时文件。
    在1996年的第二版中，1003.4分成了1003.lb（实时）和1003.c（线程）两个部分。
    尽管在几个关键的领域里（比如信号处理语义上）说明不足，也遗漏了BSD套接字，
最初的POSIX标准还是成为了所有后来Unix标准化工作的基础。它仍然作为一个权威
被引用，纵使许多都是通过POSIX Programmer's Guide（POSIX裎序员指南）[Lewine】等间
接引用。实际上的Unix API标准仍然是“POSIX+套接字”，以后的标准主要是增加功
能以及在不常见边界情况更紧密的一致性规定。
    下一个参与者是X/Open（后来更名为Open Group），它是在1984年形成的Unix商家
联盟。它们的X/Open Portability Guides （XPGs）最初与POSIX草案平行发展，而在1990
年之后，XPGs整合扩展了POSIX。POSIX试图捕捉所有Unix的安全子集，而XPG更
倾向前沿开发的普遍实现；即使是1985年的XPGI，就跨越了SVr2和4.2BSD，还包含
了套接字。
    1987年的XPG2增加了终端处理API，基本上是System V的curses（3）。1990年的
XPG3融合了XII API。1992年的XPG4完全遵从了ANSI C 1989标准。XPG2、XPG3
4最初1986年的试用标准叫做IEEE-IX。  “POSIX”的名称是Richard Stallman的建议。POSIX.I的
介绍说：  “应该发[pahz-icks】的音，而不是[poh-six】或别的什么，公布发音方式是为了以尝试传播一
种il用标准操作系统接口的标准化方法。”
www.pdf365.com
17.2 Unix标准
401
和XPG4极度关注国际化的支持，并描述了一套详尽的API来处理字符集和消息目录。
    在阅读Unix标准的时候，也许会碰到“Spec 1170"（自1993年）、“Unix95"（自
1995年）和“Unix 98”（自1998年）。这些认证标记都基于X/Open标准；现在仅仅只
是历史的兴趣罢了。但是XPG4完成的工作成为了Spec 1170，而Spec 1170又转变成第
一版的“单- Unix规范’’  （Single Unix Specification，SUS）。
    1993年，包括每个主要Unix公司在内的75个系统和软件提供商对Unix战争作出
了了断，宣布支持X/Open开发出Unix的通用定义。作为协商的一部分，X/Open组织获
得了Unix商标权。整合的标准变成了单- Unix苏磋版本1。接下来就是1997年的版本
2。在1999年X/Open并入了POSIX的活动。
    在2001年，X/Open（现在的The Open Group）发布了单- Unix标准版本
3<ht tp：／/wwW。unlx．org/version3 1>。所有Unix API的标准化流程最终汇合到一
起。这反应了如今的现宴状况；不同种类的Unix已经会聚在～个通用API集合中。并且，
至少对1980年代的动荡记忆犹新的老一辈人来说，这太令人愉悦了。
17.2.2庆功宴上的幽灵
    但很不幸地，有个尴尬的情况——支持整合努力的1日学派Unix商家处于新学派开源
Unix的严峻压力之下，在某些时候不得不抛弃（有利于Linux）已经为确保一致性付出
巨大努力的专有Unix。
    单一Unix规范的一致性验证检测是个昂贵的任务。每个发布都需要做一次，但这超
出了大多数开源操作系统发布者的能力。无论如何，Linux的变化如此之快，任何发布版
本在获得认证时，可能都已经过时了5。
    诸如单- Unix规范之类的标准并没有完全失去实用性，它们仍然对Unix实现者有
很高的指导价值。但是Open Group以及其它旧学派Unix标准化机构如何适应开源发布
的节奏（以及开源开发组低预算或零预算运作），还有待观察。
5有个Linux发布商，英国的Lasermoon，确实获得了POSIX．】FIPS 151-2认证～一它已经倒闭了，
因为潜在用户对此根本不关心。
UNtX编|腥艺术
    www.pdf365.com
402
第1 7章可移植性：软件可移植性与遵循标准
17.2.3开源世界的Unix标准
    在1990年代中期，开源社区开始了自己的标准化努力。这些努力建立在由POSIX
及其继承标准确保的源码级兼容性之上。特别是Linux，它从头到尾都是按POSIX之类
类Unix API标准编写的。6
    在1998年，Oracle把领先市场的数据库产品移植到了Linux上，这场运动正是Linux
被大型机所接受的一次重大突破。在被记者问及Oracle必须战胜的困难是什么的时候，
负责移植的工程师的回应很有说服力：API标准工作完成得相当出色。他回答：  “我们
键入‘make'。
    由此看来，新学派Unix的问题并不是在源码层次上API的兼容性。每个人都理所当
然地认为在不同的Linux、BSD和专有Unix发布之间移植源码是轻而易举的。新问题不
是源码而是二进制的兼容性。因为由于商业PC机硬件的胜利，Unix的底层基础已经发
生了微妙的变化。
    在旧时代，每种Unix都运行在实际上属于它自己的硬件平台上。存在许多种类的处
理器指令集和机器体系，所以应用程序若要移植就必须在源码层次上完成。另一方面，
又只有极少数几个Unix的重要版本，相对来说其有较长的生命期。而诸如Oracle之类的
应用程序提供商能够为三到四个硬件／软件组合分别编译和提供独立的二进制发布版本，
因为他们可以通过大量的使用人群和较长的产品生命期来摊低源码移植的成本。
    但是后来小型机和工作站商家淹没在了基于386廉价的个人机中，而开源Unix改变
了规则。商家发现再也不能找到一个稳定的平台来发售它们的二进制程序。
    首先，表面的问题是，大量的Unix发布者——随着Linux发布市场的统一，越来越
清楚真正的问题是时间变化率。API是稳定的，但是系统管理文件的预期位置、实用程
序以及用户邮箱名和日志文件的前缀路径等常常发生变化。
    首次标准化努力是新学派Linux和BSD社区自身中发展出来（始于1993）的文件系
统层次标准（Fijesystem Hierarchy Standard，FHS）。此标准被集成到Linux标准基础（Linux
Standards Base，LSB）中，它标准化了一套预期的服务库和辅助应用程序库。两个标准
6进一步讨论请参考《Just for Fun》（玩玩而已）[Torvalds]。
www.pdf365.com
17.3 IETF和RFC标准化过程
403
都成为了自由标准组织（Free Standards Group） <http:/／www．freestandards．
org/>的行为，到2001年，该组织已经扮演了在旧学派Unix商家中X/Open的角色。
17.3  IETF和RFC标准化过程
    当Unix社区同互联网T程师文化相结合时，也继承了从互联网工程任务组（Intemet
Engineering Task Force，IETF） RFC标准化过程中形成的思维方式。在IETF传统中，标
准必须来自于一个可用原型实现的经验——但是一旦成为标准，同标准不一致的代码就
被认定是不合规范的，必须无情地抛弃。
    不幸地是，这并不是标准通常发展的方式。计算机历史充满了许多这样的例子，技
术标准是别有企图研究的最糟糕特征与黑暗密室政治结合的产物——这样产生的规格说
明在任何曾经的实现中都找不到踪影。更糟糕的是，许多规范不是严苛得无法实际实现，
就是说明不够充分，解决的问题远不如产生的困惑多。这些规范随之被塞给软件商，它
们如果发现什么地方不易实现，就忽略掉标准。
    标准无用最臭名昭著的例子就是，1980年代同TCP/IP竞争的开放系统互联（Open
Systems  Interconnect）扔议——它的七层模型乍看很优雅，但在实际中却被证明是过度复
杂而不可实现的7。视频显示终端功能的ANSI X3.64标准是另～个恐怖故事：同标准保
持一致的实现版本之间居然存在微妙的不兼容性，真是该死。即使在字符阵列终端大部
分被位图显示终端所替代以后，这些也还是问题（特别地，这就是为什么xterm （1）中
功能和热键偶尔会失效的原因）。串行通讯的RS232标准也是说明不够充分，有时候似
乎没有两个串行线是相似的。关于标准类似的恐怖故事真是可以写一本厚厚的书。
    IETF的哲学已经被概括为著名的“我们反对国王、总统和投票。我们信任大致的共
识和可运行代码”8。首先，要求可工作实现将使其免于最糟的莽撞行为。实际上，它的
规范更严格：
7网络搜索可以找到一个流行的幽默帖子，将OSI七层模型和七层玉米卷比较一一前者还处于劣势。
8这句最初是由IETF的高级干事Dave Clark在混乱的1992年会议上，IETF拒绝OSI协议时所说的。
UNIX编睡！艺I术
  www.pdf365.com
404
第17章可移植性：软件可移植性与遵循标准
    （任何）候选规范在被采用为互联网标准之前，必须得到实现，对操作的正确性
    以及众多独立方的互操作性必须得到测试，以及必须已经使用在要求越来越高的
    环境中。
    互联网标准过程一一修订稿3（ RFC 2026）
    所有的IETF标准都要经过RFC（请求评注）的阶段。RFC的提议过程故意地设置
为非正式的。RFC可以提出标准、调查结果、建议后续RFC的哲学基础，或者甚至是玩
笑。每年4月1日愚人节RFC年鉴的出现就是互联网玩家中最盛大的庆祝仪式，并且产生
许多如宝石般的精华标准，例如Transmission of IP Datagrams on Avian Carriers （IP数据报
的信鸽传递，RFC 1149）9、Hyper Text Coffee Pot Control Protocol（超文本咖啡壶控制协议，
RFC 2324）10、Security Flag in the IPv4 Header （IPv4包头的安全标志位，RFC 3514）。11
    但是搞笑RFC大概是唯一能够立即成为RFC的提议。严肃的提议实际上以“互联
网草案（lntemet-Drafts）"开始，通过IETF在／L个著名主机上的目泵让公众评注。没有
正式身份的互联网草案个体，其提出者在任何时候都可以改动或终止。如果他们既不撤
销也不提升到RFC状态，在六个月后草案将被移除。
    互联网草案并不是规范，而软件实现者和软件商被特别禁止宣称符合某条草案，并
将其按规范对待。互联网草案通常是在一个由电子邮件列表联系在一起的工作组讨论的
焦点。当工作组领导认为适合的话，就把互联网草案提交给RFC编辑，从而被分配～个
RFC号码。
    一旦互联网草案作为一个带编号的RFC发布，就成为其实现者可以宣称与之相符的
规格。接下来，RFC的作者和社区将开始以实际实验来更正规格说明。
    ～些RFC就到此为止了。一个未能吸引用户和经受现场测试的规格可能被默默遗忘
了，而且最后被RFC编辑标记为“Not recommended（不推荐）”或“Superseded（被取代）”。
失败的提议通常认为是进程的日常开销，相关的提议不会因此打上耻辱的印记。
9 RFC 1149见网页<http：／／www. ietf .orgirfc/rfc1149．txt>。不仅如此，其实现参见
<ht tp:  //www. blug. linux. no/rfc114 9 /wri t eup. html>.
10 RFC 2324兄网页<http：／/www.ietf.org/rfc/rfc2324.txt>。
‘1 RFC 3514见网页<http：／／www.ietf.org/rfc/rfc3514.txt>。
www.pdf365.com
17.4  规格DNA，¨油马RNA
405
    IETF的指导委员会（IESG，或者Internet Engineering Steering Group）负责将成功的
RFC推向标准之路。他们将合格的RFC标明为“Proposed Standard（提倡标准）"。对
于具备提倡标准资格的RFC，其规格必须稳定，经过同行评审，并且已经吸引了互联网
社区的极大兴趣。当然，一个RFC成为提倡标准，并不绝对要求存在实现，如果有则最
好不过；如果RFC改变或可能动摇互联网核心协议，IESG则有权要求RFC提供实现。
    提倡标准仍可能被修订，如果IESG和IETF确实有更好的解决方案，甚至还会被撤
消。它们并不推荐在“崩溃敏感环境”中使用——不要将他们使用在空中交通控制系统
或是需要精心照料的设备上。
    对于提倡标准，如果至少存在两个可工作的、完备的、独立发展出来的、可互用的
实现，就能够由IESG提升到“草案标准”状态。如RFC2005所说：  “提升到草案标准
阶段是个重要的进步，表明有充分理由相信规格是成熟而有用的。”
    一旦RFC达到了草案标准状态，就只能更改规格说明中的逻辑错误。草案标准可随
时被部署使用在崩溃敏感环境中。
    当草案标准经道了实现的广泛测试并且达到了普遍接受的程度，就可以成为一个互
联网标准（Internet Standard）。互联网标准保留自身的RFC编号，也可以申请一个STD
序列号。在本书写作时，虽然有3000多个RFC，但仅仅只有60个STD。
    尚未成为标准的RFC被标记为Experimental（实验性）、Informational（资料性）（搞
笑RFC就被赋予该标记），或者Historic（历史性）。历史性的标记被用于过时标准。RFC
2026注释为：  “（完美主义者建议这个词应该是“Historical（历史上的）”；但是，在这
一点上，  “历史性”一词的使用是历史上的原因。）
    IETF标准化过程有意提倡由实践而非理论驱动的标准化过程，并确保标准协议都经
受过严格的同行评审和测试。这种模式的成功结果显而易见——全世界的互联网。
17.4  规格DNA，代码RNA
    甚至在PDP-7的旧石器时代，Unix程序员就比其他业界同行更倾向于认为代码是可
弃的。这无疑是Unix传统注重模块性的产物，使其更容易在无损失的情况下抛弃和更换
UN/X编翟Yae
    www.pdf365.com
第17章可移植性：软件可移植性与遵循标准
系统的各个子部分。Unix程序员已经从经验中认识到补救糟糕的代码或设计比起重新开
始常常更费时费事。在其它编程文化中，被迫弥补大型单个程序是种本能的反应，因为
从头再来需要太多太多的工作，而在Unix文化则主张干脆拆毁重来。
    IETF传统反复教导我们将代码作为标准的从属物来思考。正是标准让程序可以协
作，将各项技术结合起来成为比部分之和更大的整体。IETF向我们展示了，精细的标准
化过程，瞄准获得最好的实践，其实是种强有力的形式，相比于无法实现的完美理想的
信誓旦旦来说，能够获得更大的成功。
    1980年后，Unix社区越发受到这个教训的影响。从1989年以来的ANSI/ISO C标准
虽并非毫无瑕疵，但考虑到其长度和重要性，它的确异常简洁和实用。单- Unix规范在
更广泛的领域中包含三十年来的实验和改进，比ANSI C更为凌乱。但是标准的组成相
当良好。一个强有力的证明就是，Linus Torvalds通过它而成功从头开始编制了一个Unix。
IETF强大的示范给Linus Torvalds的壮举创造了一个关键背景，并使其成为可能。
    尊重已颁布标准和IETF过程已经在Unix丈化中根深蒂固；故意违反Internet STD
就是不妥当的。这一点有时候往往会造成Unix背景的技术人员同其它技术人员之间相互
不理解，其它技术人员往往设想最流行或最广泛配置的协议实现就是定义上的正确——
即使定义严重地违反标准而不能与完全符合标准的软件进行协作。
    Unix程序员可能大力反对其它种类的前规格说明，他们对已颁布标准的尊敬显得很
有趣。当“瀑布模型”（首先详尽说明，然后实现，然后调试，在任何阶段都没有反向
动作）在软件工程学中失宠时，在Unix程序员中成为笑柄其实已经好几年了。经验以及
合作开发的浓厚传统，已经训练了Unix程序员，先原型然后循环不断地测试和演进才是
更好的方法。
    Unix传统清楚地意识到良好的规格说明具有巨大的价值，但是需要像“互联网草案，，
和“提议标准”的方式那样，被视作是暂时的、需要订正的对象，必须通过在现场实验
中的不断改进。在最好的Unix实践中，程序的文档就近似于规范主体的“提议标准”，
需要不断修改订正。
www.pdf365.com
17.4  规格DNA，代码RNA
407
    与其它环境不同，在Unix开发中，文档常常在程序之前，或者至少同程序一
起编写。对于X11，X核心标准在X第一版发布之前完成，并且自从那时起基本
上就没有改动过。不同X系统间的兼容性更进一步地被严格的规格驱动测试所改
善。
    有了良好编写的规格说明，开发X测试套件便更加容易。在X规格说明中的
每一项声明都转换成代码来测试其实现，在这个过程中发现了几个次要的、跟规
格不一致的地方，其最终结果就成为了一个测试套件，覆盖了X实例库和服务器
中重要的代码路径，并且不引用实现源码。
    -Keith Packard
    生成半自动化的测试套件被证实为～个主要优势。尽管图形艺术的现场实验和发展
导致对X设计基础的许多批判，尽管X的某些部分（例如安全和用户资源模型）似乎笨
拙而实现过度复杂，但X在稳定性和跨系统发布的互用性方面达到了非同一般的良好水
平。
    在第9章我们讨论了将编码尽量往上推以最小化常数缺陷密度效应。Keith Packard
含蓄地说明X文档并不仅是期望功能列表，而是以高级代码形式来表述。另外一个X的
关键开发者证实了这一点：
    在X中，规格说明就是一切。有时规格存在缺陷需要修正，但是代码通常此
  规格说明具备更多的bug（对任何值得着墨的规格说明）。
—■im Gettys
    Jim继续阐明X的过程实际很像IETF过程。它的功用并不是仅仅局限于构建优良的
测试套件；它也意味着相关的系统行为争论可以在关于规格的功能层面解决，避免了太
多实现问题的纠缠。
    以考虑周全的规格说明来驱动开发可能会引起“bug还是功能”的小小争论；
但没有正确实现规格说明的系统就是破损不全的，必须得到修正。
我怀疑这在我们当中是如此的根深蒂固，有时反而忽略了它的威力。
www.pdf365.com
408
第1 7章可移植性：软件可移植性与遵循标准
    一个在Bellevue以东一家小公司工作的朋友奇怪，Linux应用程序开发者为
什么可以随着应用程序发布版本同步地进行OS改动。在那个公司里，主要的系
统级API频繁改动以容纳一些古怪念头，所以基本的OS功能必须常常随着每个
应用程序一起发布。
    我向他描述了规格说明所具有的威力以及实现应当如何遵从规格，然后接着
断言，如果一个应用程序按接口文档得到一个非预期的结果，那么不是违反了规
格，就是发现了bug。他认为这个观念非常令人吃惊。
    分辨这类bug再简单不过了，只要检查接口实现是否违反了规格。当然，如
果有实现的源码会更简单。
    -Keith Packard
    这种标准先行的态度对于最终用户同样有益。Bellevue以东的那个小公司变大了，
它难以兼容以前发行的办公软件，而在1988年为X11编写的GUI应用程序在今天的X
实现中仍然没有改变地运行着。在Unix世界中，这种长寿是很正常的——这也就是为什
么将标准视作DNA的原因。
    经验表明，遵从标准、喜欢抛弃重建的Unix文化，虽然花费额外时间，但相比于因
为没有标准提供指导和连续性，而必须不停地对代码基础库缝缝补补，往往熊够产生更
好的互用性。这真的或许是Unix最重要的教益。
    Keith最后的评注直接引出一个问题，也是随开源Unix的成功而提到前台的问题
—二开放标准和开放源码间的关系。我们将在本章末尾讨论这个问题——但在这之前，
是讨论Unix程序员如何能够使用大量的标准和知识来获得软件可移植性的实践问题的
时候了。
17.5可移植性编程
    软件可移植性通常是准空间问题：代码可以从其诞生的环境移到别的硬件和软件平
台吗？但是几十年的Unix经验告诉我们时间上的持久性同样重要，甚至更重要。软件的
未来如果可以详细地预测，最好现在就来预测——然而，在可移植性编程中，我们应该
www.pdf365.com
17.5可移植性编程
409
尝试考虑选定最可能持续的软件环境特征作为构建软件的基础，同时要避免不久的将来
就可能消亡的技术。
    Unix二十年对详述可移植性API问题的关注，在很大程度上解决了这个问题。在单
- Unix规范中描述的功能今天几乎仍然存在于现代的Unix平台中，将来也不会不支持。
    但并不是所有的平台依赖性都同系统和库函数API相关。实现语言也有关系；源系
统和目标系统之间文件系统设计和配置的不同也是个问题。还好，Unix实践已经发展出
解决方法。
17.5.1  可移植性和编程语言选择
    可移植性编程的首要问题是实现语言的选择。所有我们在第14章讨论过的主要编程
语言，从在全部现代Unix上都有兼容实现的角度来说，均具有较高的可移植性；而大多
数在Windows和MacOS下也有实现。在这里，可移植性问题往往并不在于核心的编程
语言，而在于支持库以及同本地环境整合的程度（尤其是IPC、并发进程管理以及GUI
的基础设施）。
17.5.1.1  C的可移植性
    C语言核心的可移植性非常高。标准的unix实现是GNU C编译器，它在开源Unix
和现代专有Unix中普遍存在。GNU C也已经移植到了Windows和古典的MacOS申，
但在那里使用并不普遍，因为缺少对本地GUI的可移植接口。
    标准输入／输出库、数学例程以及国际化支持都可以移植到所有的C实现中。如果小
心谨慎地只使用在“单- Unix规范”中描述的现代API，文件1/0、信号、进程控制也
可以移植到各个Unix;老一些的C代码常常需要经过条件预处理宏才能移植，但使用
POSIX之前接口的代码往往来自于古老专有的Unix，而且在2003年这些Unix如果不是
已经废弃就是接近废弃了。
    对于IPC、线程以及GUI接口，C的可移植性问题开始有些严重了。我们在第7章
已经讨论过IPC和线程的移植问题。真正实际中的问题是GUI工具包。许多开源的GUI
工具包可跨越各种现代Unix使用，还被移植到了Windows和传统的MacOS中-Tk、
wxWindows、GTK和Qt是其中四个最著名的，可以通过网络搜索得到的源码和文档。
但是它们中没有一个随所有平台一起发布，而且（更多的是法律而不是技术因素）没有
UNIX编惺艺术
  www.pdf365.com
410
第17章可移植性：软件可移植性与遵循标准
一个能够提供所有平台原汁原味的GUI观感。我们已在第15章给出了处理这个问题的
指导原则。
    已经有大批关于如何编写可移植性C代码的书了，本书并不想成为其中的一本。我
们推荐阅读Recommended C Style and Coding Standards（C的推荐风格和编码标
准）[Cannon]以及《The Practice of Programming（程序设计实践）》[Kemighan-Pike99]）中关
于可移植性的相关章节。
17.5.1.2 C++的可移植性
    在操作系统层次上，所有C语言的移植性问题C++都有，当然也存在一些自身的问
题。其中一个增加的问题是开源的C++编译器已经落后于专有的实现；这样，在2003年
年中，仍然没有一个统一的像GNU C-样能够成为事实标准的基础。更进一步，仍然没
有一款C++编译器完全实现了C++99 ISO语言标准，尽管GNU C++是最接近的一个。
17.5.1.3 Shell的可移植性
    很不幸，shell脚本的可移植性非常糟。问题不在shell本身．bash（1）（开源的Bourne
Again shell）已经普遍存在，所以纯shell卿本几乎可以到处运行。问题是大多数的shell
脚本大量使用了其它可移植性差的命令和过滤器，而且绝不保证在任意指定的机器上它
们都存在。
    这个问题可以借助一些额外的工作来克服，比如autoconf （l）工具。但是这个问题
很严重，所以大多数在shell中稍重量级的编程都转移到诸如Perl、Python、Tcl等第二代
脚本语言中完成。
    Perl的可移植性良好。Perl的核心版本甚至提供一套支持跨Unix、MacOS和Windows
平台GUI的rk工具包接口。然而也有个问题很讨厌。Perl脚本常常要求来自CPAN
（ Comprehensive Perl Archive Network）的插件库，无法保证它在每个Perl实现中都存在。
17.5.1.5  Python的可移植性
    Python可移植性极其出色。如同Perl -样，Python的主干版本甚至提供一个Tk包
的可移植接口，可支持Unix、MacOS和Windows的GUI。
www.pdf365.com
4l l
    Python主干版本存在比Perl更丰富的标准函数库，但是没有等价于Perl程序员可以
依靠的CPAN;重要的扩展模块常常随主干Python的次要版本的发布一起发布。这是以
牺牲空间来换取时间，使得Python更少成为模块丢失效应的对象，代价是Python的次版
本号要比Perl发布的版本级别重要得多。在实践中，权衡似乎对Python更为有利。
17.5.1，6 Tcl的可移植性
    Tcl的可移植性总的来说不错，但是随着项目复杂度的不同而有极大差异。为跨平台
GUI编程而生的Tk包原生于Tcl。同Python -样，语言核心的发展相对顺利，很少存在
版本不兼容问题。但不幸的是，Tcl甚至比Perl更依赖那些并不能保证随着每个实现一
起发布的扩展功能——也没有像CPAN -样的地方来集中发布这些扩展功能。
    因此，对于不依赖扩展的小项目，Tcl的移植性相当高。但是大项目往往大量依赖扩
展，和（同shell编程一样）调用在目标机器可能存在也可能不存在的外部命令；这些东
西的移植性相当糟。
    具有讽刺意味地，Tcl也许吃够了容易增加扩展的苦头。当一个特殊的扩展开始引人
注目，似乎可以成为标准发布中的一个部分时，一般都已经夺在好几个不同的版本了。
在1995年的Tcl/Tk学术研讨会上，John Ousterhout对为什么没有在标准Tcl发布中加入
00支持而解释道：
    想想五位大学者围坐一圈，一起叫着“杀死他，异教徒”。如果我把某个特
  殊的oo设计加入到内核中，其中一个就会说“祝福你，我的孩子，吻我的戒指
  吧j”，而另外四个则说“杀死他，异教徒”
    语言设计者并不一定愉快。
17.5.1.7 Java的可移植性
    Java的可移植性特别出色——毕竟，它是以“一次编写，到处运行”作为主要设计
目标的。然而，可移植性仍非尽善尽美。麻烦主要是JDK l.1及老AWT GUI工具包（一
方面）和JDK l.2及新Swing GUI包之间的版本兼容问题。这有几个重要的原因：
●  Sun的AWT设计不完善，不得不用Swing来代替。
UNIX编程艺术
  www.pdf365.com
412
第1 7章可移植性：软件可移植性与遵循标准
    ●  微软拒绝在Windows中支持Java开发并试图以C#来取代Java。
    ●  微软决定继续保留IE中对JDK I.I版的小应用程序的支持。
    ●  Sun许可证授权让JDK l.2的开源实现完全小可能，这延缓了它的部署进程（特
    别是在Linux世界）。
    对于涉及GUI的程序，追求移植性的Java开发者在可预知的未来，时常面临一个选
择：采用糟糕设计的JDK l.1/AWT工具包取得最大可移植性（包括移植到Microsoft
Windows），或者采用更好的工具包和JDKl.2功能而牺牲部分可移植性。
    最后，正如我们前面注意到的一样，Java对线程的支持也存在移植性问题。Java API，
不像其它抱负较小语言的操作系统接口，它勇敢地去尝试弥补不同操作系统提供的不同
进程模型之间的差异：但还没有掌握诀窍。
17.5.1.8  Emacs Lisp的可移植性
    Emacs Lisp的可移植性相当好。Emacs安装往往频繁地升级，而严重的过时失效情
况很少出现。相同的Lisp扩展到处都被支持，而所有的扩展都随Emacs本身一起发布。
    而且，Emacs的原语集相当稳定。几年前就获得了一个编辑器应有昀完备性（缓冲
区处理，shell脚本支持）。仅仅只是X的引入损害了这个优点，并且需要感知X的Emacs
模式也非常少。可移植性问题通常表现在操作系统功能C层次接口上的格格不入；例如，
邮件代理模式的从属进程控制大概是唯一这种表征经常出现的地方。
17.5，2避免系统依赖性
    一旦选定开发语言和支持库，下～个可移植性问题通常就是系统关键文件和目录的
放置：邮件池同志文件目录等等。这类问题的原型一般就是邮件池目录到底是
/var/ spool/mail还是/var/mail。
    通常可以通过退一步重新架构这个问题来避免此类依赖性。为什么要打开邮件缓冲
目录下的文件？如果需要写入，简单地触发本地邮件传输代理，来完成以获得正确的文
件锁定不是更好吗？如果需要读入，通过POP3或IMAP服务器查询不是更好吗？
www.pdf365.com
17.6国际化
413
    同类的问题在别处同样适用。如果发现需要手动打开日志文件，为什么不使用
syslog（3）代替？通过C库函数调用的接口比起系统文件定位容易标准化得多。应当利用
这个事实！
    如果必须在代码中使用系统文件定位，最好的选择取决于是发布源码还是采用二进
制形式。如果发布的是源码，我们在下个部分讨论的autoconf工具能够提供很好的帮助。
如果发布的是_进制形式，良好的实践是在程序运行期试探是否可以自动地适应本地条
件——例如，实地检查／var／rnail和／var/spool/rnail是否存在。
17.5.3移植工具
    通常可以使用我们在第15章介绍的开源GNU autoconf（1）来处理移植性问题，进
行系统配置探查，定制出makefile文件。如今，从事源码编译软件的人们往往希望能够
键入  configure;make;make  install  来干净利落地编译。  在
<http：／/seul．org／docs／autotut／>处有这些工具的优秀指导手册。即使是发布二
进制码，autoconf（1）工具也能够帮助自动化处理针对不同平台的条件代码问题。
    其它解决这个问题的工具中，其中两个较为知名的是与X window泵统相关的
Imake（l），以及由Larry Wall（后来的Perl语言发明者）编制的Configure工具，也被许
多项目采用。所有的工具至少都跟autoconf套件一样复杂，使用也不如以往频繁。它们
无法覆盖众多的目标系统。
1 7。6  国际化
    软件代码的国际化设计使得接口容易适应多种语言和各种字符集，对于这方面的深
入讨论超HJJ了本书的范围。然而，在Unix经验中有一些良好实践的突出事例。
    首先，分离信息库和代码。良好的Unix实践应把程序使用的消息字符串同程序代码
分离开来，这样不用修改代码就可以增加其它语言的消息字典。
    完成此项工作最知名的工具就是GNU的g已ttext，这个工具要求把需要进行国际化的
原生语言字符串包装在一个特殊的宏中。该宏使用各个字符串作为各文件提供的各种语
UNIX编腥艺_术
    www.pdf365.com
414
第1 7章可移植性：软件可移植性与遵循标准
言字典主键。如果某种语言的字典不可访问（或者存在该字典但查询没有匹配返回），
那么宏就简单地返回其参数，也就是隐式地退回到代码的本地语言。
    尽管在2003年中期，gettext本身一团乱麻，但其总体指导思想却是可靠的。对于许
多项目，使用这种思想可以手工打造出这种国际化设想的轻量级版本，并收到良好的效
果。
    其次，在现代Unix中有种清晰的潮流：抛弃所有历史上与多字符集相关的记法而让
应用程序原生地使用UTF8，八位移位Unicode编码字符集（或者相反地说，让他们原生
地使用1 6位宽字符）。UTF-8的前128个字符就是ASCII，前256个字符是Latin-I，这
就意味着它向后兼容使用得最广泛的两个字符集。XML和Java事实上促进了这种选择，
但是即使没有XML和Java，趋势也会如此。
    第三，使用正则表达式时，当心字符的范围。【a—z】元素并不必然包含所有的小写
字母，如果脚本或是程序应用于（比如说）德语，B被认为是小写字母但并没有包含在
上述范围之内；法语中的重音字母也存在类似的问题。安全的方式是使用【[．lower：】】，
以及其它在POSIX标准中拙述的符号范围。
17.7可移植性、开放标准以及开放源码
    可移植性需要标准。无论是发布传播一项标准还是敦促专有软件商遵循标准，开放
源码基准实现都是已知最有效的方法。而对于开发者，已颁布标准的开源实现既极大地
减轻了编码负担，也允许产品（有意或意外地）从他人的劳动中获益。
    让我们设想，例如，为数码相机设计一个图像捕捉软件。既然存在（正如我们第5
章所提到的）功能齐全经过良好测试的PNG读写开源库，那为什么要编写自己的格式来
存储图像数据或是购买专有代码呢？
    开放源码的新生（重生）同样给标准化过程带来了重要的影响。尽管并非正式要求，
IETF自从大约1997年前后，愈发抵制连一个开源基准实现都没有的RFC成为预备标准。
将来与某标准是否一致，似乎愈发有可能以“是否同已经得到标准作者们认可的开源实
现相一致（或者完全使用该实现）”来判定。
www.pdf365.com
17.7可移植性、开放标准以及开放源码
415
暗含的意思就是，成为标准的最好办法就是发布一个高质量的开源实现。
-Henry Spencer
    最后，确保代码移植性最有效的一个环节就是不要依赖于专有技术。永远不会知道
所依赖的闭源库／工具／代码生成器或网络协议何时会结束生命，接口何时会以某种非向后
兼容的方式改变，从而崩溃掉已有的项目。而使用开源代码，即使前沿版本的改变方式
足以崩溃已有的项目，也有前行之路；因为可以获取源码，如果需要，就可以向前移植
项目到新的平台。
    直到1990年代晚期，这个建议都还是不切实际的。少数几个代替依赖专有操作系统
和专有开发工具的软件还只是昂贵的实验品、学术上有待证实的观点或者小玩意。但互
联网改变了一切；在2003年中期，Linux和其它开源Unix不但存在，并且已经证明了自
身完全可以是出产高质量生产级软件的平台。现在开发者有了更好的选择，而不是依赖
于为垄断而设计的短期商业决策。实施防御性设计——基于开放源码编程，便不会束手
无策。
UNIX编程艺术
  www.pdf365.com
www.pdf365.com
1 8
文档：向网络世界阐释代码
Documentation: Explainin  Your
Code to a Web-Centric World
    I've never met口human being who would want to read J 7:000 pages of documentation，
    and if there was，，fd kill him to get him out西the gene pool.
我从没见过一个愿意阅读1 7000页文档的人，如果有，我会杀了他，这样人的基因
    必须抹去。
    -Joseph Costelio
    在1971年，Unix的第一个应用，是作为文档整理的平台-Bell实验室用来整理专
利文件以进行归档。那时，计算机驱动的照排还是新颖的想法，但几年后，1973年Joe
Ossana的troff（1）格式器出台，一举决定了这门艺术的地位。
    自那时起，各种复杂精致的文档格式器、排版软件、版面设计程序就已经成为了Unix
传统中的一个重要主题。尽管troff（1）令人吃惊地持久耐用，Unix还是在这个应用领
域中促生了许多其它具有突破意义的软件。现在，由万维网的发明而触发了文档实践的
深远转变，Unix开发者和Unix工具正站在这种转交的前沿。
    在用户表示层，自从上世纪九十年代中期以来，Unix社区的实践已经迅速地朝着“一
切皆HTML，所有引用都是URL”的方向发展。越来越多的现代Unix辅助浏览器完全
可看做解析确定特殊种类URL的网页浏览器（例如，“man:ls（l）”将ls（l） manpage转换
UNIX编腥艺-术
    www.pdf365.com
41 8
第1 8章文档：向网络世界阐释代码
成HTML）。这解决了不少因为主文档格式太多而产生的问题，但并不彻底。文档编辑
器仍然挣扎在哪种主格式最适合需求的权衡中。
    本章，我们将讨论许多种不同的文档格式，以及经受了几十年考验而传承下来的文
档工具，  “太多”意味着“不幸”。当然，我们也会逐步发展出良好实践和风格的指导
准则。
18.1  文档概念
    我们要讨论的第一项区分，就是“所见即所得”（WYSIWYG）的文档程序同以标记
为中心的工具之间的差异。大多数的桌面出版程序和字处理器都属于前者：具备图形用
户界面、键入的文字可以直接插入到文档在屏幕上的表示之中，并尽可能地接近最终的
打印版本。在以标记为中心的系统中，相对应地，主文本通常就是包含明确可见控制标
记的纯文本，跟期望的输出完全不同。标记的源文件可以由普通的文本编辑器修改，但
必须传入某个格式器程序来渲染输出以供打印或显示。
    界面可视的、WYSIWYG的风格对于早期的计算机硬件来说太昂贵了，直到1984年
Macintosh个人机问世前一直都很稀有。在当今非Unix的操作系统中，WYSIWYG的风格
完全占据了统治地位；而另一方面，Unix的原生文档工具，几乎都是以栎记为中心的。1971
年的Unix troff （1）就是个标记格式器，而且很可能是现在仍在使用的程序中最古老的一
个。
    以标记为中心的工具依然扮演着重要角色，因为实际上，WYSIWYG风格的实现往
往在很多情况下工作得并不好——有些是表面的，有些是深层次的。我们在第11章讨论
过GUI的一般问题，WYSIWYG的文档处理器也不可避免；任何事的结果都能看得到，
就意味着任何事都得看着做。所以，即使在屏幕和打印输出达到一致了，这个问题依然
存在——何况这两者从来没一致过。
    实话实说，WYSIWYG的文档处理器并不真正所见即所得。大多数程序的界面，并
没有真正消除屏幕显示和打印输出的差异，只是让你看不出来而已。这样做其实违反了
最小立异原则：界面的可视部分鼓励将程序作为打字机使用，但实际上并不能这么用，
而你的输入又时不时地产生无法预料或是非期望的结果。
    再实事求是点，WYSIWYG系统实际依赖的是标记码，只不过额外支付了巨大的努
力以期将此隐藏在一般使用中。这又违反了透明原则：因为无法了解所有的标记，就难
以标记位置错误的损坏文档。
www.pdf365.com
419
    尽管存在这些问题，但如果仅仅只是想把一张图片往右拖三个字宽，把它放到～
个四页小册子的封皮上，WYSIWYG的文档处理器可以干得非常漂亮。然而一旦需要
对三百页手稿的版面设计做出整体更改，便会有巨大的不便。WYSIWYG的用户面对
此类的挑战必须放弃，或是忍受要命的千百次鼠标点击的痛苦；在这样的情形中，编
辑明确标记的能力是无可替代的；此时，以标记为中心的Unix文档工具提供了更佳的
解决方案。
    今天，当全世界都受到了万维网和XML的影响，把表现方式和结构标记在文档中
区别开是再正常不过的了——前者是关于文档外观的指令，而后者是关于文档如何组织、
有何用意的指令。这种差异在早期的Unix工具中并没有得到清晰的理解和遵从，但是理
解这种设计差异非常重要，正是它导致了那些工具发展为如今的继承者。
    表现级标记在文档本身中携带所有的格式信息（例如希望的空白布局和字体变化）。
而在～个结构标记系统中，文档必须和～个样式单相结合，它告知格式器如何将文档中
的结构标记转换为物理的版面布置。最后两种标记一起控制打印和浏览文档的物理外观，
但是，如果希望既能为打印又能为网页生成良好的输出结构，结构标记有必要通过一个
更高级剐的间接层完成。
    大多数以标记为中心的文档系统都支持宏。宏是用户定义的命令，可以由文本替换
来扩展成内嵌的标记请求序列。通常，这些宏为标记语言增加了结构特征（例如声明小
节标题的能力）。
    troff宏集合（mm、me和我的ms包）实际上是设计来将人们从面向格式的
编辑推动到面向内容的编辑。这种思想就是将语义部分进行分类标记，以各种风
格包来确定在这种样式中标题是否应该大写或者居中等等。这样，一套宏可以尝
试模仿ACM刊物的风格，而另一套使用基本-ms标记的宏则模仿Physical Review
（物理评论）刊物的风格。然而对于既要集中精力构建文档内容，又要注意控制
外观，所有的宏都不好使，就如同网页陷入到底是读者还是作者应该控制外观的
争吵一样。我常常发现那些秘书仅仅为了产生斜体而使用.AU（作者名）命令，
因为发现它能产生斜体，该命令的附加效应将使他们无比烦恼。
-Mike Lesk
最后，我们注意到对于小文档（商务和私人信函、小册子以及时事通讯）和大文档
UN/X编腥艺l术
  www.pdf365.com
420
第1 8章文档：向网络世界阐释代码
（书籍、长文、技术论文以及手册）之间，作者所期望处理的事情存在重要差异。大文
档往往需要更多的结构，需要一部分一部分地结合在一起，而又能够单独改动，同时需
要一些自动生成功能，例如内容的目录；这些特点都倾向于以标记为中心的工具。
18.2 Unix风格
    Unix风格的文档（以及文档工具）具备几个技术和文化特征，使之有别于其它地方
的实现。首先熟悉这些鲜明的特征，便能够打下良好的背景基础，从而理解为何文档有
那样的实际外观，为何文档有那样的阅读方式。
18.2.1  大文档偏爱
    一直以来，Unix文档工具主要是为应对创作庞大复杂文档的挑战而设计的。最初
是专利申请和文书工作；后来是科技论文，以及各式各样的技术文档。结果，大多数
Unix开发者渐渐喜欢上了以标记为中心的文档工具。与时下的PC用户不同，尽管在
1980～1990年代早期，WYSIWYG的字处理器非常普遍，但在Unix文化中并没有留下
什么印记——即使在今天，年轻一辈的Unix玩家中，也很少发现有谁真正地喜欢那种
工具。
    对不透明二进制文档格式的厌烦情绪—～尤其是不透明的专有二进制格式——也在
拒绝WYSIWYG工具的过程申起到了一定作用。另一方面，PostScript（图像打印机的现
行控制语言标准）刚可以使用，Unix程序员就投入了极大的热情；这门语言整洁优美地
符合Unix传统的域专用语言。现代的开源Unix系统都有优秀的PostScript和可移植文档
格式（ Portable Document Format，PDF）工具。
    另一个历史结果就是，Unix的文档工具对于包含图像的支持往往相对较弱，但
是对图表、图形和数学方面排版的支持却很强——这些都是在技术论文中常常需要用
到的。
    Unix对于以标记为中心系统的依恋常常被讽刺为一种偏见或是顽固的特性，但是实
际上并不真的女日此。同Unix被公认为“原始”的CII风格在许多地方比GUI更能适应高
www.pdf365.com
18.2 Unix风格
421
级用户的需要一样，诸如troff（1）等以标记为中心设计的工具，比起WYSIWYG的程
序更能适应高级文档管理者的需要。
    偏爱大文档并不仅仅让Unix开发者继续对诸如troff程序等以标记为核心的格式器
保有依恋，也激发了对结构标记的兴趣。Unix文档工具的历史，是一场步履蹒跚、充满
困惑、左右摇摆的运动，虽然总方向是从表现性标记转到结构性标记。在2003年年中，
这个旅行仍未结束，但放眼放去，终点已不远。
    万维网的发展意味着在大概1993年以后，文档工具面临的主要挑战是提高描绘多媒
体文档（或者，至少是为了打印和HTML显示）的能力。同时，即使是普通的用户，在
HTML的影响下，也变得更加适应以标记语言为中心的系统。这直接导致了在结构性标
记上浓厚兴趣的爆发以及1996年后XML的发明。突然间，1日时代Unix对以标记为核
心系统的依恋开始变得不再是反动，而是具有先见之明的了。
    如今，在2003年年中，多数基于XML使用结构性标记文档工具的前沿开发正在
Unix下进行。但是同时，Unix文化并没有放弃古老的表现级标记系统的传统。HTML和
XML只在部分场合取代了嘎吱嘎吱作响的、穿若笨重铠甲大恐龙般的troff。
18.2.2文化风格
    绝大多数软件的文档都是由技术人员写给可能连最小公分母都不知道的普通大众的
——渊博者写给无知者。但是同Unix系统一起发布的文档传统地是由程序员写给程序员
的。即使不是写给同行的，但在风格和格式上，也往往受到大量同Unix系统一起发布的、
程序员写给程序员的文档所影响。
    这种思想产生的差异可以用一个观察来总结：Unix手册页传统上也包含一个叫做
BUGS的部分。在其它地方，技术作者为了让软件产品看起来更漂亮，常常省略或一笔
带过那些已知的bug o而在Unix文化中，同行彼此互相事无巨细地揭露软件的已知缺陷，
而用户也认为一个简单但详细的BUGS部分是高质量软件的表征。隐瞒了BUGS部分，
或是改头换面为诸如LIMITATIONS或ISSUES或APPLICATION USAGE等轻描淡写词
语、从而打破这个约定的商业Unix发布版本，无一例外地走上了不归之路。
    多数其它软件的文档往往总是在高深莫测和过度简化间摇摆，而经典的Unix文档则
简洁而完善。虽然并非手拿把教，但通常指明了正确的方向。这种风格设想的读者积极
UNIX编程艺．术
    www.pdf365.com
422
第1 8章文档：向网络世界阐释代码
而进取，愿意并能够举一反三。
    Unix程序员往往擅长于编写参考书籍，而大多数Unix文档也带点参考书籍或辅助
备忘录的味道，这是为那些能够象文档作者一样思考但对软件还称不上专家的人编写的。
答案看起来常常比实际上的隐秘和匮乏得多。然而，仔细逐字逐句地阅读，因为想知道
的一切就在那里，或者可以从那里推导。仔细逐字逐句地阅读，因为话很少会说两遍。
18.3各种Unix文档格式
    所有主要的Unix文档格式，除了最近的，都具有宏扩展包支持的表现级标记。我们
将按照从老到新的时间顺序讨论。
18.3.1    troff fo Documenter*s Workbench Tools
    在第8章，作为如何整合一个多微型语言系统的实例，我们讨论过Documenter's
Workbench的体系和工具。现在，我们转过来讨论这些工具用作排版系统的角色。
    troff格式器可看作是一个表示层的标记语言。最近的实现版本，诸如GNU项目groff
（1）之类，默认情况下生成PostScript输出，当然也可以通过选择适当的驱动来得到其
它格式的输出。参看实例18.1，是几行可能会在文档源文件中碰到的troff代玛。
例18.1  groff （1）标记实例
This is riinning text.//这是运行文本
．＼”Conunents begin with a backslash and doulole quota.//注解以反斜扛加双引号开始。
．ft B
This text will be in bold font.／／这里的文本字体为粗体。
．ftR
This text will be back in the default  （Roman）  font．／／这里的文本又回到默认的（Roman）
字体
These lines， going back to 'fThis is running text"， will
be formatted as a filled paragraph.//这几行，回溯到“This is running text”被格
式化为…‘个加载段。
．bp
The bp request forces a new page and a paragraph break.//bp请求生成新页结束段落。
This line will be part of the second filled paragraph.  ／／这一行属于第二加载段的
部分。
.sp 3
The .sp request emits the number。f blank lines given as argument//sp谙求生成
给定参数数量的空行。
www.pdf365.com
18.3各种Unix文档格式
423
．nf
The nf request switches off paragraph filling.//nf请求取消段落加载。
Until Lhe fi request switches it back on  ／／直到fi请求切换回来
whitespace and layout will be preserved.  ／／空白和版面继续保留
One word in this line will be in \fBbold\fR font.//该行的一个字将是＼fBbold\ fR
字体。
．fi
Paragraph filling is back on.//切换回段落加载。
troffl1）有很多其它的请求命令集，但是人们通常都不会去直接阅读它们。几乎没有
文档直接用troff编写。troff支持宏，通常都使用五六个宏命令包。在这些当中，压倒性
最普遍的是man（7）宏命令包，用来编写Unix手册页。例18.2作为一个样本供参考。
例18.2 man标记实例
. SH  SAMPLE  SECTION
The SH macro starts a section，  boldfacing  the  section  title. //SH宏标志一个部分
的开始，并使标题的字体为粗体。
.p
The p request starts a new paragraph.  TheIrequest sets its//pj青求开始一个新
的段落，工请求将字体设置为其后指定的参数
argumentln
．工i七alics.／／在该例中为斜体。
．IP  ★
This starts an indented paragraph with an asterisk label.//从此开始一个以星号为
前标的缩进段落。
More text for the first bulleted paragraph.//段落更多的文本，每行以星号为前标。
.TP
This first line will become a paragraph label/／这第一行成为新段落的标记
This will be t-he first line in the paragraph， further indented
relative to the label.／／这将是新段落的第一行，相对标记有更多的缩进。
The blank line just above this is treated almost exactly like a
paragraph break （actually， like the troff-level request .sp l）．／／知上的空行几
乎总是当作段落的结束（实际上，像troff层次的.sp 1请求）。
．SS A subsection
This  is  subsection text，／／这是子段文本，标题为“A subsection"
在历史上其它五六个rroff宏指令库中，ms （7）和mm （7）是仍在使用的两个。BSD
Unix含有自身精心制作的扩展宏指令集，mdoc （7）。它们在风格上与man宏集相似，
但更精致，并且倾向于生成排版输出。
www.pdf365.com
424
第1 8章文档：向网络世界阐释代码
    troff（1）是一个叫做nroff（1）的小变种，它为诸如行式打印机和字符元终端等只支持
定宽字体的设备生成输出。在终端窗口浏览的Unix手册页正是nroff程序提供的。
    Documenter's Workbench的工具被设计来完成技术文档工作，它在这方面做得相当
漂亮，这就是为什么尽管三十年间计算机能力提高了千倍，而它一直还被人们使用的原
因。这些工具在图像打印机上生成可靠质量的排版文本，也可以在屏幕上显示虽不完美
但可忍受的格式手册页。
    在好几个领域中，这些工具也做得很糟糕。可供选择的主要字体是有限的。图像处
理得不好。在页面里很难精确地控制文本、图像或图表的位置。多语言文档的支持也不
存在。还有不少其它问题，有些由来已久但不太重要，有些绝对是为了特殊目的而仓促
写就的。但大多数严重的问题都是因为标记仅仅处于表示层，所以不加修改的troff源文
件很难生成效果良好的网页。
    无论如何，在编写本书时，manpage仍旧是唯～虽重要的Unix文档形式。
18.3.2  TEX
    TEX（发音为/teH/，浊音h就像口含着水发音一样）是个威力强大的排版程序，如
同Emacs编辑器一祥，最初也来自Unix文化之外，但现在却在Unix文化中落地生根。
它是由著名的计算机科学家Donald Knuth在1970年代晚期发明的，那时的他腻烦了印
刷排版的——特别是数学方面的——排版质量。
    TEX，同troffll）一样，是以标记为中心的系统。TEX的请求语言比troff更具威力：
就其它而言，在处理图像，准确的内容页面定位，以及国际化方面都做得较好。TEX特
别擅长处理数学方面的排版，基本的字距调整，线填充以及连字符等问题也做得非常优
秀，难以超越。TEX已经成为了众多数学刊物的排板标准。现在实际上已作为开源软件，
由美国数学学会（ American Mathematical Society）维护。它也常被用于科学论文。
    同troffll）相似，人们通常也不需要手工编写大量原始的TEX宏；而是使用宏命令包
以及各式各样的辅助程序。一个特别的宏命令包，LATEX，几乎无所不能，而且大多数
人所谓在使用TEX创作时实际上几乎总是指用LATEX编写。与troff的宏命令包一样，
许多请求都是半结构性的。
www.pdf365.com
18.3各种Unix文档格式
425
    TEX -个通常用户不可见的重要用法就是，其它文档处理工具宁愿生成LATEX来
转换成PostScript，而不是尝试自己生成PostScript，因为那样做更困难。我们在第14章
作为shell编程而讨论的xmlto（1）前端使用的就是这个策略；我们稍后要讨论的
XML-DocBook工具链也如出一辙。
    TEX比trofj（1）有着更广的应用范围，而且在很多地方有更好的设计。在愈发倾向以
网络为中心的世界里；TEX存在同troff -样的基础性问题；其标记更接近表示层，而要
从TEX源文件中自动生成网页很困难，很难不出错。
    TEX从未被Unix的系统文档使用，也很少使用在应用程序的文档中；对于这些任
务，troff就足够了。但是一些源自Unix社区之外的学术界已经引入了TEX作为文档的
主要格式，例如Python语言就是个典型的例子。如上所述，它也大量地使用在数学和科
学论文中，而且还会在那个小环境中占据好几年的统治地位。
18.3.3  Texinfo
    Tcxinfo是由自由软件基金发明的文档标记，其目的是为了管理GUN项目文档——
包括诸如Emacs和GUN编译器集之类基本工具昀文档。
    Texinfo是第～个为既支持排版纸面输出又支持可供浏览的超文本输出而设计的标
记系统。尽管那种超文本格式并不是HTML，而是一种更原始的类型，叫做“info，，，
它最初是设计在Emacs中浏览的。在打印方面，Texinfo先转换成TEX宏然后再转换为
PostScript。
    Texinfo工具现在可以生成HTML。但并不能很好地完整地完成这项工作，而因为许
多Texinfo的标记都是处于表现级别，真有可能永远无法达成目标。在2003年年中，自
由软件基金正在开发从Texinfo到DocBook的启发式转换器。在一段时间里，Texinfo将
可能继续作为一个有用的格式而存在。
18.3.4  POD
    Plain Old Documentation是Perl支持者使用的标记系统。它生成手册页，具备所有表
示层标记的相似问题，包括不能生成良好HTML的顽疾。
UNIX编程艺术
  www.pdf365.com
426
第1 8章文档：向网络世界阐释代码
18.3.5  HTML
    自从万维网在九十年代早期进入主流社会以来，一小部分但比例越来越高的Unix项
目直接使用HTML来编写文档。这种方式的问题是难以从HTML中生成高质量的排版输
出。也存在特殊的索引问题：需要生成索引的信息在HTML中并不存在。
18.3.6  DocBook
    DocBook是为大规模、复杂技术文档而设计的SGML和XML文档类型定义。在Unix
社区中使用的标记格式中这是唯一的纯粹结构性的标记语言。在第14章讨论的xmlto（l）
工具，支持转换到HTML、XHTML、PostScript、PDF、Windows帮助以及其它几种次重
要的格式。
    几个主要的开源项目（包括Linux文档项目、FreeBSD、Apache、Samba、GNOME
和KDE）已经使用DocBook作为首要格式了。本书也是用XML-DocBook编写的。
DocBook是个大话题；我们将在总结Unix文档当前状态的问题之后再回来讨论。
18.4  当前的混乱和可能的出路
    Unix文档管理，目前，是一团乱麻。
    在现代的Unix系统中，文档的首要文件形式散布在man、ms、mm、TEX、Texinfo，
POD、HTML和DocBook之间。没有统一的方法来浏览所有的描绘版本。它们不能通过
网络访问，也不能交叉索引。
    Unix社区的许多人已经意识到这是个问题。在本书写作时，大多数朝着解决这个问
题方向的努力都来自于开源开发者，比起那些专业Unix的开发者来说，他们更积极地关
心是否能够赢得非技术终端用户的接受。自从2000年来，实践的方向转向使用
XML-DocBook来作为文档的交换格式。
    目标虽然可望，但需要许多的努力才可及，那就是在每个Unix系统上都装上软件作
为系统范围内的文档登记库。当系统管理员安装某个文档软件包时，需要有个步骤，将
该软件包的XML-DocBook文档注册到登记库中去，并被转换成一个通用的HTML文档
树，并且交叉链接到已经存在的文档上。
www.pdf365.com
18.5  DocBook
427
    文档登记库软件的早期版本已经可以运行。但从其它格式到XML-DocBook的转换
是个巨大而繁杂的步骤，当然转换工具将很快就位。其它的行政和技术问题有待解决，
但这是可以解决的。而在2003年年中，旧格式是否必须被抛弃，并没有一个全社区的一
致意见，其实那似乎是最有可能的解决方式。
    相应地，我们接下来将详细讨论DocBook及其工具链。可以把它当作Unix下的XML
介绍，当作一个对实践的实用指导以及一个重要的实例分析来阅读。同时，也是在Unix
社区背景下，不同项目组开发者之间，如何围绕共享的标准进行合作的上佳实例。
18.5  DocBook
    许多重要的开源项目都趋于使用DocBook作为文档的标准格式。基于XML标记的
提倡者似乎已经赢得了理论上的胜利，支持结构层标记，反对表示层标记，并日．一条高
效的XML-DocBook工具链也有了开源实现。
    然而在DocBook以及支持它的程序中依然被很多问题缠身。其支持者满口甚至被计
算机科学标准禁止的暗语，弄出许多缩写词，而都跟编写标记以及从中生成HTML或
PostScript所需要做的事并没有明显的关系。XML标准和技术文章声名狼藉她晦涩不清。
在余下的部分，我们将试图驱散笼罩在暗语行话上的这层迷雾。
．1 Q只1 tT赴址米并II，{，W
 I o.J．I）0，IIj犬刍芭人匕）0
    （注：为了叙述上的简便，这部分叙述有些偏颇，主要是省略了大部分的历史。在
下一个部分会侧回来完整地讨论。）
    DocBook是个结构级标记语言。特别地，是XML的一种方言。一份DocBook文档
其实也是XML文档，使用了XML标签作为结构标记。
    对于一个文档格式器，如果需要将样式单应用到文档，并让它美观大方，就必须知
道文档的整个结构。例如，为了能够正确地格式化章节标题，就需要知道书稿通常包含
哪些前言、章节和附录。为了让格式器知道这些东西，就需要指定一个文档类型定义或
DTDo DTD告诉文档格式器文档结构中有哪些元素，以什么样的次序出现。
UNIX编曜艺术
  www.pdf365.com
428
第1 8章文档：向网络世界阐释代码
    DocBook被称作XML方言，这句话的含义是，DocBook实际上是个DTD--个
相当庞大的DTD，大概有400个左右的标签。1
    隐藏在DocBook后的一类程序叫做验证解析器。如果格式化一个DocBook文档，第
一步就是将其传递给一个验证解析器（DocBook格式器的前端）。这个程序检查文档是
否符合DocBook DTD以确保没有违反任何DTD的结构规则（否则，格式器的后端，应
用样式单的部分，会变得无所适从）。
    验证解析器要么抛出错误并给出文档哪处结构违反了规则，要么将文档转变成XML
元素和文本流，并由解析器后端将样式单的信息整合在一起产生格式化后的输出。
    图18.1揭示了整个过程。
格式器
图18.1  结构化文档处理过程
    图中虚线框内的部分就是格式化软件或工具链。除了明显可见的输入以外（待格式
化的文档原件），请牢记：格式器还需要两个隐含的输入（DTD和样式单），这样才能
理解随后的过程。
18.5.2  其它DTD
    先扯远一点，说说其它的DTD，这样可能有助于澄清上一节中哪些部分是DocBook
独有的，哪些部分是所有结构性标记语言‘所通用的。
1用XML的话来说，我们斫谓的“方言”其实应该叫做“应用”；我们避免这种用法，是因为跟这
个词另一个更常用的意思有些混淆。
www.pdf365.com
18.5  DocBook
429
    TEkhttp：／／www. tei-c．org／>（Text Encoding Initiative）是个大型精细的DTD，
主要使用在学术界书稿文本的计算机电子稿件。TEI基于Unix的工具链，使用了许多类
似于DocBook中的工具，但是样式单（理所当然）和DTD截然不同。
    XHTML，最新版的HTML，也是由DTD描述的一个XML应用，阐明了XHTML
和DocBook标记之间的家族相似性。XHTML工具链包含可以将HTML格式化成纯ASCII
文本的网页浏览器，也整合了许多专用的HTML打印功能程序。
    许多其它的XML DTD在维护着，它们是用来在诸如信息生物和银行等领域进行结
构化信息交换的。可以参阅<http：／/www．xml．com/pub/rg/DTD_Repositories>
的列表，以对这些有个概念。
18.5.3  DocBook工具链
    通常要从DocBook源文件生成XHTML，需要使用xmlto（l）前端。命令看起来像这
样：
    本例将把具有三个主体部分的XML-DocBook文档foo.xml转换成目录页和内容页两
部分。生成一个长页面只需：
最后，可以这样生成PostScript卧各打印：
bash$  xmlto ps  foo.xml           #  To  make  Pos七Script  #生成 PostScript
bash$ Is *.ps
foo.ps
    将文档转换成HTML或者PostScript，需要一个引擎，将DocBook DTD和针对文档
的恰当样式单组合起来，应用到你的文档上。图18.2说明了开源工具是如何完成协作过
程的。
    有三个程序可以解析文档并应用样式单进行转换。最常用的是xsltproc，同Red Hat
Linux -起发布的解析器。剩下的两个是Java程序，．Saxon和Xalan。
UNIX编腥艺：术
    www.pdf365.com
           ><
            r0
                         . rl
           rJ
               o
                H
               o
       ' r0
i-l    l
 x    七
 .     J:
 o     .
f       O
七  r-l  r
><  七
      J::  i-l
 o  .  m
 {11  a  r
b n  rlj
r-l
 ><
 o
 o
rn
-1t:
 o
  I
N-I
U  i+
><  t
 o  .
七  +:
m  cn ~-i
><  :-i  m
$$ J:
rn  {n  o
 a  a  0
n b  q-l
430
第1 8章文档：向网络世界阐释代码
┏━━━━┓
┃DocBook ┃
┗━━━━┛
    图18.2  如今的XML-DocBook工具链
    从DocBook生成高质量的XHTML相对容易；事实上XHTML只不过是另外一种
XML DTD，这一点当然有益于转换。对文档施用相当简单的样式单就可以完成HTML
转换，这也是整个过程的结束。按照这种方式，RTF的生成也很简单，而在XHTML或
RTF基础上，必要时生成近似的纯ASCII文本也就是轻而易举的了。
    麻烦的是打印。生成高质量的打印输出一一实际上是Adobe的PDF（Portable
 Document Format，可移植文档格式）——是困难的。需要从算法上重现人工排版中区分
内容和表现精准判断。
    因此，首先，样式单将DcoBook的结构性标记转换成另一种XML方言-FO
（Formatting Objects，带格式对象）。FO标记是完全表示层的；可以认为等同于troff的XML
功能。之后，FO标记会被转换成PostScript，然后包装成PDF。
    在同Red Hat Linux -起发布的工具链中，这项工作由TEX的一个叫做Pas siveTeX
的宏命令包完成。它将xsltproc生成的格式化对象转换成Donald Knuth昀TEX语言。TEX
的输出是熟知的DVI（设备独立）格式，于是便可制成PDF。
    从XML到TEX宏，再到DVI，最后到PDF，这工具链简直就像老牛拉的杂牌老破
车，如果这么认为，确不为过。嘎吱嘎吱，呼哧呼哧，一无是处。字体是个严重的问题，
因为XML、TEX和PDF字体的工作模型都不尽相同：同样，国际化和本地化也是一场
恶梦。按这种方式走到头，真是自寻烦恼。
    FOP（FO-to-PostScript）会优雅得多，这是由Apache项目开发的从FO直接到
PostScript的转换器。在FOP中，国际化问题，如果不算解决的话，至少很好地限制住
了；XML工具总是通过FOP处理Unicode。从Unicode字形到Postscipt字体的映射也绝
www.pdf365.com
18.5  DocBook
431
对是个问题。最麻烦的是这种方法尚无法工作：到2003年中，FOP还处于未完成的alpha
状态——可用，但粗糙不堪且功能不足。
    图18.3展示了FOP工具链的模样
    图18.3  XML-DocBook未来的FOP工具链
    也存在同FOP的竞争者。另一个叫做xmlroff2项目的目标同FOP -样，但以c++
完成（因此速度较Java快也无需依赖Java环境）。在2003年年中，xmlroff也处于未完
成的alpha状态。
18.5.4移植工具
    DocBook第二严重的问题是，需要大量努力将旧风格的表示层标记转换为DocBook
标记。人们通常可以自动地将文本的表示解析成逻辑结构，因为（例如）可以从上下文
中判断一个斜体部分是“强调”还是“外来词”或别的什么。
    无论如何，将文本转换成DocBook的过程中，这种区别需要明确化。有时它们出现
在旧的标记中；有时又不出现，而缺失的结构性信息必须由聪明的算法推演或是人为补
足。
UNIX编翟艺术
  www.pdf365.com
432
第1 8章文档：向网络世界阐释代码
    下面总结了从其它格式到DocBook的转换工具。所有这些工具都不是彻底完美的；
在转换后需要检查，甚至需要人工编辑。
GNU Texinfo
    自由软件基金尝试将DocBook作为交换格式来支持。Texlnfo具有足够的结构标记
来进行良好的自动转换（人T编辑仍然需要，但不会太多），4.x版本的makeinfo有个功
能开关-docbook，可以生成DocBook。更多的信息参见makeinfo项目主页
<http:／/www. gnu. org/directory/texinfo. html>a
POD
    POD::DocBook<ht tp:／/www. cpan. org/mo dule s/by -module/Pod/>将Plain
Old Documentation标记转换为DocBook。它宣称除了L<>斜体标签，可以将所有的POD
标签都转换成DocBook。手册又说“嵌套的=over/=back列表在DocBook中不支持”，
但注意这个模块是经过大量测试的。
LATEX
    一／卜日Lf做TeX4ht<http：／／www - irz -muenchen．de/services/ software/
sonstiges/tex4ht/ mn，html>的项目，按照PassiveTEX作者的说法，可以从LATEX
生成DocBook。
man pages和其它基于troff的标记方式
    这通常被认为是最大最令人厌烦的转换问题。的确，基本troff（1）标记的表示层太
低，自动完成转换的工具简直就是吃力不讨好。然而如果我们考虑从使用man（7）之类宏
命令包编写的文档源进行转换，前景就光明了许多。这些宏具备足够的结构性特征以利
于自动转换。
    我自己编写了～个我称之为doclifer的工具来做troff到DocBook的转换，因为我找不
到什么软件的转换结果可以容忍。<http：／/www- catb. org／—esr／doclifter/>。支
持从，nan（7）、mdoc（7）、ms（7）、以及me（7）宏转换到SGML或者XML DocBook。详情请参
考项目文档。
18.5.5编辑工具
在2003年年中还缺乏的就是～款优秀的开源SGML/XML结构编辑器。
www.pdf365.com
18.5  DocBook
433
    LyX<http: //www．lyx．org/>是个GUJ的字处理器，使用LATEX进行打印并支
持LATEX标记的结构化编辑。有可以生成DocBook的LATEX包，以及描述在LyX界
面中如何撰写SGML和XML的how-to文档<http：//bgu．chez．tiscali．fr/doc/
db4lyx/>。
    GNU TeXMacs  项  目  <http://www.math.u-psud.fr/—anh/TeXmacs/
TeXmac g．html>，其目标是生成一个擅长于技术及数学材料的编辑器，包括公式的显
示。1.0版已经在2002年四月发布。开发者计划在未来加入XML支持，但目前还没有。
    许多人仍然使用Vl或者emacs来手工编写DocBook标签。
18.5.6相关标准和实践
    慢慢地可以凑起许多工具来编辑和格式化DocBook标记。但是DocBook本身只是个
手段，而不是最终目的。除了DocBook本身之外，我们需要其它标准来达成“可搜索文
档数据库”这个目标。这存在两大问题：文档编目和元数据。
    ScroIIKeeper  <ht tp：//scrollkeeper．sourceforge。net／>直接瞄准这种需
求。它提供一套简单的脚本钩子（ script hook），可以使用在软件包的安装和卸载过程中，
以登记和注销它们的文档。
    ScroIIKeeper  使用开放元数据格式  （Open  Metadata  Format）
<http：／/www. ibiblio．org/osrt/omf/>。这是为开源文档制作索引的标准，类似
于图书馆的卡片式目录系统。该创意支持丰富的搜索功能，可通过使用卡片式目录元数
据或是源文本本身。
18.5.7  SGML
    先前，我们有意地忽略了DocBook的历史。在XML之前，还有个标准通用标记语
言（SGML， Standard Generalized Markup Language）。
    直到2002年年中，DocBook的讨论必然深入到SGML中，包括SGML和XML的
不同，包括SGML DocBook工具链的具体描述。现在简单了：存在XML DocBook的开
源工具链，它甚至比SGML工具链工作得还好，也更容易使用。
18.5.8  XML-DocBook参考书籍
学习DocBook比较困难，与之相关的站点总是堆砌长长的W3C标准列表，大量
www.pdf365.com
434
第18章文档：向网络世界阐释代码
SGML理论知识以及一大堆复杂的抽象术语，这往往会吓退初学者。XML in a
NutsheIl（XML技术手册》  [Harold-Means]是本详细的优秀入门书。
    Norman Walsh的DocBook: The Definitive Guide （DocBook权威指南》的印刷版本在
<http：／/www，oreilly．com/caLalog/docbook/>，  电子版本在<http：／/www.
docbook．org/tdg/   en/html/docbook．html>，但它作为入门指导对读者而言简
直就是灾难。我们建议阅读：
    Writing Documents Using DocBook（使用DocBook编写文档）<http：／/xml .web．
cern．ch/XML/goossens/dbatcern/》。这是本优秀的入门指导书。
    同样优秀的DocBook常见问题解答<http：／/www．dpawson．co．uk/docbook/>中，
有许多关于  HTML  输出风格化的资料。  还有一个  DocBook wiki
<ht tp: //docbook. org/wiki/moin. cgi>。
    晟后，The XML Cover Pages<ht t-p：／／xml．coverpages．org/>，将会带你进入
XML标准的世界，如果有此愿望，不妨去看看。
18.6编写Unix文档的最佳实践
    本章早些时候关于阅读Unix文档的建议正好可以反过来。在Unix文化环境中为他
人编写文档时，别自降身价。愚弄读者，就是承认自己也是傻瓜。愚弄读者的文档同真
正易于理解的文档大相径庭；前者偷懒而忽略了重要的东西，后者则要求深思熟虑以及
不留情面的修订。
    数量多不会被认为是质量高。尤其是，决不要因为害怕别人看不懂而省略功能细节，
决不要为了面子而不对存在的问题提出警示。不愿坦露问题才会损害信誉和用户，坦白
了的问题则不会。
    信息密度要适中。过低过高都不好。少用屏幕截图；它们除了界面风格和观感之外
往往很少带有其它信息。它们从来无法代替清晰的文字描述。
    如果项目规模比较大，应该发布三种不同的文档：手册页作为参考资料，教程手册
和常见问题解答列表。应该有个网站，作为发布中心（参考第19章关于交流的指导）。
    没人喜欢庞大的手册；在其中浏览比较困难；如果确有此虞，考虑编写参考手册，
手册页提供快速的摘要，并指向参考手册，以殁程序如何调用的细节。
www.pdf365.com
18.6编写Unix文档的最佳实践
435
    在源码中，需要包含第19章关于开源发布惯例部分阐述的标准维护文件，例如
README。即使是专有代码，也请遵守Unix的约定俗成，具备Unix背景的未来维护者
将会很快上手。
    手册页应该为传统的UfliX用户以传统风格的命令引用形式呈现。考虑非技术用户，
入门手册应该多用全称，少用缩写。而FAQ应该随着软件支持群体对软件常用问题及如
何回答的深入了解而不断改进。
    2003年年中，最前沿的实践中，还有几个重要的习惯应该养成：
    1．使用XML-DocBook维护主文档。即使手册页是DocBook RefEntry文档。关于
    如何编写用户期望看到的手册页来解释内容和组织，这里有个非常有用的
    HOWTO<http:／/www. linuxdoc. org/HOWTO/mini/Man- Page. htrn]>。
    2．发布XML主文档。同时，需要发布troff源码，对主文档运行xmlto man就可
    以得到它，以备用户的系统上没有装载xmlto（1）。软件的安装程序应该以常规方式
    进行，如果有人需要编写或者编辑文档，请引导他们使用XML文件。
    3．让项目的安装包支持ScroIIKeeper，
    4．从主文档生成XHTML（使用命令xmlto xhtml）并放到项目的网页上以供访问。
    无论是否使用XML-DocBook作为主格式，都应该找到某个方法将文档转换为
HTML。无论软件是开源的还是专用的，用户越来越愿意通过网络找到它。将文档放在
网上，其直接效应就是能够让知道软件的潜在用户和消费者更容易阅读，更容易了解软
件。而其间接效应就是软件被网络搜索找到的机会更多。
UNIX编-程艺术
    www.pdf365.com
www.pdf365.com
1 9
开放源码：在Unix新社区
中编程
Open Source: Programming in the
New Unix Community
Software is like sex-it's better when it'sfree.
    软件和性一样——越自由越好。
    -Linus Torvalds
    在第2章，作为总结，我们评述了Unix历史中最大规模的模式；当Unix实践最接
近开放源码时，就欣欣向荣，反之则停滞不前。然后在第16章，我们又断言开源开发工
具往往具备高等级质量。至于本章，我们将以简要说明开源开发怎样工作且为何这样工
作作为开始。实际上，其大多数行为都只不过是Unix传统长期实践的强化而已。
    随后我们将从抽象领域下到具体，转而描述一些Unix从开源社区借鉴而来的最重要
的大众习惯的——特别是由社区发展的、关于如何成为良好源码发布的指导原则。其它
现代操作系统的开发者同样可以沿袭大多数这些习惯并从中受益。
    我们将假设你用开放源码进行开发而描述这些习惯；当然，即使是编写专有软件，
多数习惯仍不失价值。基于开放源码的设想在历史上也是有用的，许多习惯在专有Unix
中都能找到痕迹，像无处不在的工具例如patch （1）、Emacs和GCC筹等都是。
UNIX编程艺术
    www.pdf365.com
438
第1 9章开放源码：在Unix新社区中编程
19.1  Uni×和开放源码
    开源开发利用了这样的事实，甄别和修改bug的任务适合分解成多个并行的子任务
——这和实现某个特殊算法不一样。围绕某个原型设计进行邻域开发，也很适合并行处
理。所以，随着正确技术和社会机制的到位，通过网络松散连接的庞大开发团队可以把
工作做到出色得让你吃惊。
    是的，这会让你吃惊，如果还抱守那种把秘密开发和专有控制视为必然的话。从《人
月神话》[Brooks]直到Linux的兴起，软件工程的正统观念都是关于如何在重量级组织，
例如企业和政府中，构建小型而管理紧密的团队。而实践却是紧密管理的大型团队。
    在AT&T拆分以前的早期Unix社区的运作实际就是开源的典型例子。尽管拆分前
的Unix代码在技术上和法律上是专有的，但在用户和开发者社区中，却被视作共享的。
那些人们的自愿努力，受到解决问题强烈愿望的推动而自觉迸发出来。而在这些努力之
中，优秀者层出不穷。的确，开源开发的方法和技术在Unix社区作为一种无意识的群众
实践而发展，其实在1990后期被分析和标记之前，就已经持续了四分之～个世纪。（参
考《The Cathedral and the Bazaar<大教堂和集市）》[Raymond01]和《Understanding Open
Source Software Development（理解开源软件开发）》[Feller-Fitzgerald]）。
    回顾过去，令人惊讶的是我们对自己的行为意味着什么是多么茫然无知。有些人的
理解却很透彻；Richard Garbiel在文章“差即是好”中表达的思想是其中最著名的，在
Brooks【Brooks] （1975）也可以找到预示，甚至远到Vyssotsky和Corbato在Multics的设
计中的思考（1965）。在1990年代中期被Linux唤醒之前，多达20年的软件开发观察中，
我也没有意识到这～点。这样的经历应该让任何有见解而谦逊的人知道，是不是还有其
它什么重要的统一理念依旧暗含在我们的行为中，潜藏在我们集体的眼皮底下未被发掘，
不是因为复杂而是因为太简单。
    开源开发的规则很简单：
    1．源码公开。别隐藏秘密。公开代码以及产生代码的过程。鼓励第三方的同行复审。
确保其他人能够自由地修改和重新发布代码。尽可能地发展合作开发者。
www.pdf365.com
19.1  Unix和开放源码
439
    2．尽早发布，经常发布。快速的发布节奏意味着反馈迅速而有效。每次递进发布间
隔越小，回应真实世界反馈的修改过程就越容易。
    确保第一次的发布能够编译和运行，所有允诺的功能都可运作。通常，一个开源程
序的启动版本通过至少完成最终目标的某个部分来展示项目的前景，这充分表明发起人
确实可以继续这个项目。例如，字处理器的启动版本应该支持文本的输入以及文本在屏
幕上的显示。
    不能编译或是运行的第一次启动发布会毁掉整个项目（例如大家都知道，这差点就
在Mozilla浏览器身上发生）。不能编译的发布表明项目开发者不能够完成项目，同样地，
不能运行的程序也难以吸引其他开发者的参与，因为任何改动对程序是好是坏都不确定。
    3．给贡献以表扬。如果不能够给合作开发者以物质奖励，就给予精神表扬。即使可
以给予物质的奖励，也不要忘记人们往往是为展示才华而不是为钱努力工作。
    规则2的必然推论就是，单一发布不应该视为重大的事件，无需伴随太多的
  附带许诺和准备。将发布过程无情地精简非常重要，这样就不再为经常发布而感
  到痛苦。在发布准备期，其余工作都必须停止的安排是个可怕的错误（值得一提
  的是，如果使用CVS或者类似酌版本控制，处于准备期的发布应该同主干开发线
  分开，这样就不至于阻塞主线开发过程。）总的来说，不要把发布当作什么特别
  的大事；而应该当作是例行公事。
-Henry Spencer
    牢记：频繁发布的原因是为了缩短和加速同用户和开发者间的反馈循环。因此，精
工细作，等一切完美了才发布的想法是要不得的。不要许太多愿。一步一步地来，承认
和公布现有的bug，并有信心随着时间的推移，一定会达到完美。发布点多一点儿不是
坏事，不必为版本号的增加而烦恼。
    开源开发利用散布在互联网上，而且主要通过email和网络文档交流的大型程序员
团队。典型地，任何项目的多数贡献者都是为了提高软件对自身效用的回报以及声誉激
UN1×编程艺术
  www.pdf365.com
440
第1 9章开放源码：在Unix新社区中编程
励而自愿工作。一般由一个核心开发者或核心开发组来指导项目；其他贡献者可以零星
地加入或离去。为了鼓励志愿者，重要的是避免在他们和核心团队之间产生社会壁垒。
因此需要最小化核心团队的特权，努力模糊界限。
    开源项目遵循Unix传统尽可能自动化的建议。使用patch（l）工具分发递进更改。许
多项目（以及所有大型的）都拥有使用诸如CVS（回顾第15章的讨论）等版本控制系
统的网络访问代码库。Bug和补丁自动追踪系统的使用也很普遍。
    1997年，在黑客文化之外几乎没人能明白，这样管理大型项目并同样获得高质量的
开发结果是完全有可能的。在2003年，这已不再是新闻；诸如Linux、Apache和Mozilla
项目都已经获得了巨大的成功和非常高的公共上镜率。
    抛弃秘密开发的习惯，转而支持过程的透明化和同行复审是炼金术成为化学学科最
关键的一步。同样你也开始发现，开源开发标志着软件开发终于长成为一门学科。
19.2  与开源开发者协同工作的最佳实践
    开源社区最佳开发实践实际上便是对分布式开发自然而然的适应；在本章中可以了
解到许多行为准则，用来同其他开发者进行良好沟通。有些Unix绚定是偶然的（例如文
件的标准命名表达关于发布源的元信息），这常常可以上溯到1980年代早期的Usenet，
或者GNU项目的约定和标准。
19.2.1  良好的修补实践
    多数人在发布自己的项目之前，都是从修补他人的软件而开始接触开源软件开发的。
假定已经为某个基准源代码更改了一些代码，现在需要设身处地去想想，别人该怎样判
断是否可以采纳这个补丁呢？
    代码的质量很难判断，所以开发者往往通过提交的质量来评估补丁，在提交者的风
格和交流行为中寻找线索——该提交者是否设身处地为他们着想，是否知道评估和合并
新的补丁究竟该怎样。
    这是鉴定代码质量相当可靠的方法。在许多年处理来自数以百计陌生人补丁的过程
中，我很少看到一个考虑周全、尊重我的时间的补丁会是技术上的赝品。反过来看，经
www.pdf365.com
19.2与开源开发者协同工作的最佳实践
441
验告诉我们，看起来马马虎虎或是打包很疏懒的补丁往往实际上就是赝品。
    这里有一些怎样让补丁能够被接受的技巧：
19.2.1.1  发送补丁而不是完整档案包或文件
    如果改动包含了一个源代码中并不存在的新文件，当然就必须发送整个新文件。但
如果修改的只是已有文件，无须发送整个文件。只须发送diff就行：运行difi（1）命令，
将基准发布版本与修改版本进行比较，并提交输出。
    dif1）命令及其对偶命令patch（l），是开源开发最基本的工具。差异文件要比整个文件
好，因为自从获得旧拷贝之后，接受补丁的开发者可能已经更改了主干版本。呈送开发
者以一个diff文件，节省了别人将改动从其中分离出来的精力；也表示了对别人时间的
尊重。
19.2.1.2发送针对当前版本代码的补丁
    如果发送给维护者的补丁是针对好几个版本以前的，并期望维护者会判断补丁中哪
些改动已经完成，哪些是新颖独创，这样做既不能达到预期目标也有些粗鲁无礼。
    追踪源码状态以及把主线代码库需要做什么的最小化补丁提交给维护者，是补丁提
交者必须承担的责任。这也意味着应该发送针对当前版本的补丁。
19.2.1.3不要包含可生成文佯的补丁
    在发送补丁之前需通览一遍，对于一旦维护者采用补丁、重新make后就能重新生成
的文件，其补丁段应予删除。犯错的经典例子就是Bison或Flex产生的C文件。
    当今最常见的错误就是，发送的diff文件只包含有巨大的更改段来表明你的
configure脚本和维护者的差异。其实这个文件可以由autoconf产生。
    这是有欠考虑的。它把接收者置于麻烦之中，需要把补丁的真实内容从一大堆乌七
八糟的干扰里分离出来。当然它只是个次要的错误，同我们将要进一步探讨的内容相比，
并非那般严重——但也是不好的。
UNl×编l茬艺术
    www.pdf365.com
442
第1 9章开放源码：在Unix新社区中编程
19.2.1.4不要发送与只是优化RCS或者SCCS $-symbols的补丁段
    有些人喜欢在源码文件中放置一些特殊符号，在登入版本系统时会自动扩展：例如
RCS和CVS使用的$id$构造。
    如果使用自己本地的版本控制系统，更改可能会改变这些符号。这并非真正有害，
因为当接收者在采用补丁而登回代码时，特殊符号可以按照维护者版本控制系统的状态
设置重新扩展。但这些特殊的补丁段是干扰物，会让人分心。不发送它们更能体现考虑
的周全。
    这是另外一个次要的错误。如果别的大事没弄错，这是可以原谅的。但最好避免。
19.2.1.5使用-c或-u格式而不是缺省的（-e）格式
    difj（1）默认的（-e）格式非常脆弱。它不包含任何上下文，因此在得到用来修改的
拷贝之后，如果基准代码中插入或者删除了任何一行，patch工具无法得到正确结果。
    拿到-e格式的diff文件令人恼火，表明发送者如果不是位新手或马大哈，就是个菜
鸟。大多数这种补丁想都不用想便可抛弃掉。
19.2.1.6在补丁中包含文档
    这非常重要。如果补丁增加了用户可见的部分或者改变了软件的功能特征，请在补
丁中包含相应手册页和其宅文档文件。不要期望补丁接收者会乐于为此代码编写文档，
或是在代码中隐藏没有文档说明的功能特征。
    针对改动做好文档体现了一些好习惯。首先，已经为试图说服的维护者设身处地考
虑过了。其次，表明对改动后的效果了如指掌，可以向其余不能查看代码的人解释清楚。
第三，表示了对软件最终用户的关心。
    良好的文档常常是区分“可靠的贡献”和“匆忙而邋遢的改动”最显著的特征。如
果花费了足够的时间和心思来做好文档，最后就会发现让多数开发者接受补丁的道路已
经走完了85%。
www.pdf365.com
1 912与开源开发者协同工作的最佳实践
443
19.2.1.7在补丁中包含解释
    补丁应该包含一份说明，来解释为什么补丁是必须和有用的。这个说明并不直接给
软件用户而是给接受补丁的维护者。
    说明可以很短——实际上，我见过的一些最有效的说明仅仅是“请参看补丁中的文
档更新”。但必须表明正确的态度。
    正确的态度非常有帮助，是对维护者时间的尊重，也是从容而谦逊的自信。表现出
对所修补的代码充分理解，展示对维护者问题的认同，这些都是有益的。对于觉察到的
应用补丁风险预先说明同样大有裨益。下面是一些经验丰富的开发者所发送的各种解释
示例：
    “我已经发现代码中有两个问题，X和Y。我改掉了X，但是我并没有试图去解决
Y问题，因为我对牵涉到的代码还不理解。’’
    “修改了一个当输入过长时的coredump。我在修改的时候，试图寻找另外的溢出错
误。我发现有一个可能在blarg.c中，在第666行附近。你能确定在每个传输中发送端产
生的字节不会多于80?”
    “你是否已经考虑使用  Foonly  算法来解决这个问题？在
<ht tp：／/www．example．com/～j smith/f oonly．htm]>处有个好的实现。”
    “补丁解决了当前的问韪，但我意识到内存分配被不恰当地复杂化了。在我这里可
以工作，但在发布前你应该进行重负荷测试。”
    “这可能太过于花哨，但无论如何我还是提交了。也许你会知道一个实现这种功能
的更简洁的方法。”
19.2.1，8在代码中包含有用的注释
    在合并补丁之前维护者希望能够对更改有准确的理解确。当然，这并不是一成不变
的法则；如果确实同维护者存在很好的合作工作记录，他也许在半自动化地检查前就只
会随意地瞄上～眼。但是任何帮助维护者理解代码和降低不确定性的作为都会提高补丁
被接受的几率。
    代码中良好的注释可以帮助维护者理解代码。糟糕的则不然。
    以下是个糟糕的注释例子：
／★norman newbie fixed this 13 Aug 2001  ★／
UNIX编程艺-荩
  www.pdf365.com
第1 9章开放源码：在Unix新社区中编程
    这没有任何用处。只是在维护者的代码中间，无端地加入了践踏领土的泥泞靴印。
如果维护者接受了补丁（不太可能），他几乎肯定会抛弃这段注释。如果希望获得声望，
应该在工程的News或History文件中包含一个补丁段。这样维护者更可能接受。
    以下是良好的注释例子：
/*
  k This conditional naeds tObe guarded so七hat crunch_data（） never
  * gets passed a NULL pointer  <norman_newbie@foosite.com>
    这样的注释表明，不仅理解了维护者的代码，也理解了维护者对接受你的改动所需
要的信心。这种注释正好给予维护者对于更改的信心。
19.2.1.9如果补丁被拒绝，别往心里去
    存在许多理由，一个补丁可能会遭到拒绝，这并不存在怀疑和责备的意思。记住多
数软件维护者都处于相当沉重的时间压力之下，并很保守地接受补丁，生怕一不小心项
目代码就会崩溃。有时候重新提交改进后的补丁会有所帮助，有时候不会。大家都不容
易。
19.2.2  良好的项目、档案文件命名实践
    随着诸如ibiblio、SourceForge以及CPAN维扩者工作量的增加，一个不断发展的趋
势就是，项目提交部分或整体会由程序来处理（而不是完全由人来处理）。
    对于项目和档案文件的命名而言，更重要的是需要采用更适合计算机程序可以解析
和理解的规则模式。
19.2.2.1  使用GNU风格的命名法：主干加major.minor.patch的编
    三j
    !了．
    如果档案文件都是类似GNU风格的名称，主干前缀全小写且只包含字母和数字，后
接连字号，后再接版本号、扩展和其它后缀，对大家都有帮助。
具备这些部分的名称，其良好的通用形式顺序如下：
1．项目前缀
2．横杠
www.pdf365.com
19.2  与开源开发者协同工作的最佳实践
445
    3．版本号
    4．点
    5．“src”或”bin”（可选）
    6．点号或横线（更倾向点号）
    7．二进制类型和选项（町选）
    8．归档和压缩扩展名
    这种风格的名称主干可以包含连字号或下划线来分隔音节；横线实际上更常用些。
把相关的项目联合成组，给予一个通用的主干名前缀，并以连字符结束，也是个良好的
实践。
    假设正好有个叫做“foobar”的项目，主版本号为1，次版本号或发布号为2，补丁
级别为3。如果只有一个档案部分（假定为源代码），则文件名称看起来应该像这样：
foobar-1.2.3．tar．gz
源文件档案。
foobar．lsm
    LSM文件（假定提交到ibiblio）
    不要使用如下这样的命名方式：
    foobar123．tar．gz
    这让许多程序看起来像一个叫做“foobar123’’没有版本号的项目档案。
    foobarl.2.3．tar．gz
    这对许多程序而言像是“foobarl”项目版本2.3的档案。
    foobar-vl.2.3．tar．gz
    许多程序误认为这是称作“foobar-vl’’的项目。
    foo_bar-l.2.3．tar．gz
    下划线给人们带来发音、打字和记忆的困难。
    FOOBar-1.2.3。tar．gz
    除非喜欢看起来像出售的熏肠，否则不要这样。这也给人们带来发音、打字和记忆
的困难。
UNIX编程艺术
  www.pdf365.com
第1 9章开放源码：在Unix新社区中编程
    如果必须区分源码和二进制档案，或是区分不同的二进制码，或是表达某种文件名
的编译选项，请紧接在版本号之后加上文件扩展名。也就是，像这样做：
foobar-1.2 . 3 . src .tar _gz
源码。
foobar-1 2 _ 3 bin _ tar _ gz
二进制，类型没有指定。
foobar-l. 2 . 3 .bin. i386 _ tar. gz
f386二进制。
    foobar-l.2.3.bin. i386. static. tar. gz
    i386静态链接二进制。
    foobar-l.2.3.bin.SPARC.tar.gz
    SPARC二进制。
    请不要使用像“foobar-i386-1.2.3.tar.gz”之类的名字，因为程序难以从名字主干中识
别出类型的插入词（如“-i386”）。
    区分主要和次要发布的约定很简单：补丁号为修正错误和次要功能：次版本号为兼
容的新功能，而主版本号为不兼容的更改。
19.2.2.2尊重适当的本地约定
    有些项目和社区，对于命名和版本号有良好的约定，并不需要遵从以上的建议。例
如，Apache模块就像mod_foo -样命名，并配有自身的版本号以及协同工作的Apache
版本。同样地，Perl棋块的版本号可以像浮点数～样命名（例如，可能会发现1.303而不
是1.3.3的版本号），Foo::Bar模块的1.303发行版通常命名为Foo-Bar-I.303.tar.gz。（另
一方面，Perl自身，在1 999下半年转换回使用19.2.2.1中描述的约定。）
    查询和尊重特殊社区和开发者的约定；而对于一般的使用，遵守如上19.2.2.1中的
指导。
www.pdf365.com
19.2与开源开发者协同工作的最佳实践
447
19.2.2.3努力选择唯一且容易键入的名称前缀
    主干前缀应该适用于整个项目文件，并且应该容易读写和记忆。所以，不要使用下
划线。没有极特殊的理由，也不要大写或双大写——这会弄乱人眼自然的浏览顺序，并
且看起来像自作聪明的销售小花招。
    如果两个不同的项目存在相同的主干名称会让人们感到迷惑。因此在第一次发布前
就尝试检查是古存在冲突。两个地方可以完成此项检查任务，一个是ibiblio
<http：／/metalab．unc．edu/pub/Linux>的索引文件，  一个是Freshmeat
<http：／/www．freshmeat．net>的应用程序索引。另一个检查的好地方是
SourceForge<h七tp：／/www．sourceforge．net>;做  1个名称搜索。
19.2.3  良好的开发实践
    这里有些作法，可以让项目有别于不起眼而易于湮没的项目，能吸引众多奉献者，
从而成为成功项目。
19.2.3.1  不要依赖专有代码
    不要依赖专有语言、函数库或者其它代码。即使在最有利的情况下这样做都充满风
险；而在开源社区中，这是彻头彻尾的无礼行为。开源开发者不相信他们无法评审酌源
码。
19.2.3.2  使用GNU自动工具
    配置选择应该留到编译期。开源发布的一个巨大优势就是允许软件包适应编译期发
现的环境。这至关重要，因为这可以让软件包运行在连开发者都从未预见的平台上，并
且允许软件社区的用户定制自己的移植。只有最大规模的开发组才买得起所有硬件，以
及雇用足够的员工来支持种类有限的平台。
    因此：使用GNU自动化工具来处理移植性问题，进行系统配置探测，以及量身定制
makefile文件。今天，人们在编译源码时期望能够键入configure; make; make
install就可以得到一个简洁的编译——并且是正确的。关于这些工具的优秀指南可见
<http://seul.org/docs/autotut/>.
    autoconf和autoheader都是成熟的软件。automake如前所述，在2003年年中仍然
脆弱，到处是bug；可能必须维护自己的Makefile．in。幸运的是，它是自动化工具中
重要性最小的一个。
UNl×编程艺．术
    www.pdf365.com
448
第19章开放源码：在Unix．新社区中编程
    无论使用何种配置方法，编译时软件不应向用户咨询系统的信息。安装软件包的用
户并不一定知道问题的答案，这种方法从一开始就注定是失败的。在编译或安装时软件
必须能够自己决定所需的全部信息。
    但是autoconf不应该认为是对一团乱麻式设计的许可。如果可能，编程应遵循POSIX
标准以及尽可能少地向系统询问配置信息。应尽量保持最少的“ifdef" -或者，最好
根本不要有。
19.2.3.3先测试再发布代码
    良好的测试套件使得团队在发布前能够非常容易地执行回归测试。建立强大而便于
使用的测试框架，以便逐步把测试增加到软件之中，测试套件就不那么专用和错综复杂，
开发者也就无需培训了。
    测试套件的发布也使得，社区用户可以在将贡献发转回制作组之前能够测试他们的
代码片段。
    鼓励开发者在他们的桌面和测试机上使用迥异的平台，这样在日常开发中，代码的
移植性就可以不断得到检验。
    代码随着自己使用的测试套件一起发布，并且测试套件可以由make test来运行，
这是非常好的实践，并且可以增强对自己代码的信心。
19_2.3.4发布前对代码进行健全检查
    “健全检查（sanity check）”的意恩是：
类易犯的错误。使用工具捕捉到的错误越多，
使用可以获得的每一款工具来检查每个人
用户和自己需要对付的就越少。
    如果正用GCC编写C/C++，带-Wall选项测试编译，并且在每个发布之前清除掉所
有的警告信息。使用能够找到的每一款编译器编译代码——不同的编译器常常会发现不
同的问题。特别地，在一个真正的64位机器上编译软件。底层的数据类型在64位机器
上可能有所改变，所以常常会发现新的问题。寻找商业Unix系统并且对软件运行lirlt程
序以进行检查。
    使用查找内存泄漏和运行期错误的软件；Electric Fence和Valgrind就是其中两款可
以开源获得的优秀软件。
    对于  Python珂{目，  PyChecker  <http：／／sourceforge．net／projects／
pychecker>是个很有用的检查工具。它常常能捕捉到许多不平凡的错误。
    如果编写Perl程序，可使用perl -c（或是-T，如果可用的话）检查代码。并虔诚
地使用perl -w以激活警告以及“use strict”来限制不安全的结构和语句。  （进一步的讨
论参考Perl文档。）
www.pdf365.com
19.2  与开源开发者协同工作的最佳实践    449
 19.2.3.5发布前对文档和README进行拼写检查
    对软件的文档、README文件和软件中的错误信息进行拼写检查。马虎的代码，编
译时产生警告信息的代码以及README文件或报错信息里的拼写错误，都会让用户认
为软件加工草率、不负责任。
19.2.3.6推荐的C／C++移植性实践
    如果编写C程序，应完全使用ANSI功能特征。特别应使用函数原型，可以帮助发
现跨模块冲突。1日式风格的K&R编译器早就成为历史了。
    不要用编译器的专门特征，例如GCC的-pipe选项或支持嵌套函数的功能。这会导
致其他人在移植到非Linux、非GCC系统时遇到麻烦。
    需要移植的代码应被隔离在一个单独区域的一组源文件（例如，一个Os子目录）中。
涉及不I司编译器、库以及操作系统接口的移植码应该抽象到该目录的文件中。
    移植层是一个库（或者可能仅仅就是头文件中的一套宏），抽象了程序使用到的某
个操作系统的一些API。移植层使软件更容易被移植到新的平台。开发团队中往往没人
了解移植的目标平台（例如，存在成百上千种不同的嵌入式操作系统，没有人知道它们
之间的重要冲突）。通过创造一个分离的移植层，了觯平台的专家就有可能无需理解任
何移植层之外的事情而进行软件移植。
    移植层也简化了应用程序。软件很少需要全功能的、更为复杂的系统调用，例如
mmap（2）和stat（2），并且配置如此复杂的接口也往往让程序员错漏百出。一个具备抽象接
口的移植层（例如，某个叫做一file_exists的stat（2）调用替代物）使你可以从系统
导入有限的、必需的功能，从而简化了应用程序中的代码。
    基于所需功能而不是平台来编写移植层。尝试为每个支持的平台创建单独的移植层
会导致多重更新的维护梦魇。一个“平台”至少总是基于两方面来选择：编译器和库／操
作系统发布版本。在某些情况下，应该是三方面，就像当Linux商家选择一个独立于操
作系统发布版本的C语言库的时候。M个商家、N个编译器以及O个操作系统发布版本，
平台的数目很快就增大到任何最大开发团队都力所不及的地步。另一方面，通过利用语
UNIX编程艺．术
  www.pdf365.com
450
第1 9章开放源码：在Unix新社区中编程
言和系统标准，例如ANSI和POSIX 1003.1，功能特征集总是相对有限的。
    移植性的选择既可以基于代码行数也可以基于编译文件。在同一个平台上，真正的
实现是选择备选代码中的某几行，或是几个不同的文件中的某一个并没有本质区别。经
验原则是，当实现存在重大不同时（例如在Unix和Windows中的共享内存映射），应
把为不同平台的移植代码分离到不同的文件中，而当区别比较微小时（例如，是使用
gettimeofday. clock_gettime、f七ime还是time来获取当前时间），将移植代
码放在单一文件中。
    在移植层之外的任何地方，注意这条建议：
    #ifdef和#if是最后一招，这通常是思路不当、产品过度差异化，无理由
    “优化”或是无用垃圾聚集的先兆。在代码中，它们就是诅咒。GNU的
    /usr/include/   stdio．h就是典型的悲剧。
    ~Doug McIlroy
    在移植层#ifdef和#if的使用是允许的（如果控制得当）。在此之外，应该尽量
限制使用，只用于有条件地触发#include。
    决不要占用系统其它部分的命名空间，包括文件名、错误返回值以及函数名。若育
共享命名空间的地方，应做好文档说明。
    选择一个编码规范。有关规范选择的争论会永无休止地进行下去——但无论如何，
在编写软件过程中支持多重编码规范是太困难太昂贵了，难以达到，所以必须选择某个
通用的规范。严格地坚持编码规范，代码的一致和干净优先级最高；而编码规范自身的
细节倒远在其次。
19.2.4  良好的发行制作实践
    这些指导描述了软件的发行应该如何去做，以供他人更好地下载、获取以及解包。
19.2.4.1  确保打包文件总是解包到单一的新目录下
    初出茅庐的奉献者最要避免的错误就是编制的打包文件，在解包时往往将发行版本
中的文件和目录解包到当前目录中，这很可能会覆盖已经存在的文件。决不要这样做。
www.pdf365.com
19.2与开源开发者协同工作的最佳实践
451
    相反地，应确保所有的档案文件都有一个共同的、以项目名命名的目录部分，如此
一来它们可以解包到一个直接位于当前目录下的顶级目录。为了方便，该目录名应该同
tarball的主干名相同。这样，例如，一个叫做foo-0. 23．tar.gz的文件包，希望能够
解压到一个叫做foo-0. 23的予目录中。
    例19.1展示了一个makefile技巧，假设发行的目录名为“foobar"，而SRC包含一
系列发布文件，可以这样来完成：
例19.1  tar文件包制作过程
foobar-$ {VERS） .targz :
 @ls  $ （SRC）   I  sed  s : ^ : foobar-$ {VERS） / :  >MANIFEST
 @ （cd  . . ;  In -s  foobar  foobar-$ （VERS》
 {cd  . . ;  七ar -czvf foobar/foobar-$（VERS） tar.gz  'cat  foobar/MANIFEST'
 @ （cd  . _ ;  rm foobar-$ （VERS》
19.2.4.2包含README文件
    在源码发行版本中包含一个路标文件README。按照古老的习俗（从1980年以前
发端于Dinnis Ritchie本人，而80年伐早期在Usenet上传播开来），这是勇敢的开拓者
在解包源码之后阅读的第一个文件。
    README文件应该短小精简容易阅读。确保只是一份介绍，而不是长篇累牍。在
README文件中应该包括如下的良好内容：
    1．项目的简短描述。
2．指向项目站点的链接（如果存在）。
3．开发者编译环境的注意事项以及潜在的移植性问题。
4．描述重要文件和子目录的路标。
5．编译及安装的指令或者指向同样内容的文件（通常是INSTALL文件）。
6．维护者光荣榜列表或者指向同样内容的文件（通常是CREDITS文件）。
7．项目的最近新闻或者指向同样内容的文件（通常是NEWS文件）。
8．项目邮件列表地址
UNIX编程艺．术
  www.pdf365.com
452
第1 9章开放源码：在Unix新社区中编程
    曾经有段时问，该文件通常命名为READ .ME，然而这与浏览器存在严重的不兼容问
    题，所有的浏览器往往都假定.ME后缀表示该文件并非文本，只能下载而不能浏览。这
    种做法已被废除。
    19.2.4.3尊重和遵从标准文件命名实践
    甚至在阅读README文件之前，勇敢的开拓者可能已经快速浏览了软件解包后顶级
    目录中的文件名。这些文件名本身也承载了信息。坚持一定标准的命名习惯，可以让开
    拓者得到有价值的线索，以得知接下来该浏览什么样的文件。
    这里是些标准的顶级文件名及其含义。当然，并不是每个发行版本都需要所有文件。
    README
    最先被阅读的路标文件。
    INSTALL
    配置、编译和安装指导。
    AUTHORS
    项目贡献者列表（GNU惯例）。
    NEWS
    最近的项目新闻。
    HISTORY
    项目历史。
    CHANGES
    修订版本之间重大更改的日志。
    COPYING
    项目许可证条款（GNU惯例）。
    LICENSE
    项目许可证条款。
    FAQ
    项目常见问题解答的纯文本文档。
    注意整体上的习惯，文件名一律大写表明是关于软件包的供人阅读的元信息，而不
    是关于编译构件的。README文件源自早期自由软件基金的开发经验。
UNIX缟程艺术
    www.pdf365.com
19.2与开源开发者协同工作的最佳实践
453
    拥有FAQ文件可以让你省很多力气。当关于项目的某个问题经常出现时，就加到
FAQ文件中；然后引导用户在发送问题或者错误报告之前首先阅读FAQ文件。一个发
展良好的FAQ可以减少项目维护者一个数量级的负担，甚至更多。
    为每个发布编写一份标有时间戳的HISTORY或NEWS文件是非常有价值的。别的不
说，这可以帮助确定在专利侵犯诉讼案中的先前证明（虽然还未在任何人身上发生，但
最好先预备着）。
19.2.4.4为可升级性设计
    随着新版本的不断发布，软件也不断变化着。有些更改无法向后兼容。相应地，设
计软件的安装布局时，应认真考虑，以确保多个软件版本能在同一系统中共存。对于库
来说这尤其重要——不能强求所有的客户端程序都同API的更改保持同步的升级速度。
    Emacs、Python以及Qt项目对此有个良好的实践：以版本号来命名目录（另一项被
FSF作为惯例的实践）。Qt库安装后的层次类似这样（$（ver）是版本号）：
# Where you find moc
# Where you find .so
 # Where you find header files
    正是由于这种组织，多重版本才可共存。客户端程摩必须指定其需要的版本，当然，
需要付出点小的开销，不要弄乱相关接口。这个良好实践避免了象Windows臭名昭著的
“DLL地狱’’的失败模式。
19.2.4.5  在Linux  提供RPM
    在Linux下可安装二进制软件包的事实标准格式是Red Hat Package Manager，即
RPM。在多数流行的Linux发行中均得到支持，其它所有的Linux的发行版本实际也有
支持（除了Debian和Slackware；Debian可以从RPM安装软件）。相应地，在项目站点
同时提供可安装的RPM和源码包是个绝佳的主意。
    在源码包文件中包含RPM的spec文件，并设置～个选项可以从makefile生成
RPM，这也是个好主意。spec文件应该具备．spec扩展名；这样才能让rmp一t选项在
压缩包中找到它。
UNIX编l程艺-术
    www.pdf365.com
                           r0
                -rl  -r-l  n
    r  S-l  r  r
    V      r-     r  V
            \-J，L rt rt
          IIII
七  LJ  JJ  _U  U
U q U  q  q
rl  -H  rl  .+  r+
r+  r-l  -l  r+  -l
r  1-1  r  u  s-l
rn  S  S   rn   cn
:j  :j  :j  o  U
454
第1 9章开放源码：在Unix新社区中编程
    额外的风格要点，编写可以自动生成spec文件的shell脚本，自动分析项目的
makef ile或version．h文件而插入正确的版本号。
    注意：如果应用源码RPM，应使用BuildRoot让程序在/tmp或/var／tmp下编译。
如果不这样，在运行make install的过程中，安装过程将会把文件安装到最终的位置。即
使文件有冲突或是并未想要实际安装时，这个过程也会发生。在完成以后，文件已经安
装而系统的RPM数据库却毫不知晓。此类糟糕的SRPM行为，是个雷区，应该远离。
19.2.4.6提供校验和
    提供二进制文件的校验和（压缩包、RPM等等）。这将允许人们验证文件是否损坏
或是否被木马程序侵入。
    尽管有好几个命令来干这个（例如sum以及cksum），但最好还是使用一个密码安
全的哈希函数。GPG软件包的-detach-sign选项提供这种能力：也可以使用GNU命令
md5 sum。
    对于发布的每个二进制文件，项目网页应该列出校验和及其生成命令。
19.2.5  良好的交流实践
    软件和文档，如果除自己之外无人知晓它们的存在，那将毫无益处。要是将项目放
到互联网上，则可以蒂助招揽用户和合作开发者。这里是一些标准的做法。
19.2.5.1  在Freshmeat上发布通告
    可以在Freshmeat<ht tp：／/www．freshmeat．net>上发布通告。这个组织的读者
群众多，也是网络技术新闻的主要提供者。
    不要设想用户从头一直阅读自己的通告。所以在通告中应该一直保留至少一句关于
软件目的的说明。糟糕的说法像这样：“宣告FooEditor最新的发布版，现在速度快了十
倍。”优秀的例子是：“宣告最新的FooEditor发布版，为盲打者设计的文本编辑器，现
在速度快了十倍。”
www.pdf365.com
19.2  与开源开发者协同工作的最佳实践
455
19.2.5.2在相关的主题新闻组上发布通告
    找到～个直接与应用程序相关的Usenet主题组，然后在那儿发布通告。但应该克制，
只在与代码实现功能相关的地方张贴。
    如果（例如）正发布使用Perl语言编写的IMAP服务器查询程序，就一定应该张贴
到cornp．mail．imap。而不应该张贴到comp．lang．perl上，除非程序也同样是Perl
前沿技术的启发实例。
    通告应包含项目网站的URL。
19.2.5.3建立一个网站
    如果试图围绕项目建立坚实的用户和开发者社区，那应该拥有一个项目网站。网站
上需要包含如下一些标准的东西：
●  项目说明（项目存在的理由、项目受众等等）。
●  项目源码的下载链接。
●  如何加入项目邮件列表的指导。
●  常见问题回答列表（FAQ）。
●  项目文档的HTML版本。
●  相关或竞争项目的链接。
优秀项目网站的实例请参考第16章。
    建立网站的一个简单方法就是将项目放到那种专门提供免费主机服务的站点上。在
2003年年中，晟重要的两个站点是SourceForge（这是专有合作工具的展示和测试站点）
以及Savannah（作为一种意识形态的声明，它存放了很多开源顼目）。
19.2.5.4提供项目邮件列表
    私有的开发用途的邮件列表可以让项目合作者以此交流和交换补_J’，这是个标准的
惯例。一些人希望能尽早得到项目进展信息，你应该为他们准备一个通告列表。
    如果正在管理一个名为“foo"的项目，开发者列表应该是foo-dev或
foo- friends;通告列表应该是foo -announce。
    ～个非常重要的决策是“私有”开发列表到底应该有多私有。在设计讨论中更广泛的
参与常常是件好事，但是如果列表相对开放，迟早就会有些用户在其上询问一些初级问
UNIX编茬艺术
  www.pdf365.com
456
第1 9章开放源码：在Unix新社区中编程
题。如何最好地解决这个问题的答案各种各样。仅有文档告知新用户不要在开发列表中
询问初级问题不是个办法；必须以某种方式加以强调。
    通告列表应严格控制。通信量最多一月几条；这个列表的整体目标是，向希望知道
某些重要事情何时发生的人们提供信息，但并不需要知道日常繁冗的细节。如果这个列
表在他们的邮箱中开始带来严重的混乱，许多人会立刻取消订阅。
19.2.5.5发布到主要的档案站点
    关于主要开源存档站点的详细说明参考第16章“何处找”部分。应该将软件包发布
到这些站点上。
    其它重要的站点包括：
O    The Python  Software Activity  <http : / /www . py七hon . org> site （for software
     written in Python）.
O    The CPAN <h七tp : //www . language .perl . com/CPAN>， the Comprehensive
     Perl Archive Network （for software written in Perl）.
o     The Python Software Activity<http : //www _ py七hon . org>  （ Python裎序）   。
O    The CPAN <ht七p : //www. language .perl . com/CPAN>， the Comprehensive
     Perl Archive Network  （ Perl程序）  。
19.3许可证的逻辑：如何挑选
    许可证条款的选择涉及这样的决定，软件作者是否希望对人们怎样处理软件施加某
些限制。
    如果根本就不想做任何限制，应该把软件放到公共域里去。在每个文件头都包含如
下的文本是很恰当的做法：
Placed in public domain by J. Ramdom Hacker， 2003. Share and enjoy!
    这样做就等于放弃了版权。任何人都可以对代码的任何地方做任意改动。再也没有
比这更自由的了。
    但是很少有开源软件是真正像这样发布在公共域的。一些开源开发者希望能够使用
他们对代码的所有权来确保代码可以保持开放的状态（这往往采取GPL）。而另外～些
仅仅期望控制代码的合法公开；所有开源许可证共通的一点就是对软件不作任何担保。
www.pdf365.com
19.5各种开源许可证
457
19.4为什么应使用某个标准许可证
    同开放源码定义保持一致并广泛为人所知的许可证，已经具备长期建立的传统默认
解释。开发者（以及他们关心的用户）知道这些许可证究竟意味着什么，并且理性地承
担所涉及的风险和折衷。因此，如果可能，应使用oSI站点所载的许可证之一。
    如果必须编写自己的许可证，请确保得到OSI的认证。这可以避免许多的争论和额
外开销。除非曾经亲身经历过，不然你无法想象Usenet上许可证谴责战的激烈程度；许
可证被认为是涉及开源社区核心价值近似神圣的盟约，人们的情绪都变得非常激动。
    更进一步，如果许可证在法庭上当作证词，已经确立的传统解释的存在或许就非常
重要。到本书写作时（2003年年中）还没有案例支持或反对任何开源许可证。然而，法
律原则是（至少是在美国，并且或许其它存在习惯法的国家，例如英国和其余的英联邦
国家），法庭应按照产生许可证和契约的社区所能预料的行为和实践来解读许可证和契
约。这样，就有充分的理由相信，当最后不得不由法庭系统来处理的时候，开源社区的
实践将有决定意义。
19.5各种开源许可证
19.5.1  MIT或者×Consortium许可证
    最宽松的自由软件讦可证是这样的，授予无限权利的拷贝、使用、修改和对修改拷
贝的再发行，只要在所有修改的版本中保留版权和许可证条款。接受这种许可证就意味
着放弃控告维护者的权利。
    可  以  在  OSI  站  点  <hL Lp：／/www．opensource．org／licenses／mit
-license．htrnl>找到标准X Consortium许可证的模板。
19.5.2  经典BSD许可证
    比上面稍严一点的许可证，授予无限权利的拷贝、使用、修改，以及对修改拷贝的
再发行，只要在所有修改的版本中保留版权和许可证条款，并且在广告和软件包相关的
文档中包含致谢。受让者也必须放弃控告维护者的权利。
UNIX编程艺_术
  www.pdf365.com
458
第1 9章开放源码：在Unix新社区中编程
    最初的BSD许可证是这类许可证最著名的。在血统上可以追溯回BSD Unix的自由
软件文化中，这个许可证甚至使用在离伯克利数千英里之外的地方编写的自由软件上。
    BSD许可证的次要变种更改了版权所有人和删除了对广告的要求（实际上等价于
MIT许可证），也并非不常见。注意在1999年年中，加州大学技术转让办公室（Office of
Technology Transfer of the University of California）废除了BSD许可证中的广告条款。所以
BSD软件中的许可证的限制已经更宽松了。如果选择BSD方式，我们强烈推荐使用新式
（没有广告条款的）而非1日式许可证。广告条款被废除了，因为这导致了确定授权广告
构成时，在法律和过程上的极端复杂性。
    可以召E OSI站点<http：／/www．opens ource．org/licenses/bsd  -license．html>
找到BSD许可证的模板。
19.5.3 Artistic许可证
    下一个稍严点的许可证授予无限的拷贝、使用和本地修改的权利。允许再发行修改
后的=I进制版本，但是限制修改源码的再发行以保护作者和自由轶件社区的利益。
    Artistic许可证为Perl而设计，广泛使用在Perl开发者社区，它就是此类许可证。它
要求被修改的文件包含“显著声明”，表示已经被修改过。也要求发布更改者让更改可
以自由获取，并努力将其传播回自由软件社区。
    可以在  OSI  站点<http：／／WWW，opensource．org／licenses／artistic
-license．html>找到Artistic许可证的拷贝。
19.5.4通用公共许可证
    GNU通用公共许可证（及其派生，Library或“Less”GPL）是最广泛使用的单一自
由软件许可证。如同Artistic许可证～样，若修改后的文件带有“显著声明（ prominent
notice）’’则允许修改源码再发布。
    GPL要求，如果程序包含了任何处于GPL涵盖下的部分，则整个程序都处于GPL
涵盖之下。  （触发这项要求的确切情况并不会让每个人都能清晰理解）。
    实际上这些特殊的要求使得GPL比其它常用的许可证都要严格。（在针对同样的目
标问题时，Larry Wall编写的Artistic许可证回避了这个问题。）
www.pdf365.com
19.5各种开源许可证
459
    可以在FSF的copyleft站点<ht tp：／/www．gnu．org/copyleft．html>找到指向
GPL的链接以及如何应用的指导。
19.5.5  Mozilla公共许可证
    Mozilla公共许可证支持开源软件，但是可以链接闭源的模块和扩展。它要求发行的
软件（被涵盖代码，Covered Code）仍然保持开源，但附加软件，如果通过良好定义的API
来调用，允许保持闭源。
    可以在  OSI  站点<http：／／www，opensource．org／licenses／MPL-I. 1.
html>找到MPL许可证的模板。
UNIX编腥艺-术
  www.pdf365.com
www.pdf365.com
函
  来：  【机与机遇
Futures:
Dangers and Opportunities
The best way to predict thefuture is to invent以，
    预测未来最好的方法就是去创造未来。
    /97/年XEROX PARC会议上的发言
    -Alan Kay
    历史远未结束。Unix将继续成长变化。围绕Unix的社区和传统也将继续演进。试
图预见未来有些投机，但我们也许可以从两个方面预测：首先，看看Unix是如何应对过
去的设计挑战的：其次，确定需要解决的问题和有待开拓的机会。
20.1  Uni×传统中的平质和偶然
    为了理解Unix的设计在未来会如何变革，我们可以先看看Unix编程风格在过去的
日子里是如何随时间而变化的。这种努力将我们直接引领到理解Unix风格的一个挑战面
前——区分平质属性和偶然属性。也就是说，分辨出哪些特征是从暂时的技术中发展而
来的，而哪些又是紧密联系于核心的Unix设计挑战——如何正确地模块化和抽象化的同
时而保持系统的透明和简洁的。
    这种区分可能是困难的，因为那些偶然发展而来的特征有时会变成平质功用。作为
UNIX编程艺术
  www.pdf365.com
462
第20章未来：危机与机遇
实例，考虑我们在第1 1章讨论过的“沉默是金”的Unix接口设计原则；该原则最初是
为了适应缓慢的电传打字机，但因为输出简明扼要的程序更容易跟脚本组合而流传至今。
今天，在大多数程序都通过GUI可视运行的普遍环境下，又有了第三个用处：寡言的程
序不会分散或浪费用户的注意力。
    另一方面，一些曾经是Unix本质的特征由于特定成本比例的变化而成为了偶然属
性。例如，旧学派Unix偏爱的程序设计．（以及像awk （1）的微型语言），逐行处理输
入流或者逐条记录地处理二进制文件，并需要在块与块之间维护上下文，由精心制作的
状态机代码实现。另一方面，新学派Unix的设计就幸福多了，可以假定程序把全部输入
读进内存而可以在需要时随机访问。实际上，现代各种Unix提供mmap （2）操作允许
程序员将整个文件映射到虚拟内存中，而J/O序列化操作的读盘写盘操作则完全被隐藏
了。
    这种变革以存储操作的经济性换取更简单透明的代码。这是出于内存成本比程序员
时间廉价的调整。1970-1980年代旧学派Unix设计同1990年后新学派Unix设计之间
的许多差别都可以回溯到相对成本的巨大转变上，今天，所有的机器赘源相对于程序员
时间来说，比起1969年要廉价好几个数量级。
    回顾过去，我们可以甄别出三个特殊的技术变化驱动了Unix设计风格中的重大变
革：网络互联、位图图形显示以及个人计算机。在每场革新中，Unix传统都通过抛弃不
再合适的偶然属性、寻找新方法来适应新技术的核心观念，从而成功战胜了挑战。生物
进化也以同样的方式。进化生物学家有个法则：  “不要以为历史起源确定了当前效用，
反之亦然”。概要地看看Unix是如何适应这些变化的，或许会提供一些线索，让我们认
识到Unix将如何适应未来我们预测不到的技术变迁。
    第2章描述了第一个变化：互联网的兴起，并从历史文化的角度，讲述了在1980年
后TCP，IP如何将最初的Unix和ARPANET文化融合为一体。在第7章，有关诸如System
V STREAMS之类的过时IPC和网络互连方法的材料，表明在接下来的十年里，许多错
误的开始、失足以及死胡同迷惑了Unix开发者。关于协议、关于不同机器间的网络互连
与同一机器上不同进程的通讯之间到底是什么样的关系，那时有太多混乱。t
1有好几年似乎ISO的七层互联网标准可能战胜TCP/IPo ISO标准由欧洲标准委员会提出，他们在政
治上言怕采用任何诞生自五角大楼的技术。唉，意气用事盖过了技术的敏锐。结果证明是过度复杂
和十分无用的，请细节有关参考[Padlipsky]。
UNIX编鹱；艺术
    www.pdf365.com
20.1  Unix传统中的平质和偶然
463
    最后当TCP/IP胜出以及BSD套接字重申Unix本质上～切都是字节流的隐喻时，迷
惑便～扫而空。IPC和网络互联都普遍使用BSD套接字，而两者的老方法大部分弃而不
用，同时，通信双方是否位于同一主机对Unix软件来说也就更无关紧要了。1990～1991
年间万维网的发明便是合乎逻辑的结果。
    1984年，TCPfIP出现的几年之后，位图图形以及Macintosh机登场时，带来了～个
更加困难的挑战。最初来自Xerox PARC和苹果公司的GUI非常漂亮，但是系统的太多
层次都捆绑在一起，让Unix程序员对这种设计感到很不舒服。Unix程序员当下的反应
就是让分离机制与策略成为一个明确准则；到1988年，X窗口系统将其确立下来。通
过将X窗口构件与完成底层图形操作的显示管理器分离，他们创造了一种架构，按Unix
的标准是模块化的、清晰的，并且随着时间，可以很容易在此基础上发展出更好的策略
来。
    但那只是问题较为容易的部分。困难部分在于决定Unix是否应该拥有统一的界面策
略；而如果是，又是什么。通过专有工具包（例如Motif）来建立统一界面策略的几个不
同努力已经宣告失败。知今，在2003年里，GTK和Qt彼此争当这个角色。而在2003
年这个问题的争论也还没有结束，我们在第II章讨论过的各种UI风格同时并存的持续
状态似乎很明显。新学派Unix设计保留命令行方式，并通过编写许多在两种风格都可以
使用的CLI引擎+GUI界面组合，来解决GUI和CLI方式之间的冲突。
    个人计算机作为技术本身并没有带来什么主要的设计挑战。386以及后来的芯片，
性能足够强大，所以围绕其设计的系统在成本比例上同Unix非常成熟的小型机、工作站
和服务器相似。真正的挑战是Unix潜在市场的变化：硬件价格的全面走低，让个人计算
机吸引了更广泛的、不太懂技术的用户群。
    专有Unix软件商习惯了把更强大系统卖给高深技术买家的丰厚利润，从未对这个实
际上更广泛的市场表示出兴趣。理所当然，朝终端用户桌面系统努力的第一次重大启动
产生于开源社区，并由于本质的意识形态原因而不断增加。到了2003年年中，市场调查
显示Linux已经占到大约40-/0～5%的份额，接近了苹果分司的Macintosh。
    无论Linux是否会充分地做得更好，Unix社区反应的本质已经很清楚。我们在第
三章Linux的分析中检视了这一点。这包捂采取一些取自别处的新技术（例如XML），
并且付出了许多努力将GUI移植到Unix世界。但是在主题GUI和安装包之下，主要
www.pdf365.com
第20章未来：危机与机遇
的重心依然是模块化和清晰的代码一一为严肃、高度可靠的计算和通信提供正确的基
础设施。
    诸如Mozilla和OpenOffice.org的大规模桌面开发始于1990年代末，其发展历史很
好地展示了我们所说的重点。在上述两个开发例子中，社区反馈中最重要的议题并不是
要求增加新特征，也不是安排发布日期——而是对巨大的单体程序的厌恶以及一致感觉
在那些巨大程序成为障碍之前，必须瘦身、重构、分解成块。
    尽管伴随着许多创新，但所有对这三个技术的响应都保持着Unix的设计准则——模
块化、透明性、机制同策略分离及其它我们在本书早前描绘的品质。Unix程序员在30
年风雨中学到最有经验的回应，就是回到最初的准则——优先从流、命名空间、进程等
Unix基本抽象中得到更多效用，而不是增加新的东西。
20.2  Plan 9：未来之路
    我们知道Unix的未来看起来会怎样。
在贝尔实验室编制了Unix的研究组设计。
它被称作“来自贝尔实验室的Plan 9”2，由
Plan 9尝试重做Unix，做更好的Unix。
    设计者在Plan 9中尝试应对的核心设计挑战是整合图形和无处不在的网络互联，使
它们成为好用的Unix式框架。他们保曰了Unix的选择，尽可能多地通过单一大型文件
层次命名空间来访问系统服务。实际上，他们是在此基础上改进；许多在Unix中需要通
过不同专用接口的功能，比如BSD套接字、fcntl （2）以及ioctl（2），在Plan 9中都可通
过在类似设备的专用文件上使用最普通的读写操作来完成。为了可移植性和易访问性，
几乎所有设备接口都是文本的而非二进制的。许多系统服务（包括视窗系统在内）都是
文件服务器，以特殊文件或目录树来表示服务资源。通过将所有的资源都表示成文件，
Plan 9把访问不同服务器资源的问题转变成访问不同服务器文件的问题。
2名字来源于1958年的电影，《Plan 9from Outer Space））（外层空间第九计划），该片被当作“最糟
糕的”而写进历史。（不幸的是，榜单似乎并不正确，1966年有部甚至更糟的影片叫做《Manos: The
Hands of Fate》（Manos:命运之手），少数看过的人可以作证）。文档，包括描述架构的技术文件，
以及可以安装在PC机上的完整源码和发布包，都可以通过搜索短语“Plan 9 from Bell Labs”得到。
UNI×编程艺术
www.pdf365.com
20.2  Ptan 9：未来之路
465
    Plan 9将这种“比Unix更Unix’’的文件模式和一个全新的概念整合在一起：私有命
名空间（ private namespace）。每个用户（实际上，每个进程）都可以拥有自己的系统服
务视图，通过创建自己的文件服务器装配树（ mount tree）。有些文件服务器的装配树将
由用户手动设置，其它的在登录时自动建立。这样（如同Plan 9from Bell Labs的技术资
料指出的一样）“/dev/cons总是指终端设备，而/bin/date则指date命令正确的运
行版本，但是这些名字代表的文件依赖于环境，例如执行date机器的架构等等”。
    Plan 9最重要的特征是，无论何种实现，所有挂载的文件服务器都具备相同的类文
件系统接口。有些可能相对于本地文件系统，有些相对于通过网络访问的远程文件系统，
有些相对于在用户空间运行的系统服务器实例（比如窗口系统或另～种网络栈），还有
些相对于内核接口。对于用户和客户端程序而言，它们没有区别。
    Plan 9技术资料中的有个例子就是实现FTP访问远程站点。在Plan 9下并没有ftp（l）
命令，而存在一个ftpfs文件服务器，每个FTP连接看起来兢像是挂载一个文件系统。在
挂载点下，对于文件和目录的open、read以及write命令，都由ftpfs自动地转换为FTP
协议事务。这样，所有普通的文件处理工具，例如/s（1）、  mv（l）以及cp（l）都可以正常
工作：无论是在vrP装配点下，还是跨越到其它用户眼中的命名空间。用户（或是脚本
和程序）能够注意到的唯一不同就是不尽一致的检索速度。
    PJan 9还有许多其它值得推荐的地方，包括一些问题重重Unix系统调用接口的再造、
摒弃了超级用户概念的，以及许多其它有趣的再思考。它的血统没有污点，设计优雅，
而且揭露了Unix设计中的一些严重错误。
    同大多数二次系统不同，在许多地方Plan 9都创造了比其前身更简洁更优美的体系。
但它为什么没有统治世界呢？
    有人会提出许多特殊的理由——缺乏重大的市场努力、文档的稀少、许可证和费用
的困惑和阻碍。对于那些不熟悉Plan 9的人，似乎它的主要功能就是作为关于操作系统
研究有趣论文的题材。但在先前，Unix自身已经就超越了各种障碍吸引了无数为之献身
的追随者，最后遍布全球。但为什么P1an 9没有昵？
    深入到历史长河的调查也许会揭开一个不同的故事，但是在2003年，看起来Plan
9昀失败仅仅是它的改进尚不足以取代它的前任。对比Plan 9，Unix似乎明显嘎吱作
响，锈迹斑斑，但是Unix的工作完成得很棒足以保持它的地位。这是个教训，提示
UNIX编程艺_术
  www.pdf365.com
466
第20章未来：危机与机遇
雄心勃勃的系统架构师：更优秀解决方案的最危险敌人，就是一个现存的、足够优秀
的代码库。
    一些Plan 9的思想已被吸收进现代的Unix，尤其是在更革新的开源版本中。FreeBSD
具备—个/proc文件系统，几乎完全借Plan 9的模型，可以用来查询或控制运行的进程。
FreeBSD的rfork（2）以及Linux的clone（2）系统调用也借自Plan 9的ork（2）。Linux的
/proc文件系统，除了当前进程信息，也附加保存了许多类Plan 9设备文件的综合信息，
几乎全部使用文本接口来查询和控制内核。Linux 2003年的实验性版本也实现了逐进程
的装配点，这是迈向Plan 9私有命名空间的一大步。不同的开源Unix版本现在朝着系统
范围内支持UTF-8的方向努力，而UTF-8正是一种实际上为Plan 9而发明的编码。3
    随着时间的推移，可能就会那样，随着Unix内部架构某些部分的渐渐老化，越来越
多的Plan 9思想将整合进Unix中。这是Unix未来一个可能的发展路线。
20.3 Unix设计中的问题
    Plan 9洗涤了Unix;但在Unix的基础设计概念集上真正所加的全新的概念足有一
个（私有命名空间）。但是还有别的基本设计概念存在严重问题吗？在第1章，我们接
触了几个Unix存在争论的失败之处。既然开源运动已经将Unix的未来设计交回到程序
员和技术员手中，那些问题就不再是我们必须永远忍受的定局了。我们将重新检视它们
以更好应对Unix未来应该如何发展的问题。
20.3.1  Uni×文件就是一大袋字节
    Unix文件仅仅是个字节大袋子，而没有其它文件属性。特别是没有能力存储有关文
件类型的信息，以及指向文件实际数据之外相关应用程序的指针。
    更普遍地，一切都是字节流，甚至包括硬件设备也是字节流。这种隐喻在早期的Unix
中取得了巨大的成功，而且，在某些地方，例如，被编译的程序不能够产生传递回编译
器的输出，的的确确是个真正的进步。管道和shell编程也正是从这个隐喻上发轫的。
3 UTF_8如何诞生的传说涉及Ken Thompson.  Rob Pike、一次新泽西的午餐以及彻夜疯狂的编程
<ht t_p：／／www.cl.cam.ac.uk／-mgk2 5/ucs／utf -8-history.txt>.
www.pdf365.com
20.3 Unix设计中的问题
467
    但是Unix的字节流隐喻太过重要，以至于如果软件对象的某些操作不是特别适合字
节流或是文件操作（创建、打开、读写删除）的话，那么Unix就存在整合的困难。GUI
对象尤其是个问题，例如图标，窗口，以及正在操作的文档。在Unix世界经典的模型中，
“一切都是字节流’’这个隐喻的唯一扩展方式就是ioctl调用，使用内核空间声名狼藉
的后门。
    Macintosh系列操作系统的发烧友往往对此咆哮不已。他们提倡～种模型，其中，单
一文件名可以既有数据“分支”又有资源“分支”。数据分支对应于Unix的字节流，而
资源分支则是名／值对的集合。而Unix支持者更喜欢文件数据自描述的方式，这样，同
种类的元数据都有效地存放在该文件中。
    Unix方法的问题在于写文件的每个程序都必须清楚自描述的方式。这样，例如，如
果我们需要文件携带类型信息在其中，涉及该文件的每个工具都得小心，要么原封不动
地保留该类型域，要么解析之后重写。尽管这在理论上可以实现，但在实践中太脆弱了。
    另一方面，支持文件属性会产生难以应付的问题，什么样的文件操作应该保留文件
属性。很明显，具名文件的复制应该拷贝源文件的数据及属性．但是如果我们cat（1）文件，
将其输出重定向到一个新的名字又该如何？
    答案依赖于属性实际上是否真是文件特性，还是以某种特殊方式作为不可见的前编
码或后编码与文件数据捆绑在一起。这样问题又变为：属性对何种操作可见？
    远在七十年代，Xerox PARC文件系统设计就在这个问题中不断挣扎。它们创造了一
个序列化打开（open serialized）调用，返回同时包含内容和属性的字节流。如果应用在目
录上，就返回目录属性和目录中所有文件的序列化结果。这种方法是不是一直都有改善，
并不清楚。
    Linux 2.5已经支持附带任意名／值对来作为文件特性，但在写作本书时，并没有为太
多的应用程序所用。Solaris最近的版本也有几乎等价的特征。
20.3.2  Unix对GUI的支持孱弱
    Unix的经历证明了使用众多隐喻作为框架的基础是个威力巨大的策略（回忆我们在
第13章关于框架和共享上下文的讨论）。现代GUI核心的可视隐喻（文件由图标表示，
打开靠点击，点击会激发某个设计好的处理程序，通常能够创建和编辑这些文件）也证
UNIX编程艺求
  www.pdf365.com
468
第20章未来：危机与机遇
明了是成功而持久的。自从Xerox PARC在七十年代先驱性开拓以来，这些就紧紧地抓
住了用户和界面设计者。
    尽管最近做出了相当多的努力，在2003年，Unix仍然只是蹩脚地、勉强地支持这
种隐喻——层次太多，约定太少，构建程序太过于简陋。Unix老手典型的反应就是怀疑
这折射出GUI隐喻本身更深层次的问题。
    我认为产生这样的问题部分是由于我们仍未正确理解隐喻。例如，在Mac上，
  把一个文件拖到垃圾桶去是删除，但把文件拖到某个磁盘上却又是复制，而打印
  时却又不能把文件拖到打印机的图标上去，那需要通过菜单才能完成。我还能够
  继续举例下去。它像OS/360上的文件操作，那会儿还没有Unix简单（但不简陋）
  的文件思想。
-Steve Johnson
    对于类似的效应，在第Il章我们引用了Brain Kernighan和Mike Lesk的话。但是这
个疑问并不能简单归罪于GUI就停止了，因为尽管GUI存在许多缺点，但终端用户却有
巨大的需要。设想，如果我们能够在设计用户交互层面上，把隐喻弄正确明白，Unix就
能够优雅地支持它了？
    答案是：也许不能。我们在思考字节袋子模型是否先天不足时就接触到这个间题。
Macintosh风格的文件属性或许可以帮助提供一种机制，支持更为丰富的GUI。然而这
似乎并不是完整的答案。我们需要仔细思考，才能得出结论，一个真正强大的GUI框
架究竟是什么样的一一而且，同样重要地，又如何同现存的Unix框架整合在一起。这
是个难题，需要基础性的顿悟，但在喧闹而令人困惑的大众软件工程或学术研究巾还
未出现。
20.3.3文件删除不可撤销
    有过VMS经验的人，或是还记得TOPS-20的人，往往怀念这些系统的文件版本功
能。删除或打开并修改现存文件，实际上只是以一种包含版本号的可预知方式重命名文
件，只有对版本文件明确的删除操作才会真正地删除数据。
    Unix没有这种功能，其小小代价是，在因打字疏忽或shell通配符结果不符而错误删
除文件，把用户惹怒。
    这个问题好像并没什么可预见的前景，会在操作系统级别上得到更改。Unix开发者
www.pdf365.com
20.3 Unix设计中的问题
469
喜欢清晰、简单的操作，用户告诉什么他们就做什么，即使用户指令等于“向我开枪”
的命令。Unix开发者本能的辩解就是重申：保护用户免受自我损害，应该是GUI或应用
程序级别的事，而非操作系统。
20.3.4 Unix假定文件系统是静态的
    某种角度上，Unix世界的模型完全是静态的。程序的运行总被设想为暂时的，所以
文件和目录环境在整个执行中都可以当成静态的。如果某个指定的文件或目录发生了改
变，没有标准的、良好的方式来让系统通知应用程序。当编写长期运行的用户界面软件，
如果又希望知道环境的改变时，这就会成为重大的问题。
    Linux具有文件和目录更改通知功能4，有些BSD的版本也复制了这个功能，但尚无
法移植到其它Unix。
20.3.5作业控制设计拙劣
    除了挂起进程（在本身，微不足道地增加了调度程序负担，并不是那么令人讨厌）
的能力之外，作业控制就是在多重进程中切换终端。不幸地，操作系统只做了最简单的
部分——确定触发了哪个键——而把所有难题当皮球似地踢给了应用程序，例如保存和
恢复屏幕的状态。
    该功能真正良好的实现对于用户进程应该完全不可见：没有专用的信号，不需要保
存和恢复终端模式．不需要应用程序定时重绘屏幕。其模型应该是，虚拟的键盘必要时
连接到真正的键盘（如果没有连接，在请求输入时会遭到阻塞），以及一个虚拟屏幕，
必要时可以显示在真正的屏幕上（当没有显示时，无所谓阻塞不阻塞输出）：而以同样
的多路复用方式，系统应该可以多路复用磁盘、处理器等等，而用户程序根本就不受影
响。5
    正确的做法要求Unix tty驱动跟踪整个当前屏幕的状态，而不仅仅只是支持行缓存
区，并且当一个挂起的进程恢复到前台运行时，需要在内核级知道终端的类型（可以求
4在fcntl（2）下查找F—NOTIFY。
5本段基于Henry Spencer在1984年的分析。他继续注意到作业控制对于POSIX及后来的Unix标准
是需要和适合认真考虑的，因为它渗透到了每个程序，所以在任何应用程序到系统的接口都必须考
虑。因此，POSIX认可了这个错误设计，而正确的解决方案却因“不在讨论范围”而甚至没有考虑
过。
UNIX编程艺术
  www.pdf365.com
470
助于一个后台进程）才可以正确地恢复。
离某个对话，例如xterm或Emacs作业，
型的）。
如果没有做好，Unix内核不能够从一个终端分
然后又将其配接到另一个终端（可能是不同类
    随着Unix的使用已经转向X显示和终端模拟器，作业控制就变得相对不那么重要
了，而也就没有曾经那样的破坏力了。然而，仍然讨厌的是没有suspend/attach/detach等
操作，这种功能对于在不同登录中保留终端对话的状态非常有用。
    叫做screen（1）的通用开源程序解决了这些问题中的好几个6。然而，必须显式地
由用户调用，既然这样，就不能保证在每个终端对话都拥有其功能；同时，在功能上与
之重叠的内核级代码也还没有移除掉。
20.3.6  Unix API没有使用异常
    C语言缺乏抛出附带数据的命名异常的机制。因此，Unix API中的C函数用与众不
同的的返回值（通常是。l或NULL）并设置全局变量ermo来报告错误。7
    回顾过去，这的确是许多微妙错误的发源之地。匆匆忙忙的程序员常常忽略返回值
检查。因为没有异常抛出，补救原则也被破坏了；程序流程继续进行，直到错误情形在
后来的执行中表征出某种失败或数据损失。
    异常的缺失也意味着某些理虚简单的任务——例如在具备Berkelev风格信号的Unix
版本上，从信号处理程序中退出——不得不由复杂的代码来实现，从而成为移植的障碍，
和众多错误的渊薮。
    这个问题也可能（且通常是）隐藏在Unix API对诸如Python和Java之类具备异常
的语言的接口中。
    异常机制的缺乏实际上也牵连出一个更大的问题：由于C语言是弱类型语言，所以
使用C语言实现的高级语言之间，其通信也是问题多多。多数现代的语言都将诸如链表
和字典作为基本数据类型——但是，因为这些在通用C语言中没有规范的表示，所以在
类似Perl和Python之间尝试传递链表就是一个非自然的行为，需要许多胶合代码。
存在解决更大规模问题的技术，例如CORBA，但是却往往涉及运行期的转换，并且
6 <http：／／www - math．fu-berlin．de／～guckes/screen/>是screen（1）的项目站点。
7对于非程序员，异常抛出是程序从函数过程中间跳出的一种方法。它并不是真正的退出，因为在某
个封装的过程中，抛出的异常可以被捕获代码中途拦截。异常往往用来表示错误或是不希望的情
形，意味着试图继续正常处理逻辑是毫无意义的。
www.pdf365.com
20.3  Unix设计中的问题
471
太过重量级，令人不舒服。
20.3.7  ioctl（2）和纪几t/（2）是个尴尬
    ioctl（2）和fcntl（2）机制提供一种在设备驱动中插入钩子的方法。原始的、历史的ioctl（2）
用法，就是设置波特率以及设置串行通信驱动中的帧比特，所以就产生了这个名字（“I/O
控制”）。后来，其它驱动函数可以使用ioctl调用，而fcntl（2）作为一个钩子函数增加到
了文件系统中。
    年复一年，ioctl和fc:ntl调用不断增加新的用法。但常常缺乏文档，也常常产
生移植性问题。每一个都带来一大堆繁杂的宏定义来描述操作类型和特殊的参数值。
    根本的问题同“字节大袋子”一样；Unix的对象模型孱弱不堪，没有留下自然的空
间放置太多增加的辅助操作。设计者不得不在不满意的解决方案中胡乱选择：
fcntl／ioctl在／dev中检查设备、新的专用系统调用、或是通过特殊用途虚拟文件系
统钩子加载进内核里去（例如，在Linux以及别的地方的／proc）。
    还不清楚在未来，Unix的对象模型是否会得到加强或如何加强。如果类MacOS的
文件属性成为Unix的通用特征，在设备驱动上调节各式具名属性就可卧接替
ioctl／fcntl现在的作用（这样至少不需要在接口可以使用前定义一堆宏）。我们已
经看到Plan 9使用具名文件服务器或文件系统作为基础对象，而不是文件／字节流，这提
供了另外的可能方法。
20.3.8  Unix安全模型可能太过原始
    或许root用户权限太大，对于系统管理功能，Unix应该具备粒度更细的能力或是
ACL（Access Control Lists，访问控制列表），而不是只有一个什么都能做的超级用户。
站在这一边的人们或许会辩解，许多系统程序通过set-user-ID就会拥有永久的root用户
权限；一处被攻破，就意味着全面沦陷。
    然而论据是小充分的。现代Unix允许指定用户帐户分属多个安全权限组。通过使用
执行许可以及在程序可执行时set-group-ID，每个组的作用就可以像文件程序的ACL。
UNIX编程艺-术
  www.pdf365.com
472
理论可行，却很少使用，可以这样认为，对ACL的需求在实践上远比理论少。
20.3.9  Unix名字种类太多
    Unix统一了文件和本地设备——都是字节流。但是通过套接字访问的网络设备在不
同的命名空间却具有不同的语义。而Plan 9展示了文件同本地及远程（网络）设备可以
平滑地统一在一起，并且所有这些事情都可以通过一个命名空间来管理，当然，命名空
间可以根据每个用户甚至是每个程序动态地调整。
20.3.10文件系统可能有害论
    拥有文件系统根本就是个错误？自从1970年代晚期起就一直存在有趣的研究，研究
持续对象存储，研究根本没有全局共享文件系统，而将磁盘存储当作巨大交换区，做任
何事情都通过虚拟对象指针来完成的操作系统。
    这条阵线上现代的努力（例如EROS8）提示这样的设计可以提供大量的好处，包括
被证实的安全策略一致性以及更高的性能。然而必须注意到，如果Unix是个失败，它所
有的竞争者都同样是失败；没有作为主要产品的操作系统都跟随EROS的领导。9
20.3.11  朝向全局互联网地址空间
也许URL扬名得还不够。关于Unix未来的方向，我们把最后的话留给Unix的发明者；
    我未来的理想就是开发一个文件系统的远程按口（也就是Plan 9），然后使
其在互联网成为标准实现，取代现在的HTML。那实在是酷毙了。
-Ken Thompson
8 http：／／www - eros-.s .org／
9 Apple Newton、AS/400小型机以及Palm手持设备上的操作系统可以认为是例外。
www.pdf365.com
20.4 Unix的环境问题
473
20.4  Unix的环境问题
    Unix旧有的文化在开源运动中大部分进行了自我再造，在灭亡的边缘挽救了我们，
但这也意味着开放源码的问题现在就是我们自己的问题。
    问题之一就是如何让开源开发获得持续的经济支持。我们重新植根于Unix早期的
合作开放进程。我们已经在很大程度上，在抛弃私用专有系统的技术争论上取得胜利。
我们已经想出了许多方法，在比1970～1980年代更平等的地位上，同市场和管理人员
合作，并且在许多地方我们的革新都获得了成功。在2003年，开源Unix和它的核心
开发组，达到了如大型机般受人尊敬和权威的地位，这在1990年代中期是不敢想象的。
    我们已经走过了很长的路，但是我们还有更长的路要走。我们知道哪种商业模式
在理论上管用，而且我们现在甚至可以指出一些零星的成功，展示了那些商业模式在
实践中也确实运营良好；当然，现在我们必须显示那种模式可以可靠地运营更长的时
间。
    这并不一定是个容易的转变。开放源码将软件业转变成服务业。服务提供商（想
想医疗和法律行业）并不会注入更多资本的比例来扩张；那些仅仅尝试追加固定成本，
就期望得到高产出的做法，注定会被饿死。合理的选择可以归纬为卖唱（通过小费或
捐款），经营街角小店（一种小型的、低开销的服务商务），或是找到一个富有的赞
助人（某些大商家为其商业目的而需要使用及修改开源软件）。
    总而言之，技工的小时工资随着汽车的降价而上升10，同样的原因，雇用软件开发
者的费用也会如预料中地提高。而个人和商家也越来越难以获得投资。会有许多程序
员富裕起来，但是仅有少数几个能成为百万富翁。这实际上是进步的标志，无能的就
被竞争出局。但这也将表示整个软件环境气候的一大变化，可能意味着投资者将失去
他们仅存的、在赞助软件启动中很少的利益。
io~-完整的讨论，参见《The Magic Cauldron》 [Raymond01]。
UNIX编程艺术
  www.pdf365.com
474
第20章未来：危机与机遇
    一个有关真正大型软件商维护越来越困难的子问题是如何组织终端用户测试。历
史上，Unix文化首要关注内部架构，这意味着，能够提供最终用户舒适界面的价值，
从未被我们当作程序构建的基础。如今，尤其是把在目标瞄准同微软和Apple竞争的
开源Unix中，这一点正在改变。但是最终用户界面需要实际用户系统地测试一一这存
在～些挑战。
    实际最终用户测试需要机构、专家以及一定水准的管理，然而以分布自愿团体为
特征的开源开发却难以部署这些。也许因此，开源的字处理器、电子表格以及其它生
产型应用程序不得不留在由大商家赞助的研究计划手中，例如OpenOffice.org，只有它
们才能提供那种开销。开源开发者往往认为单…商家就意味着单点失败，并且非常担
心这种依赖，但更好的解决方案还没有发展出来。
    这些是经济问题。我们还有其它更政治化的问题，因为成功招徕敌人。
    有些是老对头啦。微软要成为计算机世界不可动摇垄断者的野心，使得在我们知
道我们卷入战争的五年前，就把打败Unix作1980年代中期该公司的战略目标。在2003
年年中，尽管好几个成长性市场遭到Linux大范围的侵占，微软仍然是世界上最富有
和最疆大的软件公司。微软很清楚地知道必须打败新学派的开源Unix以求生存。而为
了获胜，必须毁灭或是羞辱产生它的文化。
    Unix借开源社区之手回来了，而同互联网自由文化的结合，也带来了新的敌人。
  好莱坞和媒体巨头感到了互联网深深的威胁，对不受控制的软件开发发起了多重攻击。
’  现存的法案，例如Digital Millennium Copyright Act已经被用来起诉那些为媒体权势不
  喜的软件开发者（最臭名昭著的案件就是针对能够复制加密DVD的DeCSS软件）。
  预期的计划例如所谓的可信计算甲台联盟（ Trusted Computlng Platform Alliance）和微
  软的Palladium威胁11要让开源开发成为非法活动一一而如果开放源码消亡了，Unix也
  很可能随之消亡．
    Unix、黑客以及互联网～起反对微软和好莱坞及媒体巨头。这是我们需要获胜的
斗争，不仅是出于我们传统的专业主义、我们对技艺的热爱，以及共有的部族忠贞，
还有更重要的原因使这个斗争如此重要。政治可能性渐渐成形于通信技术一一谁可以
使用、谁应该检查以及谁可以控制。政府和法人对网络内容的控制，对什么人可以利
用计算机的控制，都是对政治自由一个长期严重的咸胁。恶梦般的场景就是这样，垄
断商家和中央独裁，永远的自然同盟者，相互勾结并炮制理论，越来越多地制订规章、
2 1参考TCPA FAQ<http：／／WWW - cl．cam. ac．uk／～rj aj 4/tcpa- faq．html>，由一个著名安全
专家所做的一个相当毛骨悚然的可能性分析摘要。
www.pdf365.com
20.5 Unix文化中的问题
475
无情镇压以及罗织电子言论罪名。在反对这一切的斗争中，我们是自由的战士一一不
仅仅是为了我们自己的自由，也同样是为了所有人的自由。
20.5  Uni×文化中的问题
    围绕在Unix社区的文化问题，同Unix自身的技术问题以及伴随成功而来的挑战
同样重要。至少存在两个重大的问题：小挑战是内部转型，大挑战是我们要克服历史
上的优越感。
    小挑战是老学究与新派开源大众之间的摩擦。Linux的成功，特别地，对许多老一
辈的Unix程序员来说并不完全舒服。部分是由于代沟的问题。Linux小子们吵闹活泼
天真愉悦的狂热行为激怒了老一辈，他们自从七十年代就接触Unix了，而且（常常公
正地）认为自己更有智慧。而小子们在老一辈失败的地方不断取得成功的事实更激化
了这种现象。
    在2000年，当花了三天时间参加了一个Macintosh开发者会议之后，我愈发清晰
地意识到了更大的心理问题。沉浸在一个同Unix世界假设基础完全相反的编程环境中
真是个给人启迪的经历。
    Macintosh程序员最为关心用户体验。他们是建筑设计师和装饰家。他们由外而内
进行设计，首先就问“我们需要支持哪种交互？”，然后构建隐藏其后的狸序逻辑来
满足用户界面设计的需求。这就会导致程序外观非常漂亮而内部结构脆弱摇摆。一个
声名狼藉的例子，在MacOs 9以前的发布版本中，内存管理器有时对于那些退出但仍
占用内存的程序，竟然要求用户手动回收内存。Unix支持者本能地反感这类病态设计：
他们不能理解Macintosh的人怎么能够忍受这些。
    比起来，Unix程序员先考虑基础设施。我们是水管工和砖瓦匠。我们的设计由里
而外，构建强大的引擎以解决抽象定义问题（例如“我们如何通过不可靠的链接和硬
件而获得从A点到B点的可靠信息包流交换”）。然而引擎外，我们的包装难看，甚
至接口常常相当丑陋。date（l）. find（l）和ed（l）就是臭名昭著的例子，但还有其它成百上
千的程序也是这样。Macintosh人也本能地反感这种病态设计；他们也不能理解Unix的
人怎么能够忍受这些。
    两种设计哲学都有正确的一面，但是两个阵营却难以理解彼此的立场。Unix开发者
典型的反应就是把Macintosh软件当作是给无知人的绣花枕头而抛弃，然后继续构建能
UNIX编}翟艺_术
  www.pdf365.com
476
第20章未来：危机与机遇
够吸引其它Unix开发者的软件。如果终端用户并不喜欢，那是终端用户的不对：他们了
解多了之后，会回来的。
    在许多地方，这种狭隘思想已经为我们工作得很好。我们是互联网和万维网的守护
者。我们的软件和我们的传统统治了重大计算，统治了必须是全天候可靠的、宕机时间
最少的应用程序。我们真正极端擅长构建坚实的内部结构；虽非完美，但无论如何没有
其它的软件技术文化能够在任何地方接近我们的纪录，这是非常值得骄傲的。
    问题是我们愈发必须直面的挑战，是需要更多丰富视图的挑战。世界上大多数的计
算机都不是放在服务器机房里，而是在那些终端用户手中。在Unix早期的日子里，在个
人计算机之前，我们的文化把自身部分定位为大型机神父，那个大铁玩意管家的反叛者。
后来，我们吸收了早期小型机狂热者给人们以力量的理想。但是今天，我们成为了神父；
成为了网络和大铁块的守护者。我们潜在的要求是，如果想使用我们的软件，就必须
学会像我们一样思考。
    在2003年，在我们的态度中存在深深的矛盾一一精英和大众之间的摩擦。我们希
望影响和改变这世界92%的人，对他们来说，计算机就意味着游戏、多媒体、漂亮的
GUI界面、  （对他们来谠最技术的）邮件软件、字处理器以及电子数据表。我们正花
费主要努力在诸如GNOME以及KDE等设计来给予Unix美妙外观的项目。但在内心
深处，我们仍旧认为自己是精英，不能或不想去甄别或是倾听以王大婶为代表的普通
用户需求。
    对于非技术最终用户，我们构建的软件往往不是令人迷惑无法理解，就是样子难
看故意屈尊似的，又或两者兼有。即使我们怀着尽可能高的热情尝试去做对用户友好
的事，却可悲地前后矛盾。对于完成这份工作，我们从旧学派Unix继承的许多态度和
反应都是不恰当的。即使我们想要倾听或帮助王大婶，我们也不知道如何去做一一我
们设计了我们的服务类目、关心她并提供“解决方案”，但她却发现这同她存在的问
题一样可怕。
    我们在文化上面临的巨大挑战是，我们是否能够不再过分依赖那些已经很好地为
我们工作过的设想——我们是否能够承认，不仅是在思想上，也是在日常实践的施行上，
承认Macintosh支持者也抓住了要点。他们的要点也是基于普遍实际，而非Mac专用方
式，在“The Inmates Are Running the Asylum[CooperJ”，一部具有深刻见解和充分论证
的书籍中，其作者称（别管偶尔的一些奇谈怪论），交互设计乜包含了大量坚实的真理，
需要为每个Unix程序员所知道。
    我们可以避开这～点：我们可以保留教父地位，祈求碰到最好最聪明的少数人——
一小撮关注我们历史作用的知识精英——作为软件内部架构和网络的守护者。但如果我
www.pdf365.com
20.6信任的理由
477
们这样做，就很可能走向衰落，直到最后失去几十年来一直支持我们的动力。自有别
的东西去服务人们；自有别的东西会赢得动力和金钱并拥有未来92%比例的软件。而
这个可能成功的机会，无论是不是属于微软，都将使用我们所不喜欢的软件和实践来
完成。
    或者我们真正接受这个挑战。开源运动正努力这样去做。但在过去用来解决其它问
题的相同工作和思想是不够的。我们的态度必须在根本上有所转变，虽然困难。
    在第4章，我们讨论了抛弃设想限制以及在解决技术问题上“抛弃过去”的重要性，
建议同禅宗思想类似的超然和“初衷”。我们拥有～个需要更多种类的分离工作。我们
必须学会在王大婶面前虚心，并且放弃某些我们长期坚持的、曾使我们如此成功的偏见。
    明显地，Macintosh文化已经开始同我们的文化相融合-MacOS X拥有Unix的底
层架构，并且在2004年Mac开发者（虽然在某些方面有所斗争）进行了思想上的调整
来学习注重内部架构的Unix美德。我们的挑战将是，相互地，吸纳Macintosh以用户为
中心的美德。
    还有几个表明Unix文化摆脱其狭隘性的迹象。其中之一就是Unix开源社区似乎开
始融入被称为“敏捷编程”12的远动。我们在第4章注意到，Unix程序员已经愉快地抓
住了重构的概念，那就是敏捷编程思想的重点之一。
    重构，以及其它的敏捷编程概念，例如单元测试和围绕情景设计，似乎清晰地说明
和突出了那些迄今已经在Unix传统广泛但隐性流传的实践。另一方面，Unix传统可以
给敏捷编程带来长期经验的积累和教训。随着开源软件不断获得市场份额，可以想象这
些文化将会融合在一起，如同过去互联网和早期Unix文化在1980年后的融合一样。
20.6信任的理由
    Unix的未来充满难题。我们确实想让它走好吗？
    三十多年来，我们在应对挑战中兴盛起来。我们开拓了软件工程中最好的实践。我
们创造了今天的互联网和万维网。我们编制了有史以来最庞大、最复杂、最可靠的软件
系统。我们打破了IBM的垄断，我们正在开展反对微软霸权的运动，并且已经深深地震
慑了它。
12更详细的敏捷编程介绍，参考《Agile Manif est。》（敏捷宣言）<http：／／agilemanifest。，。rg／>
    UNI×编rkc:艺术
    www.pdf365.com
478
第20章未来：危机与机遇
    而无论如何，胜利并不是全面的。在1980年代，我们同意专有权对Unix的占领，
这几乎毁了我们自己。长期以来，我们忽视了低端市场，忽视了非技术的终端用户，因
此让微软钻了空子，大幅度地降低了软件的质量标准。甚至精明的观察家多次断言我们
的技术、我们的社区、我们的价值死亡了。
    但我们总是可以重振旗鼓地王者归来。我们犯了错，但我们从错误中汲取了教训。
我们的文化薪火相传：我们已经从早期的学院黑客、ARPANET实验者、微机狂热者以
及其它许多文化中汲取了精华。而开源运动已经复兴了我们早年的激情和理想，今天，
我们的力量，我们的规模将远胜过去。
    迄今为止，打赌Unix玩家会输的人总是聪明一时糊涂一世。我们能赢——只要我们
想赢。
www.pdf365.com
附录A
缩写词表
Glossary of Abbreviations
API
The most important abbreviations and acronyms Uksed in the main text are defined here.
本书中最重要的简称和缩写定义如下。
Application Programming Interface（应用编程接口）。同可链接程序库或操作系统内
核或两者通信的过程调用集。
BSD
    Berkeley System Distribution;也作Berkeley Software Distribution;名字具体来源已不
可考。在1976到1994年之间，由加利福尼亚大学伯克利分校计算机科学研究组发布的
Unix版本统称为此，许多开源Unix都从此继承而来。
CLI
    Command Line Interface（命令行界面）。有些人认为太陈1日了，但在Unix世界仍然
很有用。
CPAN
    Comprehensive Perl Archive Network。<http：//cpan．org/>，Perl模块和扩展的
网络中心库。
GNU
    GNU's Not Unix （GNU不是Unix）!自由软件基金的项目，原意是开发一个Unix昀
克隆版本，但完全自由的软件；GNU是其递归的缩写名。这个项目并没有取得完全成功，
但是产生了许多现代Unix开发的基本工具，包括Emacs和GNU编译器集（GNU Compiler
Collection，GCC）。
www.pdf365.com
480
附录A缩写词表
GUI
    Graphical User Interface（图形用户界面）。应用程序界面的现代风格，与老式CLI
或roguelike风格不同，使用鼠标、窗口及图标，由Xerox PARC中心在1970年代创造。
IDE
    Integrated Development Environment（集成开发环境）。代码开发的GUI工作台，功
能包括符号调试器、版本控制以及数据结构浏览。在Unix下通常并不使用，原因在第
15章讨论过。
IETF
    Intemet Engineering Task Force（互联网工程任务组）。负责定义诸如TCP/IP之类互
联网协议的实体。一个松散平等的组织，主要由技术人员构成。
IPC
    Inter-Process Communication（进程间通信）。独立地址空间运行进程的数据传输方
法。
MIME
    Multipurpose Internet Mail Extensions（多用途互联网邮件扩展）。一系列的RFC，描
述了在RFC-822邮件中内嵌二进制和multipart信息的标准。除了使用在邮件传输之外，
MIME也被一些重要的应用协议（如HTTP和BEEP）作为基础使用。
00
    Object Oriented<面向对象）。一种编程风格，将处理的数据和处理数据的代码封装
在一种称作对象的闭合容器内。相比之下，非面向对象编程更容易暴露内部的数据结构
和代码。
OS
    Operating System（操作系统）。机器的基础软件；完成任务调度、分配存储空间以
及在应用程序之间提供默认的用户界面。操作系统提供的功能及其一般性的设计哲学，
强烈影响着围绕其宿主机而成长起来的编程风格和技术文化。
PDF
    Portable Document Format（可移植文档格式）。控制打印机和其它成像设备的
PostScript语言，设计来将数据流输出给打印机。而PDF是一系列的PostScript页，并包
入标记描述，可以方便作为显示格式使用。
www.pdf365.com
附录A缩写词表
481
PDP-11
    Programmable Data Processor l l（可编程数据处理器11）。可能是历史上最成功的单一
大型机设计；于1970年首次发布，1990年结束发布，并且是VAX的直接祖先。PDP-lI
是第一款主要的Unix平台。
PNG
    Portab】e Network Graphics（可移植网络图形）。万维网联盟（The World Wide Web
Consortium）的位图图形图像标准和推荐格式。这是二进制图像格式的一个优雅设计，
曾在第5章讨论。
RFC
    Request For Comment（请求评注）。一个互联网标准。当其文档作为提议被提交、
处于某种目前虽不存在但期望的正式承认过程时，就称为RFC。而正式的承认过程从未
实体化。
RPC
    Remote Procedure Call（远程过程调用）。使用IPC方法，试图创造～种错觉，进程
间互相交换数据就像是在同一地址空间，这样可以方便地（a）共享复杂的数据结构，和（b）
就像函数库互相调用一样，忽略时延和其它的性能考虑。想维持这种错觉异常困难。
TCP/IP
    Transmission Controj Protocol/lnternet Protocol（侍输控制协议／互联网协议）。自1983
年从NCP（网络控制协议）转变而来的互联网基本协议。提供可靠的数据流传输。
UDP/IP
    Universal Datagram Protocol/lnternet Protocol（通用数据报协议／互联网协议）。提供小
型数据包的不可靠低迟延传输。
UI
    用户接口（界面）。
VAX
    正式名称Virtual Address Extension（虚拟地址扩展）：由DEC（后来同Compaq合
并，再后来又与HP合并）开发的经典大型机设计。VAX第一次发布是在1977年。1980～
1990年间，VAX是最重要的Unix平台之一。针对微处理器的再实现正在开发中。


附录
贡献
Contributors
     Anyone who has attended a USENIX conference in a fancy hotel can tell you that a
sentence like "You're one of those computer people， aren't youl" is roughly equivalent to
"Look， another amazingly mobile form of slime mold.t" in the mouth of a hotel cocktail
waitress.
    只要在大饭店参加过会议的人就会跟你说这么一句：  “你是搞计算机的，不是吗？”
基本上等同于酒店鸡尾酒会女招待嘴里的“瞧，粘土人还能动呢！’’
- Elizabeth Zwicky
Ken Arnold是创造4BSD Unix发布版的成员之一。他编写了最初的curses（3）库，也
是最初的rogue（6）游戏作者之一。他也是Java Reference Manual （Java参考手册）的合作作
者之一，是Java和00技术的头牌专家之一。
Steven M. Bellovin于1979年在北卡罗莱纳大学创造了Usenet（]司Tom Truscott祁Jim
Ellis）。在1982年加入AT＆T贝尔实验室，在那里，他完成了安全领域、密码系统、以
及Unix系统和其它操作系统网络的前沿研究。他是互联网工程任务组的积极成员，以及
美国国家T程院（ National Academy of Engineering）的成员。
    Stuart Feldman是Bell实验室Unix开发组的成员之一。他编写了rnake（1）和f77（1），
他现在是IBM负责计算研究的副总裁。
Jim Gettys laJ Bob Scheifler、Keith Packard -起，是1 980年代晚期X窗口系统的主
要架构者之一。他编写了X库的相当部分，编写了X许可证，以及清晰地指出了“机制
而不是策略“的X设计中心信条。
www.pdf365.com
O  者
496
附录C贡献者
    Steve Johnson编写了yacc（1），并用它编写可移植C编译器（Portable C Compiler，
PCC），从而取代了最初的DMR C编译器，成为后来Unix C编译器的鼻祖。
    Brain Kernighan已经是Unix社区良好风格的最好诠释者。他已经编著或合著了好
几本不可或缺的、关于Unix传统的经典作品，包括《The Practice of Programming（编程
实践）》、《The C Programming Language （C编程语言）》、《The Unix Programming
Environment （Unix编程环境）》。在Bell实验室时，他合作开发了awk（l）语言，并在troff
系列工具的开发中发挥了主要的作用，包括eqn（l）（同Lorinda Cherry合编），pic（l），
以及grap（l） （Jon Bentlev）。
    David Kom编写了Korn shell，在风格上，是几乎所有现代Unix shell设计的先驱。
他创造了UWIN，为被迫使用Windows者设计的Unix模拟器。David也在文件系统和移
植工具的设计研究中有相当成就。
    Mike Lesk是Bell突验室最初Unix研究组的成员之一。除了许多其它的贡献以外，
他还编写了ms宏命令包，tbl（）和refer（l）字处理工具，lex（I）词法分析生成器，以及
UUCP  （Unix-to-Unix copy program）。
    Doug Mcllroy在贝尔实验室领导创造了Unix的研究组，发明了Unix管道。他编写
了spell（1）、diff/l）、sort（】）、join（1）、tr（1）以及其它经典的Unix工具，同时帮助定义了
Unix文档的传统风格。他也在存储分配算法、计算机安全以及数学定理自动证明方面做
出了开拓性的工作。
    Marshall Kirk McKusick实现了4.2BSD快速文件系统，并且是Berkeley Computer
Systems Research Group （CSRG）的计算机机研究科学家，亲历了4.3BSD和4.4BSD的开
发和发布。
    Keith Packard是最初XII代码的主要贡献者。在1999年开始的第二阶段开发中，
Keith重写了X的渲染代码，使其性能更强而体积大幅减少，从而可用于手持电脑和PDA
中。
    Eric S．Raymond自从1982年就一直在编写Unix软件；在1991年，编辑了《The New
Hacker's Dictionary（新黑客字典）》，并一直从历史和人类学角度研究Unix社区和互联网
黑客文化。在1997年，这个研究产生了《The Cathedral and the Bazaar（大教堂和集市）》，
帮助定义（或重新定义）和激发了开源运动。他现在维护着三十多个开源软件项目以及
十几个关键的FAQ文档。
www.pdf365.com
附录C贡献者
497
    Henry Spencer是1970年代Unix走出Bell实验室时第一次拥抱Unix浪潮中程序员
的领袖。他的贡献包括公共域的getopt（3），第一款开源的字符串处理函数库，以及使用
在4.4BSD、后来作为POSIX标准参考的开源正则表达式引擎。他也是著名的C语言专
家。他是C News的合作者，而且多年来都一直是Usenet的理性之声以及最受尊敬的老
常客。
Ken Thompson发明了Unix。
UNIX编程艺：术
  www.pdf365.com
www.pdf365.com
附录D
无根的根：无名师的Unix心传
Rootless Root: The Unix Koans of
Master Foo
编者导言
    《无根的根》这部心传的收录集在西山纯净的空气中得以保存数十年，它的发现在
学术圈中掀起轩然大波。这些出土文稿是否为早期Unix教义的新发现？抑或仅是后世高
明的赝品？那些半神秘的人物，像尊者Thompson、Ritchie和Mcllroy，是否以此发展出
我们所处时代的教义？
    答案无法确知。各方争论均被收入那本经典之作，  《编程之道》（The Tao of
Programming）.1但是《无根的根》在论调风格上都与那本James松散诗化的逸闻译作有显
著差异，所有一切都围绕着卓越而谜…般的无名师。
1  The Tao of Programming可查看网页<http：／/www．canonical．org/-kragen/tao-of -
programming．ht ml>.
UNIX编程艺：术
  www.pdf365.com
500
附录D无根的根：无名师的Unix心传
    把AI Koans（AI心传）与之相提并论颇为恰当；2在AI Koans中也可发现《无根的根》
作者的着笔痕迹。它和Loginataka（箴言剧）也有密切关联：3实际上，  《无根的根》和
Loginataka大有可能是出自一人之手笔，此人正是无名师。
    Tales of Zen Master Greg（禅祖Greg传说）也值得～说，4对“九寸钉”的引用已经使
人对其古老程度产生怀疑，它对《无根的根》影响微乎其微。
    毫无疑问，可以认为标题借鉴了Mumon的禅宗经典读物5《无门之门》（The Gateless
Gate）。数个心传都可看作是对Mumon的回应。
    无名师应该归于东派（New Jersey）还是西派（尊者Thompson往Berkeley的划时代之
旅）。如果不能回答这个问题，我们甚至也许无法宣称无名师确实存在。它也许只是一群
教师，也许是一批达摩尊者。
    即使把无名师的传说附会在单独的人身上，那他最看重的学生Nubi怎么办？Nubi
是个有血有肉的形象，是个完美的门徒。也许有人会想起佛祖最喜爱的追随者阿难达的
传说，但他的性格特质在神话传说中并没留下痕迹，而佛祖也是永恒的谜。
    最络，我们可做的便是讲述故事的本原，抽丝剥茧，挖掘其中真意。
    《无根的根》还在编写之中，素材的整理和解释都是难题。难题解开后，将被收录
到未来版本中。
2  AIKoans  可  查  看  网  页  <ht tp：／／www．catb. org/-esr/j argon/html/Some-AI
-Koans．html>.
3 The Loginataka可查看网页<http：／/www．catb. org/-esr/faqs/loginataka．html>.
4 Tales of Zen Master Greg可查看网页<http：／／www - gu．uwa．edu．au/users/greg/>．
5'IheGateless  Gate  可查看网页<hLtp：／／www．ibibli。，。rg/ zen/cgi-bin/koan
-index．pl>.
www.pdf365.com
附录D无根的根：无名师的Unix心传
501
无名师与万行码
无名师曾对来访的程序员说：“Unix传统上认为，一行shell脚本胜过万行C程序。”
这个程序员自以为对C极其精通，说：  “这不可能。Unix内核正是用C实现的。”
    无名师回道：  “确是如此。不过，Unix传统上认为，一行shell脚本胜过万行C程
序。”
    程序员颇为沮丧：“但是在C中我们可领会到尊者Ritchie的智慧。我们与操作系统
和机器合而为一，可以获取无与伦比的性能。”
    无名师回道：  “诚如你言。不过，Unix传统上认为，一行shell脚本胜过万行C程
序。”
    程序员冷笑着想愤然离去。无名师向学生Nubi颔首示意，Nubi在黑板上写下一行
shell脚本，问道：“尊敬的程序员，看看这行管道。用纯C实现，是不是要一万行C代
码？”
    程序员沉吟念诵。最终他承认如此。
    “你需要多长时间来实现和调试那个C程序？”Nubi问道。
    “很长”，来访程序员承认。“但傻子才会干这个而不去完成更有价值的任务。”
    “那么谁更了解Unix传统？”无名师问道。“是写一万行代码的，还是看到任务的
无谓而不去编码的？’’
    听到此，程序员眼中一亮。
UNIX编程艺术
  www.pdf365.com
502
附录D无根的根：无名师的Unix心传
无名师与脚本狂
    无名师和学生吃早饭时，从黑客大陆来了个陌生访客。
    “I hear y00 are very l33t，”他说。“PI33z teach m3 all y00 know”。（我听说你很牛，
请把你会的都教给我。）
    无名师的学生面面相觑，都没听懂这类粗鄙言语。无名师微笑道：“你想弄懂Unix?”
    “1 want to b3 a wizard haxOr"，陌生人回答，  ‘‘and Own ever30ne's bOxen。”（我想
当个顶尖黑客，能掌握所有人的机器。）
    “我不教这个’’，无名师答道。
    陌生人很激动。“DOOd，y00 r nothing but a pOser”，他说。“If y00 n00 anything，y00
wud t33ch m3。”（哥们儿，敢情你没真本事啊，你要知道点儿东西就教给我了。）
    “有条路，”无名师说，  “可以将你带入真知。’’他在纸上写了个IP地址。“黑掉
这台机器，这对你来说应该不费什么力气，它的管理员不称职。回来后告诉我你发现了
什么。”
    陌生人鞠了一躬就离开了。无名师把他的早饭吃完。
    几天过去了，几个月过去了。没人再想起陌生人。
    数年过去了，黑客大陆来的陌生人回来了。
    “你混蟹！”他说，  “我黑掉了那台机器，你说的没错，太容易了。但是我被FBI
抓起来扔进监狱了。”
    “好”，无名师说，“你可以继续下一课了。”他在另一张纸上写了个IP地址交给
陌生人。
    “你疯了？”陌生人喊道。  “经过这事，我再也不黑别人的机器了。”
    无名师脸现微笑。“这里就是”，他说，  “真知的开始。”
    听到此，陌生人眼中一亮。
www.pdf365.com
附录D无根的根：无名师的Unix心传
503
无名师的双路论
    无名师如是教导学生：
    “达摩教义有条准线，这在尊者Mcllroy的符咒“做一件事并做好”中得到体现。
它强调软件应当具有简单一致的行为，这符合Unix惯例，人和其它程序便都很容易想象
其心理模型。
    “但达摩教义还有另一条准线，体现在尊者Thompson的符咒“有怀疑，用穷举’’
中，很多经文都教导我们现在得到的90%，比等不来的100%更有价值。它强调实现的健
壮性和简单性。
    “现在告诉我：什么程序符合Unix传统？”
    想了一会儿后，Nubi沉思道：
    “老师，这些教义有冲突。”
    “简单的实现往往对边缘情况有欠考虑，比如资源耗竭、无法关闭竞争窗口以及在
未完成事务中超时等等。”
    “发生边缘情况时，软件行为往往不规律、难以猜测。这当然不是Unix传统。”
    无名师颔首同意。
    “另一方面，大家都知道精巧的程序很脆弱。更进一步说，每个对边缘情况的修正
往往牵扯到程序的核心算法，还牵扯处理其它边缘情况的代码。”
    “于是，对边缘情况防患于未然、确保描述的简单性，反而会使得代码过分复杂、
bug成堆、根本无法发售。这当然不是Unix传统。”
    无名师颔首同意。
    “那么，什么是正确的达库道？”Nubi问道。
UNI×编程艺．术
  www.pdf365.com
504
附录D无根的根：无名师的Unix心传
    无名师说：
    “当鹰飞翔时，它忘记爪子与地面相触？当虎捕食时，它忘记腾空的一刻？VAX只
重三斤！”
    听到此，Nubi眼中一亮。
www.pdf365.com
附录D无根的根：无名师的Unix心传
505
无名师与方法论
道。
无名师和学生Nubi在圣地行走，无名师习惯在晚间为城市和乡村的Unix新门徒布
一次，聆听者中混入了一名方法论者。
    “优化程序时不对热点进行反复衡量，就像渔夫把网撒入空湖中。”无名师说。
    “那么，”方法论者说，  “管理资源时不持续地衡量你的产能，不也像渔夫将网撒
入空湖中么？”
    “我一次碰到一个渔夫时，他正将网撒入船下的湖中，”无名师说，  “他摸了好一
会儿船底，像在寻找他的船。”
    “但是，’’方法论者说，  “如果他把网撒入湖中，为什么还要找船呢？”
    “因为他不会游泳。”无名师答道。
    听到此，方法论者眼中一亮。
UNIX编I程艺．术
www.pdf365.com
506
附录D无根的根：无名师的Unix心传
无名师的GUI论
    一晚，无名师和Nubi参加一个程序员的探讨会。有个程序员问Nubi和他的老师来
自哪所学校。当得知他们是Unix大道的追随者时，程序员颇为不屑。
    “Unix命令行工具太粗糙太落后”，他讥讽道。“现代的、设计得当的操作系统可
以在图形用户界面中做任何事情。”
    无名师一言不发，只是指着月亮。旁边的一条狗对着他的手狂吠。
    “我不明白。”程序员说。
  无名师依然缄默，指着一幅佛祖像，然后又指着一扇窗。
  “你想说什么？”程序员问。
  无名师指着程序员的头，接着指着一块大石。
  “请把话说清楚！’’程序员要求道。
  无名师深深蹙眉，轻拍程序员的鼻子两下，把他扔到旁边的垃圾箱中。
  程序员试图从垃圾堆挣扎出来之时，那条狗跑过来在他身上便溺。
  此时，程序员H艮中一亮。
www.pdf365.com
附录D无根的根：无名师的Unix心传
507
无名师与Unix狂
…个Unix狂热者听说无名师掌握Unix大道真知，便跑来求教。无名师对他说：
    “当尊者Thompson发明Unix时，他并不理解它。随后他理解了，受益了，不再发
明了。”
    “当尊者Mcllroy发明管道时，他只知道它将传递软件，并不知道它能传播思想。”
    “当尊者Ritchie发明C时，他将程序员放到缓冲溢出、堆损坏和烂指针bug的地域
中惩罚。”
    “说实话，这些尊者既瞎又蠢！”
    狂热者对无名师的用词极为愤怒。
    “这些智者”，他抗议道，“给了我们Uriix的大道。我们嘲笑他们，就是混淆是非，
比转世为牲畜和MCSE还不如。”
    “你的代码全无污点和缺陷？”无名师问。
    “不，”狂热者承认，  “没人不犯错。”
    “这些尊者之智，’’无名师说，  “就是J，解自身之愚。”
    听到此，狂热者眼中一亮。
UNIX编}程艺术
  www.pdf365.com
508
附录D无根的根：无名师的Unix心传
无名师的Unix传统论
一学生对无名师说：  “我们听说SCO公司把握着纯正的Unix。”
无名师领首。
学生继续说，  “我们还听说OpenGroup公司也把握着纯正的Unix。
无名师颔首。
“这怎么可能？”学生问。
无名师答道：
    “SCO确实把握着Unix源码，但是Unix的源码不是Unix。OpenGroup确实把握着
Unix的名称，但Unix的名称不是Unix。’’
“那么，什么是Unix传统？”学生问。
无名师答道：
“非源码。非名称。非思想。非实物。恒变，不变。”
“Unix传统是简单和空。正是简单，正是空，才使得它更强胜飓风。
    “以自然法则前行，‘在程序员手中，吸纳各种优良设计。与之竞争的软件最终必与
之相像；空，空，真空，虚无，万岁！’’
    听到此，学生眼中一亮。
www.pdf365.com
附录D无根的根：无名师的Unix心传
509
无名师与最终用户
    无名师又一次布道时，一个最终用户听说了他的智慧，跑来求教。
    他对无名师三鞠躬。“我欲学习Unix大道，”他说，  “但是弄不懂命令行。”
    一个旁观的新门徒开始嘲讽最终用户，说他脑子一锅粥，说只有经训练者、有智慧
者才配使用Unix。
    无名师抚手不语，命这个嘲笑最终用户的新门徒前坐，坐到最终用户身边。
    “告诉我，”他对新门徒说，  “你写过什么代码，有过什么突出设计。”
    新门徒嗫嚅了两句，然后沉默了。
    无名师转向最终用户。“告诉我”，他问，  “为何你要寻求大道？”
    “我用的软件并不能令我满意”，最终用户答，  “既不稳定，也不美观。听说Unix
之道尽管艰难，但超越一切，我愿抛去～切诱饵和虚像。”
    “那么，”无名师问，  “你为何想尽办法让软件帮你做事？”
    “我是个建筑工”，最终用户答道，  “这座城里的很多房屋都出自我手。”
    无名师转向新门徒。“家猫也能欺负老虎”，无名师说，  “但是猫叫永远比不过虎
吼。”
    听到此，新门徒眼中一亮。


    大多数译序是给作者说好话，顺便带动一下译本销量的，本篇是一个例外。
    《The  Art of UNIX Programming》，简称TAOUP，作者Eric S．Raymond，简称ESR。
这大概是计算机类书籍中很少见的一本课外读物。TCP/IP编程之类典型Unix编程书中
讲到的东西在这本书里面找不到，所以书里讲到的当然就是别的书里找不到的东西。读
者也许需要有相当的Unix背景、或者长期钻研某个专题，才能体会到作者的弦外之音。
ESR作为老牌黑客信手拈来的典故，如果不是在Unix里面长期浸淫，大概很难有所共鸣，
所以把这当作Unix的一部坊问史话倒也合适。
    本书总结了历史上Unix众多成功的经验和失败的教训、经时问考验和临时搭救的编
码策略、大众喜爱和小众受用的实用工具：一些被跨国界信仰地广泛接受，一些则在不
rIIJ环境中各有见地。被TAOUP总结为失败的，也许恰恰是某些工程的保命神药：总结
为成功的，也许正好是压垮另一些工程的最后一根稻草。情景各异而已。书是写给程序
员看的，因此很多观点都太过技术昧儿，比如所见即所得的编辑器不如手写标记的纯文
本更直接-90%的人会想：这怎么可能？！
    这本书是给读者增长见讽的，很多案例分析不管结论如何，读者都可以从中见到红
蓝两方的思维方式和行事方法，以及各方高手看待问题的角度。无论成功还是失败，都
只是一念之间，而读者只需要体味出这些对自己过去的、手头的、未来的项目可以有何
种借鉴，便已得其中三昧。
    网络上关于TAOUP的书评甚多，正负反响各有不少，负面评价大体集中在认为作
者视角较窄、对商业公司有偏见以及过分抬爱自己的fetchmail几方面。我个人的感觉，
Unix、尤其是开源Unix上有太多好用的丁具极欠雕琢，目标受众太过技术。ESR并未回
避这些，读者不妨多留意为数不多的痛切之笔。
UNIX编程艺_术
  www.pdf365.com
译序
    本书翻译经历～年多的时间，之前我曾经约略翻过纸版，偶尔见到一些合我胃口的
言论，于是心有灵犀认为这书不错；然而等到译到中途，便发现ESR实在是个美国愤青，
这便是课外读物和工本教程给读者的不同感受了。翻译的过程对译者是精读的过程，但
希望读者能用它打发堵车、候机、等人时的无聊时间，这书适合从任何一篇翻起。
    翻译过程颇为艰辛：何蔡两位初译，由我统稿。书中寻章摘句之处，我们尽力将其
还原。书名保持原文并给出译名，人名不译，专有名词给出原文，特意不加入任何译注。
相关背景常识、翻译感受以及付梓后的任何问题，可以在中译版网页上与我们交流。这
一年间，侯捷老师的推荐，周筠老师、方舟和兴璐两位编辑、何蔡二位给我的莫大帮助
和宽容使得本书最终面世；身边诸位好友同事也不同程度地在各个技术方面给予指导和
支持，尤其感谢bz、主任、delphij、kola几位。我的爱人王冰陪我加班，容忍我对程序
的沉迷，给我心灵的温暖，是我翻译这本书的力量源泉。
    KISS。
    姜  宏
2005年12月于北京
www.pdf365.com
序
Preface
Unix is not so much an operating system as an oral history.
与其说Unix是个操作系统，不如说是一部口述历史。
    -NeaJ Stephenson
    知识和专能差异巨大，凭借知识可以推断出该做什么，而专能让你甚至在无意之间，
条件反射似的把事情做好。
    这本书确实有关“知识”，但更着眼于“专能’’。你将学到那些Unix专家们都不自
知的Unix开发知识。少一点技术，多一些共享文化：显见和隐微的，直观和潜流的——
这是本书和大多数Unix书籍不同的地方——不止于方法，更重乎理念。
    理念于实用大有裨益，有太多设计不良的软件：体积臃肿，难于维护、移植和扩展
——这些都是蹩脚设计的症候。我们希望本书的读者能品出什么是Unix所教示的良好设
计。
    本书分为四部分：场景、设计、工具和社群。第一部分（场景）涉及哲学和历史，
为后续内容埋下伏笔。第二部分（设计）将Unix哲学的原理细分为有关设计与实现的、
更专门的建议。第三部分（工具）着眼于Unix所提供的工具，可助你解决问题。第四部
分（社群）则讲述人与人之间的事务与约定，而这正是Unix文化拥有高效能的原因。
    这本书是关于共享文他的，我从未想像过独自完成它。你会发现正剧中包含数位Unix
资深专家的客串演出，正是这些人塑造了Unix的习俗。本书曾有过公开大范围的审阅过
UNIX编腥艺．术
  www.pdf365.com
序
程，这期间我邀请这些明星人士对书稿进行评审与研论。这些意见没有湮没在本书定稿
中，而你可以在书中聆听到他们的真实声音：无论是为本书呐喊助阵、还是摇头反对。
    本书中用到人称“我们”时，我并不是虚张声势，仅以此说明这是整个社群都清楚
明了的事实。
    因为本书着力传递文化，因此加入了很多野史和坊间传说，这在技术书中并不多见。
希望你喜欢，这些东西其实是Unix程序员的教养。须弥不重，芥子不轻。我们希望以这
种方式更好地讲述故事。了解Unix的由来和变迁，会培养你对Unix风格的直觉。
    同样地，基于此，我们不打算使用回述历史的腔调。你会发现本书参考了众多时下
信息。我们不希望给你一种错觉：书里说的都是亘古不变的终极真理。参考时下的信息
这一做法，也提醒读者，三十年河东，三十年河西，眼前所见，也许过不了多久就会过
时，而需要重新检省。
    另外，本书不是C教程，不是Unix命令和API的手册，不是sed/yacc/Perl/Python
的语言参考，也不是网络编程入门，更不是巨细靡遗的令人费解的X指南。本书也不打
算带你巡游Unix内幕和体系。有很多其它的好书涵盖这些领域，本书会在适当的时候告
诉你该看哪些。
    在这些技术细节外．Unix文化有一个未见诸笔端的行工传统，以熟练工的考量，它
已经有几百万人年的发展1。本书即立足于这样一个信念：领会此传统，并将它的设计手
法应用到手边，你将成为更好的程序员和设计师。
    构成文化的是人，一直以来，获知文化的方式大约是口口相传、潜移默化。本书不
打算取代人际的文化传播，但可以促进这一过程，使你能俯耳倾听他人的心声。
1从1969到2003年，35年时间可不算短。以这期间Unix站点数量的年度曲线计算，人们在Unix
上耕作了约有5000万人年。
www.pdf365.com
序
谁应该看这本书
    如果你是个Unix编程老手，经常教导菜鸟，或者与人进行操作系统论战时无法阐明
使用Unix方案所带来的好处时，可以看看这本书。
    如果你是个C、C++或者Java程序员，有其它操作系统的开发经验，现在轮到你开
展一个Unix项目时，可以看看这本书。
    如果你是个初级或者中级水平的Unix用户，但是没什么开发经验，想学习在Unix
下如何高效地设计软件时，可以看看这本书。
    如果你不在Unix下编程却发觉Unix的传统给你带来某种启迪，那你就对了，Unix
哲学适用于其它的操作系统。因此我们会花比其它Unix书籍更多的篇幅关注非Unix环
境（特别是微软的操作系统）；当所用到工具或者案例可用于其它操作系统时，我们会
告诉你。
    如果你是一个系统架构师，正为通用市场或垂直应用准备平台方案或实现策略时可
以看看这本书。本书将帮助你了解Unix作为开发平台的强大功能，以及开放源码这个
Unix的传统所带来的开发方式。
    如果你想学到C编程的细节或者想知道怎么用Unix内核API，本书可能不适合你。
Advanced Programming in theUnix Envirortment[Stevens921是探究Unix API妁经典名著；
The Practice of Programming [Kernighan-Pike99]是每个C程序员的必读书目（任何语言的
程序员都该看看这本书）。
    这本书既重实践，更富理念：既包含警世格言，又不忘检点Unix开发中的特殊案例。
在每个警句前后，都有生动实例阐明其由来，这些例子绝不来自小儿科式的示例程序，
而均出自真实世界满眼所见的运行代码。
    我们着力避免以大量代码或者规范文件来胡乱凑数，当然这么做会让本书的写作轻
松许多（某些地方或许读起来也更轻松）。绝大多数编程书籍只授你以鱼，而本书避免
这种做法，力求培养读者“探求事情何以如此，，的感知力。
UN/X编腥艺：术
  www.pdf365.com
l∈j
坐咀
    正由于此，本书会时常请你阅读代码与规范文档，它们中极少量的内容会附在书中，
其余部分我们会在举例时告诉你如何从网上获取。
    从这些范例中汲取养分，将有助你将所学原则消化变为疱丁之技。如果你能就着一
部跑在Unix系统上的网页浏览器来读书，是再理想不过的了。任何Unix系统都适合，
但是我们将要研究的案例大多都会预装在、或者可以从Linux系统上获得，书中会提示
请你浏览或亲身感受它们。这些提示通常是按部就班的，跑开玩一会儿并不会打散整个
讲述过程的连续性。
    注意：我们虽力求，但无法给你打保票，声称我们所引用的URLs稳定可用。如果
你发现某个引用连接已陈旧过时，来点常识，用你喜爱的搜索引擎来个短语搜索。如有
可能，我们会在所引用的URLs附近给出如何搜索的提示。
    大多数缩写形式会在首次出现时伴随其全称。为方便起见，我们在附录中提供了名
词对照表。
    交叉索引通常以作者名字为主导词。带编号的脚注是那些可能会扰乱你阅读正文，
或者是易变的URLs;也可能是旁征博引的战争故事或者笑话2。
    为了使这本书不至于让非技术人员太过难读，我们邀请了一些非程序员试读，并指
出一些晦涩但起贯穿作用的词汇。我们把那些编程老手不太舍需要的名词解释也放在脚
注中。
相关引文
    一些Unix早期拓荒者的著名论文和书籍，比如Kernighan和Pike的《The Unix
Programming Environment》[Kemighan-Pike84]就是其中佼佼者，被世人尊为圭臬。而今
看来此书廉颇老矣，它没提到Intemet、万维网以及诸如Perl、Tcl和Python这些解释型
语言的新秀。
    写作本书的中途我们借鉴了Mike Gancarz的《The Unix Philosophy》 [Gancarz]。这
本书在它的覆盖范围内极其优秀，但是我们觉得需要更多内容才能反映出事情的全貌。
尽管如此我们仍对此书作者心存感激，他愈发使我们知道最简单的Unix设计手法就是最
持久耐用的。
2这个特别的脚注献给Terry Pratchett，他对脚注的用法简直是……绝了。
www.pdf365.com
l同
坐咀
《The Pragmatic Programmer》fHunt-Thomas]是一本关于良好设计的书，文风机智诙
谐，它与本书相比，倾向于软件设计工艺的另一个层面（更注重编码，而少着墨于高层
面的问题划分）。作者的哲学是其Unix领域耕耘的成果，也是本书内容极好的补充。
《The Practice of Programming》[Kernighan-Pike99]包含了一些与《The Pragmatic
Programmer》共通的内容，但更钻入Unix传统的深处。
    最后（明知道会激怒你），我们推荐《Zen Flesh，Zen Bones》 [Reps-Senzaki]，一部
重要的佛教禅宗本源的合集。对禅的引用书目遍布全书。我们将这些书目包含进来，是
因为禅为表达某种想法提供了丰富的语汇，而在软件设计中却很难烂熟于心。信奉宗教
的读者，请您不要把禅当成宗教，它是一种心灵鸡汤似的东西，纯净而没有神灵的干扰
——此即是禅。
本书的习俗约定
    术语“UNIX’’技术上和法律上讲，是The Open Group的商标，并且应该仅限于那
些通过The Open Group严格的“符合标准”认证的操作系统。奉书中我们使用其较宽松
的定义，印大多数程序员所指的，Bell实验室Unix代码的后裔或旁支。在这个意义下，
Linux（大多数例子都举自它）也算是一种Unix。
    本书也使用了Unix手册页（manual page）的传统，即以括号括起来的手册节号来标
记Unix设施。通常用于强调一个Unix命令首次出现。比如“munger（l）”可解读为“munger
程序加入存在于你的系统中，其文档位于Unix手册页的第1节”。第2节是C的系统调
用，第3节是c的库函数调用，第5节是文件格式与协议，第8节是系统管理工具。其
它节号本书未曾用到，其定义在各个Unix系统各有不同。在你的Unix外壳提示符下输
入man l man（老式的System VUnix系统可能要输入man -s l man）以获得更多信
息。
    有时我们会提及某个Unix程序（比如Emacs），后面没有手册节号而且首字母大写。
这意味这个名字代表一族Unix程序，其基本功能相同，而我们将讨论其通用特性。比如
Emacs，就包含了xemacs。
    本书很多地方我们同时给出了老式（old school）和新式（new school）解法。new-school
和rap音乐～样，开始于1990年前后。在这个含叉下，我们往往把它与脚本语言、图形
UNIX编喱；艺术
    www.pdf365.com
序
用户界面、开放源码的Unix和万维网联系起来。Old-school指代1990年以前（特别是
1985年以前）的世界：昂贵的共用计算机、专属的Unix，shell脚本和无所不在的C。值
得指出这些差异，机器越来越便宜，内存多了起来，这些有如暗流，渐渐影响着Unix编
程的风格。
所用案例
    很多编程书籍为证明某一观点而特地造出一个范例，你手中这本书不这么干。我们
的案例研究均来自真实世界，在生产环境中工作已久。下面是一些主要案例：
cdrtools/xcdroast
    这两个独立的项目通常被～并使用。cdrtools是一组刻盘工具（用关键字“cdrtools”
可以在网上找到）。xcdroast是cdrtools的图型界面前端，其项目网站为
<ht tp:／/www. xcdroast. org/>。
f etclunail
  fetchmail用于从远程邮件服务器上收信，支持POP3和IMAP邮箱协议。其主页为
<ht tp：／／www．catb．org/-esr/fetchmail>，也可以用关键字“fetchmail从网上
找到。
G工MP
    GIMP（GNU Image Manipulation Program，GNU图像处理程庠）是一个全特性的绘
画和图像处理程序，可对多种图像格式进行复杂处理。其源码可从GIMP主页
<http：／/www．gimp．org/>获得（也可以通过关键字“GIMP"从网上搜到）。
mutt
    mutt邮件客户端是目前各类基于文本的邮件客户端程序中的翘楚，提供对MIME
（Multipurpose Intemet Mail Extensions）、个人隐私辅助程序，如PGP（ Pretty Good Privacy）
和GPG （GNU Privacy Guard）等特性的绝佳支持。其源码和二进制可执行文件可以从
Mutt项目主页<http：／/www．mut七．org>获得。
xmlto
xmlto可将DocBook和其它XML文档以多种格式渲染输出，包括HTML、纯文本
www.pdf365.com
序
和PostScript。其源码和文档可在xmlto主页<http：／／cyberelk．net／tim/xmlto／>获得。
    为了将读者理解本书例子所要阅读的代码量降低到最小程度，我们尽量挑选那些可
重复使用、并能体现多种不同设计原理和设计实践的案例。出于同样原因，很多示例来
自于我本人的项目。我没想说这些例子最为恰当，只是我觉得它们对阐述我的观点非常
有用。

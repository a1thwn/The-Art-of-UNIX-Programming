
5.3应用协议设计
123
    人们一直说，真正的Unix式解决方案也许是用file （l）透过压缩看文件前缀――如
果不行，就围绕file （l）写一个shell脚本，对压缩内容执行gunzip（1）再看。
5.3应用协议设计
    我们将在第7章讨论“将复杂应用程序划分成几个协作进程、通过应用程序专用命
令集或协议通信”的优点。所有将数据文件格式设计成文本格式的好理由同样适用于应
用程序专用协议的设计。
    如果应用协议是文本式的，而且仅凭肉眼就能很容易地分析，那么很多好事情就更
容易实现了。事务转存更容易解释。测试负载也更容易编写。
    服务器进程通常由inetd （8）之类的统一控制程序（harness programs）调用，其方式是
服务器程序从标准输入中接收命令，然后将响应发送到标准输出。我们将会在第1 1章更
详细地描述这种“CLI服务器”模式。
    CLI服务器的命令集是为达到简洁性而设计的，这种服务器程序有一个可贵的特性，
就是测试人员能够直接向服务器进程键入命令来探知软件的工作情况。
    另一个需要牢记在心的问题是端对端（ end-to-end）设计守则。每一个协议设计者都
应该读一读经典的《系统设计中的端对端论》（End-to-End Arg肌ments in Svstem Design）
[SaltzerJ。人们经常会严肃地对究竟协议栈哪一层应该处理安全和认证之类的功能提出问
题。这篇文章为如何考虑这个问题提供了一些很好的概念性手段。除此以外，还有第三
个问题，就是为获得良好的性能而设计应用协议。我们将在第12章更详细讨论这个问题。
    1980年以前，互联网应用协议的设计传统一直独立于unix发展4。但自那以后，这
些传统已经完全融入了Unix实践。
    下面我们将研究三个使用最广泛，也是被广大互联网hacker看作典范的应用协议实
例：SMTP、POP3和IMAP，来说明互联网的风格。这三个协议分别致力于邮件传输（和
万维网一起构成网络最重要的两个应用）的不同方面，而所涉及的问题（传输消息、设
置远程状态、报告错误状态）对非电子邮件应用协议也颇具普遍意义，并且通常也可采
用类似的技巧来处理。
4互联网协议的行结束符通常是CR-LF，而不是Unix的单LF，这就是这段前Unix历史的遗留痕迹。
UNIX编喔艺-术
    www.pdf365.com
124    第5章文本化：好协议产生好实践
5.3.1  实例分析：SMTP，一个简单的套接字协议
例5.7是RFC 2821描述的SMTP协议（简单邮件传送协议）中的一个处理实例。在
这个例子中，C:行由发送邮件的邮件传输代理（MTA）发送，S；行由接收邮件的MTA
返回。届蝌鲈手强调的是注释，并非事务处理的实际部分。
例5.7  SMTP会话实例
C：  <client
HELO sna
250 0K H
connects to service port 25>
rk. thyrsus .com    sending  host   iden￡王fies  self  f发送主机鉴另0消息j
ello snark， glad to meet you  recei ver  acknowl edges d妾收方硼l认）
MAIL  FROM :   <esr@thyrsus . com>
250 <esr@thyrsus.com>_ Sender
RCPT  TO :  cor@cpmy _ com
250 root. . . Recipient ok
DATA
  identify sending user以鉴另0发送用户）
ok  recel ver  acknowl edges“妾收方确认J
  iden亡ify  target   user  灌别发送目标用户J
    receI ver  acknowl edges  倦收方确认j
S:  354  Enter mail，  end with  " . ii  on a  line by  itself
C: Scratch called.  He wants to share
C :  a  room  wi七h  us  aC  Balticon _
C:  .                                       end of multiline send
r多行发送结束，）
S: 250 WAA01865 Message accepted for delivery
 c：QUIT    sender signs off  （，发送方退出j
 S：  221  cpmy．com  clo-:ing  connection    recei ver  disconnects d妾收方断线）
 C：  <client hangs up>
邮件就是这样在互联网机器上传输的。注意以下特征：请求的命令参数格式，应答
由状态码和紧接其后的指示信息构成，以及“DATA”命令的有效数据部分以一个只有
单个“．”的行结束。
SMTP是互联网上仍在使用的最古老的两三个应用协议之一。这个协议简单有效
经受住了时间的考验。我们在这里重点指出的几个特征，也经常在互联网其它协议中出
现。如果说设计良好的互联网应用协议有个原型的话，那么这个原型一定是SMTP。
5.3.2  实例分析：POP3，邮局协议
男一个经典的互联网协议是POP3，即邮局协议（Post Office Protocol）。这个协议也用
T邮件传输，但是SMTP是邮件发送者启动事务处理的“推（push）”协议，而POP3
www.pdf365.com
cJ  cn C  S  u  cn C
5.3应用协议设计
125
是邮件接收者启动事务处理的“拉（pull）’’协议。不连续访问互联网的用户（如拨号连
接）可以让他们的邮件存在一个邮箱机器上，然后使用POP3连接将邮件通过网线接收
到自己的电脑上。
    例5.8是POP3会话的一个例子。其中，C:行由客户端发送，57行由邮件服务器
端发送。可以看它到跟SMTP有很多相似之处。这个协议也是文本协议，也是面向行的，
发送的有效消息部分由单点行加上行终止符结束，甚至使用同一个退出命令-QUIT。
如同SMTP，每次客户端操作都经过回复行确认，回复行以状态码开头，其中包括了可
供人眼识别的提示信息。
例 5.8   POP3会话实例
C.
o.
C.
s:
C:
（: .
o.
c:
C.
o.
<clienL connects to service por七 110>
 +OK POP3 server ready<1896.697l@mailgate.dobbs.org>
 USER bob
 +OK bob
 PASS redqueen
 +OK bob's maildrop has 2 messages （320 0c七e七s}
 STAT
 +OK 2 320
 LIST
 +OK 2 messages （320 0ctets）
 1 120
 2 200
 RETR I
 +OK 120 0ctets
<the POP3 server sends  the text of message l>
DELE I
+OK message l deleted
RETR 2
+OK  200  0ctet s
<tha POP3 server sends the texL of message 2>
DELE 2
+OK message 2 deleted
QUIT
+OK dewey POP3 server signing off （maildrop empty）
C:  <client hangs up>
www.pdf365.com
（-J  S U S u S  C  S U cn cn cn cn u cn cn S cJ cn C
126
第5章文本化：好协议产生好实践
    与SMTP有一些不同之处，最明显的区别是POP3使用状态标记，而不是像SMTP
那样使用3位数字的状态码。当然，请求的语义也不同。但是两者的族谱相似性（本章
稍后讨论通用互联网元协议时会对此详细说明）很明显。
5.3.3实例分析：IMAP，互联网消息访问协议
    为了完整展示互联网应用协议的三剑客，我们最后再看看IMAP-另一个设计风
格略有不同的邮局协议。请看例5.9:跟前面一样，C:行由客户端发送，S?行由邮件服
务器发送。用影绣宇强调的是注释，并非事务处理的实际部分。
._-______‘______一_’-^..-._-______^___Il__一
例5.9  IMAP会话实例
C:
 o.
c:
 o.
C:
 o.
 c: -
 o.
S:
Q.
o.
C:
o.
s:
c;
S:
（client connects to service porL 143>
  * OK example.com IMAP4revl v12.264 server ready
AOO01  USER   " frobozz "   "xyzzy "
  * OK User frobozz authen七icated
A0002 SELECT INBOX
 t I EXISTS
 N I RECENT
 * FLAGS （YAnswered kFlagged YDeleted YDraft kSeen）
 ~ OK jUNSEEN l] first unseen message in /var/spool/mail/esr
AU002 0K [REAIJ-WRITE] SELECT complered
A0003 FETCH l RFC822.SIZE       Get message sizes ca~#l.aM）
:Jk  I  FETCH  （RFC822 .SIZE 2545}
A0003 0K FETCH completed
A0004 FETCFl l BODY[HEADER]    Cet first message header （a―一条力争自关）
t 1 FETCH （RFC822.HEADER {1425}
<server sends 1425 0cte七s of message payload>
 s: ）
S: A0004 01< FETCH completed
（:: A0005 FETCH l BODY[TEXT]      Get first message body ca3F~.~一・一条力争蛊常j
s: :Jt l FETCH （BODY[TEXT] {1120}
<server sends 1120 0ctets of message payload>
s: t. I FETCH （FLAGS （\RecenL \Seen》
S: A0005 0K FETCH completed
C :  A0006  LOGOUT
 S: 7k BYE examplecom IMAP4revl server terminating connec七ion
 S: A0006 0K LOGOUT completed
 C:  <clianc hangs up>
www.pdf365.com
5.4应用协议元格式
127
    IMAP对有效载荷部分的分隔方法略有不同，它不是用一个点号来结束，而是将有
效载荷的长度直接放在有效载荷之前发送。这稍稍增加了服务器的负担（消息必须提前
完成组合，无法在初始化后流转），但使客户端工作更容易了――客户端可以提前知道
需要分配多少存储空间作为整个处理消息的缓冲区。
    同时，应注意，每个响应都标上了由请求提供的序列标签，本例中这个标签的形式
为AOOOn，但客户端也可以在这个位置上生成任何其它标记。这个特性使IMAP命令无
需等待响应就可以流向服务器端；然后客户端的状态机就能够在数据回来时直接解析响
应和有效数据载荷。这样可以减少等待时间。
    IMAP（为取代POP3协议而设计）是一个成熟而强大的互联网应用协议的优秀设计
典范，值得学习和效仿。
5.4应用协议元格式
    就像数据文件元格式是为了简化存储的序列化操作而发展出来一样，应用协议元格
式是为了简化网络间事务处理的序列化操作而发展出来的。但在这种情况中采取的折衷
略有不同：因为网络带宽要比存储昂贵得多，所以需更加重视事务处理的经济性。尽管
如此，文本格式的透明性和互用性优势仍然十分显著，所以大多数设计者还是抵制住了
牺牲可读性未优化性能的诱惑。
5.4.1  经典的互联网应用元协议
    Marshall Rose的RFC 3117《论应用协议的设计》  （On the Design of Application
Protocols）5很好地概括了互联网应用协议设计中的种种问题。它明确了我们在分析
SMTP、POP和IMAP时所注意到的一些经典互联网协议的描述手段（ trope），：并对其
进行了具启发意义的分类。推荐大家一读。
    经典的互联网元协议是文本格式，使用单行请求和响应，但有效数据载荷可以多行。
有效数据载荷要么是8位组数据作为前导，要么以“\r\n’’行作为结束符。在后一种情
况下，有效数据载荷在字节上已被补齐；所有以句点“．”开始的行前面需要另加一个句
5刖L< ftp：／／ftp．rfc-editor．org/ in-notes/rfc3117．七x七>处参阅RFC3117。
UNl×编羁量艺-术
  www.pdf365.com
128
第5章文本化：好协议产生好实践
点，接收方既负责识别结束符又负责去除补齐字节。应答行由状态码和后接人可识别的
消息构成。
    这种经典风格的关键优势是可以随时扩展。解析器和状态机框架无需太多修改就能
够适应新的请求，而且代码也容易编写，使其可以解析未知请求并返回错误信息或直接
忽略这些未知请求。SMTP、POP3和IMAP在使用过程中都经历了相当频繁的小扩展，
互用性问题极少。相比之下，那些设计比较简单的二进制协议，却以不耐用而臭名昭著。
5.4.2作为通用应用协议的H丌P
    自从万维网在1993年左右吸引到足量用户以来，应用协议的设计者已经越来越倾向
于在HTTP上构建专用协议，并使用网页服务器作为通用服务平台。
    这是一种可行的方案，因为在事务层上，HTTP非常简单和通用。HTTP请求采用类
似RFC-822/MIME格式的消息：通常，消息头包含识别和认证信息，第一行是对通用资
源指示符（ URI）指定的某个资源的方法调用。最重要的方法是GET（获取资源）、PUT
（修改资源）和POST（将数据发送给某个表单或后端进程）。URI最重要的形式是URL，
且口统一资源定位符（ Uniform Resource Locator）；URL通过服务类型、主机名称和在主
机上的位置对资源进行识别。HTTP响应只是一种RFC-822fMIME消息，可以包含由客
户端解释的任意内容。
    网页服务器处理HTTP的传输和请求多路复合层，同时也处理标准的服务类型，如
http和ftpo要编写可以处理自定义服务类型的网页服务器插件相对比较容易，也很容易
分派URI格式的其它元素。
    除了避免很多底层细节之外，这种方法也意味着应用协议可以通过标准的HTTP服
务端口，不需要自身的TCPfIP服务端口。这成为一个非常显著的优势：大多数防火墙都
开放80端口，而试图穿透其它端口则可能遇到技术上和政治上的困难。
    风险也伴随这种优势而来：这意味着网页服务器和插件会越变越复杂，任何这些代
码的破解都可能带来巨大的安全问题。要隔离并关闭出问题的服务也可能会更加困难。
通常此时就要在安全和便利间做出折衷。
www.pdf365.com
5.4应用协议元格式
129
    RFC 3205《论使用HTTP作为底层》  （On the Use of H7TP As dSubstrate）6向正在
考虑将HTTP作为应用协议底层使用的人提出了很好的设计建议，文中还总结了各种权
衡方案和所涉及的问题。
5.4.2.1实例分析：CDDB/freedb．org数据库
    音频CD由一序列称为CDDA-WAV的数字格式音轨组成。在一般计算机拥有足够
速度和声音处理能力来实时解码之前几年，音频CD是为让简单消费型电子产品能够播
放而设计的。正因为如此，它没有提供相应的格式来记录甚至非常简单的一些元信息，
如唱片专辑和歌曲音轨标题等。但是现代计算机中的CD播放器需要这些信息，这样用
户可以整理和编辑播放列表。
    连上互联网，网上有（至少两个）资料库可提供根据CD上音轨长度表计算出的散
列码与艺术家／专辑名／音轨名之间的对应记录。最初的一个资料库是cddb．org，但另一
个名为freedb．org的站点也许现在资料更完整，用的人也更多。随着新CD的不断推
出，这两个站点都依靠用户来完成更新数据库的巨大任务。当CDDB决定将用户提供的
所有信息都收为专有后，作为开发者的反抗，f reedb．org友展了起来。
    对这些服务的查询本可以作为基于TCP/IP的自定义应用协议来实现，但是那样就要
求采取以下步骤，如给它分配一个新的TCP/IP端口号，还要为它费力地从成千上万的防
火墙上争取到通路。为了避免这些麻烦，该服务基于HTTP作为简单的CGI查询来实现
（就好像CD的散列码是用户通过在网页上填表提供的）。
    由于作了这种选择，所有现行各种编程语言的HTTP和Web访问程序库的基础代码
都可以支持数据库的查询和更新。结果，在CD播放器中增加这样的支持功能几乎不费
吹灰之力，而实际上现在每款CD播放软件都知道如何使用这些功能。
5.4.2.2实例分析：互联网打印协议
    互联网打印协议（IPP，Internet Printing Protocol）是一个非常成功、被广泛采用的网
络访问打印机控制标准。指向RFC的链接、各种实现和大量的其它相关材料都可以在
IETF的打印机工作组站点<http：／/www．pwg．org／ipp／>获得。
    IPP使用HTTP l.1作为传输层。所有的IPP请求都通过HTTP POST方法调用发送；
响应是普通的HTTP响应。（《互联网打印协议模型和结构基本原理》（Rationale for the
Structure酊the Model and Protocolfor the Internet Printing Protocot），RFC 2568程龟4.2 j矗
6参见 RFC 3205<ht七p : / /www . faqs . org/rfcs/rfc3205 . html>。
UNIX#j程艺|求
    www.pdf365.com
130
第5章文本化：好协议产生好实践
很好解释了做出这种选择的理由，值得正在考虑编写新应用协议的所有人员研究）。
    在软件方面，HTTP l.l得到了广泛应用。HTPP l.l已经解决了许多传输层问题，不
然，这些问题将使协议的设计者和实现者无法集中精力解决打印的域语义问题。HTTP l.1
能够很干净地进行扩展，因此IPP还有足够的发展空间。人们非常熟悉处理P（）ST请求
的CGI编程模型，开发工具也很丰富。
    大多数具有网络能力的打印机已经内置了网页服务器，因为这是能人工远程查询打
印机状态的一个自然的方法。这样，向打印机固件增加IPP服务的额外成本并不是很高。
（这一点也适用于许许多多具有网络能力的硬件，包括自动售货机、自动咖啡机7和自动
澡盆！）
    基于HTTP的IPP协议的唯一严重缺点就是协议完全由客户端的请求来驱动。这样，
模型中就不存在可供打印机向客户返回异步报警信息的余地（然而，聪明的客户可以运
行一个很小的HTTP服务程序，来接收打印机发送的HTTP请求格式报警信息）。
5.4.3 BEEP：块可扩展交换协议
    BEEP（原先叫BXXP）是一种通用协议，对于通用底层这一角色来说和HTTP -样
具有竞争力。之所以谠竞争，是因为目前为止还没有一个制定较完善的元协议非常适合
真正的对等网（P2P）应用，不像客户端．服务器应用-HTTP在这一领域游刃有余。
访问<http：／/www．beepcore．org／beepcore／docs／sl-beep．j sp>项目网站可
以找到有关标准以及数种语言的开源实现。
    BEEP的特点是既支持客户端／服务器模式，又支持对等网模式（ peer-to-peer）。协
议作者们对BEEP协议和支持库进行了良好设计。这样，只要选取正确组件就能省去很
多杂务，如数据编码、流控、堵塞（congestion）处理、端对端加密支持和用多路传输组成
长应答等。
    从内部而言，BEEP用户端（peer）之间相互交换自描述二进制包序列，后者与PNG中
字节块类型非常相像。跟经典的互联网协议或HTTP相比，BEEP设计对经济性的强调
高于透明性，当数据量非常大时可能是更好的选择。BEEP也避免了HTTP所有请求都
7  参  见 RFC 2324  <ht七p://wwwietforg/rfc/rfc2324.txt>  和 RFC 2325
<http : / "www . iet f . org/rfc/rfc2325 - txt>.
www.pdf365.com
5.4应用协议元格式
13 1
必须由客户端发起的问题：在服务器端需要向客户端异步返回状态信息的情况下，BEEP
协议会更好。
    到2003年年中，BEEP仍然是一项新兴技术，只有几个演示项目。但是BEEP论文
是非常不错的关于设计最佳协议的分析材料：即使BEEP本身无法得到广泛采用，这些
论文仍然具有相当重要的指导价值。
5.4.4   XML-RPC，  SOAP ~O Jabber
    应用协议设计的一种发展趋势是在MIME中使用XML来架构请求和有效数据载荷。
BEEP用户端使用这种格式进行信道协商。有三个重要协议始终采用XML路线，包括
XML-RPC，用于远程过程调用的SOAP（Simple Object Access Protocol，简单对象访问
协议）和用于即时消息和在线状态报告（instant messaging and presence）的Jabber。这三
个协议都基于XML文档。
    XML-RPC非常具有Unix精神（其作者宣称在二十世纪七十年代通过阅读原始的
Unix源码学会了编程）。它着意追求最简化，但是仍然非常强大，对于绝大多数专为传
送布尔／整数／浮点／字符串标量数据类型的各种RPC应用提供一种方法，使它们能够以一
神轻量、易于理解和监控的方式来完成任务。XML-RPC类型实体比文本流丰富，但仍
然简单而具有移植性，可被有效地用于检查接口复杂性。它有很多开源实现。XML-RPC
主页<http：／/www．xmlrpc．com/>做得不错，提供了规格书和多个开源实现。
    SOAP是一个较重量级的RPC协议，数据类型更为丰富，包括数组和类似C的结构。
这个协议受到了XML-RPC的启发，但一直被批评为过分追求“第二系统效应”设计的受
害者，这么说不无道理。直到2003年中，SOAP标准还在制定当中，但是在Apache上的
试验版实现一直紧跟其设计草案。大家可以很容易地在网上搜索到Perl、Python、Tcl和Java
中的开源客户端模块。W3C规范的草案可从<http：／/www - w3．org／TR/SOAP/>获得。
    作为远程过程调用方法的XML-RPC和SOAP都会带来某种风险，我们将在第7章
结尾部分予以讨论。
    Jabber是一个为支持即时消息和在线状态报告而设计的对等协议。Jabber作为应用
协议的有趣之处在于：它支持XML表单和随时更新文档（live document）的输送。规格
说明、  文档和开源实现都可以通过Jabber款件基金会的站点
<http:／／www.j abber. org／about/overview. html>获得。
UNIX编I翟艺术
  www.pdf365.com
www.pdf365.com
伺
芭
透明性：来点儿光
Transparency: Let There Be Light
    Beauty fJmorefmportant加computing than anywhere else in technology because
sofiware is so complicated. Beauty is the ultimate defense against complexity.
    美在计算科学中的地位，要比在其它任何技术中的地位都重要，因为软件是太复杂
了。美是抵御复杂的终极武器。
    Machine Beauty:Elegance and the Heart of Technoloogy  （1998）
    《机器美学：优雅和技术本质》（1998年）
    -David Gelernter
    我们在前一章讨论了把数据格式和应用协议进行文本化的重要性，这种方式的表
达容易让人分析和参与，使一些设计品质得以提升，虽然Unix传统非常重视这些品质，
但很少（如果有的话）明确谈论过，那就是：透明性和可显性。
    如果没有阴暗的角落和隐藏的深度，软件系统就是透明的。透明性是一种被动品质。
如果实际上能预测到程序行为的全部或大部分情况，并能建立简单的心理模型，这个程
序就是透明的，因为可以着透机器究竟在于什么。
    如果软件系统所包含的功能是为了帮助人们对软件建立正确的“做什么、怎样做，，
的心理模型而设计，这个软件系统就是可显的。因此，举例来说，对用户而言，良好的
UNIX编程艺-宋
  www.pdf365.com
1 34
第6章透明性：来点儿光
文档有助于提高可显性；对程序员而言，良好的变量和函数名有助于提高可显性。可显
性是一种主动品质。在软件中要达到这一点，仅仅做到不晦涩是不够的，还必须尽力做
到有帮助1。
    透明性和可显性对用户和软件开发人员都很重要。但是重要性体现在不同的方面。
用户喜欢UI中的这些特性，是因为这意味着学习曲线比较平缓。当人们说UI“直观’’
时，很大程度上是指UI的透明性和可显性；剩下一部分则来源于最小立异原则。我们将
在第1 1章更深入分析这些使用户界面舒适而有效的特性。
    软件开发者喜欢代码本身（用户不可见部分）的这些品质，因为他们经常需要对代
码有很好理解后才能进行修改和调试。同时，如果程序的设计使内部数据流程非常容易
理解，则这个程序更不可能因设计者没有注意到的不良交互而崩溃，更可能优雅地向前
发展（包括适应新维护者接手的变化）。
    透明性是本章引言David Gelemter所说的“美”的主要构成部分。Unix程序员借鉴
了数学家的说法，经常使用更明确的术语“优雅”来表达Gelemter所说的品质。优雅是
力量与简洁的结合。优雅的代码事半功倍；优雅的代码不仅正确，而且显然正确；优雅
的代码不仅将算法侍达给计算机，同时也把见解和信心传递给阅读代码的人。通过追求
代码的优雅，我们能够编写更好的代码。学习编写透明的代码是学习如何编写优雅代码
的第一关，很难的一关――而关注代码的可显性则帮助我们学习如何编写透明的代码。
优雅的代码既透明又可显。
    通过两个极端例子来辨别透明性和可显性之间的差别可能会更容易些。Linux的内核
源码相当透明（相对其行为的内在复杂性而言），但根本不具备可显性――要获得必要
的知识以便融入代码中并理解开发者的惯用语相当困难，而一旦做到，～切便豁然开朗2。
另一方面，Emacs Lisp库是可显的，但却不透明。要获得足够的知识来领会一件事很容
易，但要理解整个系统却相当困难。
1一位有经济头脑的朋友评论：  “可显性降低进入门槛；透明性则减少代码中的存在成本。”
2 Linux内核在可显性上做了很多努力，包括Linux内核源码tarball中的Documentation子目录和相
当多的教程网站和指导书籍。这些努力比起内核变化的速度来说远远不够，文档还将长期落后。
UNIX编程艺术
    www.pdf365.com
6.1研究实例
135
    我们将在本章分析Unix设计的几个特性，这些特性不仅提高了用户界面的透明性和
可显性，而且还提高了用户通常无法看见部分的透明性和可显性。我们将逐步提出可以
应用到编码和开发实践中的几个有用原则。以后，我们将在第19章看看好的发布工程实
践（如编写一个内容恰当的README文档）如何能够让源码和设计一样具备可显性。
    如果需要足够的理由，来回答这些品质为什么很重要，请记住：编写透明、可显的
系统而节省的精力，将来完全可能就是自己的财富。
6.1  研究实例
    本书的通常做法是将实例分析贯穿在基本原理中。但我们在本章首先将分析几个展
示透明性和可显性的Unix设计，在介绍全部实例后才尝试从中总结经验。本章后半部分
的每个分析点都要用到这些实例，这种编排方式会避免在论述中引用读者还没有见到的
实例。
6.1.1  实例分析：audacity
    ．，
    首先，我们看一看UI设计中展示透明性的一个例子。这就是audacity，运行在Unix
系统、Mac OS和Windows上开源的声音文件编辑器。源码、可下载的二进制文件、文
档和屏幕截图可以在该项目的站点<http：／／audacitv．sourceforge．net，>处获
得。
    这个程序支持对音频采样的剪切、粘贴和编辑操作，支持多声道编辑和混音。UI部
分相当简洁：audacity窗口显示声音波形图，可以剪切和粘贴波形图。对波形图的操作
在实施的同时直接反映在音频采样中。
    多音轨编辑通过尽可能简单的方式支持：
各条音轨的同期性，又很容易检查匹配特性。
的相对时间。
屏幕按空间关系显示每条音轨，既表达了
可以用鼠标左右拖动音轨来改变各条音轨
    这个UI有几个特性非常优秀并且值得效仿：以不同颜色区分了大而直观且可点击的
操作按钮，提供了撤销命令，免除了许多尝试风险，音量控制滑杆使得柔度／响度在形状
上一眼便可认出。
UNIX编程艺术
  www.pdf365.com
    震@。莲  盏搿幽翻秒较髂慧辫鞯馥圈
    德这些都是缀节。这个程序的=黢主要优点在于它具有非常透明、自然的用户界面，
在用户和声音文件之闯尽可能少地设置障碍。
6。1。2  实例分析：国忿黪擀凌露的一v选项
  扣玩是劁霸是…拿溺络隧关程序，主要目的是在p◇p3或蔓磁A爹的远程娜件协议翻互
袭嘲自带的SM粉协议之阚进行转换，献焉进行电子鄙{孛交换。在采用SL稽（串行线路
攘弱协议）或ppp偶尔（端到端协议）连接到≥Sp（夏载藤服务商）的U魏ix机器中，弦托盎黼秘蠢
使用非常广泛，占据了甄联隧邮件业务量相当可观的一个部分。
    劳搬盎删i￡的命令行选项不少于鳓个（薤如本书后r瓯所提出，这可畿太多了），还育
不是在命令行丽是在运行控制文件中进行漫麓的其它遥项。在所有这些选项中，最蘩要
的…个选项――目前为止――是-V，辍§详缡（ve南。se）选项。
www.pdf365.com
6.1研究实例
137
    当使用-v选项时，fetchmail将发生的每一单POP、IMAP和SMTP处理都转储到标
准输出设备中。开发者真正能够实时看到远程邮件服务器及邮件传输程序的协议处理代
码。用户可以发送附有错误报告的会话记录。例6.1是～段典型的记录。
例6.1  fetchmail的-v记录实例
fetchmail :   6 . 1 . 0  querying  hurkle . thyrsus . com  （protocol  工MAP}
         at Mon， 09 Dec 2002 08:41:37 -0500 （EST） : poll started
fetchmail: running ssh %h /usr/sbin/imapd
          （hos七  hurkle. thyrsus.com  service  imap）
fetchmail: IMAP< le PREAUTH [42.42.1.0] IMAP4revl v12.264 server ready
fetchrnail :   IMAP>  AOO01  CAPAB工LITY
 fetchmail: IMAP< ~ CAPABILITY IMAP4 IMAP4REVI rxjAMESPACE IDLE SCAN
             SORT MA工LBOX-REFERRALS LOGIN-REFERRALS AUTH=LOGIN
             THREAD=ORDEREDSUBJECT
 fetchmail:  工MAP< AOO01 0K CAPABILITY completed
 fetchmail:  工MAP>  A0002  SELECT   "INBOX r'
 fetchmail: IMAP< t 2 EXISTS
 fetchmail :   IMAP（  ~  1  RECENT
 fetchmail:  工MAP< t OK [UIDVALIDITY 1039260713J UID validi七y sta七us
 fetchmail:  工MAP< t OK [UIDNEXT 23982} Predicted next UID
 fetchmail: IMAP< t FLAGS {\Answered YFlagged YDeleted \Draft \Seen}
 fe七chmail :   IMAP<  t  OK   [ PERMANENTFLAGS
            （\* \Answered kFlagged \Dele七ed \Draft \Seen}J
          Permanent flags
 fetchmail: IMAP<★ OK [UNSEEN 2] first unseen in /var/spool/mail/esr
 fetchmail:  工MAP< A0002 0K [READ-WRITE] SELECT completed
fetchmail:  IMAP> A0003 EXI:UNCE
fetchmail: IMAP< A0003 0K Mailbox checkpoin七ed， no messages expunged
fetchmail: IMAP> A0004 SEARCH UNSEEN
fetchmai/:  工MAP< t SEARCH 2
fetchmail: IMAP< A0004 0K SEARCH completed
2 messages （1 seen） for esr at hurkle.thyrsuscom.
fetchmail: IMAP> A0005 FETCH l:2 RFC822.SIZE
fetchmail:  工MAP< ~ 1 FETCH （RFC822.S工ZE 2545>
fetchmail: IMAP< * 2 FETCH （RFC822SIZE 8328）
fetchmail: IMAP< A0005 0K FETCH completed
skipping message esr@hurklethyrsuscom:l （2545 0ctets） not flushed
fetchmail: IMAP> A0006 FETCH 2 RFC822.HEADER
fetchmail: IMAP< ~ 2 FETCH {RFC822.HEADER {1586}
readincJ messaqe esr@hurkle.thyrsus.com:2 0f 2 （1586 header octets）
fe￡chmail: SMTP< 220 snark.thyrsus.com ESMTP Sendmail 8.12.5/8.12.5;
           Mon，  9 Dec
2002  08 : 41 : 41  -0500
www.pdf365.com
138
第6章透明性：来点儿光
 fetchmail :  SMTP>  EHLO  localhos七
 fecchmail :   SMTP<  250-snark. thyrsus _ com
             Hello  localhost  [127 . 0 . 0 . 1] ，  pleased  to  meet  you
 fe七chmail :   SMTP<   2 5 0 -ENHANCEDSTATUSCODES
 fetchmail :  SMTP<  250-8BITMIME
 fetchmail :  SMTP<  250-SIZE
 fet chrnail :   SMTP>  MAIL  FROM :<瑚utt -dev-owner@rnu七t _ org>  S工ZE=8328
 fetchmail :  SMTP<  250  2 . I . 0<mutt-dev-owner@mutt .org> . - .  Sender  ok
 fetchmail :   SMTP>  RCPT  TO :<esr@localhos七>
 fetchmail :   SMTP<  250  2.1.5  <esr@localhost:. . . .  Recipient  ok
 fetchmail: SMTP> DATA
 fe七chmail:  SMTP< 354 EnLer mail，  end with " _ "  on a line by itself
 #
 fetchmail :  IMAP<  >
 fe七chmail: IMAP< A0006 0K FETCH comple七ed
 fetchmail:  IMAP>  A0007  FETCH  2  BODY. PEEK[TEXT]
 fetchmail:  IMAP<  dt  2  FETCH  {BODY [TEXT]   {6742}
   （ 6742   body   octets ）    ;\ ;k ;k ir ir ir ir k :N k -k k k le k k ir ir t 7k 7k   ir lr lr rk lr t i   k k *A k lr k :tr t :k rtr dr k ir ir ir dr ir k
 fe七chmail :  IMAP<  >
 fetchmail: IMAP< A0007 0K FETCH comple七ed
 fe七chmail :   SMTP> _   （ EOM）
 fe七chmail: SMTP< 250 2.0.0 gB9ffW008245 Message accepted for delivery
  flushed
 fetchmail: IMAP> A0008 STORE 2 +FLAGS （YSeen kDeleted）
fetchmail: IMAP< t 2 FETCH （FLAGS （YRecent \Seen \Deleted》
ferchrnail: IMAP< A0008 0K STORE completed
fetchmail :  IMAP>  A0009  EXPUNGE
fetchmail: IMAP< :e 2 EXPUNCE
fetchmail: IMAP< t 1 EXISTS
fetchmail: IMAP< ~ 0 RECENT
fetchmail: IMAP< A0009 0K Expunged l messages              .
f etchmail :  工MAP>  A（J 010   LOGOUT
fetchmail: IMAP< t BYE hurkle IMAP4revl server terminating connection
fetchmail: IMAP< AO010 0K LOGOUT completed
fetchmail: 6.1.0 querying hurkle.thyrsus.com （protocol IMAP}
            at Mon， 09 Dec 2002 08:41:42 -0500: poll completed
fetchmail: SMTP> QU工T
fetchmail: SMTP< 221 2.0.0 snark.thyrsus.com closing connection
fetchmail: normal termination， sta七us 0
www.pdf365.com
6.1研究实例
139
    -v选项使得fethcmail的行为具有可显性（可以让人看见协议交换过程），这非常有
用。我认为这一点相当重要，所以编写了专门代码，在-v处理转储中遮住用户口令，这
样，人们无需记住编辑其中的敏感信息就可以传阅或寄出。
    这被证明是一个不错的决定。在八成以上的错误报告中，一个懂行的人只要看一下
对话记录，几秒内就可以进行诊断。在fetchmail邮件列表中有不少懂行的人――事实上，
由于大多数bug都非常容易诊断，很少需要我亲自处理。
    多年来，fetchmail已经赢得了“防弹程序”的美名。fetchmail也可能发生配置错误，
但很少彻底无法工作。如果怀疑这归功于十之八九的bug都能迅速被发现这一事实，那
我打赌你错了。
    我们可以从这个例子中学到些东西。教训是：不要让调试工具仅仅成为一种事后追
加或者用过就束之高阁的东西。它们是通往代码的窗口：不要只在墙上凿出粗糙的洞，
要修整这些洞并装上窗。如果打算让代码一直可被维护，就始终必须让光照进去。
6.1.3多哥列分析：GCC
    GCC，即现代大多数Unix都使用的GNU C编译器，也许是关于透明性更好的工程
实例。GCC由一系列处理阶段组成，并由一伞驱动程序将其紧密结合在一起。它们是：
预处理器、解析器、代码生成器、汇编器和链接器。
    前三个阶段都接受可读文本格式的输入，然后输出可读的文本格式（汇编器必须输
出而链接器必须输入二进制格式，这一点从定义便可理解）。运用gcc （1）驱动程序的
不同命令行选项不仅可以看到C预处理之后、汇编生成之后和目标码生成之后的各个结
果，而且可以监控解析进程和代码生成进程中的许多中间步骤的结果。
    这完全就是第一款（PDP-11）C编译器cc的结构。
-Ken ThorTipson
这种组织有很多好处，其中对GCC特别重要的一个好处体现在回归测试中3。
3回归测试是一种检测软件修改后是否引入bug的方法。方法是对于处在修改变动期的软件，根据
某些固定的测试输入，定期检查软件的输出是不是跟先前获得并已知（或假定）正确的输出快照
一致。
UNIX编程乏≥笨
  www.pdf365.com
140
第6章透明性：来点儿光
因为各个中间格式的大部分都是文本格式，在回归测试中，对中间结果使用简单的文本
diff操作就可以发现并分析结果是否偏离预期结果；没必要使用专门的转储．分析工具，
这些工具完全可能隐藏自身的bug，而且无论怎样都意味着额外增加维护负担。
    这个例子揭示的设计模式是驱动程序应该具备监控开关，这些监控开关仅仅（但足
够了）揭示组件间的文本数据流。如同fetchmail的-v选项一样，这些选项也不是事后追
加，而是为了可显性才设计进来的。
6.1.4实例分析：kma『／
    kmait是随KDE环境一起发布的GUI邮件阅读程序。kmail的用户界面非常优雅，
设计得很好，包括很多优良特性，如自动显示MIME multipart内嵌图像和支持PGP密钥
加密／解密等。对最终用户相当友好――我心爱但不懂技术的妻子就喜欢使用它。
    许多邮件用户代理只是向可显性做了个姿态，用一个命令来切换显示邮件头的所有
信息，而不是显示From（发件人）和Subject（主题）等选择性信息。但kmail的用户界
面在这个方向上走得更远。
    kmail运行时在窗口底部的单行子窗口显示状态通知，青灰色的背景上显示小字体文
字，很阴显是模仿了Netscape/Mozilla的状态栏。例如，打开一个邮箱，状态栏显示邮件
总数和未读邮件数。这个视觉显示并不突兀：可以不理会这些通知信息，但如果希望的
话又很容易注意到它们。
    kmail的GUI是很好的用户界面设计。这个GUI内容翔实但并不令人分心；它宣扬
了我们在第II章引证的理由，即让Unix工具正常运行的最好策略是在大部分时间里沉
默。kmail设计者在借鉴浏览器状态栏的外观和感觉方面显示了良好的品味。
    但是，在你检查为什么信件无法发出时才会领会kmail开发者的品味。如果在发送
过程中仔细观察，可以发现SMTP和远端邮件传输处理每一行都在进行的同时，也回显
在kmail状态栏上。
www.pdf365.com
    巷。孳戮究樊铡    l4l
    _“__“”h__6W_，--_1一*“WH_…““d_M_一
篓鞋鲑蠡蠢缝羹蓥饕璃}筘豢莲羲f燮臻靠肇超雾簿耋鞋释}摊嚣§壁建l雾
国稼国
陲陲融逾瓣嗡霎瓣罐
乒囊巷黎描  攀
，一“～女“*，～…*一‰^却
黼翱l
磊童l鞭b洲
④。u}貉粼
国sgnf―m赢}}
≥黪}f魏s融
嚣蓦dr馥鍪
嚣爹e棼摊￡籍簋}
戳舅m鬯
裁鲻鬻懑黼熬
羲攀s雾矗m
鑫鞋躐霆￡￡
基杂臻基譬r
    H魏器a船￥蓄题l辩耍珏窀鬯辩莲巷蘸避
    彝。9。f融罄r蕊释划窑§’下轴霞搿em
    鎏。彗群l}}鬯f慕瑟列鲤f丁魏雹0黼m
    筑卺：转0雪磷ilf霆r蕊嚣魏V鞋矿下魏国0fem
    谴鲤：b0霉落靛鬯r黩爨耐雹r下h黎嚣f巷m
    鼹蒹！f撵魏麟to h建{口钭l嘲骚0鍪鹾l孵e r
    鼹叠：5》礁舞错l孽斡￡lH彗潲￡鞔m埘许m*器函羞e羚
  V孽l§捂鲤ns甄
  0筵驯…。
  琏挚‘络09斟l|毒鬯F黪。5 l§0_￡
  一霆霉+b￡垮澎}}￡避F馨弘鎏耍鐾蓦￡}0张嚣
；  器湖拼ll￡露}娃》Q}t蠹i辩l鞋r避誊}{嚣磐
；  ≯盎。RK邕矗i附抟w§from缃建鬯鼹鼗黼￥1嚣￡a∽雾
囊篓兰竺㈣㈣威1籁羞￡. -t、拣盈妇燃放域燃奠敝一黝
    …““#等芽…
热掣l筘f霆密dm巍辩
磁蠢哦黼。H氍馅冉蕊戆
醚矗魄鞘，H@事黼&翻
醚巍漱黼。翻《管黼鑫秘
黼巍陵黼。H《誓m氇相
赢《rla孵0镩稳
j睦f建m￥黪{露妻§巷f
黪霞b群巍h L。糊疆辩器0秘
隧睡誊§驻||隧鞋l誊溯
基rl￡S棼擎pa靠鬯n
 l黼i撑舞巍n器群霪翌盈f癌
蕊擎i F髓鬯《m盎强
Ff鬯堪
┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃                                                                          ┃
┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃笋彰◇擎张：毋p疆攀l巍S遘爨锺霆爹蓉”《蘸遴擎霪魂鹈◇雾嚣i键。《婚￡鞯》  ┃
┃了姆：    《避蕊爹嵇嘲第爹霪鞘黪。敛婷戮》                                ┃
┃豁遘耄黎：T魏魅+2蓥矗鞑瓣釜∞2薹碡翦凌4巷蛰≯蛰秘                         ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
l黔on鼗。譬y。鞑F丁C蕊丁鹜蕊醴i艺l姥蕊，y姆髅瓣昏{紫震{辆霸熏≯最r曩鹱睡ls《。
◇》避轴S◇醢fe鲤
li屯避糖si瓣g}稍主W逍跫攀跫lo驴i鞴穗}携绶蓦O《瓿避爹{辆疆秘螽。{薏辫ar姥，》移S蓦i黪ly
l黔荆鞭嚣l《，鞭
l薹嚣黼8 f辘趣誊蠹蠢羹避氢，0瓣瓣}棼蕊趣；
辫8，囊鼢露群群幕裁瀚
跏蛾群开发者巧妙地避开了一个陷阱，这个陷阱经常让类似囊俄琏i￡翰GU{程乎故陵捡
测员裰端痛苦。鞠撅攫lf圈标相同的大多数设计者常零完全压制这些信息；生怕这些信
息会吓着假想中的邻厝阿姨弱iiie，遥她回头去用华丽簿俗又伪装简洁的Wi确◇鞘s机器。
相反，他们为透明性而谩计………溉盥暴了事务处理信息，又报容易让入视丽不觅。
通过恰当的表现形式，他们成功满足了骶llie阿姨和鳞决她计算机润题的“缀客”（譬鬯故y）
侄予M巷lvi髓。这招很聪明，其它G琴董界翥麓够也应该效仿之。
当然，鬣后，这些珂视纯信息对T弧e阿姨也非常有用，因为这意味着磁elv{蕤在熬
决憋的电子邮件问越时，不大可麓在挫折面前举手般输。
www.pdf365.com
霾㈠㈠鬈麓蕤黧麓霪纛黧鬻麟落
142
第6章透明性：来点儿光
    这个例子的教训很明显：让UI沉默只做对了一半。真正的聪明是找到一个方法，可
以访问具体细节，但又不让它们太显眼。
6.1.5实牺g分析：SNG
    sng程序在PNG图形格式及其纯文本形式（SNG即Scriptable Network Graphics，可
脚本化网络图形）之间进行转换，这个文本表达可用普通的文本编辑器检查和修改。对
PNG文件运行程序，可产生SNG文件：对SNG文件运行程序，又能恢复等价的PNG
文件。两个方向都是l00%可靠的无损转换。
    在语法风格上，SNG很像CSS（Cascading Style Sheets，层叠样式表），另一种控制
图形表达的语言，这至少朝最小立异原则的方向摆了一个姿态。以下是一个测试实例：
例6.2  SNG实例
#SNG: This is a synthetic SNG test file
# Our first  test is a paletted （type 3） imaqe.
IHDR :   {
 width: 16;
 height :   19 ;
 bitdepth: 8;
 using color: palette;
 with interlace;
# Sample bit depth chunk
sBIT: {
  red: 8;
  green: 8;
  blue :  8;
# An example palette: three colors，
# we will render transparent
PLTE :   {
     （0，     0， 255）
     （255，   0.   0）
              " dark   slate   gray " .
# Suggested palette
www.pdf365.com
143
SPLT {
   name :   "A  random  suggested  pale七te" ;
   depth: 8;
    （0，      0，  255> ，  255，  7;
     <255，   0，   0}， 255. 5;
    （ 70f  70，   70） ，  255，  3;
#  The viawer will  actually  use  this _
IMAGE :   {
   pixels base64
2222222222222222
2222222222222222
000000111110 0 0 0 0
0 0 0 0 011111110 0 0 0
0 0 0 01110 01111 0 0 0
0 0 01110 0 0 011110 0
000111 0 0 0011110 0
0 0 0 0110 0 011110 0 0
0000000011110 000
000 0 0 0 0iiiiooooo
ooooooiiiioooooo
0 0 0 00011110 0 0 0 00
0000000000000000
0000000110000000
0000001111000000
o oooooiiiioooooo
oooooooiiooooooo
2222222222222222
2222222222222222
}
tEXt: （    # Ordinary text chunk
  keyword :   J'Ti七le 'J ，
  text :   " Sample  SNG  script " ;
}
# Test file ends here
    芙键在于，通用图形编辑程序不～定支持各种难懂的PNG块类型，这种手段使用户
可以对其编辑。无需编写专用代码来迎合PNG二进制格式，用户只要将图像转换成纯文
本表达，对之进行编辑，最后再转换回图像。另一个可能的应用是使图像可以被版本控
制：在大多数版本控制系统中，文本文件要比二进制文件容易处理得多；对SNG表现形
www.pdf365.com
144
第6章透明性：来点儿光
式进行diff操作，产生的信息也将是有价值的。
    然而，此处的收获不仅仅是节省了编写专用代码来处理二进制PNG文件的时间。sng
程序的代码本身并不特别透明，但是通过让PNG的全部内容可显，提高了程序中较大系
统的透明性。
6.1.6  实例分析：Terminfo数据库
    Terminfo数据库是视频显示终端的描述集。每一条记录描述了在终端屏幕上执行的
不同操作的转义序列，例如插入行或删除行、删除光标位置到行尾或屏幕末端的全部内
容、开始或结束反相、下划线和闪烁等屏幕高亮显示。
    terminfo数据库主要由curses （3）库使用。这些构成了我们将在第lI章讨论的
“roguelike”式接口风格的基础，也构成了mutt（1）、lynx （1）和slrn（1）等广泛使
用程序的基础。尽管在当今位图显示器上运行的xterm（1）之类的终端仿真器，所具备
的能力都是以ANSI X3.64标准终端以及由来已久的VTlOO终端能力为基础，而作了一
些小变化，但其中一些变化足以使将ANSI能力硬塞进应用程序成为一个糟糕的想法。
terminfo也值得研究，因为在管理其它没有标准方式报告自己能力的外设硬件对经常产
生问题，这些问题和terminfo所解决的问题在逻辑上非常相似。
    terminfo的设计得益于使用更早期名为termcap的能力格式的经验。termcap描述的
数据库以文本格式存放在／etc／七ermcap大文件中；尽管这个格式已经过时，但是每个
Unix系统几乎肯定包含了一份拷贝。
    通常，用来查找终端类型记录的关键字是环境变量TERM，就本实例分析而言，这
个环境变量似乎是魔术般设置好的4。使用terminfo（或termcap）的应用程序在启动时会
有小小的延时：当cursEs （3）库自身初始化时，它必须查询TERM的对应记录并将其载
入内存。
    使用termcap的经验表明，启动延迟主要由解析终端能力的表达文本所要求的时间
决定。因此，terminfo的记录是二进制结构转储，列集和散集的速度能够更快一些。整
个数据库有～个主文本格式，即terminfo能力文件。该文件（或单个记录）可以使用
4事实上，TERM是系统在登录时设置的。对串行线上的实际终端而言，从tty（电传打字机终端）
行到’l-ERM值的映射在启动时由系统配置文件进行设置。视Unix版本不同，具体情况也不同。xterm
（l）之类的绛端仿真器自己设置这个变量。
www.pdf365.com
6.1研究实例
145
terminfo编译器tic （1）编译成二进制形式；二进制记录可以由infocmp（1）反编译成可
编辑的文本格式。
    从表面上看，这个设计与我们在第5章给出的反对二进制缓存的建议矛盾，但实际
上它是个极端例子，这里，采用二进制是个好策略。对主文本的编辑很少――实际上，
Unix通常带着预编译过的terminfo数据库一起发布，主文本主要作为文档使用。这样，
通常可能影响这种方法的同步性和不一致性问题几乎从未发生过。
    terminfo的设计者本可以用另一种方法来优化速度，包含二进制条目的整个数据库
本可以放入某种大而晦涩的数据库文件中。事实上，他们实际采取的方法更聪明而且更
符合Unix精神。Terminfo记录存放在一个目录层次结构中，在现代Unix上通常放在
/ur／share/terminfo下。请查阅一下terminfo （5）的手册页来找到在你系统中的位
置。
    如果访问terminfo目录，可以看到由单个可打印字符命名的子目录。每个子目录下
存放以该字符开始的终端类型的记录。这种结构旨在避免在很大的目录中进行线性查找。
在更现代的Unix文件系统中，为了优化快速查找而以B-tree或萁它结构来表达目录，子
目录就不需要了。
    我发现，即使在相当现代的Unix上，将一个大目录分拆成子目录也能显著提
高性能。在一台运行DEC Unix的新型DEC Alpha机器上，为一所大型教育机构
制作的授权用户数据库有好几万个文件（子目录名由名字的首字母和尾字母构成
――比如，  “Johnson”可能在目录“j_n”中――在我们的测试中最管用。使用头
两个字母就没这么好，因为许多系统生成的名字要到结尾才不同）。这也许就是
说复杂的目录索引仍然没有它应该表现的那样达标……但即使如此，也使得无需
它就能运行良好的结构要比需要它才能运行的结构更具备可移植性。
    ~Hen叫Spencer
    这样，打开一个terminfo记录的开销就是两个文件系统查找操作和一个文件打开操
作。但既然从大数据库找到同一个记录本来就需要对数据库进行一个查找操作和一个打
开操作，terminfo结构的增量成本最多也就是一个文件系统的查找操作。事实上，比这
个还要低――只是一个文件系统查找操作和大数据库所使用的任何检索方法之间的成本
差a这可能微不足道，并且在每个应用程序启动时只进行一次也可以容忍。
UNIX编程艺术
    www.pdf365.com
146
第6童透明性：来点儿光
    terminfo本身使用文件系统作为～个简单的层级数据库。这种偷懒相当具有建设性，
符合经济性原则和透明性原则。这意味着对文件系统进行浏览、检查和修改的所有普通
工具都可以用于对terminfo数据库进行浏览、检查和修改；无需编写和调试专用工具（用
于打包和解包单个记录的tic （1）和infocmp（1）工具除外）。这也意味着要加速数据
库的访问就得要加速文件系统本身，知道这～点可以使更多应用程序受益，而不仅仅是
curses （3）的用户。
    这种结构还有另外一种优点，但在terminfo例子中没有展示出来：你开始使用Unix
的授权机制而不用自己编写带来额外bug的访问控制层。这也是采纳而不是对抗Unix'‘一
切皆文件’’基本原则的结果。
    terminfo目录的布局在大多数Unix文件系统上都很浪费空间。每条目长度通常在
400～1400字节之间，但是文件系统通常为每一个非空磁盘文件至少分配4k的空间。出
于选择压缩二进制格式的同一个原因，即为了把terminfo使用的程序的启动延时降到最
小，设计者接受了这个代价。同一价格所能买到的磁盘容量已经猛增了一千倍，更能证
明这个决定的芷确。
    比较这种格式和Microcsoft Windows的注册表文件所用的格式很有启发意义。注册
表是Windows本身及应用程序都使用的属性数据库。所有注册记录都存放在一个大文件
中。注册记录既包含文本也包含二进制数据，需要专用的编辑工具。别的不说，这种“一
个大文件”的方法还导致了臭名昭著的“注册表蠕变”现象：平均访问时间随着新记录
的加入而无限上升。因为系统没有提供标准API来编辑注册表，应用程序本身使用专用
代码编辑注册表，使得注册表极易受损，甚至能够锁定整个系统。
    使用Unix文件系统作为数据库是一种策略，对数据库要求简单的其它应用程序可以
效仿并从中受益。不这样做的充分理由通常与性能问题无关，更可能的情形是数据库关
键字不太适合做文件名。无论如何，这是在原型设计时非常有用的一种很好的快速编程
方法。
6.1.7实例分析：Freeciv数据文件
    Freeciv是一款受到Sid Meier经典的CivilizationⅣ启发而制作的开源策略游戏。在
该游戏中，每个玩家从一群到处流浪的新石器游牧民开始缔造一个文明。玩家的文明可
以探索并拓殖世界，参与战争，从事贸易和研究先进技术。有些玩家实际上可能是人丁
智能；祁这些电脑玩家玩单机游戏很有挑战性。如果谁统治了整个世界，或者第一个
www.pdf365.com
6.1研究宴捃0
147
研制出先进技术从而获得宇宙飞船飞往半人马座阿尔法星（ Alpha Centauri），谁就是游
戏的胜利者。源码和文档可以在<http：//www. freeciv. org/>处获得。
    我们还会在第7章把Freeciv这个策略游戏作为客户端朋＆务器划分的一个例子提出，
在这个游戏里，服务器维持共享状态而客户端专注GUI表现。但是这个游戏还有另外一
个值得注意的体系特征：游戏的大部分固定数据，没有编入服务器的代码中，而是在属
性登记表中说明，由游戏服务器在启动时读取。
    这个游戏的登记表文件以文本数据文件的格式编写，把文本串（相关的文字和数字
属性）放到游戏服务器各个重要数据（比如民族和装备类型）的内部列表中。微语言
（minilanguage）具有包含（include）指令，所以游戏数据可以划分为许多语意单元（不同的
文件），每一个都可以独立编辑。这个设计方案得到了充分贯彻，根本不需要改动服务
器代码，只要简单地在数据文件中进行声明就可以定义新的民族和装备。
    Freeciv服务器的启动解析过程有一个非常有趣的特性，它与Unix的两个设计原则
有些冲突，因此值得进～步关注。服务器会忽略它不知道如佴使用的属性名。这使得可
能在不中断启动解析的前提下对服务器还没有使用的属性进行声明。这意味着游戏数据
（策略）的开发和服务器引擎（机制）的开发可以干干净净地分离出来。另一方面，这
也意味着启动解析不会理会属性名简单的拼写错误。这种不声不响的“不作为，，似乎违
反了补救原则。
    要解决这个冲突，应注意：使用登记表数据是服务器的工作，但是仔细检查数据的
任务可以移交给另一个程序，每次修改登记表时，由编辑人员运行这个程序。Unix的解
决方案可以是一个独立的审核程序，后者分析可以机读的规则集格式规范说明，或服务
器源码来确定程序使用的属性集，并解析Freeciv的登记表来确定程序提供的属性集，然
后准备～份差异报告5。
    所有Freeciv数据文件的聚合在功能上类似于Windows注册表，甚至使用和注册表
文本部分类似的语法。但是，我们所注意到的Windows注册表蠕变和损坏问题在这里并
没有发生，原因是没有程序（在Freeciv套件内部和外部）写入这些文件。这是一个只能
由游戏维护者编辑的只读登记表。
5在Unix下，此类验证程序的老祖宗是舰卜一一个从c编译器独立出来的c代码校验器。尽管GCC
已经吸收了其功能，但是老一荤的Unix人仍然倾向于把运行验证器的进程称之为“linting”，这个
名字也在一些公用程序中保留了下来，如xmllint。
www.pdf365.com
豳巷。3 F潞∞l掣游戏辫主窿麓
    对数搦文件解析的性熊影响已经降到了最低，因为对每个文件丽言，簿析撩作只有
在客户端或嚣羹务器端寤动时执行…次。
翁。2  为透明性和可显洼隔设计
    要为透嘲性和可显性丽设计，就必须运溺各种计策来保持代码的简洁，也必须专注
代码闭其袍A交流的方式。在“这个设汁能行秘马？”之后要提出的头几个阀题就是靠舅《
人麓读蠖这个设计吗？这个设计优雅吗？”我们希望，此时大家已经很清楚，这些滴麓
www.pdf365.com
6.2  为透明性和可显性而设计
149
不是废话，优雅不是一种奢侈。在人类对软件的反映中，这些品质对于减少软件bug和
提高软件长期维护性是最基本的。
6.2.1  透明性之禅
    从本章目前为止，已经研究过的例子展现出来的一种模式是：要追求代码的透明，
最有效的方法很简单，就是不要在具体操作的代码上叠放太多的抽象层。
    在第4章讲述分离价值的部分，我们建议对引起设计问题的特殊、意外的情况进行
抽象、简化和概括，并尽量从中分离出来。如何抽象的建议同我们在这里提出的不要过
度抽象的建议实际上并不矛盾，因为摆脱假设和忘记正在解决的问题并不一样。这也是
我们提出要保持薄胶合层建议时的部分用意所在。
    禅的一个主要教导是，通常我们都透过源于欲望的偏见和成见的迷雾观察世界。要
开悟，我们必须遵循禅的教导，不仅要“去欲望，少依恋”，还要“如实见”――不要
让偏见和成见蒙住了眼。
    这是给软件设计者的一个非常好的实用建议，也是Unix做极简主义者的经典建议的
部分隐含意义。软件设计者都是聪明人，可对其处理的应用域形成概念（抽象）。他们
把围绕这些概念编写的软件组织起来。然后，调试时，他们经常发现很难透过这些概念
弄明白到底发生了什么。
    任何祥宗大师鄯能马上认出这个问题，笑日“麻三斤’’，或许还会好好地敲一下学
生6。有意识地为透明性而设计，即是在暗处解决透明性。
    我们在第4章批评了面向对象的编程，对于1990年代在00福音下成长起来的编程
者，可能是危言耸听。面向对象的设计并非必然是过度复杂的设计，但我们却发现事实
往往如此。太多的00设计就像是意大利空心粉一样，把“is-a"和“nave-a"的关系弄
得一团糟，或者以厚胶合层为特征，在这个胶合层中，许多对象的存在似乎只不过是为
在陡峭的抽象金字塔上占个位置罢了。这些设计都不透明，它们（臭名昭著地）晦涩难
懂并且难以调试。
    正如我们在前面所注意到的那样，Unix程序员是最早提倡模块化的狂热分子，但又
往往以比较平和的方式处理这个问题。保持薄胶合层也是其中的一个部分：更普遍的是，
6参考“无门关洞山三斤”的公案[Mumon]。
UNI×编腥艺．术
  www.pdf365.com
150
第6章透明性：来点儿光
Unix传统教导我们不要垒高台，要用设计简单而透明的算法和数据结构紧贴基面。
    和禅宗一样，优秀Unix代码的简洁依赖于严格自律和高水平技艺，这两者乍看未必
会看得出来。透明性是项辛苦的工作，但值得我们努力追求，而且并不为附庸风雅。和
禅宗不一样的是，软件需要调试――而且通常在整个使用期都需要不断的维护、向前移
植和改写。因此，透明性不仅是一种美学意义上的成功；更是一种胜利，反映在软件整
个生命周期上，意味着更低的成本。
6.2.2为透明性和可显性而编码
    透明性和可显性同模块性一样，主要是设计的特性而不是代码的特性。仅仅做对一
些底层风格要素，如清晰且统一的代码缩进，或具有良好的变量命名约定，是不够的。
这些特性更多与代码中不易硬性规定的特性有关。以下这些问题需要好好思考：
    ●程序调用层次中最大的静态深度是多少？也就是说，不考虑递归，为了建立心
    理模型来理解代码的操作，人们将要调用多少层？提示：如果大于四，就要当
    心。
    ●代码是否具有强大、明显的不变性质7 7不变性质帮助人们推演代码和发现有问
    题的情况。
    ●每个API中的各个函数调用是否正交？或者是否存在太多的特征标志（magic
    flags）相模式位，使得一个调用要完成多个任务？完全避免模式标志会导致混乱
    的API，里面包括太多几乎一模～样的函数，但是频繁使用模式标志更容易产生
    错误（很多易忘并且易混的模式标记）。
    ●是否存在一些顺手可用的关键数据结构或全局唯一的记录器（scoreboard），捕获
    了系统的高层级状态？这个状态是否容易被形象化和检验，还是分布在数目众多
    的各个全局变量或对象中，而难以找到？
7不变性质是指一个软件设计中各个操作都保持不变的特性。例如，在大多数数据库中，两个记录的
关键字不能相同，这就是不变性。在正确处理字符串的C程序中，从各个字符串函数退出时，每一
个串缓冲区都必须包含终止符NUL字节。在一个库存系统中，没有哪部分的总数量可以小于零。
www.pdf365.com
6.2为透明性和可显性而设计
151
    ●程序的数据结构或分类和它们所代表的外部实体之间，是否存在清晰的一对一映
    射？
    ●是否容易找到给定函数的代码部分？不仅单个函数、模块，还有整个代码，需要
    花多少精力才能读懂？
    ●代码增加了特殊情况还是避免了特殊情况？每一个特殊情况可能对任何其它特
    殊情况产生影响：所有隐含的冲突都是bug滋生的温床。然而更重要的是，特殊
    情况使得代码更难理解。
    ●代码中有多少个magic number（意义含糊的常量）?通过审查是否很容易查出实
    现代码中的限制（比如关键缓冲区的大小）?
    代码能简单最好。但是如果代码很好地解决了上述问题，则代码也可以复杂，而且
不会对维护人员造成认知负担。
    读者会发现，把以上这些问题和第4章模块性列出的问题作比较将很有启发性。
6.2.3透明性和避免过度保护
    程序员经常建造过分精细的抽象城堡，这一倾向的近亲是过度保护底层细节。尽管
在程序的正常操作模式中隐藏这些细节并不是不良作法（fetchmail的-v选项的缺省被关
闭），但这些细节必须能够找到。隐藏细节和无法访问细节有着重要区别。
    不能展示其行为的程序使故障检测困难得多。所以，经验丰富的Unix用户实际上
把调试和探洌开关的存在视为良好程序的标志，不存在则认为程序可能有问题。不存
在表明开发者不是经验不足就是粗心大意：存在则表明开发者很聪明，遵循了透明性
原则。
    在针对最终用户编写的GUJ应用中，如邮件阅读器，过度保护的诱惑特别强烈。Unix
开发者对GUI界面比较冷淡的原因之一是，在设计者仓促完成的每个看起来“用户友
好”的GUI界面中，都令必须解决用户问题的人感到无从下手而非常沮丧――或者，确
UNIX编程艺：术
  www.pdf365.com
152
第6章透明性：来点儿光
切地说，在设计者预想的狭窄范围以外，与界面的交互令人感到相当不透明。
    更糟的是，对自身在做什么的不透明程序常常夹有很多假定，在设计者没有预计到的
使用场合，程序不是无法工作，就是非常不稳定，或者两者皆有。表面光鲜但一压即垮的
工具是没有长远价值的。
    Unix传统大力倡导具有灵活性的程序，以适应更广的使用范围和排错情形，包括当
用户表明愿意处理时，有能力给用户提供尽可能多的状态和活动信息。这对排错非常有
用；对于培养更聪明、更独立自主的用户也很有用。
6.2.4透明性和可编辑的表现形式
    以上这些例子所展现的另一个主题是～些程序的价值，这些程序可以把不易实现透明
性的定义域问题转换为容易实现透明性的定义域问题。Audacity、sng（l）和tic（1）linfocmp
（l）程序对都有这种特性。它们所处理的对象无法手工处理或容易阅读：音频文件不是
可视的对象，尽管PNG格式表达的图像可视，复杂的PNG标注块并不可视。以上这三个
程序都将二进制文件格式的处理转换成人们可以更容易运用日常生活中获得的直觉和能
力来解决的问题。
    所有这些例子都遵循的一个原则，即把表现形式的损失降到最小――实际土，这些
转换都是町逆、无损的。这个特性非常重要，即使没有明确提出lOOu/o忠实的应用需求，
这个特性也值得实现。这给潜在用户以不断尝试而不会损坏数据的信心。
    第5章讨论的数据文件格式文本化的所有优点同样适用于sng （1）、infocmp（1）
和其同类程序所生成的文本格式。sng （1）的～个重要应用是通过脚本自动生成PNG标
注――因为sng （l）的存在，这类脚本更容易编写。
    无论何时碰到涉及编辑某类复杂二进制对象的设计问题，Unix传统都提倡首先考虑，
是否能够编写一个类似于sng（1）或tic （1） linfocmp （l）组的工具，以便能够在可编
辑的文本格式和二进制格式之间来回进行无损转换。对于这类程序还没有确定的术语，
但我们姑且称之为文本化器（textualiZer）。
    如果二进制对象是动态生成的，或者非常大，那么用文本化器转化所有状态可能不
实际或根本不可能。在这种情况下，对应的任务是编写一个浏览器。这方面的范例是向扔
（1），即不同版本的Unix都支持的文件系统调试器；Linux上的对应程序是出西犍母（1）。
另外两个例子是浏览PostgreSQL数据库的psqt （l），用于在配置SAMBA的Linux杌
www.pdf365.com
6.2为透明性和可显性而设计
153
器上查询Windows文件共享的smbclient（1）。这五个程序都是简单的CLI程序，可由
脚本和测试工具来驱动。
    至少以下四个理由表明编写文本化器或浏览器非常值得～试：
    ●可以获得良好的学习经验。也许还有其它好方法来认识所处理对象的结构，但是
    没有哪一个方法明显比这个好。
    ●有能力将结构内容转储，以供审查和调试。因为这样的工具方便了转储操作，所
    以可以经常进行。得到的信息越多，就可能获得更多认识。
    ●有能力轻松生成测试负载和特例。这意味着更有可能探测到对象状态空间的死角
    ――并且更容易把相关软件用垮，所以可在用户用垮它之前将其修补好。
    ●可以获得可复用的代码。如果编写浏览器／文本化器时很小心，并且保持CLI解
    释器和列集／散列库的分离，就会发现代码可以在实际的应用程序中得到复用。
    完成这些后，很可能发现，把文本化器／浏览器作为引擎使用就可以应用“接口和引
擎分离”模式（参考第1 1章）。可以受益于这种模式的各种好处。
    让文本化器甚至能够对损坏的二进制对象进行读写操作，尽管很难，但值得
  去做。第一，可以对压力测试软件生成受损测试用例；第二，可以让紧急修复更
  容易。也许很难处理对彖结构已经混乱的情况，但至少应该处理结构内容无意义
  的情况，例如，可以用十六进制表达无意义的值，然后把十六进制转换回无意义
  的值。
6.2.5透明性、故障诊断和故障恢复
--Henry Spencer
    透明性还有一个与简化调试有关的好处，就是bug发作时，透明的系统更容易实旅
恢复措施――而且，经常是，首先更能抵抗bug的破坏。
    对比terminfo数据库和Windows注册表，我们发现注册表出名地容易受到错误代码
的破坏。这可能会使整个系统都无法使用。即使系统没有瘫痪，但如果破坏本身干扰了
专用的注册表编辑工具，恢复工作就会很困难。
UNIX编程窆多定
  www.pdf365.com
154
第6章透明性：来点儿光
    我们的Unix实例表明，为透明性设计可以防止这类问题的发生。因为terminfo数据
库不是单一的大文件，修补一条terminfo记录不会使整个terminfo数据集都不能用。像
termcap这样纯文本化的单一大文件格式的解析通常都使用（与二进制结构转储的块读取
不同）可以从单点错误恢复的方法。SNG文件中的语法错误人工就可以解决，不需要专
用编辑器，那些专用编辑器可能拒绝载入受损的PNG图像。
    回到kmail案例，这个程序使得故障诊断更加容易是因为遵循了补救原则：SMTP
错误信息太扰人，这就非常有用。根本不必解析kmail自身产生的混乱信息层来了解同
SMTP服务器的交互情况。所需做的一切就是到该去的地方查看，因为kmail就是透明的，
而且不抛弃错误状态的信息（SMTP本身也是文本化的，并且在其事务处理中包括人可
读的状态信息，这也很有用）。
    像文本化器和浏览器这样的可显性工具使得故障诊断更加容易。我们已经接触过其
中一个原因：它们简化了系统状态的检查。但还有另外一个同样起作用的效应；数据的
文本化版本往往具备有用的冗余（比如使用空白进行可视化的分隔或成为清楚的解析分
隔符>。这些的出现不仅便于人类阅读，而且还让程序更能抵御微小失误造成的不可挽
回的破坏作用。PNG文件的受损块很少能够恢复，但是人有识别和从上下文推导的能力，
能够修复等价的SNG格式。
    再一次，健壮原则就非常清楚了。简洁加上透明，降低了费用，缓解了每个人的压
力，让人们从中解放出来，更多地投入到新问题中，而不是总为旧错误擦屁股。
6.3为可维护性而设计
    如果作者以外的其他人能够顺利地理解和修改软件，则这个软件就是可维护的。可
维护性不仅要求代码能够运行；还要求代码能够遵循清晰原则，并且和人以及计算机成
功沟通。
    对于什么有助于生成可维护的代码，Unix程序员有许多隐性知识，原因是Unix有
许多可以追溯到几十年前的源码。基于我们在第17章将要讨论的原因，Unix程序员学
到了一种品性，就是宁愿抛弃、重建代码也不愿修补那些蹩脚的代码（参见第1章Rob Pike
对此的考量）。这样，那些顶住了数十年发展压力而留存下来的任何源码都经历了可维
护性的考验。这些古老、成功、构建良好的项目和可维护代码一起成为Unix社区实践的
好榜样。
    在评价工具以供使用时，Unix程序员――特别是开源世界的Unix程序员――学会
www.pdf365.com
6.3为可维护性而设计
155
提出的一个问题是：  “代码是活代码、睡代码还是死代码？”活代码周围存在一个非常
活跃的开发社团。睡代码之所以“睡着”，经常是因为对作者而言，维护代码的痛苦超
过了代码本身的效用。死代码则是睡得太久，重新实现一段等价代码更容易。如果希望
让代码成为活代码，则最有效的时间花费方法之一就是投入精力使代码具备可维护性（并
以此吸引未来的维护者）。
    为了透明性和可显性而设计的代码已经朝着可维护性的目标前进了很多。但是我们
从本章所举的实例项目中还能观察到其它一些值得效仿的实践。
    一个非常重要的实践就是应用清晰原则：选择简单的算法。在第1章，我们引用了
Ken Thompson的话：  “拿不准，用穷举”。Thompson完全明白复杂算法的代价――不
仅在于开始实现时更容易出bug，而且更在于维护者要完全理解这些算法更困难。
    另一个重要的实践是要包含开发者手册（hackerts guide）。在发布源码的同时包含指导
文档，简略地描述代码的关键数据结构和算法，这种做法永远得到高度认可。实际上，
跟编写最终用户文档相比，Unix程序员常常更善于编写开发者手册。
    开源社区已经抓住并且细述了这个习惯。除了能给末来的维护者提出建议之外，开
源项目的开发者指南也是为了便于临时贡献者增加功能和修改bug而设计的。随fetchmail
一起发布的Design Notes（设计笔记）文件就是其中的代表。Linux内核源码实际上也包括
很多这样的文档。
    我们将在第19章描述Unix开发者为了让源码发布便于校验和编译执行码所形成的
一些约定。这些实践也促进了代码的可维护性。
UNI×编程艺术
  www.pdf365.com
www.pdf365.com
1j
多道程序设计：
分离进程为独立的功能
Multiprogramming: Separating
Processes to Separate Function
     If we believe in data structures， we must believe in independent （hence simultaneous）
processing. For why else would we collect items within a structurel Why do we tolerate
languages that give us the one without the otherl
  如果我们相信数据结构，我们就必须相信独立的（因而是并发的）处理方式。我们还会为
了其它原因在结构内收集数据吗？为什么我们要容忍那些只给其一不给其二的语言？
Epigrams in Programming， in ACM SIGPLAN （ Vol 17 #9，  1982）
    《编程隽言》 ~ ACM SIGPLAN （1982 17卷 9#）
                                              -Alan Perlis
    Unix最具特点的程序模块化技法就是将大型程序分解成多个协作进程。这在Unix
世界中通常叫做“多处理’’，但在本书中我们将恢复使用老的术语“多道程序设计”．
以避免和多处理器的硬件实现相混淆。
    多道程序设计是设计中的荒蛮之地，几乎没有好的实践方针。许多程序员尽管精于
判断如何将代码分解成子过程（subroutine），然而最终还是编写出单个庞然大物般的单进
程程序，而这些程序往往失败在自身的内部复杂度之．上。
无论在协作进程还是在同一进程的协作子过程层面上，Unix设计风格都运用“做单
www.pdf365.com
1 58
第7章多道程序设计：分离进程为独立的功能
件事并做好”的方法，强调用定义良好的进程间通信或共享文件来连通小型进程。因此，
Unix操作系统提倡把程序分解成更简单的子进程，并专注考虑这些子进程间的接口。这
至少可通过以下三种方法来实现：
    ●  降低进程生成的开销。
●  提供方法（shellout[shell执行模块]、1/0重定向、管道、消息传递和套接字）
  简化进程间通信。
    ●  提倡使用能由管道和套接字传递的简单、透明的文本数据格式。
    平价的进程生成和简单的进程控制对能否以Unix风格编程起着关键作用。在VAX
 VMS之类的操作系统中，启动进程开销极大、速度缓慢并且需要特别的权限，因此人们
别无选择，必须编制单个庞然大物般的程序。幸运的是，Unix家族操作系统的倾向一直
是减轻而不是加重fork （2）的开销。特别是Linux，尤擅此道，倬得讲稗牛成萼E卜许名
其它操作系统的线程生成还要快1。
    历史上，shell编程的经历鼓励了许多Unix程序员从多个协作进程的角度思考问题。
创建由管道连接的多进程组，在后台或前台运行，或者在后台和前台都运行，相对来讲，
在shell中较容易实现。
    在本章剩余部分，我们将分析廉价进程生成昀含义，并讨论如何及何时应用管道、
套接字和其他进程间通信（IPC）方法将设计划分成协作进程（再下面一章，我们将对接
口设计应用同样的功能分离原理）。
    尽管将程序划分成协作进程带来了全局复杂度降低的好处，但代价是我们必须更多
地关注在进程间传递信息和命令的协议设计（在所有种类的软件系统中，接口都是bug
聚集之地）。
    我们在第5章分析了这个设计问题的底层――如何统筹透明、灵活、可扩展的应用
协议。但是还存在另一个而且是更高一层的设计问题，我们当时冒失地忽略了。这就是
为通信各方设计状态机的问题。
    给定模型，如SMTP、BEEP或XML-RPC，则在应用协议语法中运用良好的风格并
不难。真正的挑战不是协议语法而是协议逻辑――设计一个协议，既有充分的表达能力
1例如，参考（（Linux下提高空闲任务的上下文切换性能》（Improving Context Switching Performance
of Idle Tasks under Linux）[Appleton]引用的结果。
UNIX编程艺I术
www.pdf365.com
7.1  从性能调整中分离复杂度控制
159
又有防范死锁的能力。几乎同样重要的是，协议必须看得出很有表现力并可防范死锁：
也就是说人们必须能够在头脑中尝试对通信程序的行为建模并验证其正确性。
    因此，我们的讨论将着眼于那种可以很自然地运用于各种进程间通信的协议逻辑。
7.1  从性能调整中分离复杂度控制
    然而，首先，我们必须排除一些分神之事。我们的讨论并非关于利用并发性提升性
能。在开发出可以把全局复杂度降至最低程度的干净体系之前，关注性能问题便是过早
优化――万恶之源（详细讨论参见第12章）。
    一个密切相关的干扰话题是线程（也就是，共用同一存储地址空间的多个并发进程）。
使用线程是为了调整性能。为了避免长时间分散注意力，我们将在本章结束时更详细讨
论线程。总的来说，线程不是降低而是提高了全局复杂度，因此，除非万不得已，尽量
避免使用线程。
    向说说模块化原则，则不算跑题：它能使你的程序――和你的生活――更轻松。进
程分解的所有理由，都是我们在第4章提出的模块划分缘由的延续。
    另～个把程序划分成多个协作进程的重要原因是为了更强的安全性。在Unix下，必
须由普通用户运行的程序，如果又必须拥有对安全性至关重要的系统资源的写访问杈限，
可以通过一个叫setuid bit的特性获得2。可执行文件是可以拥有setuid bit的最小代码单
元；因此，必须信任setuid可执行程序中的每一行代码（然而，写得好的setuid程序首
先完成所有需要特权的行为，剩下的时间则把权限交还给用户级）。
    通常，一个setuid程序只在一个或很少几个操作中需要特权。常常可以把这样的程
序划分成两个协作进程，小进程需要setuid，大的则不需要。当我们能够这样做时，只须
2 setuid程序并不以调用该程序的用户权限运行，而是以可执行文件拥有者的权限来运行。这个特性
可以用来对口令文件等不允许非系统管理员直接修改的文件实施受限的、程序控制的访问权管理。
www.pdf365.com
160
第7章多道程序设计：分离进程为独立的功能
信任较小程序的代码。Unix比竞争对手拥有更好的安全记录，很大一部分就是因为这种
划分和委托在Unix中是可行的3。
7.2  Unix IPC方法的分类
    和单进程程序体系一样，摄简的就是最好的。本章剩余部分将大致按照编程技术复
杂度由低到高的顺序介绍各种IPC技法。在使用更晚出现、更复杂的技法前，应该通过
实证――用原型和基准检测结果――所有更早出现、更简单的技法都不管用。经常，你
会把自己吓一跳。
7.2.1  把任务转给专门程序
    廉价的进程生成使程序间的协作变为可能，其中最简单的形式就是一个程序调用另
一个程序来完成专门任务。被调用的程序经常通过system （3）的调用被指定为一个Unix
Shell命令，因此这通常称做对被调用程序“shell out”（外壳执行）。被调用的程序在
运行完毕之前接管用户的键盘和显示，退出后，调用程序重新控制键盘和显示并继续运
行4。因为在被调用程序的执行过程中，调用程序并不与之通讯，所以协议设计在这种协
作类型中并不成问题，除非从调用程序可能向被调用程序传递命令行参数以改变其行为
这层微不足道的意义上来说。
    经典的Unix shellout实倒是在邮件或新闻组程序中调用文本编辑器。Unix的传统中，
不要求使用常规文本编辑输入的程序捆绑专门用途的编辑器。相反，允许用户在需要编
辑时指定自选的文本编辑器以供调用。
    专门程序通常借由文件系统与父进程进行通信，方法是在指定位置读取或修改文件；
编辑器或邮件器的shellout就是这样工作的。
    这种模式的常见变形是专门程序可以接受标准输入，用C库的popen（…，”w”）或
作为shell脚本的一部分进行调用。或者专门程序也可以有标准输出，用popen（…，”r”）
或作为shell脚本的部分加以调用（如果它既从标准输入读入又向标准输出写出，则可以
通过批量方式完成，即完成全部读操作之后才进行写操作）。通常不把这种子进程称为
3也就是，按在互联网上每台机器多长时间内会被攻陷来衡量而得出的更好记录。
4 shellout编程的一个常见错误是子进程运行时忘记在父进程中阻塞信号。如果不对此防范，进入子
进程的中断可能会对父进程造成不期望的副作用。
www.pdf365.com
7.2  Unix IPC Z穷去甘9生批类
161
shellout;目前还没有一个标准术语称呼这个子进程，但完全可以称其为“bolt-on’’（栓
合）。
    这些情态的要点在于专门程序在运行时并不需要跟父进程交流。只有在任意一方（主
进程或从进程）接受了另外一个程序的输入，还必须能够对此解析这个意义上来说，它
们之间才存在关联协议。
7.2.1.1  实例分析：mutt邮件用户代理
    mutt邮件用户代理是现代Unix邮件程序中最重要设计传统的典型。它有～个简单的
面向屏幕的界面，使用单键命令来浏览和读取邮件。
    使用mutt撰写邮件（以地址为命令行参数进行调用或使用回复命令）时，它检查进
程环境变量EDITOR，然后生成一个临时文件名。环境变量“EDITOR”（编辑器）的
值作为命令调用，并以临时文件名为参数5。当命令终止时，mutt恢复控制运行，并认定
临时文件包含的文本就是所要的邮件正文。
    几乎所有的Unix邮件和网络新闻撰写程序都遵循同样的约定。正是因此，创作程序
的实现者可以不必编写上百个截然不同的编辑器，用户也不必学习上百个不同的界面。
相反，用户可以使用最喜欢的编辑器。
    这种策略的重要变形通过shelJ调用～个小型代埋程序，让其向正在运行的大程序实
例，如编辑器或网页浏览器等传递专门任务。这样，通常已经在X显示上运行emacs实
例的开发者可以设置EDITOR -emac sclient，当需要在mutt中编辑时，在emacs编
辑～块缓存。这样做的目的并不是真正要节省内存或其它资源，而是为了让用户能够把
所有的编辑动作统一到单独的已macs进程中（这样一来，举例来说，在不同缓存间进行
剪切和粘贴操作时可以捎带诸如字体高亮等emacs的内部状态信息）。
7.2.2管道、重定向和过滤器
    继Ken Thompson年口Dennis Ritchie之后，对早期Unix影响最重要的人大概非Doug
Mcllroy莫属。他发明的管道结构始终闪现在Unix设计中，促进了“做单件事并做好，，
5实际上，上述过程有点过分简化了。完整部分请参考第10章关于EDITOR和VISUAL的讨论。
    UN/X编程艺术
    www.pdf365.com
162
第7章多道程序设计：分离进程为独立的功能
哲学的萌发，并且引发了Unix设计中绝大多数后续IPC方法的诞生（尤其是用于网络的
套接字抽象概念）。
    管道依赖这样的约定，即每个程序一开始（至少）有两个1/0数据流可用：标准输
入和标准输出（文件描述符数字分别为0和1）。许多程序都可写作过滤器，从标准输
入顺序读数据，并且只向标准输出写数据。
    通常，这些数据流分别和用户的键盘和显示器相连接。但是Unix shell普遍支持重定
向操作，可以把这些标准输入输出流连接到文件。举例来说，键入：
Is>foo
    把列目录命令Is （l）的输出写入到名为“foo”的文件中。另一方面，键入：
wc<foo
    将令字数统计程序wc （1）以文件“foo”为输入，然后把字符数／字数／行数发送到
标准输出。
    管道操作把一个程序的标准输出连接到另一个程序的标准输入。用这种方式连接起
来的一系列程序被称为管线。如果我们键入：
Is  ）  wc
    我们可以看到当前目录列表的字符数／字数／行数（在这种情况下，只有行数有真正意
义）。
    一个讨人喜欢的管道线是¨bc I speak¨――一个能说话的桌面计算器。这
个计算器知道1×1063以下数字的叫法。
--Doug Mcllroy
    营道线中所有阶段的程序是并发运行的，注意到这一点很重要。每一段等待前一段
的输出作为输入，但在下一段能够运行前没有哪个段必须退出。这个特性在我们接下来
分析管道系统的交互作用时非常重要，例如把某个命令的超长输出发送给more （l）。
    人们很容易低估管道和重定向的组合能力。《作为第四代语言的Unix Shell》（Unix
Shell As日4GL） [Schaffer-Wolf]是一个很有启发意义的例子，该书指出，以这些功能为框
架，组合一些简单实用程序，就可以创建和操控简单文本表格形式的关系数据库。
www.pdf365.com
7.2 Unix IPC方法的分类
163
    管道的主要缺点是单向性。管道线的成员除了终止外（在这种情况下，前一阶段的
程序会在下一个写操作时得到SIGPIPE信号）不可能回传控制信息。因此，传输数据
的协议简化为接受端的输入格式。
    目前为止，我们已经讨论了shell创建的匿名管道。还有一种变种，叫做“命名管道’’，
是～种特殊的文件。如果两个程序打开这个文件，一个读取，另一个写入，则命名管道
扮演两者间的配接器。命名管道已经成了老古董：在使用中，大部分已经被我们下面将
要讨论的命名套接字取代了（有关这个老古董的更多细节，参考以下System V IPC的讨
论）。
7.2.2.1实例分析：为分页程序建立管道
    管线有很多用处。举一个例子来说，Unix的进程列举程序ps（1）在标准输出上列
举进程时，并不关心长列表在用户的滚屏速度太快会造成用户无法看清。Unix还有另外
一个程序more（，1），它按屏幕大小显示标准输入，每次满屏显示后等待用户按键显示
下一满屏。
    这样，如果用户键入”ps l more”，把ps （1）的输出管道连接至more （1）的输
入，则每次按键后可以继续显示一整屏的进程列表。
    如此组合程序的能力极为有用。但此赴真正的成果并不是这个漂亮的组合，而是由
于管道和more（1）两者的存在，其它程序可以变得更简单一些。管道意味着Is （1）（以
及其它写标准输出的程序）之类的程序无需开发自己的分页程序――我们得以从一个到
处都是内置分页程序（自然，每个分页程序都有不同的观感）的世界中解救出来。这就
避免了代码的臃肿，降低了全局复杂度。
    一个额外好处是，如果需要定制分页程序行为，可以只在一个地方、改变一个程序
就行了。确实，可以存在多个分页程序，并且这些分页程序对每一个写标准输出的应用
程序都非常有用。
    实际上，这确实已经发生了。现代Unix中，more （1）基本上已被less（1）取代。
less（】）对显示的文件增加了向后滚屏的能力，不再只能向前滚屏6。因为less（1）独立
于使用它的程序，所以只需在shell中简单地将“less"指定“more”的alias，把环境变
量PAGER（分页器）设置成“less”（参考第10章），然后就可以在所有正确编写的
Unix程序中享受到更好分页程序所带来的全部好处了。
6 less（】）的手册页解释说，这个名字遵循了“Less is more”  （少即是多）。
UNl×编程艺术
  www.pdf365.com
164
第7章多道程序设计：分离进程为独立的功能
7.2.2.2实例分析：制作单词表
    一个更加有趣的例子是通过管道相连的程序来协作完成某种数据变换。在没有这么
灵活的环境中，要实现这点就必须定制代码。
    考虑以下管线：
七r  ―c  ’[: alnum:]‘  ’[＼n★]’  I  sort -iu  l  grep -v  1“[0―9]★S‘
    第一个命令把标准输入中非字母和数字的字符在标准输出上转换为新行。第二个命
令对标准输入的行进行排序，对于所有重复的相邻行只保留一个，然后把排好序的数据
写到标准输出。第三个命令去掉所有只含数字的行。合起来，这些操作把标准输入的文
本生成了经过排序的单词表送到标准输出。
7.2.2.3实例分析：pic2grap，7
    程序pic2graph的shell源码和自由软件基金会的groff文本格式化工具套件一起发
布。它把用PIC语言编制的图表转换为位图图像。例7.1展示了这个代码核心部分的管
线。
例7.1  pic2grah管线
 （echo  " +EQ" ;  echo  $eqndelim;  echo  IF *EN" ;  echo  '_ . PS";cat; echo  " . PE'* ） l\
       groff -e -p $groffpic_opts -Tps >${tmp}.ps \
         && convert -crop Ox0 $convert_opts $ttmp}.ps ${tmp}.${format} \
          &&  caL  $ （tmp} .$ { format }
    pic2graph（I）实现展示了仅仅依靠调用现有工具的管线能够完成多少任务。管线首
先把其输入揉制成适当的形式，然后将其传入grofj（1）以生成PostScript，最后从PostScript
转换成位图。它对用户隐藏了所有细节，用户只看到PIC源从一端进入，另一端产生了
可包含在网页中的位图。
    这是一个有趣的例子，因为它说明了管道和过滤器怎样使程序适应非预期的用法。
解释PIC的程序pic （1），最初只是为了在排版文档中嵌入图表设计的。在包含pic （1）
程序的一套工具中，绝大多数程序都行将过时。但是PIC在新用法中仍然十分便利，比
www.pdf365.com
7.2  Unix IPC方法的分类
165
如描述内嵌在HTML中的图表等。把pic （l）的输出转换为更现代格式所需要的全部机
制，可以由pic2graph（1）这类工具捆绑在一起，所以它也获得了新生。
    作为微型语言的例子，我们将在第8章进一步分析pic （1）。
7.2.2.4实例分析：bc （1）和dc （1）
    开始于版本7的经典Unix工具包包括一对计算器程序：dc （l）程序是一个简单的
计算器程序，从标准输入端接受逆波兰标记法（RPN）的文本行，并向标准输出发送计
算结果；bc （1）程序接受类似传统代数记数法的更加复杂的中缀表示法，它同样具备设
置和读取变量并为复杂公式定义函数的能力。
    尽管bc（1）目前的GNU实现版本不依赖其它程序，其经典版本却通过管道把命令
传递给dc（1）。在这种分工中，bc （1）完成变量代入和函数展开，并将中缀表示法转
换为逆波兰表示法――但实际上本身并不完成计算，相反，把输入表达式转换成RPN形
式传递给dc （l），由dc （1）来完成计算。
    这种功能分离具有明显的优势。它意味着用户可以选择自己喜欢的表示法，却无需
重复实现任意精度的数字计算逻辑（这有点需要技巧）。组合中的每一个程序都没有住
何需要选择表示法的程序复杂。这两个程序既可以独立调试，也可以独立建模。
    我们将在第8章从专门领域的微型语言这个略有不同的角度再次分析这些程序。
7.2.2.5反例分析：为什么fetchmail不是管线
    按照Unix的界定，fetchmail是个令人不舒服的庞大程序，选项繁多。想想邮件传输
的工作方式，有人可能想把它分解成一个管线。暂且假设它已被分解成这几个程序：一
对从POP3和IMAP站点获取邮件的读取程序，一个本地的SMTP队列放置器（injector）。
管线应该能够传递Unix信箱格式。当前复杂的fetchmail配置完全可以由包含命令行的
shell脚本来取代，甚至还可以在管道线中插入过滤器来拦截垃圾邮件。
# ! /bin/sh
imap jrandom@imap+ccil.org ; spamblocker I sm七p jrandom
imap jrandom@imapnetaxs.com I smtp jrandom
#  pop  ed@pop.tems .com  I  smtp  jrandom
UNIX编程艺术
    www.pdf365.com
166
第7窜多道程序设计：分离进程为独立的功能
    这可能会非常优雅，非常Uflix化。不幸的是，这行不通。我们在早些时候已经简略
谈到了其中的原因：管线是单向的。
    取信程序（imap或pop）必须要完成的一件事是决定应否为已取回的每一条消息发
送一个删除请求。在fechmail目前的结构中，它可以延迟向POP或IMAP服务器发送删
除请求，直到得知本地SMTP监听程序已经接管该消息。由管道连接的组件版本将丢失
这个特性。
    举例来说，请考虑，如果因为SMTP监听程序报告磁盘己满导致SMTP队列放置程
序失败，会发生什么呢？如果取信程序已经删除了这个邮件，我们就完了。这意味着，
smtp队列放置器通知取信程序删除邮件之前，取信程序不能删除邮件。这反过来产生了
一大堆问题。他们之间如何通信？确切地说，队列放置器应该返回什么样的消息呢？相
应系统的全局整体复杂度以及易出错性，几乎肯定要比单块程序高。
    管线是一个了不起的工具，但不是万能的。
7.2.3包装器
    和shellout程序相对的是包装器（wrapper）。包装器或者将被调用程序专用化，或者
为它创建新的接口。包装器经常用于隐藏shell管线的复杂细节。我们将在第1 1幸讨论
接口包装器。大多数专用化包装器都相当简单，但非常有用。
    和shellout -样，由于被调用程序执行过程中程序之间并不通信，因此也不存在相关
协议；但是，包装器之所以存在，常常源于要指定参数来修改被调用程序的行为。
7.2.3.1  实例分析：备份脚本
    专用化包装器足Unix shell和其它脚本语言的经典用途。既常用又典型的一类特化包
装器是备份脚本，它可能简单到只有这样的一行：
tar  -czvf  /dev/st0  ‘’S@"
    这是一个为tar （1）磁带归档程序编写的包装器，这个包装器只简单地提供一个固
定参数（磁带设备／dev/s t-O），并把用户提供的其它参数（”$@”）7传递给tar。
7一个常见错误是使用$★而不是“$@”。这在传递含有空格的文件名时会出问题。
www.pdf365.com
7.2 Unix IPC方法的分类
167
7.2.4  安全性包装器和Bernstein
    包装器脚本的常见用法是安全性包装器。安全性包装器可调用守门程序检查某类凭
证，然后根据返回的状态值有条件地执行另一个程序。
    Bemstein链（Bemstein  chaining）是一个专用化的安全性包装器技法，由Daniel
J.Bernstein首先发明。Bernstein在他的许多程序包中都使用了安全包装器（在nohup （1）
和su （l）之类命令中使用类似的手法，但是无法检查条件值）。从概念上来说，Bemstein
链和管线类似，只不过每个继发阶段的程序取代了前一阶段的程序，而不是与之并行。
    通常的应用是把较高安全级别的应用程序限制在某类门卫程序中，由这个程序把状
态传递给一个权限较低的程序。这种技法使用一组exec，或者综合fork和exec把几个程
序粘在一起。所有程序名都在一个命令行中得到指定。每个程序执行某个功能，  （如果
成功的话）用命令行剩余部分调用exec （2）。
    Bemstein的rblsmtpd包就是一个原型例子。它用于在邮件滥用防御系统（Mail Abuse
Prevention System）的垃圾邮件DNS城中查询主机。方法是通过载入环境变量
“TCPREMOTEIP”的值取得IP地址，然后对其进行DNS查询。如果查询成功，rblsmtpd
就运行自己的SMTP以丢弃这个邮件。如果不成功，它就假定剩余的命令行参数构成一
个知道SMTP协议的邮件传输代理，交给exec （2）来运行。
    Bernste】n的qmail包是另外一个例子。qmail包含有condredirect程序。第一个参数
是个邮件地址，剩余部分是门卫程序及其参数。condredirect首先fork，然后对门卫程序
带参数进行exec。如果门卫程序成功退出，condredirect就把在标准输入端（stdin）的待
处理邮件发送到指定的邮件地址。在本例子中，与rblsmtpd相反，安全策略由子进程决
定。这种情况更像经典的shellout。
    更精巧的例子是qmail的POP3服务器。它由三个程序构成，即qmail-popup、
checkpassword和qmail-pop3d。checkpassword程序是一个独立包，很聪明地命名为
checkpassword，而且让人一点不意外的是，它就是用来检查口令的。POP3协议包括认
证阶段和邮箱操作价段：一旦进入邮箱操作阶段就不能回到认证阶段。这是Bemstein链
的一个完美应用。
    qmail-popup的第一个参数是POP3提示中使用的主机名。取回POP3的用户名和口
令后，进行fork操作，并将其余参数传递给exec （2）。如果程序返回失败，口令肯定
错误，qmail-popup就报告这个错误并等待一个不同的口令。反之，程序就假设已经完成
POP3对话，qmail-popup从而退出。
UN）×奎秘里艺术
  www.pdf365.com
1 68
第7章多道程序设计：分离进程为独立的功能
    qmail-popp命令行中指定的程序要从文件描述符3处读取三个以null结束的字符串8。
它们是用户名、口令，以及如果有的话，对密码的攻击回应。这～次应该是checkpassword
老qmail-3d的名称及其参数作为参数接受。如果口令不符合，checkpassword程序就失败
退出；反之，它就切换到用户的uid、gid和主目录下，并以用户身份执行剩下的命令。
    如果应用程序需要setuid或setgid优先权来初始化连接或获得某些认证，然后放弃
这些权限让后续代码无须被信任，这时Bernstein链非常有用。在exec后，子程序无法把
用户真实ID设置回root用户。同时，这样做也比单进程灵活，因为可以在程序链中插入
另一个程序来修改系统的行为。
    例如，rblsmtpd（前面已提到）可以插进Bernstein链，放在tcpserver（来自ucspi-tcp
包）和真正的SMTP服务器（通常是qmail-smtpd）之间。当然，它也跟inetd （8）和
sendmail -bs合作得很好。
7.2.5从进程
    有时候，子程序通过连接到标准输入和标准输出的管道，变互地和调用程序收发数
据。同简单的shellout以及我们前面称为“bolt-on”的机制不同之处在于，主进程和从进
程都需要内部状态机处理它们之间的协议以避免发生死锁和竞争。比起简单的shellout，
这种结构远远更复杂、更难以调试。
    Unix的popen （3）调用可以为shellout搭建输入或输出管道，但是不能为从进程搭
建这两种管道――这似乎有意鼓励更简单的编程。而且，事实上，交互的主／从通信极为
复杂，通常只在这两种条件下使用：  （a）两者间涉及的协议完全无足轻重，或（b）从
进程是为以我们在第5章讨论的应用协议进行通讯而设计的。我们将在第8章再次分析
这个问题并讨论解决方法。
    在编写主／从进程对时，一个好方法是，让主进程支持命令行开关或环境变量来允许
调用者设置自己的从进程命令。抛开其它好处，这尤其有利于调试：经常可以发现，在
8 qmail_popup的标准输入和标准输出是套接字，标准错误（文件描述符为2）被转向为日志文件。必
须保证下一个分配得到的文件描述是3。正如一段臭名昭著的的内核注释所写的：  “不指望你能理解
这个”。
www.pdf365.com
7.2 Unix IPC方法的分类
169
开发过程中，从监视和记录主从进程之间事务处理的辅助程序中调用真正的从进程，会
带给你很多方便。
    如果发现程序中主／从进程的交互不再微不足道，剩下的，也许是考虑使用套接字或
共享内存等技法，走更趋对等结构的路了。
7.2.5.1  实例分析：scp和ssh
    两者间通信协议的确无足轻重的一个常见情况是进度显示程序。scp （1）安全拷贝
命令把ssh （1）作为从进程调用，从ssh的标准输出中截取足够的信息，然后把报告重
新组织成为ASCII动画形式的进度条。9
7.2.6对等进程间通信
    迄今我们已经讨论的各种通讯方法都存在隐含的层次关系，即一个程序实际上控制
或驱动另一个程序，而在反方向却没有或仅有有限的反馈。在通信和网络中，我们常常
需要对等的通道，通常（但不一定）需要数据能自由地双向流动。接下来，我们将分析
Unix中的对等通信方法，并在以后几章中逐步展开一些实例分析。
7.2.6.1  临时文件
    把临时文件作为协作程序之间的通信中转站使用，是最古老的IPC技法。虽然存在
～些缺点，但临时文件在shell脚本及一些一次性程序中仍然非常有用，在这些程序中使
用其它更复杂、更需协调的通信方式未兔有点小题大做。
    把i临时文件作为IPC技法使用最明显的问题是，如果进程在临时文件可被删除前中
断，则往往会遗留垃圾数据。另一个更隐蔽的风险是，如果程序的多个实例都使用同一
个名字作为临时文件名，则会产生冲突。这就是为什么shell脚本的惯例是在临时文件名
中包含“$$"符号的原因；这个shell变量将被展开为载入shell的进程ID，从而有效地
保证了文件名的唯一性（Perl也支持同样的技巧）。
9一个推荐这个实例分析的朋友评论：“是的，是可以不用这种技法……如果从进程返回的信息中恰
有几块容易识别的天然贵金块，而你正好又有夹子和防辐射服。”
UNIX编程艺_术
  www.pdf365.com
170
第7章多道程序设计：分离进程为独立的功能
    最后，如果攻击程序知道临时文件将要写入的位置，就可以覆盖掉那个文件，很可
能读取生产者进程的数据，或者通过在文件中插入修改或假造的数据哄骗消费者进程10。
这可是一种安全性风险。如果涉及的进程拥有root用户权限，风险就更为严重。当然可
以通过仔细设置临时文件目录的权限来缓解这个问题，但很多人都知道，这种部署很难
万无一失。
    撇开所有这些缺点，临时文件仍然还有一席之地；因为它们很容易创建，很灵活，
与那些复杂的方法相比，没那么容易产生死锁和竞争。而且，有时候，别的方法都派不
上用场。子进程的调用约定可能要求子进程必须得到一个文件来操作。我们在本章所举
的第一个例子，即编辑器shellout出的子进程就是个完美的实证。
7.2.6.2信号
    要让同一台机器上的两个进程相互通信，最简单最原始的方法是一个进程向另一个
发送苈号。Unix的信号是一种软中断形式：每个信号都对接收进程产生默认作用（通常
是杀掉它）。进程可以声明信号处理程序，让信号处理程序覆盖信号的默认行为；处理
程序是一个与接受信号异步执行的函数。
    信号被设计进Unix，最初是作为操作系统就某些错误或关键事件通如程序的一种机
制，并不是作为IPC功能设计进来的。举例来说，SIGHUP信号在会话结束时被发送给
每一个从该指定终端会话启动的程序。SIGINT信号，是在用户键入当前定义的中断字
符（通常是control-C）时发送给当前每一个连接键盘的程序。然而，信号对一些IPC情
形也很有用（而POSIX标准信号集就是为了这个使用目的才包含SIGUSR1和SIGUSR2
两个信号的）。它们经常用作守护程序（在后台不间断运行而且不可见的程序）的控制
通道，操作者或另一个程序用来通知守护程序重新初始化自身，或醒来执行工作，或向
已知位置写入内部状态／调试信息的方法。
    我坚持认为SIGUSR1和SIGUSR2是为BSD发明的。人们抓走了一些系统信号，
使之成为他们所希望的IPC含义。这样一来，  （例如），由于SIGSEGV己被挪用，所
以出现分段错误的程序就不会进行核心转储（ coredump）了。
10这种攻击特别危险的变形就是在生产者进程和消费者进程都期望是临时文件的地方，放一个同名
的命名Unix域套接字。
www.pdf365.com
7.2 Unix IPC方法的分类
171
    这是一个普遍原则一一人们总想挪用你写的任何工具，所以必须把它们设计
成要么根本无法挪用要么总是可以干净地挪用。这是你仅有的选择。当然，除非
被忽略一一这是一个非常可靠的保持清白的方法，但并非最初看起来的那样满意。
-Ken Arnold
    随信号IPC经常使用的一种技法是所谓pidfite。需要信号的程序会向已知位置写入
一个包含进程ID （PID）的小文件（通常放在Nar/run或调用用户的主目录下）。其它
程序可以读取这个文件来获得PID。如果守护程序只允许一个实例运行，则pidfile也可
作为隐含的文件锁使用。
    实际上存在两种不同口味的信号。在老一点的实现（特别是如V7、System ni和早
期的System V）中，给定信号的处理程序无论何时启动，该处理程序就会被复位为信号
的默认值。因此，无论处理程序如何设嚣，快速连续发送两个同样的信号通常就会杀死
进程。
    BSD 4.x版本的Unix变成了“可靠’’的信号，除非用户明确要求，它是不会复位的。
它们同时也引入了原语操作，阻塞或临时挂起指定信号集的处理。现代Unix支持这两种
方式。应该对新代码使用BSD风格的不复位入口方法，怛是必须进行防预性编程，以防
代码移植到不支持这种方法的实现中。
    收到N个信号并不一定N次调用信号处理程序。在老一点的System V信号模型中，
如果两个或两个以上的信号间隔很小（更确切地说，是在目标进程的同一个时间片内），
可能产生各种竞争¨或异状。根据系统支持的信号语义的不同，第二个或更后面的信号可
能会被忽略掉，可能会误杀一个进程，也可能延迟到前面的实例已经处理完后才发送（在
现代Unix中，这种情况最可能发生）。
    现代的信号API可以移植到最近所有的Unix版本中，但是不能移植到Windows或
传统（os X以前）的MacOS中。
¨  “竞争”是这样的一类问题，在这类问题中，系统的正确行为取决于两个独立事件按照正确顺序
发生，但是又没有机制来保证这两个独立事件实际上能够这样发生。竞争产生间歇性的、与时间有
关的问题，非常难以调试。
UNIX编睡；艺术
  www.pdf365.com
172
第7章多道程序设计：分离进程为独立的功能
7.2.6.3系统守护程序和常规信号
    许多著名的系统守护程序都接受SIGHUP（最初，这个信号在有串行线事件时发送
给程序，比如挂断调制解调器连接的操作就产生这个信号）作为重新初始化的信号（也
就是说，重新载入配置文件）：例子包括Apache和Linux的bootpd （8）、gated （8）、
inetd （8）、mountd （8）、named （8）、nfsd （8）和ypbind （8）实现。在一些例子中，
SIGHUP作为其对话关闭信号的最初意义被程序接收（特别是Linux的pppd （8）），
但是这种作用现在通常都交给SIGTERM了。
    SIGTERM（“终止”）常常扮演温和的关闭信号（区别于SIGKILL，立即杀死进
程，而且本身不能被阻塞或另外处理）。SIGTERM的行为通常包括清除临时文件和强
制把最新更新刷回数据库以及其它一些类似行为。
    在编写守护程序时，请遵循最小立异原则：使用这些约定，阅读手册来寻找现有模
型。
7.2.6.4实例分析：fetchmail的信号使用
    fetchmail实用程序通常被配置成在后台运行的守护程序，无需用户干预就能定期从
运行控刮文件定义的所有远程站点收集邮件，并传送给端口25的本地SMTP监听程序。
为了避免一直占用网络，fetch，nail在收集邮件期间根据用户定义的时间间隔休眠（默认
    ．    一
值是15分钟）。
    当不带参数调用f etchmail时，它首先检查是否已经有ferchmail守护程序在运行
（通过查找pidfile来完成）。如果没有，fetchmail采用运行控制文件指定的控制信息正
常启动；相反，如果有，fetchmail新进程仅仅发信号通知老进程，使其立即苏醒并收集
邮件，然后新进程就会终止。此外，fetchmail -q向任何正在运行的fetchmail后台
程序发送终止信号。
    这样，键入f etchmail实际上意味着“现在选出并留一个运行的后台程序等待以
后查询；不要拿后台程序是否已经运行这样的细节来烦我”。注意，至于用哪个具体信
号来唤醒和终止的细节就无需用户知道了。
7.2.6.5套接字
    套接字作为一种封装网络数据访问的方法从Unix的BSD -脉中发展而来。通过套
接字通信的两个程序通常都存在双向字节流（存在其它套接字模式和传输方法，但是重
www.pdf365.com
7.2  Unix IPC方法的分类
173
要性不大）。字节流既是按序的（也就是说，即使按单个字节发送也按照发送顺序来接
收）又是可靠的（套接字用户得到保证，底层的网络将进行错误检测和重发以确保交付）。
套接字描述符一旦获得，行为基本上和文件描述符一样。
    套接字和读／写操作有一个重要区别。如果发送的字节已经到达，但是接收的
  机器却没有ACK确认，发送机器的TCP/IP栈将超时。因此得到一个错误不一定
  意味着字节没有到达；接收端可能已经用上了这些字节。这个问题对可靠协议的
  设计具有深远的影响，原因是即使不知道哪些数据已经被接收到，也仍然必须正
  确工作。本地输入／输出（ u0）就是“是／否’’的判断，而套接字输入／输出（1/0）
  则是“是，否他许”的判断。而且没有任何东西能够确保交付――远端的机器说不
  定已经被彗星撞毁了。
-Ken Arnold
    在创建套接字的时候，可以指定协议族来告诉网络层如何解释套接字的名称。人们
  通常认为套接字和互联网有关，是一种在不同主机上运行的程序之间传递数据的方法，
  这是AF_INET套接字族。在这个套接字族中，地址被解释为主机地址和服务编号对。然
  而，AF_UNIX（也称为AF_LOCAL）协议旗支持同样的套接字抽象，作为在同一台机器
，上（名字被解析为特殊文件的位置，与双向命名管道类似）两个进程之间的通信方式。
  举个例子，使用X window系统的客户端程序和服务器程序通常就使用AF_LOCAL套接
  字进行通信。
    所有现代Unix都支持BSD风格的套接字，一个设计事实是，无论协作进程在何处
安置，这些套接字通常都是用于双向IPC的正确方法。性能压力可能会促使你使用共享
内存、I临时文件或其它要求更多局部性条件的技法，但是在现代的情况下，最好设想代
码需要增加分布式操作。更重要的是，这些局部性设想可能意味着系统的某个部分与其
它部分的内在关系过于密切，超过了良好设计能够容忍的程度。经过套接字强化的分离
地址空间是一个特性，不是bug。
    要优雅地使用套接字，在Unix传统中，首先得设计这些套接字之间使用的应用协议
――即一套请求和响应，能够简洁地表达程序通讯的语义。我们在第5章已经讨论了设
计应用协议的一些主要问题。
所有新近的Unix版本、Windows和经典的MacOS都支持套接字。
UNIX编程艺I术
    www.pdf365.com
174
第7章多道程序设计：分离进程为独立的功能
7.2.6.5.1  实例分析：PostgreSQL
    PostgreSQL是一个开源的数据库程序。如果它的实现是单个庞然大物式程序，就会
成为单进程程序，有交互式界面，直接在磁盘上处理数据库文件。界面和实现就会结合
在一起，一个程序的两个实例，如果试图同时处理同一数据库，就会产生严重的竞争和
死锁问题。
    相反，PostgreSQL套件包括一个叫做postmaster的服务器程序和至少三个客户应用
程序。每台机器的postmasier服务器进程在后台运行并拥有对数据库文件的独占访问权。
它通过TCP/IP套接字接受SQL查询语言的请求，并且返回文本格式的结果。当用户运
行PostgreSQL客户端时，该客户端启动一个和postmaster的会话并与之进行SQL事务处
理。服务器程序可以一次处理好几个客户端会话，并且对这些请求排队，所以它们不会
互相干扰。
    因为前端和后端是分开的，所以服务器程序除了知道如何解释客户端的SQL请求并
返回报表外，不需要知道其它任何事情；另一方面，客户端也不必知道数据库是如何存
储的。客户端可以依不同的需求定制并且拥有不同的用户界面。
    这种组织彤式在Unix数据库中相当典型――甚至经常可以把不同SQL客户端和服
务器程序结合并匹配起来使用。所产生的互操作性问题只是SQL服务器端的TCP/IP端
几号可能不同，以及客户端和服务器是否支持同一种SQL语言。
7.2.6.5.2  实例分析：FreecIv
    在第6章，我们把Freeciv作为透明数据格式的例子介绍给大家。但是与其支持多人
游戏方式比起来，更关键的是代码的客户端／服务器划分。这是一个其应用必须在广域网
上分布，并通过TCP/IP套接字进行通信的典型例子。
    Freeciv游戏的运行状态由服务器进程，即游戏引擎来维护。玩家运行GUI客户端，
通过包协议和服务器交换信息和命令。所有的游戏逻辑都在服务器端处理；GUI的细节
在客户端处理，不同的客户端支持不同的界面风格。
    这是多人在线游戏非常典型的一种结构。包协议使用TCP/IP进行传输，因此服务器
可以处理运行在不同互联网主机上的客户端。其它那些更像实时模拟（特别是仿真视角
射击游戏）的游戏使用原始的互联网数据报协议（UDP），并且牺牲了包发送的不确定
www.pdf365.com
7.2  Unix iPC方法的分类
1 75
性来降低延迟。在这种游戏中，用户通常连续地发送控制动作，所以零星的信号丢失是
可以忍受的，但是延迟却是致命的。
7.2.6.6共享内存
    尽管使用套接字通信的两个进程可能在不同机器上（实际上，可能跨越半个地球而
通过互联网连接起来），而共享内存要求生产者和消费者程序必须在同一硬件上。但是，
如果通信进程能够访问同一个物理内存，则共享内存将是它们之间最快的信息传递方法。
    共享内存可能以各种API的面貌呈现，但是在现代Unix中，共享内存的实现通常依
靠使用mmap （2），把文件映射成可以被多个进程共享的内存。POSIX定义了具有API
的shm_open （3）功能，支持把文件作为共享内存使用，这通常是对操作系统的提示，
告诉它无需把伪文件数据刷到磁盘上。
    因为对共享内存的访问不能通过类似于读写调用的规范自动序列化，所以处理共享
的程序必须自己处理竞争和死锁问题。典型方法是在共享段中使用信号量变量。此处产
生的问题和多线程（参考本章末的讨论）产生的问题类似，但是更容易管理，因为默认
值是不共享内存。这样，这些问题能够得到更好的遏制。
    在共享内存可用并且可靠的系统中，Apache网页股务器的记录牌功能使用共享内
存，作为Apache主进程和它管理的Apache映像负载分配池之间通信的方式。现代的X
实现也使用共享内存在位于同一机器上的客户端和服务器之间传递大图像，以避免套接
字通信的开销。这些使用都是得到经验和测试证实的性能优化而不仅仅是体系选择。
    所有现代的Unix都支持mmap （2）调用，包括Linux和开源的BSD版本，这在《单
- Unix规范》（Single Unix Specification）中有描述。一般来说，Windows、传统的MacOS
和其它操作系统都还不支持这个调用。
    在有特制的mmap （2）可用之前，两个进程通信的常用方法是打开同一个文件然后
将其删除。在所有已打开状态的文件句柄都关闭之前，这个文件不会被删除，但是一些
老的Unix版本把连接计数降到零，作为可以停止更新文件在磁盘数据的提示。不利的方
面是，存储回填用的是文件系统而不是交换设备，被删除文件所在的文件系统在使用该
文件的程序关闭之前不能卸摘，而且把新进程附到（attach）已存在的、按这种方式模拟的
共享内存段中极为复杂。
UNI×编程艺术
  www.pdf365.com
176
第7章多道程序设计：分离进程为独立的功能
    在版本7以及BSD和System V系列分开后，Unix的进程间通信朝两个不同的方向
发展。BSD方向产生了套接字；另一方面，AT&T系列发展了命名管道（见前面讨论）
和一种基于共享内存双向信息队列、为传输二进制数据而专门设计的IPC功能。这被称
为“System V IPC"-或者，在那些老前辈当中，被称为“Indian Hill" IPC，以AT&T
的实验室命名，这是其最初编写的地方。
    System V IPC传递消息的上层已经逐渐被废弃了。而由共享内存和信号量构成的底
层，在同一台机器上运行的进程间需要完成互斥锁定和全局数据共享的情况下，仍1日具
有非常重要的应用。这些System V的共享内存功能发展成了POSIX的共享内存API，
Linux、BSD、MacOS X和Windows都支持，但是经典的MacOS不支持。
    使用这些共享内存和信号量功能（shmget （2）、semget （2）及其类似机能）可以避
免通过网络栈复制数据的开销。大型商业数据库（包括Oracle、DB2、Sybase和Informix）
大量使用这种技术。
7.3要避免的问题和方法
    尽管基于TCP/IP酌BSD风格套接字已经成为主流的Unix IPC方法，但是人们对于
如何通过多道程序达到正确的划分仍然争论不休。一些过时的方法还没有完全消亡，而
一些从其它操作系统中移植过来的（通常与图形或GUI编程有关）技术值得怀疑。下面
我们将在危险的沼泽中游历：小心鳄鱼。
7.3.1  废弃的Unix IPC方法
    Unix（诞生于1969年）比TCPJIP（诞生于1980年）以及二十世纪九十年代和后期
无处不在的网络要早多了。匿名管道、重定向和shellout很早就在Unix中存在了，但是
Unix的历史充满了与过时的IPC及网络模型联系在一起的API遗骸，其中出现在版本6
（1976年）而在版本7（1979年）之前废弃的mx（）机能是其始作俑者。
    最后，BSD套接字胜出，成为与网络统一的IPC。但是这段摸索用了15年，期间留
下了很多遗迹。因为Unix文档可能还会提到这些，可能会让人误解它们仍在使用，所以
www.pdf365.com
7.3要避免的问题和方法
177
知道这些非常有用。这些废弃的方法在《Unix网络编程》（Unix Network Programming）
[Stevens90]中有更详细的描述。
    对于旧AT&T Unix中所有消亡的IPC功能的真正解释就是管理策略。Unix支
持小组由一个底层经理领导，而一些使用Unix的项目却由副总裁领导。这些副总
裁总有办法制造不可抗拒的请求，并且不能容忍大多数IPC机制都可互换这样的
异议。
7.3.1.1    System V IPC
-Doug Mcllroy
    System V IPC功能是基于我们此前讨论的System V共享内存的消息传递机能。
    使用System V IPC协作的程序通常定义基于短（不超过8K）二进制信息交换的共
享协议。相关的手册页有msgctl （2）及其相关页。由于这种方法多半已经被套接字间传
递的文本协议所取代，在这里我们就不举例了。
    System V IPC功能存在于Linux和其它现代Unix中。然而，由于它们是一种历史遗
留功能，所以不很经常使用。Linux版本直到2003年中期还存在bug。但似乎没人愿意
修复这些bug。
7.3.1.2  Steams
    Streams networking<网络流）由Dennis Ritchie为Unix版本8（1985年）创造。一
个重新的实现叫做STREAMS（是的，在文档里全是大写字母），最早发布在System V Unix
（1986年）3.0版中。STREAMS机能在用户进程和指定的内核驱动程序之间提供全双工
的接口（功能上类似BSD套接字，在初始设置之后通过普通的read （2）和write （2）
操作进行访问）。设备驱动程序可能是串口或网卡之类的硬件，也可能是为了在用户进
程之间传递数据而设置的纯软件模拟设备。
    Streams和STREAMS挖都具有～个有趣特性，就是可以把协议转换模块推到内核处
理线中，这样用户进程通过全双工通道“看到”的设备实际上被过滤掉了。举例来说，
这个能力可用于实现终端设备的行编辑协议。或者，可以实现IP或TCP之类的协议而
不用把它们直接整合在内核当中。
Streams最早是整理所谓“行守则”――另一种处理串行终端和早期局域网字符流的
12 STREAMS要复杂得多。据传闻Dennis Ritchie曾说过“大声说sLreams时，含义就有所不同了”。
www.pdf365.com
178
第7章多道程序设计：分离进程为独立的功能
模式――内核凌乱特性的一种尝试。但随着串行终端从人们视野中淡出，以太局域网到
处存在，TCPfIP逐出其他协议栈而归并到Unix内核，STREAMS所提供的特别灵活性越
来越无用武之地。在2003年，System V Unix仍然支持STREAMS，一些System lUBSD
的混和Unix操作系统，如DigitaJ Unix和Sun Microsystem的Solaris也同样支持
STREAMS。
    Linux和其它开源Unix实际上已经抛弃了STREAMS。LiS（Linux Stream）项目的
Linux内核模块和程序库可从<http：／/www．gcom．com/home／linux／lis／>获得，
但是（直到2003年中期）它们还没有整合到Linux内核主干中。其他非Unix操作系统
并不支持它们。
7.3.2远程过程调用
    尽管偶有例外，如NFS（Network File System，网络文件系统）和GNOME （GNU
Network Object Model Environment，GNU网络对象模型环境）工程，但是引进CORBA、
ASN.1和其它远程过程调用接日形式的尝试大多失败了――这些技术至今还没有为Unix
文化所吸纳。
    造成这一点似乎有几个根本原因。其中之一是RPC接口不是那么容易做到可显的：
也就是说，难以按功能查询接口，而如果不编写和被监控程序同样复杂的专用工具，也
难以监控程序的行为（我们已经为此在第6章讨论了一些理由）。RPC接口和库一样具
有版本不兼容（ version skew）问题，但是更难追查，因为它们是分布的，而且不会体现
在链接过程中。
    与之相关的问题是，类型标记越丰富的接口往往越复杂，因而越脆弱。随着时间的
推移，由于在接口之间传递的类型总量逐渐变大，单个类型越来越复杂，这些接口往往
产生类型本体蠕变问题。这是因为结构比字符串更容易失配：如果两端程序的本体不能
正确匹配，要让它们通信肯定很难，纠错难上加难。最成功的RPC应用，如网络文件系
统，都是那些在应用定义域上本来就只涉及很少量简单数据类型的应用。
    支持RPC的常见理由是它比文本流方法允许“更丰富”的接口――也就是说，接口
可以具有更复杂、更专用的数据类型本体。但是想想简洁原则吧！我们在第4章有过考
察，接口的功能之一是充当阻隔点，防止模块的实现细节彼此泄漏。因此，支持RPC的
主要理由同耐恰恰证明了RPC增加了，而不是降低了程序的全局复杂度。
www.pdf365.com
7.3要避免的问题和方法
1 79
    使用经典的RPC太容易用复杂晦涩的方式完成任务，而不是保持其简单。RPC似乎
鼓励生产规模庞大、结构复杂、过度行工的系统，加上令人糊涂的接口、居高不下的全
局复杂度、严重的版本不兼容和可靠性问题――简直就是厚胶合层为非作歹的完美实例。
    Window COM和DCOM可能是这究竟有多糟的样板，但是这样的例子还有很多。
苹果放弃了OpenDoc，CORBA和曾经大肆宣传的Java RMI，随着人们使用经验的增长，
都已经从Unix世界的视野中消失了。这完全可能是因为这些方法能够解决的问题还不如
它们引发的问题多。
    Andrew S．Tanenbaum和Robbert van Renesse在《对远程过程调用范式的批评》  （A
Critique盯the Remote Procedure Call Paradigm [Tanenbaum-VanRenesse]）中对RPC的一
般问题作了详细分析，这篇文章应该是对考虑将其作为基础架构的人们的当头棒喝。
    所有这些问题都预示着使用RPC的为数不多的Unix项目会存在长期困难。在这些
项目中，最著名的恐怕就是GNOME桌面项目了13。这些问题也使对外公开的NFS殷务
器特别容易受到安全性方面的攻击。
    另一方面，Unix传统强烈赞成使用透明、可显的接口。这就是Unix文化不断坚持
文本协议IPC的动力。经常有人固执认为，相对二进制RPC而言，文本协议的解析开销
是个性能问题――但是RPC接口往往产生更糟糕的延迟问题，原因是：  （a）无法准确
预估出～个指定调用会涉及多少数据的列集和散集，（b） RPC模型往往鼓励程序员把网
络交易视为无成本行为。即使在某个事务处理接口上只额外增加一个来回，往往也会增
加足够多的网络延迟，完全抵消了解析或列集的开销。
    即使文本流没有RPC效率高，但性能损失也是微小和线性的，最好通过硬件升级，
而不是耗费开发时间或增加结构复杂度来解决这个问题。使用文本流可能造成的任何性
能损失，都可以得到补偿，即有能力设计更简单的系统，更易于监控、建模和理解。
    今天，通过XML-RPC和SOAP等协议，RPC和Unix对文本流的坚持开始以一种有
趣的方式融合到一起。这些协议，由于是文本化而且透明的，比它们所取代的丑陋、重
13 GNOME的主要竞争对手KDE开始时使用CORBA，但在其2.0版本中将之放弃。从那以后，他
们一直在寻求一种更轻量级的IPC方法。
UNIX编程艺：术
    www.pdf365.com
1 80
第7章多道程序设计：分离进程为独立的功能
量级的二进制序列格式更合乎Unix程序员的心意。尽管它们不能解决Andrew S．
Tanenbaum和Robbert van Renesse所提出的更普遍的问题，但它们在某些方面综合了文
本流和RPC方法的优点。
7.3.3
    尽管Unix开发者早就已经习惯于通过多个协作进程进行计算，他们仍然没有使用线
程（共享整个地址空间的进程）的自发传统。线程最近才从其它地方移植过来，而Unix
程序员通常不喜欢线程这件事，决不仅仅只是意外或历史的偶然。
    从复杂度控制的角度来看，相对拥有独立地址空间的轻量级进程，线程是个糟糕的
替代；线程是那些进程生成昂贵、IPC功能薄弱的操作系统所特有的概念。
    从定义上看，尽管进程的子线程通常具有独立的局部变量栈，它们却共享同一全局
内存。在这个共享地址空间管理竞争和临界区的任务相当困难，而且成为增加整体复杂
度和滋生bug的温床。可以这样去做，但是随着锁定机制复杂度的增加，意外交互作用
所造成的竞争和死锁机会也相应增加。
    线程成为滋生bug温床源于它们太容易知道过多彼此的内部状态。与有着独立地址
空间、必须通过明确IPC进行通信的进程不同，线程没育自动封装。这样，基于线程的
程序不仅产生普通的竞争问题，而且产生了新一类bug：时序依赖，要重现这些问题都
极其困难，遑论修复。
    线程开发者已经觉察到这个问题。最近的线程实现和标准则体现了对提供线程本地
存储的更多关注，其目的是限制共享全局地址空间所产生的问题。随着线程API朝这个
方向发展，线程编程开始越来越像是对共享内存的有约束应用了。
    线程常常阻碍了抽象。为了防止死锁，
如何使用线程，以避免死锁问题。类似地，
层使用线程的影响。
经常必须了解所使用的库是否使用和
在程序库中使用线程还可能受到应用
    -David Korn
雪上加霜的是，线程的性能成本削弱了其对常规进程分解的优势。尽管线程没有快
www.pdf365.com
7.4在设计层次上的进程划分
181
速转换进程上下文的开销，但是锁定共享数据结构以防互相干涉的开销同样昂贵。
    X server的执行速度能够达到数百万次／秒（ops/second），但不是基于线程实
  现的；它使用poll/select循环。创造多线程实现的种种努力都没有产生好结果。对
  于图形服务器这种对性能敏感的程序来说，锁定和解锁操作的成本太高了。
-Jim Gettys
    这个问题是根本性的，也一直是Unix内核的对称多处理设计的长期问题。由于资源
锁定变得越来越琐细，锁定导致的延迟也迅速增加，足以超过只锁定更少的核心内存所
获得的收益。
    线程的最终难题在于，直到2003年年中，线程的标准仍然很薄弱而且规范不够明确。
Unix标准在理论上已经一致的程序库，如POSIX线程（1003.lc），仍然在不同的平台
展示了惊人的行为差异，尤其是在信号、同其它IPC方法的交互和资源清理时间方面。
Windows和传统MacOS自带的线程模型和中断功能与Unix差别非常大，即使很简单的
线程程序也常常需要相当大的精力才能移植。结果是根本不要指望线程程序可移植。
    更多的讨论以及和事件驱动编程的鲜明对照请参考《为什么线程是个馊主崽》（Why
Threads Are口Bad Idea）[Ousterhout96].
7.4在设计层次上的进程划分
现在万事俱备，我们应该怎么办呢？
    第一个要注意的是，临时文件、交互性更强的主／从进程关系、套接字、RPC和其它
一些双向IPC方法在某种程度上是等价的――它们都只不过是程序在生命期内交换数据
的方法。我们通过使用套接字或共享内存这种复杂的方法所完成的任务，大多数都可以
通过使用临时文件作为信箱和通知信号这种简单的方法来完成。差别很小，主要体现在
程序如何建立通信、何时何地完成信息的列集和散集、可能产生何种缓冲问题，以及如
何保证获取信息的原子性（也就是说，在何种程度上可以知道来自一边的单个发送行为
会在另一边成为单个的接收事件）。
我们已经从PostgreSQL实例中看到，降低复杂度的有效方法是把程序划分成客户端
UNIX编程艺：术
    www.pdf365.com
182
第7章多道程序设计：分离进程为独立的功能
／服务器对。PostgreSQL的客户端和服务器的通信通过基于套接字的应用协议来实现，但
是既便使用其它双向IPC方法，设计模式也并不会有多大改变。
    在应用程序的多个实例必须管理共享资源访问的情况下，这种划分特别有效。一个
简单的服务器进程可以管理所有的资源争用，或者协作的每个对等程序端都可以掌管某
个关键资源。
    客户端／服务器划分也有助于在多个主机上分布高时效要求的（cycle-hungry）应用程
序。或者可以使它们适应互联网的分布计算（如Freeciv）。我们将在第1 1章讨论相关
的C//服务器模式。
    由于所有这些对等进程间的IPC技法在某种程度上都很像，所以我们应该主要评估
它们引起的程序复杂度开销，以及给设计造成的不透明度。归根结底，这就是为什么BSD
套接字会在Unix IPC中胜出，以及为什么RPC根本无法获得更多支持的原因。
    线程有着根本性不同。线程支持的并非不同程序之间的通讯，而是单个程序的一个
实例内的某种分时形式。线程并不是把大程序分解成行为简单的小程序的方法，实际上
是一种性能调整（ performance hack）问题。但线程不仅具有此类问题昀通病，而且还有
自身的特殊症结。
    因此，当我们寻找方法，把大程序分解成更简单的协作进程时，在进程内使用线程
应该是最后一招而不是第一招。通常，你可以发现避免使用线程是可能的。如果能够使
用有限的共享内存和信号量、使用SIGIO的异步I/O，或polt （2） lselect （2），而不是
使用线程，就这样做吧，保持简洁，在本章所列的技法中优先使用位置更前、复杂度更
低的方法。
    把线程、远程过程调用接口和重量级的面向对象设计结合使用特别危险。如果使用
地非常谨慎和优雅，这些技术中的任何～个技术可能都非常有价值――但是如果你被邀
请加入要使用这三者的项目，逃之天天并不丢面子。
    前面我们已经讲过，真实世界里的编程其实就是管理复杂度的问题。能够管理复杂
度的工具都是好东西。但当这些工具的作用不是控制而是增加复杂度的时候，最好扔掉，
从零开始。永远不要忘记这一点，它是Unix智慧的重要组成部分。
www.pdf365.com
固
微型语言：寻找歌唱的乐符
Minilanguages: Finding a Notation
That Sings
A good notation has口subtlety and suggestiveness which at times makes it almost seem like日live
    teacher.
    从好的符号体味出的巧妙和启发，就算身边的老师也不过如此。
    The World of Mathematics《1956）
    -Bertrand Russell
    对软件错误模式进行的大量研究得出的一个最～致的结论是，程序员每百行代码出
错率和所使用的编程语言在很大程度上无关。1更高级的语言可以用更少的行数完成更多
的任务，也意味着更少的bug。
    Unix有个长期传统，即包容小型的、为专门应用领域特制、大量减少程序行数的语
言。专门领域语言的实例包括无数Unix排版语言（troff， eqn，tbl，pic，grap）、shell
实用程序（awk，sea，dc，bc）和软件开发工具（make，yacc，lex）。专门领域语言和
更灵活应用程序的运行控制文件（sendmail， BIND，X）之间、数据文件格式之间、脚
本语言之间的界限都很模糊（我佃将在第14章予以分析）。
1 Les Hatton在其写作的Software Failure（软件故障）一书中用email形式报告其分析：  “如果用可执行
的行数进行密度测量，则不同语言产生的缺陷密度的差异大概只有不同程序员所产生的缺陷密度差
异的十分之一。”
UNIX编程艺术
  www.pdf365.com
184
第8章微型语言：寻找歌唱的乐符
    从历史上讲，这种类型的专门领域语言在Unix世界中称为“小语言”或“微型语言”，
原因是相对通用语言而言的，早期这类语言的实例都较小，复杂度较低（这三个术语均
指通常情况）。但如果应用领域很复杂（体现在具有很多不同原语操作或涉及繁杂数据
结构的处理），其采用的应用语言将不得不比一些通用语言更复杂。我们将保留传统术
语“微型语言”以强调：明智的方法通常是保持这些设计尽可能小、尽可能简单。
    专门领域的小语言是一种非常强大的设计理念，可以使我们为手头的任务定义自己
更高级的语言，以详细规定恰当的方法、规则和算法；比起采用更低级硬编码的设计而
言，这降低了全局复杂度。至少有三种方式可以做好微型语言的设计，两种好的，一种
危险的。
    第一个正确方法是，预先认识到可以使用微型语言设计把编程问题的规格说明提升
一个层次；跟通用语言所能支持的表示法相比，这种表示法更紧凑、更具表达力。与代
码生成和数据驱动编程一样，微型语言允许我们切实利用“软件的缺陷率和使用的语言
在很大程度上无关”这一事实：更具表达力的语言意味着程序更短，bug更少。
    第二个正确方法是，注意到规格说明文件格式越来越类似微型话言――也就是说，
结构趋向复杂，控制的应用程序中包含行为。规格说明是否试图描述控制流和数据部署？
如果是，也许是把规格说明语言中的控制流从隐式提升到显式的时候了。
    错误方法是通过扩展变成微型语言：每次增加一个补丁或者一个仓促而就的特性。
在这条道路上，规格说明文件不断滋生出更加隐蔽的控制流向和更加杂乱的专用结构，
在不知不觉间变成了一种特别语言。一些传说中的孺梦就是这样产生的：每一位Unix大
师都会（战战兢兢地）想起的例子是sendmaill邮件传输程序用到的sencrnail．cf配置
文件。
    悲哀的是，大多数人面对第一个微型语言时就采取了错误的方法，并且事后才意识
到这个微型语言已经变得多么混乱。接下来的问题是：如何清理？有时候，答案可能意
味着要重新构思整个应用程序的设计。语言特性蠕变（Language-by-feature creep）的另
外一个臭名昭著的例子是TECO编辑器，这个编辑器首先发展了宏，然后随着程序员想
要用其包装越来越复杂的编辑程序，才增加了循环和条件。由此产生的丑陋最终只能通
www.pdf365.com
8.1  理解语言分类法
185
过基于意向性语言重新设计整个编辑器才得以解决；这就是Emacs Lisp（以下将分析）
的形成过程。
    所有十分复杂的规格说明文件都希望成为微型语言。因此，事实经常是，防御设计
不良微型语言的唯一方法是知道如何设计一个好的微型语言。这并不需要巨大的跨步或
涉猎许多形式语言理论；有了现代工具，只要学习一些相对简单的技巧，并将几个优秀
范例牢记在心就足够了。
    本章我们将分析Unix通常支持的各种微型语言，并尽量确定每种微型语言对何种问
题可提供有效解决方案。本章并非要穷举所有的Unix语言类别，而是展示围绕微型语言
建构应用程序所涉及的设计原则。我们将在第14章更详细讨论通用编程语言。
    首先，我们必须进行一个小小的分类，以便以后区分彼此。
8.1  理解语言分类法
    图8.1所示的所有语言都在本章或本书其余章节的案例分析中有描述。右侧的通用
型解释器的说明，请参见第14章。
    我们在第5章分析了Unix对数据文件的约定。这些文件的复杂度按谱系排列。其中，
底端是简单关联名称和属性的文件；／et c/passwd和．newsrc是好例子。往卜去，我
们看到对数据结构进行列集或序列化的格式；（对等地，）PNG相SNG格式是这种类型的
好例子。
    如果结构化的数据文件格式不仅表达了结构，而且在某些解释性上下文（也就是数
据文件以外的存储）下表达执行行为时，这种格式开始接近于一种微型语言。XML标记
语言往往跨入界限；我们在此要举的例子是Glade，一个用于构建GUI界面的代码生成
器。那种既可供人类读写、又可用于生成代码的格式绝对属于微型语言。yacc和lex是
其中的经典例子。我们将在第9章讨论glade、yacc和lex。
    Unix的宏处理器m4是另外一种非常简单的声明性微型语言（也就是说，在这种语
言中，程序被表示成一套预期的关系或约束集，而不是明确的行为）。它经常用在其它
微型语言的预处理阶段。
UNl×编程艺多茛
  www.pdf365.com
{葚为
麓8囊徽燮语耄：嚣找戢淄的蓉符
    lne忿矗s{鞋窑i0好擎l鞋鬯S蕊    -呻―――叫辫脚
    deel拽}靛瓠V棼￡0§漱势贮r嚣豁掣e
辫8。莲  谮富分樊
    U魏ix的徽鑫b魏棼是为了岛动化缡泽过程两设计的，表达了灏文件和派生文件2之阀熊
依赖关系以及从各个源文件生成派生文件所需髂命令。运幸亍戳蘸畿时，它用说溺来邃历憋
式依赖关系树，完成最少的必要王作以更新编译。与y躞ee和概蕊格说溺一样，燃彘撒e
是～种声黝性徽型谮言；它们以约束条件来说明在解释性上下文（在这种情况下指漾文
件帮溅生文件共满盼文件系统部分）中要完成的行为。我们将在第1 5章分析嫩斌嚣翁l#。
    用于描述X黼L转换的语言XSLT处于声明性语言复杂度的顶端。这种语富复杂到
邋鬻没有入认为它是一种徽囊语言，但它包含我们以下将更详继分析的微型语葺所其有
的一塑熏蕊特性。
    微型语言的范囔觚声明褴（其有隐式攥作）发展到命令性（其有显式攥佟）≯把蠡㈣暇l》
的运行控臻l语法可视为…种{罐弱的翕令性语言或一种暗含控制流的声明性语言。￡羚嚣和
擎◇s￡S翻p￡排舨语一身是氡含很多专用领域知识的命令性语lg。
    有些针对专fj任务的命令性徽型语言几乎抉溅为遽用解释器。当它们鞠确成为宠备
釜对技术背景较弱的读者来说：C程序的缡译形式通过编译和链耧从C潦码派生瓣采。辖o程文件鹩
p。篱￡S。却￡版奉胰㈣褥潦程序派生：轶后者生成前孝的命令是的箨调用。还有其它类篓妁派生：
髓墩棼纛i#几乎可以表示全部派生关系。
www.pdf365.com
8.2应用微型语言
187
图灵机时，它们就是解释器――也就是说，可以进行条件和循环（或递归）3操作，并且
具有用于控制结构的特性。相反，有些语言只是在某些情况下是完备图灵机――虽然它
们具有能够用于执行控制结构的特性，但只是实际设计目的的副产物。
    我们在第7章分析的bc（】）和dc （l）解释器是明显的完备图灵机语言的好例子，
它们都是专用的命令性微型语言。
    当我们进入到Emacs“sp和JavaScript这类用于特定上下文下运行的完全编程语言
时，便来到通用解释器的领域。我们在以后讨论嵌入式脚本语言时将更详细讨论它。
    解释器的范畴也是通用性不断增加的范畴；反过来讲，更加通用的解释器对其运行
上下文的假设很少。随着通用性增加，通常存在更加丰富的数据类型分类。Shell和Tcl
都具有相对简单的数据类型分类；Perl，Python和Java则更加复杂。我们将在第14章分
析这些通用语言。
8.2应用微型语言
    设计微型语言面临两个截然不同的挑战。一个挑战是在工具包中已经存在方便好用
的微型语言时，认识到何时可以直接应用它们。另一个挑战是知道应该在什么时候为应
用程序设计自定的微型语言。为了帮助读者培养这两个方面的设计崽识，本章的一半篇
章都是案例分析。
8.2.1案例分析：sng
    我们在第6章分析了在PNG和逐位等价的可编辑纯文本表达之间进行转换的sng
（1）。SNG数据文件格式在此处值得再次对照研究，这是因为它不完全是一种领域专
用语言。它描述了数据格式，但数据和任何默认的动作序列都不相关。
    然而，SNG确实拥有专门领域微型语言所拥有，但PNG之类的二进制结构数据格
式却没有的一个重要特性――透明性。结构化的数据文件使得那些编辑、转换和生成工
具无需知道任何其它方的设计假定、只需通过微型语言介质本身，就可以彼此协作。和
3任何完备图灵机语言在理论上都可用于通用编程，并且理论上和任何其它类型的完备图灵机语言一
样有效。实际上，有些此类语言在其狭窄的特定问题域以外使用时可能令人非常痛苦。
    UNIX编程艺术
    www.pdf365.com
188
第8章微型语言：寻找歌唱的乐符
专门领域微型语言一样，SNG如此设计的额外好处是便于人眼分析，便于通用工具编辑。
8.2.2案例分析：正则表达式
    有一类规格说明频繁出现在Unix工具和脚本语言中：正则表达式（简写为“regexp"）。
我们在此将其视为描述文本模型的一种声明性微型语言；它经常内嵌在其它微型语言中。
Regexp无处不在，几乎没有人认为它是微型语言，但它们取代了那种执行不同（而且不
可互用）搜索功能的大堆代码。
    以上介绍跳过了POSIX扩展、反向引用和国际化特性等细节。更详细的介绍请参见
Masterz'ng  Regular Expressions（精通正则表达式）[FriedIL
    正则表达式描述了匹配或不匹配字符串的模式。最简单的正则表达式工具是
grep（1），它用在每行输入和输出之间匹配指定regexp。正则表达式符号归纳在表8.1。
    regexp符号还存在一些小变种：
    1．Glob表达式。这是早期Unix shell用于文件名匹配的有限通配符约定集。只有三
个通配符：  “术”匹配任何序列的字符（与其它变种中的，术类似）；  “？”匹配任何一个
字符（与其它变种中的．类似）：[．．．】和其它变种中～样，匹配一类字符。有些shell （csh，
bash，zsh）后来也允许用（）表示。这样，x{a，b}c与xac或xbc匹配，但不匹配
xc。有些shell进一步朝扩展正则表达式的方向扩展了glob。
    2．基本正则表达式。最初的grep（1）实用程序使用这些符号来从文件中提取与指
定regexp匹配的文本行。行编辑器已d（1）和字符流编辑器sed （1）也使用这些符号。
Unix老手认为这些符号是基本的regexp，或“最普通”（vanilla）口味的regexp：首先接触
更现代工具的人往往采用以下描述的扩展形式。
    3．扩展的正则表达式。这是从grep公用程序扩展出的egrep（1），实用程序使用这
些符号来从文件中提取与指定regexp匹配的文本行。Lex和Emacs编辑器中的正则表达
式非常接近egrep风格。
www.pdf365.com
8.2应用微型语言
189
表8.1  正则表达式实例
┏━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃  Regexp        ┃  匹配                                                                    ┃
┣━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃  ”X．y”      ┃x后面接任何一个字符再接y。                                                ┃
┣━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃  ”x\．y”     ┃x后面接，再接y。                                                          ┃
┣━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃  “xz ?Y”     ┃x后面最多接一个z再接y；这样，可以是"xy”或“xzy”，但不是“xz”或wxdy”。 ┃
┣━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃    ”XZ★V¨   ┃x后面接任意数量的z再接y：这样，可以是w xy，，或"xzy一或"xzzzy一，但不     ┃
┃                ┃是“xz”或“xdy”。                                                       ┃
┣━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃  ’’xz+y”    ┃x后面接一个或多个z再接y；这样，可以是“xzy"或“xz zy”，但不是一xy“、    ┃
┃                ┃“xz”或“xdy w。                                                         ┃
┣━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃”s[ xyz]七”   ┃s后面接x、y或z中的任何一个字符再接c；这样，可以是"sxt“、“sytw或         ┃
┃                ┃“sz七”，但不是"st"或"sat"。                                             ┃
┣━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃”a[x0-9]b”    ┃a后面接x或0-9之间的任何一个字符再接b；这样，可以是”axbw或"aOb"           ┃
┃                ┃或”a4b"，但不是- ab”或"aab"。                                           ┃
┣━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃“s C^xyzJ t"   ┃s后面接非x、y、z的任何一个字符再接t；这样，可以是"sdt"或"set”，但        ┃
┃                ┃不是“sxt”、~syt”或wszt”。                                             ┃
┣━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃"s [^x0-9J t "  ┃s后面接非x或非0-9之间的任何-个字符再接t：这样，可以是"slt一或             ┃
┃                ┃“smt”，但不是“sxt“、"sOt"或“s4t w。                                  ┃
┣━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃”“X”         ┃x在字符串的开头：这样，可以是“xzy一或”xz zy一，但不是"y zy”或。yxy w。 ┃
┣━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃"X$ n           ┃ x在字符串的末尾；这样，可以是“vzx”或"yx”，但不是“yxz”或wzxy”。     ┃
┗━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
    4．Perl正则表达式a这是Perl和Python的regexp功能所接受的符号。它们比egrep
风格的符号更强大。
    看了这些启发性例子之后，表8.2总结了正则表达式的标准通配符。注意：该表不包
括glob变种，因此“全部”代表的只是基本、扩展/Emacs和Perl/Python这三种变种4。
    支持regexp的新语言所采用的设计实践已经固定使用Perj/Python的变种。它比其它
变种更透明，主要是因为非字母数字字符之前的反斜杠＼始终表示该字符的字面值，因此
4正则表达式的POSIX标准引进了一些符号域，如[[：lower；j]]和[ [：digit：]】等，一些专用工
具还有此处未包括的通配符，但以下这些已经足够解析大多数regexp。
    UNIX编程艺术
    www.pdf365.com
190
第8章微型语言：寻找歌唱的乐符
表8.2对正则表达式的介绍
┏━━━━━━┳━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━┓
┃  通配符    ┃支持语言                              ┃匹配                                          ┃
┣━━━━━━╋━━━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━┫
┃  l         ┃全部                                  ┃转义后面的字符。切换后续符号是否作为通配符。  ┃
┃            ┃                                      ┃根据程序的不同，后续的字母或数字可用各种不同  ┃
┃            ┃                                      ┃的方式解释。                                  ┃
┣━━━━━━╋━━━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━┫
┃    ．      ┃全部                                  ┃任何字符。                                    ┃
┣━━━━━━╋━━━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━┫
┃            ┃全部                                  ┃行首。                                        ┃
┣━━━━━━╋━━━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━┫
┃    $       ┃全部                                  ┃行尾。                                        ┃
┣━━━━━━╋━━━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━┫
┃  [．，．]  ┃全部                                  ┃在括号内的任何字符。                          ┃
┣━━━━━━╋━━━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━┫
┃  [“一．]  ┃全部                                  ┃除括号内字符的任何字符。                      ┃
┣━━━━━━╋━━━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━┫
┃    ★      ┃全部                                  ┃次数不定的重复前一个元素。                    ┃
┣━━━━━━╋━━━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━┫
┃    '       ┃egrep/Emacs. PerUPython               ┃ 0次或1次重复前一个元素。                     ┃
┣━━━━━━╋━━━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━┫
┃    +       ┃egrep/Emacs， PerUPython               ┃ 1次或多次重复前一个元素。                    ┃
┣━━━━━━╋━━━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━┫
┃  （n}       ┃egrep， Per7/Pychon; Emacs中为         ┃只n次重复前一个元素。…些较老的regexp引擎     ┃
┃            ┃                                      ┃不支持。                                      ┃
┣━━━━━━╋━━━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━┫
┃  （n，）     ┃egrep. Perl/Python;  Emacs中为        ┃n次或n次以上重复前…个元素。一些较老的        ┃
┃            ┃                                      ┃regexp引擎不支持。                            ┃
┣━━━━━━╋━━━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━┫
┃（m，n）      ┃egrep， PerUPython; Emacs中 }J         ┃最少重复m次、撮多重复n次前一个元素。一些较    ┃
┃            ┃                                      ┃老的regexp引擎不支持。                        ┃
┣━━━━━━╋━━━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━┫
┃  }         ┃egrep，  Perl/Python; Emacs中 }J\I     ┃接受左边或者右边的元素。通常用于一些模式分类  ┃
┃            ┃                                      ┃分隔符形式。                                  ┃
┣━━━━━━╋━━━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━┫
┃（…）        ┃PerUPython;老一点的版本为、（-．．、）  ┃在较新的regexp引擎中，如Perl和Python把        ┃
┃            ┃                                      ┃这种模式作为组。较老的regexp引擎，如Emacs     ┃
┃            ┃                                      ┃和grep中，要求＼（一-＼）。                   ┃
┗━━━━━━┻━━━━━━━━━━━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━━━┛
www.pdf365.com
8.2应用微型语言
191
对如何引用regexp的元素产生的混淆较少一些。
    正则表达式是一个微型语言能够多么简练的极端例子。简单的正则表达式表达了识
别行为，不这样做的话，这些行为必须用成百行繁琐易错的代码来实现。
8.2.3  案例分析：Gla拈
    Glade是X的开源GTK工具包库所用的界面创建程序。5Glade通过在界面面板上交
互地选择、放置和修改窗体部件来生成GUI界面。GUI编辑器生成描述该界面的XML
文件；反过来，这又可成为几种代码生成器的输入，最终成为界面的C、C++、Python
或Perl代码。生成的代码将调用编写的函数向界面提供行为。
    Glade用于描述GUI的XML格式是简单的专门领域语言的好例子。参见例8.1所举
的Glade格式的“Hello，world!”GUI。
    Glade格式的有效规格说明包含了响应用户行为的GUI指令表。一方面，Glade的
GUI把这些规格说明作为结构化的数据文件处理：另一方面，Glade的代码生成器则用
这些规格说明来编写GUI的实现码。有些语言（包括Python）有运行时程序库，可跳过
代码生成步骤，简单地在运行时直接从XML规格说明（解释Glade标记，而木是把这些
标记编译到宿主语言中）实例化GUI。这样，我们可以选择牺牲空间效率来提高启动速
度，或反之。
    跳过XML的冗长，Glade标记实际是一种相当简单的语言。它只做两件事：说明
GUI窗体构件层次、关联窗体构件和属性。实际上，我们并不需要懂很多Glade工作原
理才能读取以上规格说明。事实上，如果有过GUI工具包的编程经验，读～读以上例子
立刻会使我们很好地想象出Glade如何处理规格说明。  （认为这段具体的规格说明能在
窗口框架上生成一个按钮的读者请举手。）
这种透明性和简单性是一个微型语言设计良好的标志。符号和域对象之间的映射非
5对非Unix程序员来说，x工具包是一种图形库，可向使用它的程序提供GUI构件（如标签、按钮、
下拉菜单等）。其它绝大多数图形操作系统只提供一个工具包供大家使用。Unix和x都提供多个工
具包；这也是我们在第1章作为设计目标提出来的机制和策略分开的一个组成部分。GTK和Qt是最
流行的两个开源X工具包。
UNIX编程艺术
  www.pdf365.com
192
第8章微型语言：寻找歌唱的乐符
例 8.1   Glade  "Hello， World"
<?xml  version=" 1 . o " ?>
<GTK-工n七erface>
<widget>
  <class>GtkWindow</class>
  <name>HelloWindow</name>
  <border_width> 5</border_width>
  <Signal>
    <name>destroy</name>
    <handler>gt k_main_qui七</handler>
  </Signal>
  <title>Hello</title>
  <type>GTK_WINDOW_TOPLEVEL< /七ype>
  <posi七ion>GTK_WIN POS_NONE</position>
  <allow_shrink> rrue（/allow_shrink>
  <allow_grow>True</allow_grow>
  <auto_shrink>False</auto_shrink>
  <widget >
    <class>GtkButton</class:.
    <name>Hello World</name>
    <can_focus>True</can_focus>
     <Signal>
    <name>clicked</name>
    <handler>gt k_widget_destroy< /handler>
        <obj ect）HelloWindow</obj ect >
    </Signal>
     <label>Hello World</label>
  </widget>
</widget>
</GTK-Interface>
常清晰。对象之间的关系表达得很直接，舍弃了必须经过思考才能理解的间接表达方式
如名字引用。
    最终对微型语言的功能测试就是这么简单：不读手册可以编写吗？在相当多的情形
中，Glade的回答是肯定的。例如，如果知道用丁描述GTK窗体位置信息的C常量，就
可以立即用GTK WIN_POS_NONE
值改变与这个GUI有关的位置信息。
www.pdf365.com
8.2应用微型语言
193
    使用Gtade的优势应该很明显。它专门负责代码生成，所以我们就不必关心代码生
成了。这就减少了一个我们必须手工编程的例行任务，从而减少了因此产生的bug。
    更多的信息，包括源码、文档和实例应用的一些链接，都可从Glade的项目主页
<http：／/glade．gnome．org/>获得。Glade已经移植到了Windows上。
8.2.4案例分析：m4
    m4 （1）宏处理程序解释描述文本转换的声明性微型语言。一个m4程序就是一套宏
命令集，规定了把文本串扩展成其它字符串的方式。在输入文本中应用m4程序中的声
明就实现了宏扩展并生成输出文本。  （C预处理器也为C编译器执行类似的服务，但风
格截然不同。）
    例8.2演示了一个m4宏命令，把输入中的每一个“OS"字符串都转换成“Operating
System"输出。这是～个很小的例子：m4支持带参数的宏命令，可胜任更多的任务，而
不仅仅是把一个固定的字符串转换成另一个固定的字符串。在shell提示中键入info m4
可显示这种语言的在线文档。
例8.2  m4宏命令实例
define { ' os ' ，    ' operating  system '
    m4宏语言支持条件和递妇。两者结合可实现循环，设计便是如此：m4是一种有意
的完备图灵机。但实践中把m4当作通用语言使用则非常困难。
    通常，对于缺乏内置命名过程标记法和文件包含功能的微型语言，可以使用m4宏
处理程序作为预处理器。这是扩展基础语言语法的简单方法，于是，与m4相结合就可
以支持上述功能。
    m4非常出名的一个应用是避免（或至少有效隐藏）本章～开始作为反例提出的第三
种设计微型语言的方法。大多数系统管理员现在都可以应用sendmail配置提供的m4宏
语句包生成自己的sendmail．cf配置文件。宏使用特性名（或名称／值对）来生成
sendmail配置语言所用的（更加丑陋的）对应字符串。
UNIX编程艺．术
    www.pdf365.com
194
第8章微型语言：寻找歌唱的乐符
    然而，请慎重使用m4。Unix经验教导微型语言的设计者要谨防宏扩展，6具体原因
将在本章以下部分讨论。
8.2.5  案例分析：XSLT
    和m4宏一样，XSLT也是描述文本流变换的一种语言。但它的任务并不仅仅是简单
的宏替换；它还可以描述XML数据的变换，包括查询和报表生成。它是用于编写XML
样式表的语言。关于XSLT的实际应用，参见第18章XML文档处理部分的说明。XSLT
有万维网联盟（World Wide Web Consortium，W3C）标准的描述，并且拥有数个开源实
现。
    XSLT和m4都是纯声明性和完备图灵的语言，但XSLT只支持递归，不支持循环。
XSLT相当复杂，无疑是本章实例分析中最难掌握的语言――而且可能是本书所涉及的
最难的语言。7
    尽管非常复杂，但XSLT的确是一种微型语言。它具备微型语言最重要的（尽管不
是普遍的）特征：
●  有限的类型分类，  （特别是）没有记录结构或数组等类似结构。
●  对外部的有限接口。XSLT处理器的设计目的是在标准输入和标准输出之间进
  行过滤，具备有限的读／写文件能力，不能打开套接字或运行子命令。
  例8.3的程序将XML文档中每个元素的每个届性都变换成被该元素直接括入的新标
记对，原属性值作为其内容。
  在这里简单了解XSLT，部分原因是举例说明“声明性’’并不～定意味着“简单”或
“薄弱’’，更主要是因为如果必须处理XML文档，则总有一天必须面对XSLT的挑战。
    XSLT: Mastering XML Transformations （XSLT：精通XML转换）[Tidwell]很好地介绍
    L    ，
了这种语言。也可在网上找到带实例的简明教程。8
6宏扩展的英文应该拼写成“macro expansion”还是“macroexpansion”尚有争议。后者主要在Lisp
程序员中使用。
7然而，还不清楚XSLT是否能变得更简单一些、同时仍能完成任务，所以我们无法把它定性为不好
的设计。
8如XSL Concepts and Practical Use （XSL的概念和实际应用），参见<http：／／nwalsh．com／
docs/tutorials/xsl/xsl/slides.html>.
www.pdf365.com
8.2应用微型语言
195
例 8.3   XSLT程序实例
<?xml   version= iF l . 0 " ? >
<xsl : styleshee七   xmlns : xsl= "h七tp : / /www . w3 .org/1999/XSL/Transfo工 m '*
                     version= " I . 0 " >
   <xsl : outpu七  method= "xml " />
   <xsl : template  match= " t " >
      <xsl : element  name=" {name （ ） J ">
         <xsl : for-each  select= " @* " >
            <xsl : element  name=" {name （ ） } ir>
               <xsl : value-of  select= " . "/>
    </xsl : elemen七>
    </xsl : for-each>
         <xsl : apply-templates  select="* ltext （ ） " />
    </xsl : element>
  </xsl : template>
</xsl : stylesheet>
8.2.6  案例分析：The Documenterls Workbench Tools
    正如我们在第2章所说，troff（1）排版格式器是Unix最早的王牌应用程序。troff
是格式工具套件（总称为Documenter's Workbench盛DWB，文档编制工作台）的核心，
其中各个组成部分都是不同类型的专门领域微型语言。大多数是troff标记语言的预处理
或后处理器。开源Unix上有个称为groff（1）的DWB增强实现版，它来自于自由软件
基金会。
    我们将在第18章更详细介绍troff;现在，我们只要注意到troff是命令性微型语言
的好例子就足够了。这个命令性微型语言接近于一种正式的解释器（具有条件和递归，
但没有循环；偶尔是图灵完备的）。
    后处理器（用DWB的术语来讲就是“驱动器，driver”）通常对troff用户是不可见
的。1970年Unix开发组就使用最早的troff向特殊排字机输送代码；1970年代后期，这
些都被整理成设备无关的微型语言，用于在页面上插入文本和简单图形。后处理器把这
种语言（称为“ditroff"，代表“device-independent troff”（设备无关的troff））转换为
现代图像打印机能实际接受的格式――其中最重要的（在当代也是默认的）是PostScript。
    预处理器更有意思，原因是它们实际上增强了troff语言的能力。常用的三个语言是：
用于制表的tbl （l）、用于排版数学公式昀eqn （1）和用于绘制图表的pic （1）。还有
不太常用但仍然存在的语言，如制图用的grn（1）及排版参考书目的refer（1）和bib（1）。
UNIX编程艺才专
    www.pdf365.com
196
第8章微型语言：寻找歌唱的乐符
所有这些语言等价的开源实现都随groff -同发布。grap （1）预处理器提供了一个全面
的的测绘图功能；还有一个独立于groff的开源实现。
    其它一些预处理器没有开源实现，也不再普遍使用。其中最著名的是制图用的ideal（1）。
较新的chem （1）可绘制化学结构式；它还是贝尔实验室netlib代码的组成部分9。
    每个预处理器都是一个小程序，接受微型语言并将其编译成troff请求。通过查找独
特的起始和结束请求，每个小程序识别应该解释的标记（tbl查找.TS／.TE，pic查
找．PS/．PE等），其余的标记则不加修改地传递，这样，大多数预处理器通常都能互不
干涉地以任何一种次序运行。也有例外：特别是chem和grap都产生pic命令，因此必须
先于该命令出现在管道线中。
ca七  七hesis.ms I chem I tbl I refer I grap I pic I eqn \
                                                              I groff -Tps >thesis.ps
    上述只是为演示DWB处理管道线而捏造的实例。假想一篇论文，它包含化学公式、
数学公式、表格、参考书目、标绘图和图表。  （cat （l）命令只是把输入或文件参数拷
贝到输出；在此使用这个俞令是为了强调操作的顺序。）在实践中，现代troff实现往往
至少支持调用tbl （1）、eqn （l）和pic （l）的命令行选项，因此就无须编写以上这样
复杂的管道系统。即使必要，这些编译命令通常也只需编写一次，然后隐藏在makefile
或shell脚本包装器中以备重复使用。
    DWB的文档标记在某些方面已经过时，但是这些预处理器所处理的问题域仍然表明
了微型语言模型的能力――所见即所得的字处理器想具备同样的能力可能非常困难。直
到2003年，在某些方面，基于XML的现代文档标记语言和工具链仍在试图赶上DWB
早在1979年就已经具备的能力。我们将在第18章更详细讨论这些问题。
    至此，大家应该很熟悉使DWB如此强大的设计原因了；所有的工具都共享一个通
用文档的文本流表达，格式化系统划分成多个独立的组成部分，可分别调试和改进。管
道架构支持插入新的、实验性的预处理器和后处理器，而且不会干扰原有处理器。这是
个模块化和可扩展的结构。
9  http : / /www _ netlib . org/
www.pdf365.com
8.2应用微型语言
197
    DWB体系作为一个整体教导我们如何把多个专用微型语言组装成一个协作系统。一
个预处理器可搭建在另一个预处理器上。事实上，DWB的工具是管道、过滤器和微型语
言结合工具的早期模型范例，影响了Unix后面的很多设计。有效的微型语言应该如何设
计，可以从各个预处理器的设计中得到很多经验。
    其中有个教训是负面的。有时候，在微型语言中用户编写的说明可能无法干净地处
理手工插入的低级troff标记。这可能会产生交互作用和难以诊断的bug，原因是管道生
成的troff是看不见的――即使能看见也不可读。这和把C与内嵌汇编器片断混合起来的
代码中产生bug的情形相似。如果可能的话，把语言层更加完整地分离出来可能会更好
一些。微型语言的设计者应该注意到这点。
    所有的预处理器语言（尽管troff标记本身不是）都具有相对干净、类似shell的语法，
遵循了我们在第5章针对数据文件格式的设计描述过的很多约定。也有一些令人尴尬的
例外：特别是，tbl（1）默认使用tab键作为表格栏之间的字段分隔符，复制了make （1）
的设计中一个声名狼藉的补丁，而且，当编辑器或其它工具悄悄改变空白的组成时便会
引发恼人的bug，
    尽管troff本身是～种专用的命令性语言，贯穿至少三个DWB微型语言的一个主题
却是声明性语义：根据约束条件安排布局。这也是现代GUI工具包展现的一个理念――
也就是说，对图形对象不用像素坐标表示，真正要做的是说明它们之间的空间关系（A
在B上方，B在C的左方），然后让软件根据这些约束条件计算出A、B和C的最佳布
局。
  pic（1）程序就用这种方法来安排图形的各个部分。例8.1所示的语言分类图就是用
例8.410所示的pic源码，调用我们在第7章作为实例分析的pic2graph得出的。
    这是一段非常典型的Unix微型语言设计，而且即使从纯语法角度看，这段设计也有
一些地方值得关注。注意这段程序看起来多么像shell程序：#引导注释，语法很明显地
面向标记（ token-oriented），并采用尽可能简单的字符串约定。pic （1）的设计者知道，
除非有强烈、特殊的理由，否则Unix程序员所期望的微型语言的语法看起来就是这个样
子。最小立异原则在这儿得到了充分运用。
    不用费什么力就可以看出，这段代码的第一行是一个宏定义；对smallellipse0
的后续引用封装了图表的重复设计元素。也无需多仔细研究就可以推导出．box invis
'o描述pjc（l）的Unix书把例图作为编码实例涵盖进来是相当传统的。
www.pdf365.com
198
第8章微型语言：寻找歌唱的乐符
例8.4  语言分类图-pic源码
  # Minilanguage Laxonomy
  #
  # Base ellipses
  define smallellipse {ellipse width 3.0 height l.5}
   M: ellipse width 3.0 height 18 fill 0.2
  line  from Mn  to  M. s  dashed
   D: smallellipse（） with .e a七 M.w + （0.8， 0）
  line from D.n to D.s dashed
  I: smallellipse（） with .w a七 M.e - （0.8， 0）
  #
  # Captions
     r~ t~   " Da七a  formats "   at  D. S
       ii n  "Minilanguages "  at  M.s
      riii   " Interpre七ers"  at  I.s
  #
  # Heads
  arrow from D.w + （0.4， 0.8）  七o D.e + （-0.4， 0.8）
       " flat   to  structured "   i~ i~   a七   last   arrow.c
 arrow from M.w + （0.4， 1.0） to M.e + （-0.4， 1.0）
  "declarative  to  imperaL ive "   i~ il   dt   last   arrow.c
 arrow from Iw + （0.4， 0.8） to I.e + （-0.4， 0.8）
  "less  to  more  general "   i~ it  at  last  arrow.c
  #
  # The arrow of loopiness
 arrow from D+w + （0， 1.2） to Ie + （0， 1.2）
 "increasing  loopiness "  " "  at  last  arrowc
 #
 # Flat data files
 "/etc/passwd" ".nawsrc" at 0.5 between D.c and D+w
 # S七ructured data files
  "SNG" at 0.5 between Dc and M.w
 # DaLafile/minilanguage borderline cases
     " regexps "   "Glade "   at   0.5  between  M.w  and  D.e
 # Declarative minilanguages
 "m4" "Yacc" "Lex" "make" "XSLT" 'rpic" "tbl" "eqn'* \
     at 0.5 between M.c and D.e
 # Imperative minilanguages
 "fetchmail" "awk" "troff" "Postscript" a七 0.5 be七ween Mc andI.w
 # Minilanguage/in七erpreter borderline cases
 "dc" "bc" at 0.5 be七ween Iw and M.e
 # Interpreters
 "Emacs Lisp" "JavaScript" at 0.25 between M.e and Ie
 'rshii "tcl" at 0.55 between M.e and工.e
 'fPerl" "Py七hon" "Java" at 0.8 between M.e and Ie
---             -------
www.pdf365.com
8.2应用微型语言
1 99
说明了一个没有边框的方框，实际上只是一个供文本输入的框架。arrow命令同样很明
显。
    把这些作为线索看一看实际的图表，其余语法片断的意义（如M．s的位置引用last
arrow或at 0.25 between M.e and I.e之类的限制条件或某个位置增加向量偏
移等）都会立刻清楚了。和Glade标记及m4 -样，无需参考手册，这样的例子就可以教
导我们很多语言方面的东西（不幸的是，紧凑的troff（1）标记却授有这样的特性）。
    pic （l）的例子反映了微型语言一个常见的设计主题，我们发现这个设计主题也反
映在Glade中――使用微型语言解释器来封装某些形式的约束条件推理，然后将其转化
为行为。实际上，我们可以选择把pic （l）作为命令性语言而不是声明性语言来看待；
这个语言具有两者的元素，争论无济于事。
    宏与基于约束条件安排布局的结合使pic（1）具备了SVG之类基于向量的现代标记
语言无法实现的表达图表的能力。因此，幸运的是，DWB的一个影响就是pic （1）很容
易脱离DWB环境使用。我们在第7章作为实例分析的pic2graph脚本就是这么一种
特别的方法，使用g．roff （1）这个改进酌PostScript能力作为现代位图格式的中间步骤来
完成这一任务。
    更干净的方法是使用pic2plot（1）实用程序，它随GNU plotutils包一起发布，并利
用了GNU pic（l）代码内部的模块化特性。整个代码分成分析前端和生成troff标记的后端，
前端和后端通过绘图原语层进行通讯。由于这个设计遵循了模块原则，pic2plot（1）的
执行者可把GNU pic分析进程分离出来，并用现代绘图库重新实现绘图原语。然而，这
种方法的缺点在于输出文本是由pic2plot内置字体生成的，与troff字体不匹配。
8.2.7案例分析：fetchma，／的运行控制语法
参见例8.5。
    这个运行控制文件可看作命令性微型语言。存在一个隐含的执行流：循环执行查询
命令列表（在每个循环结束时休息一会儿），对每个站点依次从其相关用户收集邮件。
这个文件不通用；它所能完成的任务就是排队查询行为。
    和pic （l） -样，我们可以把这个微型语言视为一种声明性语言，也可以把它视为
～个很弱的命令性语言，并不断讨论其中的区别。一方面，它既没有条件，也没有递归
或循环，事实上，它根本没有明确的控制结构。另一方面，它确实描述了行为，而不仅
仅描迷关系，这又与Glade GUI说明这样的纯声明性语法有所区别。
www.pdf365.com
第8章微型语言：寻找歌唱的乐符
例8.5 fetchmailrc的假想例子
# Poll this site first each cycle.
poll  pop .provider .net  proto  pop3
     user  " j smith"  with  pass   "secretl"  is  'Isrriithfl  here
     user  jones  with  pass  "secret2 "  is  'jjones"  here  with  options  keep
# Poll this site second， unless Lord Voldemort zaps us first.
poll billywig.hogwarts.com with proto imap:
     user harry_potter with pass "floo" is harry_potter here
# Poll this site third in the cycle.
#  Password  will  be  fetched  from  -/ .netrc
poll mailhost.net with proto imap:
     user esr is esr here
    复杂程序的运行控制微型语言经常横跨这个界限。我们强调这个事实是因为，如果
问题域允许，命令性微型语言中没有明确的控制结构特是一种巨大的简化。
    ．f et chmailrc语法的一个显著特性是使用可选的纯修饰关键字，支持这些关键字
仅仅是为了使说明语言读起来更像英语。例中的“with"关键字和出现一次的“option”
实际上并不必要，但它们有助于使声明语言更易懂。
    这类东西的传统术语是语法糖（sVntactic sugar）；与之联系在一起的一段格言是非常
著名的俏皮话：  “syntactic sugar causes cancer of the semicolon”（语法糖导致分号癌）¨。
事实上，必须谨慎使用语法糖，以免造成的晦涩多子帮助。
    我们将在第9章看～看，数据驱动编程是怎样帮助通过GUI编辑fetchmail运行控制
文件优雅地解决问题的。
8.2.8案例分析：a瞅
  awk微型语言是老式的Unix工具，原来大量用于shell脚本。和m4 -样，它的设计
目的是为了编写小巧但有表达力的程序，从而把文本输入变换为文本输出。所有的Unix
11这句话出自Alan Perlis，他在1970年左右完成了软件模块化方面的一些先驱性工作。所质疑的分
号是Algol系列的各种语言，包括Pascal和C，把它用作语句分隔符或结束符。
UNIX编程艺：术
    www.pdf365.com
8.2应用微型语言
201
发布均包含它的某一版本，其中有几个是开源版本；Unix shell提示下键入info gawk
命令可以查看在线文档。
    awk程序包括模式／行为对。每个模式都是正鹚饿匏拭，我们将在第9章具体讨论这
个概念。awk程序运行时一行一行过滤输入文件。每一行都顺序经过模式／行为对检查。
如果模式和行匹配，则执行相关的行为。
    每个行为都用类似C子集的语言写成，具有变量、条件、循环和包括整数、字符串
和（与C不同）字典在内的类型分类。心
    awk语言是图灵完备的，而且可以读写文件。在一些版本中，它可以打开并使用网
络套接字。但awk主要用作报表生成器，尤其用于解释和减少表列数据。它很少单独使
用，而是内嵌在脚本中使用。第9章有关HTML生成的实例分析中就包括了一个awk程
序实例。
    包括awk案例分析的目的是，指出awk不是一个值得效仿的模型：实际上，从1990
年以来，它很大部分已经被逐渐废弃了，为新派脚本语言所取代――特别是Perl，就是
明确成为awk的替代程序而设计的。原因值得研究，因为awk构成了对微型语言设计者
的部分教训。
    awk语言最早的设计目的是针对报表生成的一种小巧、有表达力的专用语言。木幸
的是，结果它在复杂度和能力的取舍上做得并不好。作用语言并不紧凑，但它依靠的模
式驱动框架阻止了它的通用性――这是两个世界的最糟部分。新派脚本语言可完成awk:
所能完成的任何任务；它们的等价程序，至少和它一样易读。
    awk逐渐被废弃，还因为更现代的shell具有浮点运算、关联数组、正则表达
式模式匹配和子串能力，因此无须产生进程生成的开销就能完成小型awk脚本的
等价程序。
-David Korn
    Perl于1987年发布后的数年内awk还有竞争力，因为awk的实现更小更快。但随着
处理器和内存的成本下降，支持相对节约的专用语言在经济方面的优点就不起作用了。
程序员不断选择用Perl或（后来的）Python来完成awk能完成的任务，而不是在头脑中
12对于那些从来没有用现代脚本语言编程的读者来说，字典就是一种关键字和值对应的查找表，经
常通过散列表实现。C程序员花费了大量时间编写各种复杂的方式来实现字典。
    UNIX编I程艺．术
    www.pdf365.com
202
第8章微型语言：寻找歌唱的乐符
记住两种不同的脚本语言。13到2000年，awk已经成为Unix老牌黑客的一种记忆，而且
并不留恋。
    成本的下降已经改变了微型语言设计中的权衡。通过限制设计能力来提高设计紧凑
性可能仍然是个好主意，但通过限制设计能力来节约设备资源则不然。随着时间的推移，
设备资源变得越来越廉价，但程序员头脑中的空间只会越来越昂贵。现代微型语言，要
么就非常通用而不紧凑，要么就非常不通用而紧凑：不通用也不紧凑的语言则完全没有
竞争力。
8.2.9  案例分析：PostScript
    PostScript是一个专门向成像设备描述排版文本和图形的微型语言。它以著名的
Xerox Palo Alto研究中心的设计工作和最早的激光打印机为基础，并移植到Unix中。自
1984年首次商业发布以来，它只能作为Adobe，Inc.，的专属产品使用，而且用在苹果机上。
1988年根据授权规定被克隆成非常接近开源的版本，从那以后就成为Unix中打印机控
制的事实标准。完全开源的版本和大多数最新的Unix版本一起发布。14PostScript有很好
的技术介绍。15
    PostScript和troff标记在一些功能上很像：两着的目的都是为了控制打印机和其它成
像设备；两者通常都由程序或宏语句包生成，而不是手工编写。但是，考虑了troff请求
是一套无止境增长的格式控制代码集，并已经具备了一些语言特性之后，PostScript从头
开始作为语言设计，因此更加具有表达力、更加有效。PostScript之所以有用，就是对用
PostScript编写的图形的算法说明比它们渲染出的位图更加小，而且占据的内存和通信带
宽也更少。
    PostScipt显然是图灵完备的，支持条件、循环、递归和具名过程。类型分类包括整
数、实数、字符串和数组（数组的每个元素可以是任何一种类型），但没有结构或等价
”我曾经是awk奇才，但别人提醒我，这个语言只适用于HTML的生成，这是本书唯一出现awk
实例的地方。
14 GhostScript的项目网站：<ht tp：//www．cs．wisc．edu/-ghost/>。
15 A First Guide To PostScript （PostScript入门指南）：
<http：／/www.cs.indiana.edu/docproj ect/programrning/postscript/postscript.
html>。
www.pdf365.com
8.2应用微型语言
203
物。从技术上而言，PostScript是一种堆栈式语言；PostScript的原语过程（primitive
procedure）（操作符）的参数通常是先进后出式参数堆栈，结果值重新入栈。
    在总计400个左右的操作符中大约有40个是基本操作符。其中完成任务最多的是
show，即在页面上画一条线。其它操作符包括设置当前字体，改变灰度或色度，画直线、
曲线或贝塞尔曲线，填充闭区域，设置剪切区域等等。PostScript解释器负责把这些命令
解释成位图以便显示或打印。
    另外一些PostScript操作符实现算术、控制结构和过程。这些操作符允许把重复或定
型的图形（如由重复字体构成的文本等）表达成带图形的程序。PostScript的部分效用基
丁-这样一个事实，即打印文本或简单向量图的PostScript程序比文本或向量渲染出的位图
容量小，而且与设备无关，在网络电缆或串行线上传输速度更快。
    从历史角度而言，PostScript的堆栈式解释与一个叫FORTH的语言很像，该语言是
为了实时控制1980年代非常流行的telescope motor而设计的。堆栈式语言以支持紧凑、
经济的编码而著名，但乜以难读而臭名昭著。PostScript也有这两个特点。
    PostScript经常被实现为打印机的固件。开源实现的Ghostscript可以把PostScript转
换成各种图形格式和（比较弱的）打印机控制语言。其它大多数软件都把PostScript看成
最终的输出格式，意味着可以输送给具有PostScript能力的图形设备但不能用手工编辑或
肉眼检查。
    PostScript（无论是最初形式还是具有边界框以便嵌入到其它图形中的小变种EPSF）
都是专用控制语言的好设计实例，值得作为模型仔细研究。它也是其它标准的组成部分，
如可移植文档格式PDF的标准。
8.2.10案例分析：bc和出
    我们首先在第7章作为shellout的实例分析研究了bc （l）和dc （l）。它们是命令
性专门领域微型语言的实例。
    dc是Unix上最古老的语言：它在PDP-7上编写而成，在Unix自己移植过去
之前就已经移植到了PDP-1I上。
-Ken Thompson
UNIX编暖艺-术
    www.pdf365.com
204
第8章微型语言：寻找歌唱的乐符
    这两种语言的领域都是无限精度算术。其它程序可以使用这两个语言进行计算，而
无需考虑完成这些计算所要求的特殊技法。
    事实上，设计dc的初衷不是为了提供通用的交互式计算器，那可用简单的浮
点程序来实现。真正的动机是贝尔实验室对数值分析的长期兴趣：针对数值算法
的常量计算，前勿地花，得到了能够计算更高精度而不是运算本身所能使用的精
度的大力帮助。因此dc是任意精度算法。
-Henry Spencer
    和SNG及Glade标记一样，这两种语言的一个优势在于它们的简单性。一旦知道
dc （l）是～个逆波兰标记法计算器，bc （1）是一个代数标记法计算器，则这两个语言
的交互使用便毫不困难。我们将在第1 1章重新讨论最小立异原则的重要性。
    这两个微型语言都有条件和循环：它们都是图灵完备的，但类型的分类很有限，只
包括无限精度的整数和字符串。这使得它们处在解释性微型语言和完全脚本语言之间。
这些编程特性的设计目的是，让它们不要作为计算器涉足普通计算；实际上大多数dclbc
用户可能都没有意识到这些。
    通常，dclbc可对话式使用，但它们支持用户定义程序库的能力使得它们具备额外功
用――可编程性。这实陈上是命令性微型语言最重要的优势，我们在DWB工具的实例
分析中发现，无论程序的正常模式是否是对话式，这个优势都非常有利；可以用它们来
编写高级程序，并加入针对任务的专门智能。
    由于dclbc的界面非常简单（送入一行表达式，得到一行计算值），只要把这些程序
作为从进程调用，其它程序和脚本都可以轻而易举地获得所有这些能力。例8.6就是一
个非常著名的例子，这是一个用Perl实现的Rivest-Shamir-Adelman （RSA）公共密钥算
例8.6  使用dc的RSA实现
print  pack " C* " ， split/\D+/ . - echo   " 16iII*o\U@ { $/=$z; [ （pop， pop， unpack
   " H* " ，<》  ]  } \EsMsKsNO [ lN*1lK [d2 %Sa2/dO<X+d* IMLa^*lN%O ] dsXx++\
lMIN/dSMO<J] dsjxp " ldc '
www.pdf365.com
8.2应用微型语言
205
法，广泛发布在签名档和T恤上，以示对美国1995年的限制密码学出口的抗议；它交给
dc来完成要求的无限精度算法。
8.2.11  案例分析：Emacs Lisp
    一个专用的解释语言不仅可作为从进程运行完成专门任务，也可成为整个体系的核
心；我们将在第13章分析这种方法的优点和缺点。troff请求是早期范例；如今，Emacs
编辑器是最著名、最有效的现代实例。Emacs是围绕Lisp的语言构建而成的，原语既可
说明编辑缓存的动作，也可控制从进程。
    Emacs语言对于描述编辑动作和作为其它程序的前端来说足够强大，这意味着它除
了常规编辑外还可用于许多其它任务。我们将在第15章分析Emacs用于日常程序开发（编
译、调试、版本控制）的专门能力。Emacs的“模式”是用户定义的程序库――用Emacs
Lips编写的程序，针对具体任务定制编辑器――通常是有关编辑的任务，但也有例外。
    这样就有了特制的模式，知道大量编程语言的语法，也知道SGML、XML和HTML
等标记语言的语法。但很多人也用Emacs模式来发送和接收邮件（这些把Unix的系统邮
件实用程序当作从进程使用）或Usenet新闻。Emacs呵以浏览网页，或作为各种聊天程
序的前端。还有一个日历包和Emacs自带的计算程序，甚至还有相对广泛的可以选择的
Emacs Lisp模式游戏（包括模仿Rogersian精神病学家的著名ELIZA程序的各种后续版
本）。‘6
8.2.12  案例分析：JavaScript
    JavaScript是为了嵌入C程序而设计的一种开源语言。尽管它也嵌入在网络服务器
中，但最早也最出名的表现形式还是客户端JavaScript，可以让我们在网页中嵌入可执行
代码，以供任何具有JavaScript能力的浏览器运行。这就是我们要在此处讨论的版本。
    JavaScript是充分的图灵完备的解释性语言，和Python -样，具有整数、实数、布
尔逻辑、字符串和轻量级的字典对象。数值是带类型的，但变量可容纳任意类型值；类
UN）×编睦艺术
  www.pdf365.com
的
甜
  e
  曲
  H
  e
  Ig
  y
  印
  压  。
  从G
  删删
  来8
  微鼽
  髓就
  锄耵
  鲋耐
  觚不
  n
  研七
  一～
  亭呻
  讲舱
  ～一
  一一
  ㈣～
  ‰鼽
  驯肌
  用引
  利机
  m随
206
第8章微型语言：寻找歌唱的乐符
型之间的转换在很多上下文中自动进行。语法上，JavaScript和Java很像，都受到了Perl
的一些影响，具有类似Perl的正则表达式。
    尽管有这些特点，客户端的JavaScript还不是一个相当通用的语言。它的能力被严格
约束，以防止通过包含JavaScript的网页攻击浏览器。它可以接收来自用户的输入、生成
或修改网页，但不能直接改变磁盘文件的内容，也不能打开自己的网络连接。
    随着时间的推移，JavaScript语言变得更加通用了，而且对其客户端环境的约束也放
松了。这是任何一个成功的专用语言随着其能力在开发者和用户的头脑中逐渐展现时可
预期的结果。客户端JavaScript现在也可以通过在一个叫做浏览器DOM（文件对象模型）
的单个对象中读写值而与环境交互。虽然这个语言仍然给浏览器遗留了一些DOM无法
支持的API，但这些API都己过时，没有列入JavaScript的ECMA-262标准中，而且在
将来的版本中可能也不会支持。
    JavaScript的标准参考书是《JavaScript: The Definitive Guide》 （JavaScript：权威指南）
IFlanaganjavaScriptl，源码可下载。I7JavaScript成为一个有趣的实例有两个理由。首先，
它是我们无需真正进入但可尽量接近的通用语言。其次，客户端JavaScript及其通过单个
DOM对象的浏览器环境之间的结合是个非常棒的设计，能够作为其它嵌入情形的借鉴模
型。
8.3设计微型语言
    什么时候适合设计一个微型语言？我们已经发现，微型语言提供了把问题说明规格
提升一个层次的方法，并已经提供了数个案例分析中的施行方式。这个结论另一面是，
只要应用领域的域原语简单而固定不变，微型语言就可能成为～种好方法，但用户可能
希望应用方式要灵活多变。
    相关观点，  请参考对  Alternate  Hard  And  Soft  Layers  的说明
<ht t-p：／/www．c2．com/cgi/wiki?AlternateHardAndSof tLayers>和对脚本部
件    <http:／/www. doc. ic. ac. uk/~np2 /patterns/scripting/scripting.
html>的设计模式的说明。
17 JavaScript的开源c和Java实现可在<http：//WWW．mozilla．org/j s／>获稃。
www.pdf365.com
Q口j凸．{士型耵刑芒E言
o.o L又¨FRj兰匝口
207
    对微型语言的设计风格和设计方法的有趣总结参见《Notable Design Patterns for
Domain-Specific Languages》（领域专用语言的著名设计模式）[Spinellis]。
8.3。1  选择正确的复杂度
    照例，设计微型语言时要记住的第一要素是尽可能保持微型语言的简单。我们用来
组织实例分析的分类图表明了复杂度的层次；应该尽可能保持我们的设计靠近左手边。
如果只设计一个结构化的数据文件，而无需设计在解释时要修改外部数据的微型语言便
可以达到目的，那就尽力去做。
    坚持结构化数据而不是微型语言的～个非常实际的理由是，在网络世界，嵌入微型
语言功能容易导致滥用，从而引起不便甚至是危险。JavaScript是“不便’’类型中的主要
实例：它的设计者并没有料到它会用于弹出式广告，而且是这样令人反感，以至于有人
要求浏览器禁止解释JavaScript。
    Microsoft Word的宏病毒则展示了这种事情会变得多么危险，这个安全漏洞每年造
成的停机时间要耗费数十亿美元，而且严重损失生产力。尽管全世界至少有2000万18Unix
用户，但从来都没育任何和W'indows频繁爆发的宏病毒类似的Unix病毒爆发，注意到
这一点非常有益。造成这个事实的原因有好几个，包括Unix是本质上更好的安全设计：
但至少有一个原因应归功于一事实-Unix邮件代理不会默认执行用户查看文档中的任
何即时内容。19
    如果有任何可能使应用程序的用户最后要运行来自不受信任来源的程序，应用微型
语言的风险特性可能必须被禁止。Java和JavaScript这样的语言己被明确地沙盒化
（sandboxed） -也就是说，它们对环境的访问是受限的，目的不仅是为了简化设计，
而且是为了防止有bug或恶意代码执行潜在的破坏性操作。
    另一方面，很多不良设计都被设计者修补过了，但这些设计者并没有勇敢地正视，
他们真正需要的其实不是数据文件格式而是微型语言这个事实。把语言一样的特性加进
去作为事后补救措施，这样的事情发生得太频繁了。这个问题最普遍的两个表现是，薄
18 2000万只是2003年中期根据Linux Counter和其它地方统计数字的保守估计。
旧出于这个原因我们在第6章分析的kmail甚至不会追循HTML中的其它站点链接。
UNIX编楼艺术
  www.pdf365.com
208
第8章微型语言：寻找歌唱的乐符
弱而专用的控制结构，和孱弱或根本不存在的过程声明机能。
    设计一个偶尔图灵完备的微型语言也非常危险。如果这样做了，将来的某一天，某
个聪明的家伙可能认为他需要让语言来替他执行循坏和条件。但由于这些只能用一种晦
涩的方式完成，所以他只能写出晦涩的代码。产生的结果在短期内可能有用，但对于他
之后的人来说却可能是一个噩梦。
    微型语言的设计不仅强大而且剧报丰厚，但它同样充满了类似的陷阱。有这样一些
设计，采取自底向上的方法把几个底层服务粘合在一起，在研究了问题域之后又会担心
其组织是否得当。微型语言的优势之一是可以把一些自顶向下的决策放到微型语言的程
序控制流中，从而帮助我们从自底向上的编程中得到一个良好的设计。但如果我们对微
型语言设计的本身采取自底向上的方法，则最终我们很可能得到一种丑陋的语法，反映
出一种薄弱的语言和未经仔细考虑的实现。
    微型语言的设计中存在很多这样的地方，选择上的小小不同就会在工具的可用性和
易用性方面造成巨大差异：
    作为语言设计者，一个很好的原则是考虑给出错误信息的备选方式。当程序
员的目的实在不明确时，给出报错信息非常合适，但在目的明确的多数情况下，
让语言默黢完成正确的事则极有帮助。一个很好的例子就是，C语言在数组初始
化列表的末尾允许额外增加一个逗号，使得数组初始化的编辑和机器生成都更加
容易。反例则是各种HTML阅读器的过分挑剔，即使遇到极小的嵌套错误也会导
致大段文档被悄悄略过。
-Steve Johnson
    在这个问题上，和其它地方一样，没有什么可以替代良好的鉴赏力和工程判断。如
果要设计一个微型语言，不要半途而废。声明性微型语言应该具有一个明确、一致、类
似自然语言的语法能够为人类所阅读。命令性微型语言则应该从用户应该熟悉的语言模
型中套用一系列控制结构。把微型语言确实当作语言来考虑；问问自己一些美学方面的
问题，如“把它编码进去舒服吗？”，甚至“看上去愉快吗？”在这里，和软件设计的
其它地方一样，David Gelemter的格言也同样适用：美是抵御复杂的最后武器。
www.pdf365.com
209
8.3.2扩展和嵌入语言
    一个非常重要的基础性问题是，能否通过扩展或嵌入现有脚本语言来实现自己的微
型语言。这往往是实现命令性语言的正确办法，但对于声明性语言就不是那么合适了。
    有时候，简单地在解释性语言中编写服务函数就可能实现命令性语言，为了这个目
的，我们把这种解释性语言称作“主”语言。自己的微型语言只不过是加载服务库的脚
本并把主语言的控制结构和其它功能当作框架使用。主语言提供的一切机能都不必亲自
动手。
    这是编写微型语言最简单的方法。老派的Lisp程序员（包括我在内）热爱这种技术
并大量使用。它是Emacs编辑器的设计基础，而且在新派的脚本语言，如Tcl、Python
和Perl中，也可以找到。当然，这种技术也存在缺点。
    主语言可能无法作为所需要代码库的接口。或者，从内部而言，它的数据类型可能
并不足以完成所需要的计算类型。又或者，测量过原型性能后，发现速度太慢。出现以
上任何一件情况时，解决方案通常是用C（或C++）编码，然后把结果整合到自己的微
型语言中。
    是用C代码扩展脚本语言，还是在C程序中嵌入脚本语言，这个选择取决于为此设
计的脚本语言本身。扩展脚本语言的方法是动态载入C库或模块，C入口点咸为扩展语
言中的可见函数。也可以在C程序中嵌入脚本语言，方法是向解释器实例发送命令然后
接收结果值在C中使用。
    这两种方法都取决于在C的类型分类和脚本语言的类型分类中进行数据转换的能
力a有些脚本语言为完全支持这种转换而设计。其中之一就是我们将在第14章分析的
Tcl。另外一个是Guile，即Lisp的变种Scheme的开源语言。Guile作为库发布，设计目
的便是嵌入到C中使用。
    可以扩展或嵌入Perl（尽管在2003年还是相当痛苦和困难）。扩展Python很容易，
但要嵌入Python则要困难一点；C扩展特别频繁地用于Python中。Java有一个接口可调
用C的“原生方法”，只不过这个实践被明确阻止，因为它往往破坏可移植性。sheIJ的
大多数版本都不是为嵌入性和扩展性设计的，但Korn shell（ksh93和后续版本）是个显
著的例外。
    支持在现有脚本语言上放置命令性微型语言的理由大多并不恰当。为数不多的几个
好理由之一是确实需要实现自己的自定义语言进行错误检查。如果是这样，请参考以下
关于yacc和lex的建议。
www.pdf365.com
210
第8章微型语言：寻找歌唱的乐符
8.3.3编写自定义语法
    至于声明性微型语言，一个主要问题是，是否应该用XML作为语法基础并把语法
规定为XML文档类型。对于层次复杂的说明性微型语言，这完全可能是正确做法，但
我们在第5章有关设计数据文件格式时提到的告诫同样适用-XML可能太大材小用
了。如果不用XML，就遵循最小立异原则，并支持我们描述数据文件时谈到的Unix约
定（简单的面向标记的语法、支持C反斜杠约定等）。
    如果确实需要自定义语法，yacc和lex（或所用语言中的本地等价实现）也许是我们
最好的朋友，除非所用语言的语法很简单，而且手工编写递归下降分析器的工作量非常
小。即便这样，yacc也可能给我们更好的错误恢复。随着语法的发展，yacc的说明更容
易修改。参见第9章有关不同实现语言中从yacc和tex派生的工具。
    即使我们决定实现自己的语法，考虑一下重用现有工具所能得到的好处。如果确实
需要宏机能，考虑一下用m4 （1）进行预处理是否正确――但首先注意下一节提出的警
告。
    宏扩展机能是早期Unix语言设计者青睐的策略：当然，C语言有宏扩展，而且我们
已经在一些更加复杂的专用微型语言，如pic （l）中也着到了它。m4预处理器是实现扩
展预处理器的通用工具。
    很容易说明和实现宏扩展，而且可以用宏扩展实现很多聪明的技巧。早期的设计者
似乎都受到了使用编译程序的影响。在汇编程序中，宏经常是架构程序唯一的可用方法。
    宏扩展的优势在于它无需知道基础语言的任何基础语法就可以用来扩展该语言。不
幸的是，这种能力很容易被滥用，生成奇怪、不透明的代码，成为滋生难于辨识bug的
温床。
    在C中，这种问题的典型例子是这样一个宏：
#define max（x，  y）    x>y?x:y
    这个宏至少存在两个问题。一个问题是，如果任何一个参数是个表达式，包括比>
或？：优先级更低的运算符，则结果可能令人惊讶。考虑一下表达式max（a：b，++c）。
www.pdf365.com
8.3设计微型语言
21 1
如果程序员忘记max是个宏，则他可能会期望先完成赋值a=b和对c的预增量计算，
然后把计算值作为参数输送给max。
    但事实却不是这样的。相反，预处理器会把这个表达式扩展成a：b>++c?a
=b：++c，其中c编译器的优先规则使它解释为a：（b>++c?a：b：++c）。
其比较结果被赋值给al
    这种不良作用可以通过宏定义的防御性编码得到避免。
#define  max （x，  y）    （（x）  >  （y）  ?  （x）  :  （y））
    采用这个定义，宏会被扩展为（（a=b）>（++c）?（a：b）  ：  （++c））。这
解决了一个问题――但请注意，c可能被自增两次！这个陷阱还有更加狡猾的一个版本，
比如，向宏传递一个带副作用的函数调用。
    一般来说，宏与带副作用的表达式之间的交互作用可能导致不幸的结果，而且难以
诊断oC的宏处理器是一个有意设计得非常轻巧和简单的处理器；更强大的处理器可能
会带来更糟糕的麻烦。
    TEX格式语言（参见第18章）很好地说明了这个普遍存在的问题。TEX是有意的
完备图灵机（具有条件、循环和递归）；尽管它能完成惊人的任务，但TEX代码往往极
难阅读和调试。LATEX是使用最广泛的TEX宏语句包，其溧文件就是一个很有教育意
义的例子：很好地符合了TEX的风格，但即便这样，也太难读懂。
    与此相比，一个小问题是，宏扩展往往扰乱了错误诊断。基础语言处理器生成的错
误报告针对的是宏扩展文本，而不是程序员正在查看的原始文本。如果两者的关系被宏
扩展弄得很混乱，则生成的错误报告可能非常难于和错误的实际位置联系起来。
    当宏具有多行扩展、有条件地包括／排除文本、将改变扩展文本的行数时，预处理器
和宏之间就特别容易产生问题。
    内嵌在语言中的宏扩展可以完成一些自我补救、重定行数以备查阅扩展前的文本。
例如，pic （1）的宏功能就能这样做。如果宏扩展由预处理器完成，则这个问题更加难
以解决。
C预处理器的解决方法是，无论何时只要包括扩展或进行多行扩展就发送#line指
UNIX绢翻呈}艺术
    www.pdf365.com
212
第8章微型语言：寻找歌唱的乐符
令。C编译器可对此做出解释并相应地在错误报告中调整行数。不幸的是，m4却没有这
样的功能。
    有理由非常谨慎地使用宏扩展。Unix经验的长期教训之一是宏产生的问题比宏解决
的问题多。现代语言和微型语言的设计已经越来越远离宏了。
8.3.5语言还是应用协议
    我们必须要问的另外一个重要问题是，微型语言引擎是否可被其它程序作为从进程
交互调用。如果可以，我们的设计可能看上去不太像可供人类交互的会话式语言，而更
像我们在第5章分析的应用协议。
    主要区别在于事务边界的标定程度。人类擅长发现CLI的会话式输出在哪里结束，
下一个输入的提示在哪里。他们可根据上下文来判断什么重要，什么应该被忽略。计算
机程序要完成这个就困难多了。如果输出没有明确的结束标记或没有提前告诉输出长度，
则机器就无法判断何时停止读取。
    更糟糕的事发生在程序的输入被缓冲起来（经常是无意的，如stdio所为）的
时候。在正确的地方公然停止读取的程序仍然可以超界读取。
-Doug Mcllroy
    如果从属进程没有为这个问题专门设计便和主进程进行通信，如果它们之间同步失
败（我们在第7章首次提到这个问题），死锁就更容易发生。
    对于那堂未经仔细设计的微型语言，存在一些斡旋方案。其中绝大多数的原型都是
Tcl的expect包。这个包协助CLI间的对话。它围绕以下操作建造：自从进程不断读入，
直到匹配某个指定的正则表达式或超时。有了这个操作（当然，以及发送到从进程的操
作），即使从进程并非为与其它程序通讯这个角色定制，也往往可能使主从进程间的对
话更加可靠。
    其它语言中有工作方式类似的expect自：在网上以自己最喜爱语言的名称并加上“Tcl
expect”关键字进行搜索，很可能找到一些有用的内容。然而，作为微型语言设计者，最
好不要假设所有的用户都精通expect。即使用户是expect专家，这也是一个特别厚的胶
合层，容易在这儿犯错。
www.pdf365.com
21 3
    设计微型语言时要小心这个问题。增加一个选项，改变会话行为，使其相应地更像
应用协议，同时给出明确的输出结束分隔符和类似的字节补齐，也许是个不错的主意。
UNIX编程艺术
    www.pdf365.com
www.pdf365.com
曰
刚
生成：提升规格说明的层次
Generation: Pushing the
Specification Level Upwards
    The programmer at witts end…can often do best by disentangling himselffrom his code，
rearing back， and contemplating his data. Representation is the essence ofprogramming.
    程序员束手无策……只有跳脱代码，直起腰，仔细思考数据才是最好的行动。表达
是编程的精髓。
    The Mythical Man-Month， Anniversary Edition（】975-1995），p.103
    《人月神话，二十周年纪念版》  （1975- 1995），103页
    -Fred Brooks
    我们在第1章中说过，人类其实更善于肉眼观察数据而不是推导控制流程。概括如下：
不信可以试试比较一下，是五十个节点的指针树，还是五十行代码的流程图来得清楚明了？
或者（更明显地），比较一下究竟用数组初始化器来表示转换表，还是switch语句更清楚明
了呢？可以看出，不同的方式在透明性和清晰性方面具有非常显著的羞别。．
    数据比程序逻辑更易驾驭。无论数据是普通表格、说明性标记语言、模版系统还是
一组可以扩展成程序逻辑的宏，这～点都成立。尽可能把设计的复杂度从程序代码转移
1关于这一点的进一步展开请参考[Bentley]。
UNIX箱腥艺．术
  www.pdf365.com
216
第9章生成：提升规格说明的层次
到数据中是个好实践，选择便于人类维护和操作的数据表示法也是好实践。把这些表示
法转换为便于机器处理的形式是机器该干的事，不是人类的任务。
    更高级、更富说明力的标记法应具有另一个重要优点，就是更便于利用编译
  期检查。过程式标记法天生具有复杂的运行时行为，很难在编译期分析。而说明
  性标记法使人们可以更彻底地理解预期行为，令实现中的错误更容易发现。
-Henry Spencer
    这些领悟在理论上都以一系列实践为基础，而这些实践始终是Unix程序员工具包的
重要组成部分，这些工具包包括高级语言、数据驱动编程、代码生成器、特定领域的微
型语言等。这些工具的共同点是，它们都是提升代码生成层次从而使规格说明更简炼的
方法。此前我们已经注意到，缺陷密度与编程语言无关；所有这些实践都意味着，无论
邪恶力量产生什么作用，我们的bug都只会以更少的行数来实施破坏。
    我们第8章讨论了特定领域微型语言的用法。我们将在第14章详细说明非常高级的
语言。本章我们要分析数据驱动编程的设计实例和一些专用代码生成的例子：我们将在
第15章分析一些代码生成工具。和微型语言一样，这些方法都能大幅减少程序的行数，
并相虚减少调试时间和维护成本。
9.1  数据驱动编程
    进行数据驱动编程时，需要把代码和代码作用的数据结构划分清楚，这样，在改变
程序的逻辑时，就只要编辑数据结构而不是代码。
    数据驱动编程有时会跟面向对象混淆起来，后者是另一种以数据组织为中心的风格。
它们之间至少有两点不同。第一，在数据驱动编程中，数据不仅仅是某个对象的状态，
实际上还定义了程序的控制流；第二，00首先考虑的是封装，而数据驱动编程看重的
是编写尽可能少的固定代码。Unix中数据驱动编程的传统比00更深厚。
www.pdf365.com
9.1  数据驱动编程
217
    数据驱动编程有时也会和状态机编写相混淆。把状态机逻辑表达成表格或数据结构
事实上是可能的，但手工编码的状态机通常是固定的代码块，远比表格更难修改。
    进行任何类型的代码生成或数据驱动编程的重要原则是：始终把问题层次往上推。
不要手工修改生成的代码或中间形式――相反，应找到一种方式来改进或代替转换工具。
否则，很可能发现手工修补应该由机器王E确生成的代码会耗费无穷的时间。
    数据驱动编程，最复杂的情形是为p-code或我们在第8章讨论过的那些简单微型语
言编写解释器。对于其它情形，它类似于代码生成器和状态机编程。区别其实并非那样
重要，重要的是把程序逻辑从硬编定的控制结构转移到数据中。
9.1，1实例分析：ascii
    我维护着一个口L{ ascii OtJ程序，它非常简单，把命令行参数按ASCII（ American Standard
Code for Information Interchange，美国信息交换标准编码）字符的名称解释，并报告其它
所有等价形式的名称。这个工具的代码和文档可以在项目主页<http：／/www - catb．
org/-esr/ascii>处获得。以下是直观的屏幕截图：
esr@snark: -/Www/writings/taoup$  ascii  10
ASCII l/0 is decimal 016， hex 10， octal 020， bits 00010000: called ^pr DLE Official
   name :  Data  Link  Escape
Ascii 0/10 is decimal 010， hex Oa， octal 012， bits 00001010: called ^J， LF， NL
   Official name: Line Feed
C  escape :   ' \n'
Other names :  Newline
Ascii 0/8 is decimal 008， hex 08， octal 010t bits 00001000: called ^H， BS Official
name +
    Backspace
C  escape :   I \bl
Other  names :
ASCII 0/2 is decimal 002， hex 02， oc七al 002， bits 00000010 : called ^B， STX Official
  name :   Start  of  Tex七
    表明这是个好程序的标志之～是该程序具有意想不到的用法――作为快速的CLI辅
助工具，在字节的十进制、十六进制、八进制和二进制表示法中进行转换。
    这个裎序的主要逻辑原本可以编成有128个分支的选择语句。然而，这肯定会使代
码庞大、难以维护。变化相对较快的部分（如字符的别名清单）和变化较慢或根本不变
www.pdf365.com
218
第9章生成：提升规格说明的层次
化的部分（如正式名称）原本也可纠缠在一起，都放在同一个示意字符串中。当然，这
样出现编辑错误时，更有可能改变实际上本该稳定的数据。
    相反，我们采用了数据驱动编程。所有字符名的字符串都放在一个表结构中，这个
表结构比代码中任何函数都大（事实上，按行数算的话，它比程序任意三个函数都大）。
代码仅仅查表并完成数制转换等底层任务。初始化代码实际上存放在文件nametable.h中，
我们会在本章稍后部分说明这个文件的生成方法。
    这种结构使得增加新字符名、改变现有字符名或删除旧字符名都非常容易，只要简
单编辑数据表就行，不需要改动代码。
    （这个程序编制方法具有很好的Unix风格，但是输出格式有问题。很难看出输出能
有效作为其它程序的输入，所以这个程序不能很好地和其它程序合作。）
9.1.2实例分析：统计学的垃圾邮件统计
    数据驱动编程的有趣例子是探测垃圾邮件（不请自来的大批电子邮件）的统计学习
算法。整个一大类邮件过滤程序（网络搜索很容易找到的程序包括popfile、spambayes
和bogofilter等）都使用单词相关性的数据库来代替复杂的模式匹配逻辑条件。
    2002年，随着Paul Graham友表里程碑式的论文《反垃圾邮件计划》（A Planfor Spam）
[Graham]，这样的程序迅速在互联网上普及。虽然这种爆炸式发展由模式匹配竞赛中不
断上升的成本而引发，但最早而且最快采用这种统计学过滤思路的却是Unix阵营。部分
原因当然是因为几乎所有的互联网服务提供商（他们承受垃圾邮件的负担最重，因此采
用有效新技术的动机最强烈）都在Unix阵营――但这种方法与Unix软件设计的一些传
统主题相吻合无疑也起了很大作用。
    传统的垃圾邮件过滤器要求系统管理员或其它责任方维护在垃圾邮件中发现的文本
模式信息――除了垃圾邮件，站点名、色情网站或网络诈骗常用的诱人词组以及类似内
容，别的什么也不发。在论文里，Graham精确指出，计算机程序员喜欢模式匹配过滤器，
因为这种方法给了他们很多展现聪明的机会，所以有时很难打破藩篱。
www.pdf365.com
9.1  数据驱动编程
219
    另一方面，垃圾邮件统计过滤器通过收集用户对垃圾邮件的判断反馈来工作。反馈
经过处理后，将用户区分垃圾／非垃圾邮件的词组和词语与统计相关系数或权重相关联，
存放到数据库中。最流行的算法使用了贝叶斯定律（Bayes's Theorem）的小变种，但也应用
其它技术（包括不同类型的多项式散列法）。
    在所有这些程序中，相关性检查是个相对微不足道的数学公式。代入公式的权重和
被检查的消息一起，组成过滤算法的隐式控制结构。
    传统模式匹配垃圾邮件过滤器存在的问题是它们非常脆弱。垃圾邮件发送者不断同
过滤规则的数据库进行博弈，迫使过滤器的维护者不断重编过滤器以便在这场竞赛中保
持领先。而统计学垃圾邮件过滤器却根据用户的反馈生成自己的过滤规则。
    事实上，使用统计学过滤器的经验似乎表明，所采用的具体学习算法远没有学习算
法用来计算权重的垃圾／j#垃圾邮件数据集的质量重要。因此，统计过滤器的结果与其说
由算法驱动，不如说由数据形态驱动。
    《反垃圾由仁件计划>（A Planfor Spam）仿佛是一颗炸弹，原因是作者令人信服地证
明，一个简单甚至粗糙的统计方法把非垃圾邮件归为垃圾邮件的出错率，比复杂的模式
匹配方法或入眼所能处理的出错率都要低。对Unix程序员来说，看透聪明模式匹配的诱
惑，远比其它编程文化来得容易，因为那些编程文化没有对“Keep It Simple，Stupid!，，的
强烈依恋。
9.1.3实例分析：fetchmailcon厂中的元类改动
    随fetchmail（1）-起发布的fetchmailconf（1）点文件配置器包含-个启发性例子，
演示在非常高层的、面向对象语言中实现高级数据驱动编程。
    1997年10月，在fetchmail-friends邮件列表上出现的一系列问题清楚表明，最终用
户在生成fetchmail的配置文件时越来越困难。文件使用简单而经典的Unix式自由格式
语法，但如果用户在多个站点上有POP3和IMAP帐户，则会变得非常可怕复杂。例9.1
是fetchmail作者经过稍微简化的配置文件。
UNIX编腥艺．术
  www.pdf365.com
220
第9章生成：提升规格说明的层次
例9.1  fetchmailrc语法示例
set postmaster  ”esr“
set daemon 300
poll imapccil.org with pro七o IMAP and opLions no dns
     aka  snark .七hyrsus _ com  locke _ ccil . org  ccil . org
          user esr七here is esr here
              options fetchall dropstatus warnings 3600
poll  imap . netaxs _ com  with  proto  IMAP
         user "esr" there is esr here options dropstatus warnings 3600
    fetchmailconf的设计旨在把控制文件的语法完全隐藏在时髦、符合人体工程学、到
处是选择按钮、滑动条和待填表单的GUI之后。但是beta设计存在一个问题：它可以很
容易地从用户的GUI操作生成配置文件，但却不能读取和编辑已有的配置文件。
    针对fetchmail配置文件语法的分析程序相当复杂，实际是用yacc和lex编写的，而
vacc和lex是两个经典Unix工具，用来生成语言的C分析程序。为了让fetchmailconf熊
够编辑已有配置文件，最初，似乎用fetchmailconf的实现语言-Python来重复编写复
杂的语法分析程序是必须的。
    这个策略似乎注定要失败。即使不考虑隐含的重复工作，要确保两个用不同语言编
写的语法分析程序接受同一种语法也出了名地难。随着配置语言的发展，要保持两者同
步真有可能成为维护噩梦，完全违反了我们在第4章讨论过的SPOT原则。
    这个问题一度困扰了我。打破这个羁绊的顿悟是fetchmailconf可以使用fetchmait本
身的语法分析程序作为过滤器！我给fetchmail增加了一个- - conf igdump选项，可以分
析．fet chmailrc，并把结果以Python初始化器格式转储到标准输出。对以上文件，结
果看上去大致就像例9.2（为节省空间，省略了一些与示例无关的数据）。
www.pdf365.com
9.1数据驱动编程
221
例9.2fetchmail配置的Python结构转储
fetchmailrc = {
'poll_interval ' : 300，
" logfile " :None.
"postmaster " : " esr" ，
bouncemail '  : TRUE ，
"properties " : None，
inv工sible ' : FALSE，
 ' syslog ' : FALSE，
# List of server entries begins here
servers ' :  [
   #   Entry   for   site   ' imap . ccil . org '   begins :
" pollname " : " imap . cCil . org " ，
' active ' : TRUE，
"via" :None.
" pro七ocol " : " IMAP " ，
port’：0，
' timeout ' : 300，
' dns ' : FALSE，
" aka " : [ " snark.七hyrsus . com" ， " locke . ccil . org " ， " ccil . org " ]
'users ' :  [
     {
                                        " remote " : " esr " ，
                                 J' pas sword " :  " masked_one Jr ，
                                  ' localnames ' : [ " esr " J ，
                                  ' fetchall i : TRUE，
                                 ' keep l : FALSE，
                                 ' flush ' : FALSE，
                                " mda "  : None ，
           'limit ' :0，
          'warnings ' : 3600，
#  Entry  for  site  ' imap . ne七axs _ com'   begins :
              " pollname "  : " imap . net axs _ com " ，
                 ' active ' : TRUE.
www.pdf365.com
222
第9章生成：提升规格说明的层次
"via" :None，
 " protocol " : " IMAP " ，
'port ' :0，
 ' timeout ' : 300，
 ' dns ' : TRUE，
 " aka " : None ，
 ' users ' :   [
     {
                                  " remote" : "esr" ，
                                  " password" : " masked_two " ，
           ilocalnames ' : [ "esr" ] ~
                                  ' fetchall ' : FALSE，
                                  ' keep ' : FALSE，
                                  ' flush ' : FALSE，
                                  " mda " : None ，
                                  ~ /imit F : 0，
          twarnings ' : 3600，
    主要障碍跃过了。接下来Python解释器就可以评估fetchmail -configdump的输
出，并将fetchmailconf可用的配置信息作为变量“fetchmail”的值读取。
    但这并不是比赛中的最后一个障碍。真正需要的并不仅仅是让fetchmailconf拥有现
成的配置信息，而是要把它转变为活动对象的链接树。这棵树上有三类对象：
Configuration（代表整个配置的顶层对象）、Site（代表待查询的的服务器之一）
和User（代表站点附有的用户数据）。示例文件描述了三个站点对象，每个站点对象都
附有一伞用户对象。
    这三个对象类已经存在于fetchmailconf中。每个对象类都有一个方法使它可以弹出
GUI编辑面板来修改其实例信息。剩下的最后一个问题是如何把Python初始化器的静态
数据转换成活动对象。
    我曾考虑编写胶合层，它能够明确知道这三类的结构，并以此迎合初始化器创建匹
配的对象，但是我放弃了这个想法，因为随着时间的推移，配置语言会增加新的特性，
则也可能增加新的类成员。如果对象的创建代码用显式的方法编写而成，那么它会再次
www.pdf365.com
9.1数据驱动编程
223
变得非常脆弱，当类定义或- - configdump报表生成程序转储的初始化器结构变化时，
它往往不能同步。这又是一个带来无穷bug的方法。
更好的方法应该是数据驱动编程――可以分析初始化器形态和成员、自查询类定义
自身成员，然后阻抗匹配这两个集合的代码。
Lisp和Java程序员称之为内省；其它一些面向对象的语言称之为“元类修改（metaclass
hacking）”，通常视其为非常可怕的深奥邪招。绝大多数面向对象语言根本不支持：在那
些提供支持的语言（包括Perl和Java）中，它往往是一项复杂而脆弱的工作。但是Python
对内省和元类修改的功能却异乎寻常地容易用。
解决方法的代码可参考例9.3，从1.43版本第1895行附近开始。
例9.3  copy_instance的元类代码
def  copy_instance （ t oclass，   fromdict） :
# Make a class object of given type from a conformant dictionary.
     class_sig  =  toclass._dict  -- keys （ ） ;   class_sig . sor七 （ ）
     dic七_keys  =  fromdict . keys （ ） ;   dicL_keys . sort （ ）
      common= set_intersection（class_sig， dict_keys）
      if 'typemap' in class_sig:
          class_sig . remove （ ' typemap ' ）
     if  tuple （class_sig）   ! =  tuple （dict_keys） :
         print "Conformabili七y error"
#     print "Class signature: " + 'class_sig'
#     print "Dictionary keys: " + 'dict_keys'
         print "Not matched in class signa七ure: "+ \
                                                                                                    ' set_diff （class_sig，  common） r
          print "No七 matched in dic七ionary keys: "+ \
                                                                                                    ' set_diff （dict_keys ，   common） ~
              sys .exit （1）
      else :
           for x in dic七_keys:
                 setat七r （toclass，  x，   fromdict [x] ）
检查
的核
def
这份代码的绝大部分是对类成员和- - configdump报表生成不同步可能性的错误
。它
心是
确保如果代碣失败，失败会尽早得到发现――此即补救原则的实现。这个函数
最后两行，根据字典中的相应成员设置类中的属性，它们等价于：
copy_instance （ toclass ，   fromdict ） :
    for x in  fromdict.keys （） :
               setat七r （toclass，  x，  fromdict [x]
www.pdf365.com
224
第9章生成：提升规格说明的层次
如果代码这样简单，当然更可能正确。调用该函数的代码参见例9.4。
例 9.4   copy_instance的调用环境
      # The tricky part - initializing objeicts from the 'configuration
      # global.  'Configurationr is the top level of the object tree
      # werre going to mung
     ConfiguraLion  =  Controls （ ）
     copy_instance （ Conf iguration，   configuration）
    Configuration _ servers  =   [ ] ;
     for  server  in  configuraLion [ ' servers ' } :
           Newsite  =  Server （ ）
          copy_instance （Newsite，  server}
           Conf iguration _ servers . append （Newsite）
          Newsite.users  =  [ ] ;
           for  user  in  server [ ' users ' ] :
               Newuser  =  User （ ）
              copy_instance （ Newuser ，   user）
               Newsite . users . append （Newuser }
    以这段代码中提取的关键点在于，它遍历了初始化器的三个层次（配置／服务器／用
户），实例化了各层的正确对象并放进更高一层对象所包含的链表中。因为
copy_instance是数据驱动的而且完全通用，所以它可用于所有三个层次中三个不同
的对象类型。
    这是一个新派的例子；Python直到1990年才发明出来，但是它反映了可追溯到1969
年的Unix传统主题。  如果对上一代人身体力行的Unix编程进行的思考没有教会我建
设性的懒惰――坚持复用、遵循SPOT原则拒绝编写重复的胶合代码――我可能会匆忙
编写一个Python分析程序。fetchmail本身就可编写进fetchmailconf配置分析程序的第一
个领悟就可能永远不会产生。
    第二个领悟（copy_instance可以是通用的）来自于Unix孜孜不倦地寻找避免手
工编码的方法这一传统。但更特殊的是，Unix程序员非常习惯于编写解析器规格说明来
生成分析程序，用于处理类似语言的标记；这样一来，它就是个捷径，可以认为所剩工
作由配置结构某种通用的树遍历就可以完成。这就需要数据驱动编程有两个独立阶段，
～个构建在另外一个之上，以干净地觯决设计问题。
    像这样的领悟可能特别强大有效。我们刚才分析的代码大概在90分钟内完成，首次
运行的时候就成功了，而且从那以后一直都很稳定（唯一的一次崩溃是发生真正版本不
兼容时抛出了异常）。它少于40行，非常漂亮得简单。没有哪种通过完整构建另一个分
www.pdf365.com
9.2专用代码的生成
225
析程序的天真方法能够产生这样的可维护性、可靠性或紧凑性。重用、简化、归纳、正
交：这就是在运转的Unix之禅。
    我们将在第10章分析fetchmail的运行控制语法，这是一例标准的运行控制文件的
类shell标准元格式。在第14章，我们会以fetchmailconf为例，说明Python快速构建GUI
的优势。
9.2专用代码的生成
    Unix有一些强大的专用代码生成器，用于建造词法分析器（记号化器）和语法分析
器等目的，我们将在第15章予以分析。但是还有～些简单而且轻巧得多的代码生成方式，
我们无需了解任何编译理论或编写（容易出错的）程序逻辑就可以使生活更轻松。
    以下几个简单的分析实例可以证明这一点：
9.2.1  实例分析：生成ascii显示的代码
    如果不带参数调用，ascif生成如例9.5所示的用法屏幕（usage screen）。
    这个屏幕仔细地设计成23行79列，这样可以放进24x80的终端窗口。
    这张表也可在运行时现场生成。做出十进制和十六进制两栏内容十分简单。但是，
丛表格如何分行，到何时打印NUL之类的助记符而不是原样照印，存在很多奇奇怪怪的
边角情况，使代码明显变得别扭不舒服。仳外，表格的列间隔必须是不均匀的才能适应
79列。但任何Unix程序员在明白这些前，都会条件反射般地把它表示成一个数据块。
    生成这个用法屏幕最原始的方法就是在asc11．c源码中把每一行都放到一个C初
始化器中，然后代码通过初始化器写出所有行。这种方法的问题是C初始化器格式中中
的额外数据（换行、串引号和逗号）可能会使一行超过79个字符，折行使得让代码的显
示和输出的显示要对应起来困难重重。这反过来也会使显示难以编辑，我在对其修改以
适合24×80的屏幕时可真是伤透了脑筋。
    更加复杂的方法是使用ANSIC预处理器的字符串粘合行为，但也会产生类似问题。
本质上，任何内嵌用法屏幕的方法显然都会陷入行首或行尾没有足够空间容纳标点的困
UNIX编程艺：术
  www.pdf365.com
226
第9章生成：提升规格说明的层次
例9.5 ascu用法屏幕
Usage :   ascii   [-dxohv ]    [ -t]    [char-alias. . . ]
     -t = one-line output  -d = Decimal  七able  -o = octal Lable  -x = hex七able
    -h = This help screen -v = version information
Prints all aliases of an ASC工工 character. Args may be charsr C Vescapes，
English names， ^-escapes， ASCII mnemonics， or numerics in decimal/octal/hex.
Dec Hex
   0 00 NUL
   1 01 SOH
   2 02 STX
   3 03 ETX
   4 04 EOT
   5 05 ENQ
   6 06 ACK
   7 07 BEL
   8 08 BS
   9 09 HT
 10 0A LF
 11 0B VT
 12 0C FF
 13 0D CR
 14 0E SO
Dec Hex
  16 10 DLE
  17 11 DC1
  18 12 DC2
  19 13 DC3
 20 14 DC4
 21 15 NAK
 22 16 SYN
 23 17 ETB
 24 18 CAN
 25 19 EM
 26 1A SUB
 27 1B ESC
 28 1C FS
 29 1D GS
 30 IE RS
Dec Hex
   32 20
  33 21
  34 22  "
  35 23 #
  36 24 $
   37 25 %
  38 26 &
  :39 27 1
  40 28 （
 41 29 ）
  42 2A :N
  43 2B +
  44 2C ，
  45 2D -
  46 2E .
Dec Hex  Dec Hex  Dec Hex
 48 30 0  64 40 @  80 50 P
  49 31 1  65 41 A  81 51 Q
  50 32 2  66 42 8  82 52 R
  51 33 3  67 43 C  83 53 S
  52 34 4  68 44 D  84 54 T
  53 35 5  69 45 E  85 55 U
  54 36 6  70 46 F  86 56 V
  55 37 7  71 47 G  87 f）7 W
 56 38 8  72 48 H  88 58 X
 57 39 9  73 49 i  89 59 Y
  58 3A :  74 4A J  90 5A Z
  59 3B ;  75 4B K 91 5B [
 60 3C<  76 4C L  92 5C \
 61 3D =  77 4D M 93 5D J
 62 3E >  78 4E N  94 5E ^
Dec Hex
 96 60 '
  97 61 a
  98 62 b
  99 63 c
100 64 d
101 65 e
102 66 f
103 67 g
104 68 h
105 69 i
106 6A j
107 6B k
108 6C l
109 6D m
110 6E n
Dec Hex
112 70 p
 113 71 q
 114 72 r
 115 73 s
 116 74  t
 117 75 u
 118 76 v
 119 77 w
120 78 x
121 79 y
 122 7A z
 123 7B {
124 7C I
125 7D }
126 7E -
  is OF SI    31 IF US    47 2F，  63 3F  ?  79 4F 0  95 SF    111 6F.  127 7F DEL
    __-________________0-.P。一
    --_______________________一
    _____-________________0^_一
境2。而在运行时把表格从文件拷贝到屏幕上似乎是个糟糕脆弱的权宜之计；毕竟，文件
有可能丢失。
    以下是解决方案。发布的源码包含一个文件，这个文件包括完全同上面一致并命名
为splashscreen的使用屏幕。C源码包含以下函数：
void
showHelp （FILE  *ou七，  char  *progname）
  fprin七f （out， "Usage:  %s  [-clxohv]   [-t]   Ichar-alias. . . ] \n" ，  progname）
#include "splashscreen.h"
exit （0）；
    ______-________________0_一
2脚本语言对这个问题的解决通常比c更优雅。请研究一下shell的here document和Python的三引
号（字符串）构造来探个究竟。
www.pdf365.com
9.2专用代码的生成
227
而splashsrceen．h由makefile生成：
splashscreen .h :   splashscreen
          sed <splashscreen >splashscreen.h \
                -e   ' s/\\/\\\\/g '   -e  ' S/"/\\"/'   _e  r S/ . t/pu七s { u&"） ;/
    因此，程序编译时，splashscreen文件自动被揉制成一系列输出函数调用，然后
由C预处理器包含到正确的函数中。
    通过从数据产生代码，我们能够使可编辑的用法屏幕和它的显示一致。这提高了透
明性。而且，我们根本无需改动C代码就能随意修改用法屏幕，而该做的事情会在下一
次编译时自动完成。下～版建构就可以自动完成正确的操作。
    出于同样的原因，掌控同名字符串的初始化器也由makefile中的sed脚本产生，
makefile来自ascl源码中nametable文件。绝大多数nametable都只是简单地拷贝
进C初始化器。但生成过程使这个工具很容易适应其他8位字符集，如IS0-8859系列
（Latin-I及其友集）。
    这几乎是一个微不足道的例子，但是它仍然证明了即使非常简单专用的代码生成所
具有的优点。类似技术可以应用到吏大的程序中，相应地获得更大的好处。
9.2.2实例分析：为列表生成HTML代码
    假设要在网页上生成一页表格状数据，我们希望开头几行像例9.6 -样。
    ―――_―――――一-――――――-―――――――---――――-―――――――-___________-______________一
    ___--.....___.’-__--一
例9.6明星列表要求的输出格式
Aalat    David Weber    The Armageddon Inheritance
 Aelmos    Alan Dean Fostar    The Man who Used the Universe
 Aedryr    Steve Miller/Sharon Lee    Scout.s  Progress
 Aergistal    Gerard Klein    The Overlords of War
 Afdiar    L.  Neil Smith    Toni Paine Maru
 Agandar    Donald Kingsbury    Psychohistorical Crisis
 Aghirnamirr    Jo   Clay七on    Shadowkill
    .-_._._.._._.___.__-_____一
    笨重的处理方法是手工编写HTML表格代码以获得预期的显示效果。之盾，每需要
增加一个名字时，我们就得为新条目手写另外一套<tr>和<td>标签。这项工作很快就
会变得异常乏味。更糟的是，要改变列表的格式需要手工修改每一条记录。
UNI×4iria~Yae
    www.pdf365.com
228
第9章生成：提升规格说明的层次
    一种看上去聪明的处理方法是把这些数据做成三栏关系放在数据库中，然后使用一
些流行的CGI3技术或PHP等具有数据库能力的模版引擎来现场生成页面。但假设我们
知道列表不会经常改变，既不想仅仅为能显示这个列表而运行数据库服务器，也不想给
服务器带来不必要的CGI流量负担，情况又会怎样？3
    还有更好的解决方案，我们可以把数据放入类似例9.7的列表式平面文件格式中。
例9.7  明星表的主表
Aalat
Aelmos
Aedryr
Aergis七al
Afdiar
Agandar
Aghirnamirr
: David  Weber                        : The  Armageddon  Inheritance
:Alan Dean Foster        :The Man who Used the Universe
: Steve  Miller/Sharon  Lee   :Scout ' s  Progress
:Gerard Klein            :The Overlords of b/ar
:L. Neil Smith           :Tom Paine Maru
: Donald  Kingsbury               : Psychohis七orical  Crisis
  : Jo  Clay七on                           : Shadowkill
    我们可以使用没有冒号字段分隔符酌格式，而使用两个或更多空格作为分隔的特征
符，但是显式分隔符可以防止我们编辑某个字段值时键入两个空格而没有发觉。
    然后我们用shell、Perl、Python或Tcl编写脚本，可以把这个文件揉制成HTML表
格，每次增加新记录时就运行一次。旧派Unix的方法是以如下几乎不可读的sed（1）调
用为核心。
  sed―e  's，^，<tr><td>，’  一e  's，$，<／td><／tr>，．  一e  .s，：，<／td><td>，g.
    或者是下面这个也许稍微易读一点的awk （l）程序：
awk   -F:    l {print f （ "<tr><td>%s</td><td>%s</td><td>%s</td></tr>\n" ，    \
    （这两个例子很有趣，但如果对任何一个有所迷惑，请阅读sed （1）或awk （1）的
文档。我们在第8章说过后者现在已经不太用了。前者仍然是重要的Unix工具，我们没
3这里的CGI不是指计算机图形成像，而是指实时显示网页内容所用的公共网关接口（Common
Gateway Interface）。
www.pdf365.com
9.2专用代码的生成
229
有仔细分析的原因是：  （l） Unix程序员已经很了解这个工具；  （2） -旦非Unix程序
员掌握了管道和重定向等基本概念，就很容易从手册中掌握相关知识）。
    新学派的解决方案可能集中在以下这个Python代码或等价的Perl代码：
for  row  in  map （lambda  x:x. rstrip （ } . split （ l : I ） ， sys . stdin. readlines （》
    print   "<七r>    d）"   +   " </七d><td>iT _ j oin （ row）   +   "</td></七r> "
    这些脚本程序每个只花五分钟左右就可以编写和调试完成，当然比手工修改初始的
HTML或创建及验证数据库所需要的时间短。维护这种表格加代码的方式，比起设计差
劲的手工修改HTML方式或过度设计的数据库方式来说，要简单得多。
    这种解决问题方法的深层优点在于主文件很容易用普通的文本编辑器搜索和修改。
另外一个优点是我们可以通过改动生成脚本，不断尝试表格到HTML的不同转换方式，
或者在此之前放置grep （1）过滤器就可以很方便地生成报告子集。
    我确实使用这种技法来维护列出fetchmail测试站点的网页。以上所举例子的数据是
虚构的，原因无外乎友布真正的数据可能会泄漏帐号的用户名和口令。
    与前面一个例子相比，这个例子就不是那么微不足道了。我们在这儿的设计实际
上是把内容和格式分开，把生成脚本用作样式表（这也是另外一种机制和策略的分
离）。
    所有这些例子的借鉴之处都是一样的：尽可能少干活；让数据塑造代码；依靠工具；
把机制从策略中分离。专家级Unix程序员要学会迅速自动地看出这些可能性。建设性的
懒惰是大师级程序员的基本美德之一。
www.pdf365.com
www.pdf365.com
1 0
配置：迈出正否的§一步
Configuration: Starting on the
Right Foot
Let us watch well our beginnings， and results will manage themselves.
    积跬步，致千里。
    -Alexander Clark
    Unix的程序和周边环境交流的方式多种多样。可以很方便地把这些方式分成（a）
启动环境查询和（b）交互通道。本章我们主要讨论启动环境查询。下一章将讨论交互通
道。
10.1  什么应是可配置的
的？
在具体讨论不同种类的程序配置之前，我们先问一个高层面问题：什么应是可配置
    无畏的Unix回答是“一切’’。我们在第1章讨论的分离原则鼓励Unix程序员：只
要可能，就建立机制而把策略决定权交给用户。这种方式产生的程序往往功能强大，专
家用户用起来会非常顺手；但它所产生的接口往往选项过多，并且配置文件像杂草一样
疯长，从而彻底打击了新手和一般用户。
www.pdf365.com
232
第10章配置：迈出正确的第一步
    Unix程序员并不打算修改这种为同行和最老练用户设计的倾向（我们将在第20章
讨论这样的改变是否真的值得）。所以，也许把问题反过来，问问“什么不应该可配置？”
更加有用。Unix实践的确在这方面提供了一些指导。
    首先，对于能够可靠地进行自动检测的东西，就不要提供配置开关。这是个常犯的
错误。相反，尽量用自动检测来减少配置开关的数量，或者在运行时不断尝试其它方法
直到成功。如果觉得这个方法不够优雅或太昂贵，问问自己是不是掉进了过早优化的陷
阱。
    我所经历的最好的自动检测例子之一，发生在Dennis Ritchie和我把Unix移
植到Interdata 8/32时。这是一台高位优先的机器，我们盛须在PDP-II上为这台
机器生成数据，写入磁带，然后在Interdata上载入这个磁带。普遍的一个错误是
忘记转换字节顺序；一旦出现校验和错误我们就必须卸载，然后重新装配在PDP
- 11机器上、重新生成数据、卸载然后再重装。后来，有一天，Dennis修改了
Interdata读取磁带的程序，这样，一旦它收到一个校验和错误，就倒带、启用“字
节交换”并重新读取。第二次遇到校验和错误时停止装栽，但是99%的情况下它
都正好能读取磁带并正确完成任务。生产率迅速上升，从那时起我们几乎忽略了
磁带字节顺序的问题。
-Steve Johnson
    ～个很好的经验法则是：提高适应能力，除非这样做会产生超过0.7秒的延迟。0.7
秒是～个魔数，因为，正如Jef Raskin设计Canon Cat计算机时的发现，人们几乎觉察不
到少于0.7秒的启动延时；人们还没有来得及转移注意力，它就消失了。
    其次，用户不应该看到优化开关。让程序经济运行是设计者的任务，不是用户的任
务。与提高界面复杂度成本相比，让用户从优化开关来获取的那点儿性能收益，换来界
面复杂度的提升，往往得不偿失。
    Unix幸运地避开了文件格式的废料（记录长度、块因子等），但是同样性质
的东西在过度配置中又叫嚣着回来了。KISS原则变成了MICAHI原则：make it
complicated and hide ic（搞复杂后藏起来）。
    -Doug Mclfroy
    最后，能用脚本包装器或简单管道实现的任务，就不要用配置开关实现。能简单利
用其它程序来完成的任务，就不要增加本程序的复杂度。  （回想一下我们在第7章有关
Is （1）为什么不内建一个分页程序或是增加一个调用选项的讨论），
www.pdf365.com
10.2配置在哪里
233
无论何时想增加配置选项，请考虑以下这些较普遍的问题：
    ●  能省掉这个功能吗？为什么在加厚手册之外还要加重用户负担？
    ●  能否用某种无伤大雅的方式改变程序的常规行为从而无需这个选项？
    ●  这个选项是否花哨没用？是否应该少考虑用户界面的可配置性而多考虑正确
    性？
    ●  这个选项附加的行为是否应该用一个独立的程序来代替？
    增加不必要的选项会产生诸多不良后果。其中最不易察觉但最严重的后果是对测试
覆盖率的影响。
    除非做得非常仔细，否则增加一个开／关配置选项就会使测试量加倍。既然
  在实践中从来没有人完成双倍测试量，那么实际影响就是减少了特定配置获得
  的测试量。增加十个选项会产生1024倍测试量，所以不要多久就要讨论可靠性
  问题了。
10.2配置在哪里
-Steve Johnson
传统上，一个Unix程序可以在启动环境的五个地方寻找控制信息：
●  ／etc下的运行控制文件（或者系统中其它固有位置）。
●  由系统设置的环境变量。
●  用户主目录中的运行控制文件（或“点文件”）。  （如果不熟悉，请参考第3
    章对这个重要概念的讨论。）
●  由用户设置的环境变量。
●  启动程序的命令行所传递的开关和参数。
www.pdf365.com
第1 0章配置：迈出正确的第一步
    查询通常按以上所列的顺序进行。这样，后面（较局部）的设置会覆盖前面（较全
局）的设置。前面找到的设置可以帮助程序计算出配置数据的后续检索位置。
    当考虑使用何种机制向程序传递配置数据时，要牢记：好的Unix实践要求使用同参
数选项预期寿命虽匹配的机制。因此，对调用时可能发生变化的选项，使用命令行开关。
对改动很少但确实应该由各个用户控制的选项，使用用户主目录的运行控制文件。对需
要由系统管理员设置而不是由用户改变的整个系统级选项数据，使用整个系统里的运行
控制文件。
    我们会逐一详细讨论以上设置所在，然后再分析～些实例。
10.3运行控制文件
    运行控制文件存放与程序相关的声明或命令，在程序启动时解析。如果所有用户都
在一处共享程序的系统级配置，则通常在／etc目录下有一个运行控制文件。（有些Unix
用/etc/conf子目录来集中存放此类数据。）
    用户专有的配置信息通常存放在用户主目录下一个隐藏的运行控制文件中。此类文
件通常叫做“点文件’’，这是因为它们利用了Unix目录列表工具通常不显示点开头文件
名的约定。1
    程序也可以拥有运行控制目录或点目录。每个目录包含了数个与程序相关的配置丈
件，但最好还是将这些配置文件分别对待（也许是因为它们与程序不同的子系统相关，
或者是语法各有不同）。
    文件或者目录约定俗成的命名方式是：运行控制文件信息的位置和与读取该信息的
可执行文件的基本文件名一致。某些系统程序中仍然通行较老的约定：使用可执行文件
名后加“rc"后缀代表“运行摔制’’2。这样，如果编写一个既有系统级配置又有用户级
配置，名为“seekstuff”的程序，有经验的Unix用户就会试图在／etc／seekstuf f找
到前者，在用户主目录下的．seekstuff找到后者；当然，如果此两者位于
1要显示点文件，使用Is （l）的-a选项。
2“rc’’后缀可追溯到Unix的祖父CTSS. CTSS有一个叫做“runcom”的命令脚本功能。早期的Unix
使用“rc”作为操作系统引导脚本名字，以此纪念CTSS的runcom。
www.pdf365.com
10.3运行控制文件
235
/etc/seekstuffrc和．seekstuffrc也并不稀奇，特别是当seekstuff是一个系统
实用程序时。
    我们在第5章描述了稍有区别的一套针对文本化数据文件格式的设计准则，并讨论
了如何根据互用性、透明性和处理经济性进行不同的取舍以臻最优。运行控制文件通常
只在程序启动时读取一次而且不需要写入；因此经济性通常不是主要考虑的问题。互用
性和透明性两者都要求我们采用文本格式设计，以便能够让人阅读并且可以用常规的文
本编辑器修改。
    尽管运行控制文件的语意是完全独立于程序的，但是人们仍然广泛遵循一些有关运
行控制语法的设计规定。我们会在下文说明；但首先我们要描述一个非常重要的例外。
    如果程序是某种语言的解释器，那么人们就期望运行控制文件只是以该语言语法写
成的并在启动时执行的命令文件。这是一条重要原则，因为Unix传统强烈提倡各种类型
的程序都作为专门语言和微型语言来设计。此种类型点文件的著名例子包括各种Unix命
令的shell和Emacs可编程编辑器。
    （采用这条设计原则的理由之一是对“特殊情况是坏消息”的坚信――这样，任何
改变语言行为的转换开关都应该从语言内部进行设置。知果作为语言的设计者发现不能
用语言本身表达所有的启动设置，Unix程序员就会认定存在设计问题――应该修改，而
不是设计一个特殊的运行控制语法）。
    抛开这种例外，这里给出针对运行控制语法的～些通用的风格规定。从历史角度来
看，它们都效法Unix shell的语法：
    1．支持说明性注释，并以“样”开始。语法也应该忽略“样”前的空白符，这样注释
和配置命令才可以写在同一行。
    2．不要区别隐匿的空白符。也就是说，在语法上把一连串的空格和制表符都视为一
个单独的空格。如果命令格式面向行，忽略跨行的空格和制表符就是一个很好的做法。
总的规则就是，文件的解释不应该被人眼不能分辨的区别所干扰。
    3．把多个空行和注释行视为单个空行。如果输入格式使用空行作为记录的分隔符，
可能必须确保注释行不会结束当前记录。
UNI×编程艺：术
  www.pdf365.com
236
第1 0章配置：迈出正确的第一步
    4．词法上把文件视作简单的用空白分隔的标记序列，或多行标记。复杂的词法规则
不仅难以学习、记忆而且难以分析。应该避免如此。
    5．但是，支持以字符串语法对待内嵌空白符的标记。使用单引号或是双引号作为对
称的分隔符。如果两者都支持，如果它们语意不同（如在shell中），务必留心；众所周知，
这是混淆之源。
    6．支持反斜杠语法以在字符串中嵌入不可打印字符和特殊字符。标准做法是C编译
器支持的反斜杠转义语法。这样～来，举例来说，如果字符串“a\tb”不被解析成字符
“a"接制表符再接字符“b"，就很别扭了。
    另一方面，shell语法的某些部分不应该被运行控制语法所效仿――至少没有充分、
具体的理由，就不能这样做。shell中怪异复杂的引用和括号规定，以及通配符和变量替
换的特殊元字符均在此列。
    要重申这些约定的关键是，对于用户从未见过的程序，要减少阅读和编辑运行控制
文件所必须应对的新鲜事物。因此，如果必须打破这些约定，首先确切地告知你已经这
么做了，特别留心地做好语法文档，然后（最重要的是）设计语法，人们可以通过例子
很容易地掌握语法。
    这些标准风格规定仅仅描述了记号化（tokenizing）祁注释的约定。运行控制文件的命
名、高级语法和语法的语义解释通常和应用程序有关。当然，也存在少数几个例外：其
中之一就是点文件，从点文件通常都包含一整类应用程序使用的信息这个意义上讲，点
文件已经变得“众所周知”了。用这种方式共享运行控制格式文件减少了用户必须应付
的新鲜事物量。
    其中可能最好的应用就是．netrc文件。如果．netrc文件存在的话，必须为用户
记录主机／口令（hosUpassword）对的互联网客户端程序通常就可以从中获得该信息。
10.3.1  实例分析：．netrc文件
    在实际使用的各种标准规定中，．netrc文件是一个很好的例子。使用变化口令保
护无辜者，见例10.1。
www.pdf365.com
10.3运行控制文件
237
例10.1  ．netrc例子
# FTP access to my web host
machine  unixl . notaxs . com
            login esr
           password joesatriani
# My main mailserver at Netaxs
machine   imap .netaxs . com
            login esr
           password jeffbeck
# Auxiliary IMAP maildrop at CCIL
machine  imap . ccil . org
     login esr
     password marcbonilla
# Auxiliary POP maildrop at CCIL
macbine  pop3 _ ccil .org
      login esr
     password ericjobnson
# Shell accoun七 at CCIL
machine  locke ccil.org
       login esr
     password stevemorse
注意，臣口使此前从未见过这份文件的用户也能够读懂这个格式。它是一组主tru登录
／口令的三元组，每个三元组都描述了远程主机上的一个帐户。这种透明性非常重要
事实上比快速解析的时间经济性或更紧凑、更秘密文件格式的空间经济性重要得多。无
需阅读乎册，只需使用惯常的老式编辑器就能够阅读和修改，它节约了极具价值资源
人的时间。
同时注意，这个格式用于为多个服务提供信息――这是个优势，因为它意味着敏感
的口令信息只需存储在～个地方。．netrc文件是为最初Unix的FrP客户端程序设计
的。所有的FTP客户端都使用它，能理解它的还有部分telnet客户端、smbclient（1）命
令行工具和fetchmait程序。如果正在编写一个必须通过远程登录进行口令验证的互联网
客户端，最小立异原则就要求默认使用．netrc的内容。
www.pdf365.com
238
第1 0章配置：迈出正确的第一步
10.3.2到其它操作系统的可移植性
    系统范围的运行控制文件是一种设计策略，几乎可用于任何操作系统，但是点文件
却很难映射到非Unix环境中。大多数非Unix操作系统所缺少的关键内容是真正的多用
户能力和用户级主目录这些概念。举例来说，DOS和Windows ME以下的版本（包括
Windows 95和Windows 98）都完全没有这种概念；所有的配置信息都必须存放在固定位
置的系统级运行控制文件，即Windows注册表中，或存放在和程序运行目录一致的配置
文件中。Windows NT已经有了一些用户级主目录的概念（这概念也带入了Windows 2000
和Windows XP），但是没有很好地得到系统工具的支持。
10.4环境变量
    当Unix程序启动时，它可访问的环境包括一组名字和值的关联（名字和值都是字符
串）。有些由用户手动设置，有些由系统在登录时设置，或由shell和终端仿真器（如果
正在运行‘个终端仿真器的话）设嚣。在Unix下，环境变量往往携带文件搜索路径、系
统默认值、当前用户ID和进程号等信息，以及其它有关程序运行时环境的关键信息。在
shell提示符下，键入“set"后回车将列出所有当前定义的shell变量。
    在C和C++中，这些值都可以由库函数getenv （3）查询。Perl和Python在启动时
会初始化环境变量字典对象。其它语言通常都采用以上两种方式之一。
10.4.1  系统环境变量
    有些环境变量众所周知，可以期望在程序从Unix shell下启动时就能够找到定义。这
些环境变量（特别是HOME）经常需要在读取本地点文件前就已被赋值。
    USER
当前对话登录的帐号名（BSD约定）。
当前对话登录的帐号名（System V约定）。
www.pdf365.com
10.4环境变量
239
HOME
用户运行当前对话的主目录。
COLUMNS
控制终端和终端仿真器窗口以字符为单元的列数。
L工NES
控制终端和终端仿真器窗口的以字符为单元的行数。
SHELL
用户命令shell的名字（通常由shellout命令使用）。
    PATH
    shell寻找匹配名字的可执行命令时搜索的目录列表。
    TERM
    对话控制台或终端仿真器窗口的终端类型名称（背景知识参阅第6章terminfo的实
例分析）。TERM之所以特别，是因为通过网络创建远程对话的程序（如telnet和ssh）
期望能够经过它，并在远程对话中进行设置。
    （以上所列只是代表性的环境变量，难免挂一漏万。）
    HOME变量特别重要，是因为许多程序用它来寻找调用者用户的点文件（其它程序
调用C运行库的一些函数来获取调用用户的主目录）。
    注意，当程序用shell生成以外的方法启动时，这些系统环境变量的一部分或全部都
还未设置。特别是监听TCP/IP套接字的守护进程，这些变量通常都未设置――即使设置
了，那些值也常常无意义。
    最后，注意，当一个环境变量必须包含多个值城，尤其是值域可作为某种搜索路径
解释时，使用冒号作为分隔符（以PATH变量为证）是个传统，注意，一些shell（特别
是bash和ksh）总是把环境变量中冒号分隔的字段解释为文件名，这就特别意味着这
些shell把字段中的一扩展成用户主目录。
UNIXS譬艺术
  www.pdf365.com
240
第1 0章配置：迈出正确的第一步
10.4.2用户环境变量
    尽管应用程序可以在系统定义的范围外自由解释环境变量，但是这样做在今天实际
上已颇为少见。环境变量值并不真正适合把结构化信息传递到程序中（虽然原则上可通
过解析变量值达到目的）。相反，现代的Unix应用程序倾向于使用运行控制文件和点文
件。
然而，在一些设计模式中，用户定义环境变量仍有用武之地：
    必须由大量不同程序共享、独立于应用程序的优先选项。这套“标准”集的变化非
常缓慢，因为很多不同的程序在这些选项真正有用之前都必须逐个进行识别3。以下是一
些标准变量：
ED工TOR
用户首选的编辑器名称（通常由shellout命令使用）。4
MA工LER
用户首选的邮件用户代理的名称（通常由shellout命令使用）。
日疆西羽
用户浏览纯文本的首选程序名称。
田哥配乐耵碉
    用户浏览网页URL的首选程序名称。直到2003年，这个变量还很新，没有得到广
泛的实现。
10.4.3何时使用环境变量
    用户和系统环境变量的共同点是，在必须复制大量应用程序运行控制文件所包含的
信息时特别麻烦，而且尤其令人讨厌的是，只要优先选项改变就必须到处去改变信息。
3没有人知道真正优雅的方法来表示遮类分散的优先设置的选项数据；环境变量可能并不是最优解，
但所有已知解都有同样棘手的问题。
4事实上，大多数Unix程序首先检查环境变量VISUAL，只有在这个值没有设置时才参考EDITOR。
这是人们可以选择面向行或可视化编辑器那个时代的历史遗留痕迹。
www.pdf365.com
10.4环境变量
241
通常，用户在其shell对话启动文件里设置这些变量。
    变量值根据共享点文件或父进程需要向多个子进程传递信息的上下文环境的不同而
变化。有些启动信息希望能根据调用用户共享运行控制文件和点文件的不同上下文环境
而不同。举一个系统级的例子来说，考虑一下通过X桌面终端仿真器窗口而开启的几个
shell对话。它们都会查询同样的点文件，但可能有不同的COLUMNS、LINES和TERM
变量值。  （旧派的shell编程广泛使用这个方法；makefile至今仍然使用这种机制。）
    变量值随点文件不同而频繁改变，但每次启动都不变化。一个用户定义的环境变量
可能（举例来讲）会用于传递文件系统或Intemet位置，以作为程序将操作的文件树的根
节点。例如，CVS版本控制系统就是这样解析CVSROOT的。又如，从使用NNTP协议
的服务器中获取新闻的阅读客户端程序把NNTPSERVER环境变量解释为待查询的服务
器位置。
    进程唯一的覆盖必须以不要求改变命令行调用的方式来表述。不管出于何种理由，
如果不便于改动应用程序的点文件或提供命令行选项（也许希望这个应用程序正常地在
shell包装器或makefile中使用）．在这种情形下，用户定义的环境变量可能非常有用。
这类使用特别重要的应用环境是调试。例如，在Linux下，使用变量与ld （1）链接加载
器关联的LD―LIBRARY_PATH可以改变库加载的位置――也许为了挑选能进行缓冲区
溢出检查或性能评定（profiling）的版本。
    总的来说，当变量值经常改变，以至于每次编辑点文件很不方便，但又未必每次都
会改变（如果这样的话，总是用命令行选项设置位置也不方便），则用户定义的环境变
量是～种有效的设计方案。此类变量通常在本地的点文件之后求值，并允许覆盖已有的
设置。
    还有一个传统的Unix设计模式，我们并不建议在新程序使用。有时，用户设置的环
境变量可以作为在运行控制文件中表达程序优先选项的轻量级替代方案。例如，历史悠
久的nethaclc（1）地下城探险游戏就读取NETHACKOPTIONS环境变量作为用户优先权。
这是一个老式技巧；现代的实践通常偏向去解析．nethack或．nethackrc控制文件。
    这种老式风格的问题在于，同知道程序在用户主目录下有一个运行控制文件相比，以
这种方式来追踪优先选项信息存放的地方更加困难。环境变量可以设置在数个不同shell
运行控制支件中的任一位置-Linux中可能至少包括.profile、bash_profile
www.pdf365.com
242
第1 0章配置：迈出正确的第一步
和．bashrc。这些文件杂乱不堪，而且很不稳定，因此，随着拥有选项解析器的代码开
销越来越少，选项信息往往从环境变量中挪出到点文件中。
10.4.4到其它操作系统的可移植性
    环境变量在Unix之外的可移植性非常有限。Microsoft操作系统有一个以Unix为模
型的环境变量特性，并且和Unix -样使用PATH变量设置二进制文件查找路径，但不
支持Unix shell程序员认为理所当然应有的大多数其它类型的变量（如进程ID或当前工
作路径）。其它操作系统（包括传统的MacOS）通常都没有环境变量的对应物。
1．  命令行选项
    Unix传统提倡使用命令行开关来控制程序，这样选项可由脚本指定。这对作为管道
或过滤器的程序尤其重要。有三种约定可以区分命令行选项和普通的参数：原始的Unix
风格、GNU风格和X toolkit风格。
    在原始的Unix传统中，命令行选项是以连字符“一”开头的单个字符。后面不带参
数的模式标志选项可以组合在一起使用；例如，如果-a和-b是模式选项，-ab或-ba都
正确而且启用了两个选项。如果选项有参数的话，这些参数紧接着选项后面（是否以空
白分隔可选）。这种凤格的选项偏爱小写字符而不是大写字符。如果使用大写字符，把
它们作为小写字符的选项的特殊变种是一种很好的做法。
    原始的Unix风格从速度缓慢、以精练为美的ASR-33电传打字机上发展起来：所以
形成了这样的单字符选项。按住“shift”键也需要额外的精力，所以优先选择了小写字
符和“一”（而不是可能更合逻辑的“+"号）来启用选项。
    GNU风格使用前面有两个连字符的选项关键字（而不是关键字母）。这是在一些相
当复杂的GNU程序用完单字母选项后的几年内发展起来的（这只是一种治标不治本的方
法）o这种风格仍然非常流行，是因为GNU选项比老式的字母滥觞（alphabet soup）更
容易理解o GNU风格的选项不用空白分隔就不能组合使用。选项参数（如果有的话）既
可以用空白分隔也可以用单个“="（等号）来分隔。
www.pdf365.com
10.5命令行选项
243
    之所以GNU选择双连字符选项引导符，是因为传统的单字母选项和GNU风格的关
键字选项可以在同一命令行内混和使用而不会混淆。这样，如果原始设计的选项不多而
且很简单，就可以使用Unix风格，而不用担心以后必须转移到GNU风格时产生进退维
谷的矛盾局面（flag day）。另一方面，如果使用GUN风格，良好实践是，至少对最常
用的选项添加单字母等效选项。
    令人困惑的是，X toolkit风格使用了单连字符和关键字选项并由X toolkit进行解析。
它首先过滤并处理某些选项（如-geometry和-display）然后再把过滤后的命令行
传递给应用程序逻辑进行解析。这种风格既不能和古典的Unix风格又不能和GNU风格
很好地兼容，所以不应该在新程序中使用，除非遵循老式的X约定看起来价值很高。
    许多工具都接受一个不带任何选项字母的单个连字符，作为伪文件名，指示应用程
序从标准输入中读取数据。也习惯上把双连字符视为单连字符，作为停止解析选项的标
志，并把后面的参数都按照字面意义处理。
    大多数Unix编程语言都提供命令行程序库，以解析古典的Unix风格或GNU风格（也
解析双连字符约定）。
10.5.1  以一a到一z的命令行选项
    随着时间的推移，在一些众所周知的Unix程序中频繁使用的选项已经建立了一种松
散的语义标准，以其期望含义。以下列出一些选项及其含义，一个经验丰富的Unix用户
决不会对此感到惊讶：
-a
    所有项（all）（不带参数）。如果是GNU风格，则为-all选项，如果-a选项不是
-all选项的一个同名项的话，真的很出乎意外。示例：fuse，（1）和fetchmail（1）。
    添加（append），同在tar（1）中一样。这个命令选项和表示删除的-d选项是一对儿。
    -b
    缓冲区（buffer）大小或块（block）大小（带参数）。设置～个临界缓冲区大小，或（在
和存档或处理存储介质有关的程序中）设置块大小。示例：du （1）、df （l）和tar（1）。
    批处理（batch）。如果程序是自然交互的，-b选项可用于禁用提示或设置有其它适当
选项来接受文件的输入而不是操作员的操作。示例：flex（1）。
www.pdf365.com
244
第1 0章配置：迈出正确的第一步
    -c
    命令（带参数）。如果程序是一个通常从标准输入接收命令的解析器，那么程序期
望-c参数选项会作为单行输入传递给该程序。这个约定在shell和类似shell的解析器中
特别强烈。示例：sh（1）、ash （1）、bsh （1）、ksh （1）和python（1）。比较以下的
-e选项。
    检查（check）（不带参数）。检查命令的文件参数是否正确，但并不真正执行正常的
过程。命令文件的解释程序频繁用此作为语法检查选项。示例：getty （1）和perl （1）。
    -d
    调试（debug）（带或不带参数）。设置调试信息级别。这个用法非常普遍。
    一d偶尔具有“删除（delete）"或“目录（directory）”的含义。
    -D
    定义（define）（带参数）。在解释器、编译器或（特别是）类似宏处理器的应用程序
中给某个符号赋值。C编译器的宏预处理器对-D的用法就是如此。这和大多数Unix程
序员的关系都很密切；不要违反。
-e
    执行（execute）（带参数）。包装器程序或可作为包装器使用的程序通常允许．e对其
交付给控制权的程序进行设置。示例：xterm（1）和pert（1）。
    编辑（edit），能以只读模式或编辑模式打开某项资源的程序通常用-e规定以编辑模
式打开资源。示例：crontab（1）和SCCS版本控制系统的get （l）实用程序。
-e偶尔具有“排除（exclude）"或“表达（expression）”的含义。
-f
    文件（file）（带参数）。经常带参数使用，为需要随机访问输入或输出的程序（所以
仅通过<或>重定向还不够）指定输入文件（或者输出文件，但这种使用不太多）。经典
的例子是tar （1）：其它例子也非常多。这个选项也用于表明通常从命令行获取的参数
值应该从文件中获取；经典的例子可参见awk （1）和egrep （l）。比较后面的-o选项；
-f选项是和-o选项相对的表示输入的选项。
    强制（force）（典型情况下不带参数）。强制执行通常在某种条件下施行的操作（如
文件锁定和解锁）。这种用法不常见。
www.pdf365.com
10.5命令行选项
245
    守护进程结合这两种方法使用一￡选项，强制处理（force）非默认位置的配置文件（file）。
示例：ssh （1）、httpd（1）和很多其它守护程序。
    -h
  表头（header）（通常不带参数）。启用、禁止或修改程序生成报表的表头。示例：pr
（1）和ps （l）。
    帮助（help）。实际上，这没有人们想当然的那样普遍――因为在Unix早期历史的大
部分时期，开发者往往把在线帮助视为他们无法承受的存储开销。相反，他们编写了手
册页（这形成了我们将在第18章讨论的手册页风格）。
    -i
    初始化（initialize）（通常不带参数）。把和程序关联的关键资源或数据库设置成初值
或空值。示例：RCS中的ci （1）。
    交互（interactive）（通常不带参数）。强制那些通常不查询确认的程序查询确认。有
几个经典的例子（rm （1）和mv（1）），但这种用法并不普遍。
    一工
    包含（include）（带参数）。在应用程序将要搜索的资源中增加一个文件或目录名。这
个含义在所有要包含其它文件的Unix语言编译器中都适用。如果这个选项字母用于其它
方式，会让人感到极其意外。
-k
  保留（keep）（不带参数）。禁止莱个文件、信息或资源的常规删除操作。参见：passwd
（1）、bzip （1）和fetchmail（1）.
-k选项偶尔具有“杀死（kill）"的含义。
-l
    列表（list）（不带参数）。如果程序是某种目录或档案格式的归档器或解释／播放程序，
那么-l除要求列举项目之外的任何用法都相当突兀。示例：arc （1）、binhex（1）和
nzip （1）。  （但tar （1）和cpio （1）例外）。
    在已经是报表生成器的程序中，一l几乎始终表示“长（long）”，以启用某种长格式
来显示比默认模式更多的细节。如：如（1）和ps （l）。
    加载（load）（带参数）。如果程序是～个链接器或某种语言解析器，-l在某种意义
上始终表示加载一个程序库。一参见：gcc （1）、j77（1）和emacs（1）。
UNIX编程艺I莱
  www.pdf365.com
246
第1 0章配置：迈出正确的第一步
    登录（login）。在rlogin（1）和ssh （1）之类要求网络身份的程序中，-l表示执行方式。
    -l偶尔具有“长度（length）’’或“锁定（lock）”的含义。
    -m
    消息（message）（带参数）。带参数使用的-m选项用于日志记录或通告，其参数是消
息字符串。参见：ci （1）和cvs（1）。
    -m选项偶尔具有“邮件（mail）’’、  “模式（mode）”或“修改时间（modification-time）”
的含义。
-n
    数字（number）（带参数）。例如，在head （1）、tail（1）、nroff（1）和troff（1）
程序中使用作页码范围。通常显示DNS名字的某些网络工具用-n以显示原始IP地址。
ifconfig（1）和tcpdump（1）是原型实例。
否（not）（不带参数）。用于禁用make （1）等程序的通常行为。
    输出（output）（带参数）。当程序要求根据命令行的名字指定输出文件名或设备名时，
可以交给-o选项来完成。示例：as （1）、cc （1）和sort（1）。在带有类似编译器接口
的程序中，看到这个选项用于其它用途都将让人极其意外。支持-o逸项的程序（如gcc）
逻辑是允许把一。选项放在常规参数的前面或后面进行识别。
    -p
    端口（port）（带参数）。特别用于要求指定TCP/IP端口号的选项。示例：cvs （1）、
PostgreSQL]二具、smbclient（1）、snmpd （1）和ssh ci）.
    协议（protocol）（带参数）。示例：fetchmail（1）和snmp，zetstat（】）。
    -q
    安静（quite）（通常不带参数）。禁止正常的结果输出或诊断输出。这种用法相当普
遍。示例：ci （1）、co （l）和make （1）。也参见一s选项的“缄默”选项。
-r （also -R）（也为-R）
    递归（recurse）（不带参数）。如果一个程序作用于目录，那么这个选项可告诉程序递
归进所有子目录。在对目录作用的程序中这个选项具有其它用法非常让人意外。经典的
www.pdf365.com
10.5命令行选项
247
例子当然是cp （1）了。
    反向（reverse）（不带参数）。示例：b（1）和sort（1）。过滤器可用这个选项反向
进行其正常的转换行为（比较一d选项）。
_s
    缄默（silent）（不带参数）。禁用正常的诊断输出或结果输出（和-q选项类似；如果
两者都支持，-q表示“安静”而一s表示“绝对缄默”）。示例：csplit（1）、ex （l）
和fetchmail（1）。
    主题（subject）（带参数）。这种用法始终用于发送或处理邮件或新闻消息的命令中。
因为发送邮件的程序期望这个选项，所以支持这种用法特别重要。示例：mail （l）、elm
（1）并口，”“盯（1）。
    -s偶尔具有“大小（size）”的含义。
    -t
    标记（tag）（带参数）。命名一个位置或指定一个字符串供程序作为检索关键字使用。
在文本编辑器和浏览器中应用尤多。示例：cvs （1），、ex （1）、less （1）和vi （1）。
-u
    用户（user）（带参数）。根据名称或数字UID来指定用户。示例：crontab（1）、emacs
（1）、fetchmail（1）、fuser（1）和ps （1）.
    -v
    冗长（verbose）（带或不带爹数）。用于启用事务监控性质的、更冗长的列表或调试
输出。示例：cat （l）、cp （l）、flex （1）、tar （l）和很多其它程序。
    版本（version）（不带参数）。在标准输出上显示程序版本并退出。示例：cvs （1）、
chattr（1）、patch （1）和uucp （1）。更常见的是由-V调用。
    -V
    版本（version）（不带参数）。在标准输出上显示程序版本并退出（通常也打印编译的
配置细节）。示例：gcc （l）、flex （1）、hostname（1）和很多其它程序。把这个选项
挪做它用特别突兀。
-w
    宽度（width）（带参数）。特别用于指定输出格式的宽度。示例：faces （1）、grops
（1）、od （l）、pr （I）和shar （l）.
    警告（warning）（不带参数）。启用或禁用警告诊断。示例：fetchmail（1）、刀蹦（1）
和nsgmls（1）。
    -x
    启用调试（带或不带参数）。同一d选项类似。示例：曲（1）和““印（1）。
    UNIX编程艺术
    www.pdf365.com
248
第1 0章配置：迈出正确的第一步
    提取（extract）（带参数）。列出从存储器或工作集待提取的文件清单。示例：tar （1）
和zip （1）。
    -y
    是（yes）（不带参数）。批准启用对程序通常要求确认的潜在破坏性行为。示例：fsck
（1）和rz （1）。
-z
    启用压缩（不带参数）。存档和备份程序经常使用这个选项。示例：bzip （l）、GNU
tar （1）、zcat（1）、zip （l）和cvs （1）.
    以上例子都来自Linux工具包，但在绝大多数的现代Unix下也应该适用。
    当为程序选择命令行选项字母时，可参阅类似工具的手册页。对于和手册页中类似
的功能，尽量使用一致的选项字母。注意一些特殊的应用领域，这些应用领域对命令行
开关具有特别严格的约定，违反这些约定非常冒险――编译器、邮件程序、文本过滤器、
网络程序和X软件都是值得注意的。例如，编写邮件代理程序的人如果不把一s用作标题
选项，肯定会因为这个选择而遭到轻视。
    GNU工程在GNU编码标准中建议为一些双划线选项选用常规含义。5它也列出了一
些尽管还没成为标准但已在许多GNU程序中使用的长选项。如果使用GNU风格的选项，
并且有些需要的选项具有和标准中所列的柏类似的功能，就应尽一切办法遵循最小立异
原则并复用这些名称。
10.5.2到其它操作系统的可移植性
    要有命令行选项，首先必须有命令行。MS-DOS系列当然也有命令行，尽管在Windows
中命令行隐藏在GUI下，而且也不提倡使用；选项字符通常用“／”而不是“一”当然这只
是一个细节。传统的MacOS和其它纯GUI环境没有和命令行选项密切对应的概念。
10.6如何挑选方法
    我们依次分析了系统和用户运行控制文件、环境变量和命令行参数。注意从最不易
改变到最易改变的顺序过程。表现良好的Unix程序如果不只使用一种设置方式，就应该
5参考GNU编码标准<http：／/WWW．gnu．org/prep／standards．html>。
UNIX编程艺术
www.pdf365.com
10.6如何挑选方法
249
按照指定的顺序来考虑，允许后面的设置覆盖前面的设置，这是Unix中非常严格的约定
（存在几个特殊的例外，如指定在什么地方找到点文件的命令行选项）。
    特别是，环境变量设置通常覆盖点文件设置，但又可能被命令行选项所覆盖。良好
的实践是提供如同makfJJ中的-e命令行选项，从而可以覆盖掉环境变量的设置或运行
控制文件中的声明；这样，无论运行控制文件看起来怎样，环境变量如何设置，程序都
可用脚奉控制，从而让行为符合预期。
    考虑使用哪种方法依赖于程序在调用间隙需要保持多少持久的配置状态。设计那些
主要用于批处理模式的程序（如管道线中的生成器或过滤器），通常完全由命令行选项
来设置。这种模式的良好范例包括厶（1）、grep （1）和sort （1）。在另一个极端，有
着复杂交互行为的大程序可能完全依赖于运行控制文件和环境变量，常规使用就只涉及
很少的命令行选项或根本就不需要命令行选项。大多数X window管理器就是这种模式
的好例子。
    （Unix有能力让同一个文件具有多个名称或“链接”。启动时，每个程序都能获悉
是通过哪个文件名调用的。所以，另一个向具有多操作模式的程序通知应该以何种面貌
出现的方法．是给每个模式创建一个链接，让程序根据从哪个链接进行调用，来相应改
变自身行为。但通常认为这种技术不够清爽，因此很少使用。）
    让我们看一看从上述三个地方收集配置信息的两个程序。这对于弄明白为什么以此
种方式收集给定配置信息是非常有意义的。
10.6.1  实例分析：幻tchma『／
    fetchmail程序仅使用USER和HOME两个环境变量。这些变量由系统在预定义设置
中初始化；许多程序都使用这两个变量。
    HOME值通常用于查找．fetchmailrc点文件，该文件包含的描述配置信息语法
相当复杂，遵循以前描述的类似shell的词法规定。这是恰当的做法，因为一旦设置好，
fetchmail的配置就很少改变了。
    fetchmail没有专用的／etc/fetchmailrc或其它系统级文件。通常此类文件包含
并非针对个体用户的配置信息。fetchmail确实使用在这个范围内一个很小的属性集――
特别是本地邮件管理员名称和几个描述本地邮件传输设置（如本地SMTP监听程序的端
UN/X编程艺术
  www.pdf365.com
250
第1 0章配置：迈出正确的第一步
口号）的变量值。然而，在实践中，这些编译进来的默认值很少改变。当发生变化时，
它们往往以用户专用的方式进行修改。因此就没有必要存在一个系统级的fetchmail运行
控制文件。
    fetchmail可以从．netrc文件检索主机／登录／口令（host/login/password）三元组。
这样，它以一种最小立异的方式获得验证者信息。
    fetchmail具有～个精心设计的命令行选项集，但重复了大部分（但不是全
部）．f etchmailrc所能够表达的内容。这个选项集本来并不大，但随着时间推移，新
功能不断增加到．f etchmailrc微语言中，从而自觉或不自觉地增加相应的命令行选
项，使得这个选项集越变越大。
    支持所有这些选项的目的是，通过让用户从命令行覆盖运行控制文件的设置使
fetchmail更容易脚本化。但结果是，除了少数选项，如- fetchall和- -verbose外，
对此（脚本化）的需求非常低――而且没有人会对满足于现场创建临时运行控制文件并
用-f选项反馈给fetchmail的shellscript。
    这样，大多数命令行选项从未用到，而回顾过去，包括这些选项很可钝就是个错误：
他们膨胀了fetchmail的代码却没有完成什么有用的任务。
    如果代码膨胀是唯一的问题，那么除了几个维护者之外，没有人会在意。但
是，选项过多提高了代码错误的几率，尤其当那些很少使用的选项发生无法预料
的交互作用时。更糟的是，他们使手册变得非常臃肿，这对每个人来说都是个负
担。
    -Doug Mcllroy
    这是个教训；如果一开始仔细考虑fetchmail的使用模式并在增加功能时少用一些专
用代码的话，过度复杂也许就可以避免了。
    处理这种情况又不弄乱代码或手册的另外一个方法就是拥有一个“设置选项
变量’’  （set option variable）的选项，如sendmail的一。选项，它让人们指定一个
选项的名称和值，并给值设定该名称，就好像这样的一个设置是在配置文件中给
出的一样。一个更加强大的变种是ssh处理一。选项的做法：一。选项的参数被视
为增加到配置文件的一行信息，采用配置文件的语法。以上任何一种方法都为具
有不寻常要求的人提供了在命令行覆盖配置信息的方法，从而不需要为每一个可
能被覆盖的配置信息提供独立选项。
-Henry Spencer
www.pdf365.com
10.6如何挑选方法
251
10.6.2实例分析：XFree86服务器
    X window系统是在Unix机器上支持位图方式显示的图形引擎。通过配各位图显示
器的客户端机器运行的Unix应用程序，可以由X获得输入事件并向X发送屏幕打印请
求。令人困惑的是，X“服务器”实际上运行在客户端机器上――它们的存在是为了响
应同客户端机器显示设备交互的请求。向X服务器端发送这些请求的应用程序称为“X
客户端”，尽管它们可能在服务器机器上运行。哦不，没有办法清晰解释这个倒置的搅
来搅去的术语。
    X服务器端有一个复杂得可怕的环境接口。这并不令人惊讶，因为它们必须处理大
量非常复杂的硬件和用户选项。因此，所有X服务器端都通用的环境查询，其文档可在
X （1）和Xserver（1）手册页找到，就是一个很好的学习实例。我们在此分析的实现版
本是XFree86，是Linux和其它几个开源Unix下使用的X实现。
    在启动时，XFree86服务器端检查系统级运行控制文件；确切的路径名根据X建构
平台的不同而不同，但基名都是XF86Config。XF86Config文件的语法与上所述类shell
的语法相同。例10.2是从一个XF86Config支件中摘取的一部分。
例10.2  ×配置示例
# The 16-color VGA server
    XF86Config文件描述了主机的显示硬件（图形卡、显示器）、键盘和指示设备（鼠
标腥艮踪球／触摸板）。这些信息都适合放在系统级运行控制文件里，因为这些信息适用于
机器的所有用户。
UNI×编程艺爿e
  www.pdf365.com
                                     o
           -      o
                      C0    6
    6     ><
               r-      o
                  x   o
    4     co
                      （\l      =
          -  0
    A  i-l      -
           cD      o
           >  f-l  -   co
                    :-～
              u   al g
        t-l  e
C---
 r            o
u                      r0
252
第1 0章配置：迈出正确的第一步
    一旦X已经从运行控制文件获得了硬件配置，它就使用环境变量HOME的值在调
用用户的主目录中找到两个点文件。这两个文件是．Xdefault和.xinit rc。6
    ．Xdefaults文件指定每个用户以及每个应用程序与X相关的具体资源（这方面
的小例子包括终端仿真器的字体和前景／背景色）。然而，“X相关”这个词组指出了一
个设计问题。在一个地方收集所有的资源声明当然便于对其进行检查和编辑，但是对什
么应该在．Xde f ault文件中声明，什么应该属于针对应用的点文件始终不太清
楚。．xinitrc文件指定了在服务器端启动后应该运行的命令以初始化用户的X桌面。
这些程序几乎都包括一个窗口管理器或对话管理器。
    X服务器端有一个很大的命令行选项集。其中一些命令行选项，如-fp（字体路径）
选项，覆盖了XF86Config。有～些则是特意用来跟踪服务器端bug的，如-audit选项；
如果要使用这些选项的话，它们很可能在测试运行时频繁变化，因此不太适合包含在运
行控制文件中。一个非常重要的选项是设置服务器端显示号的选项。在同一台主机运行
的多个服务器端也许各自拥有一个唯一的显示号，但是历有实例都共享同样的一个或多
个运行控制文件；因此，显示号不能单独由这些文件得出。
10.7论打破规则
    本章所描述的约定都不是绝对的，但是违反这些约定会增加用户和未来开发者的磨
合成本。如果必须打破规则，就放手去做――但在做之前要确信自己完全知道为什么要
这样做。如果确实要打破规则，必须确保常规方法进行的尝试都非常明显地失败了，同
时保证遵循补救原则给出了正确的错误反馈。
6 .xinitrc同Windows以及其它操作系统下的启动（S￡artup）文件夹类似。
www.pdf365.com
1 1
接口：Unix环境下的用户接口设
计模式
Interfaces: User-Interface Design
Patterns in the Unix Environment
A// our knowledge has its origins zn our perceptzons.
    我们所有的知识都来源于我们的感知。
    ~Leonardo Da Vinci
一达・芬奇
    一个程序的接口就是程序同人类用户以及其它程序通讯的方法总和。在第10章中，
我们讨论了关于环境变量、命令行选项、运行控制文件和其它程序启动时接口的使用。
在这一章中，我们要解开历史的纠结，解释Unix在启动之后接口与使用者的关系（语用）。
因为用户接口代码通常会占用40%甚至更多的开发时间，所以为避免许多错误的开始和
耗时的重写，分辨出良好的设计模式就尤其重要。
    在Unix接口设计的传统中，我们会反复涉足两个主题。一是与其它程序通讯方式的
前瞻性设计；另一个是最小立异原则。
    借由互助式的组合使用，Unix程序可以发挥更大的威力；我们在第七章已经讨论了
进行这种组合的各种方式。不像其它的操作系统，在Unix下，接口设计中“其它程序’’
部分并不是一个事后追加的考虑，或者一个边角情况。楣反，这是一个核心的挑战，需
要同人类用户的接口需求进行权衡和集成。
www.pdf365.com
254    第1 1章接口：Unix环境下的用户接口设计模式
    Unix社区关于程序接口设计的许多传统也许看来既奇怪又任性――抑或更甚，在
GUI时代看来，完全是退化――特别是第一次遭遇这种传统时。但是，抛开各种瑕疵和
无规律不说，这个传统有一套内在逻辑值得去学习和理解。在Unix悠久的历史中，这种
传统聚集了许多启发式方法可以与人类用户以及其它程序进行有效通讯。它也包含一套
创造了程序间共性的约定――它为广泛的共同接口设计问题定义了“最小立异”的选择
方案。
    启动之后，程序通常通过下列来源获得输入或命令：
    ●  程序标准输入端的数据和命令。
    ●  通过IPC的输入，比如X server事件和网络消息。
    ●  已知位置的文件和设备（比如由程序传递的或计算的数据文件名）。
    程序能够以完全同样的方式发布结果（输出到标准输出）。
    有些Unix程序是图形的，有些拥有面向屏幕的字符接口，而有些使用从机械电传打
字机时代遗留的、简单生硬的文本过滤器设计。对于一个没经验的人来说，常常很难看
出为什么给定的程序使用某一风格――或者，确实的，为什么Unix支持这么多的接口风
格。
    Unix有几种竞争的接口风格。存在即是合理；它们为不同的情形而优化。通过理解
住务和接口风格之间的配合，你将要学习到如何为你的工作选择正确的风格。
11.1  最小立异原则的应用
    最小立异原则：  “少来标新立异”，是所有接口设计中的通用原则，且并非仅局限
于软件设计。这是人一心不能二用的结果（参考《The Humane Interface》【Raskin]）。接
口设计的标新立异，往往把注意力牵到了接口本身，却忽视了其所属的任务。
    因此，为了设计可用的接口，最好避免设计～个全新的接口模型。新颖其实是进入
门槛，给用户加上学习负担，所以，能少则少。相反，应该仔细考虑用户群体的经验和
www.pdf365.com
11.1  最小立异原则的应用
255
知识，应该尝试去发现那些用户已知程序同自己程序之间的功能相似性。然后效仿己知
接口的相关部分。
    最小立异原则不应被理解为在设计中号召机械的保守主义。新颖性提高了用户与接
口最初几次的交互成本，但是糟糕的设计永远使得接口令人痛苦而多余。如同在其它设
计中一样，规则并不能替代良好的品味和工程判断。仔细掂量你的折衷――而且以客户
的视角看待问题。最小立异原则的偏爱值得有意识地把持，主要因为接口设计者（像其
他程序员一样）总是不自觉地在为用户着想时聪明过头。
    最小立异原则的一个含义就是：如有可能，尽量允许用户将接口功能委派给熟悉的
程序来完成。在第7章，我们已经讨论了，如果程序要求用户编辑大量的文本，应该调
用一个文本编辑器（可由用户指定）而不是自己写一个内嵌编辑器。用户比你更清楚自
己的偏爱，让他们选择最合适的方案。
    在本书其它部分，我们提倡以共生和委派策略来提高代码的复用并降低软件复杂度。
此处的要点是，如果用户能够截获委派，并且将其导向他们自己选择的一个代理时，这
些技法就不仅仅给开发者带来实惠，也主动地增强了用户的自主权。
    更进一步：不能委派时，那就效仿。最小立异原则的目的就是为丁减少用户在使用
接口时必须学习的复杂过程。继续先前的编辑器例子，这就意味着如果必须实现一个内
嵌的编辑器，编辑命令最好是那些著名通用编辑器命令集的一个子集。（或者多个子集。
bash和ksh都允许用户在vi和Emcas编辑风格之间进行选择。）
    比如，在Unix下的Netscape和MoziIJa网页浏览器，在填写表单字段的编辑器中，
同样支持Emacs编辑器的键盘绑定方案。“Control-A”定位到行的起始处，“Control-D，，
删除后一个字符等等。这种选择对于知晓Emacs的用户很有益处，至于其他用户，当然
也不会比任意的专用命令集更糟。唯一更好的方式就是采用某个比Emacs使用更广泛的
编辑器命令集；但是在Netscape最初的使用群体中，不存在这么个东西。
    这些准则适用于许多其它的接口设计领域。比如，当用户都已经习惯在HTML网页
浏览器中查看在线帮助时，创造一种新颖文档格式的在线帮助真的是很傻。即使在设计
一个街机游戏时，也应该明智地参考以前游戏中的动作设置，允许用户使用在那些游戏
中学到的操纵杆技术，这样可以给予用户一种舒适的感觉。
UNtX编腥YaC
    www.pdf365.com
256    第1 1章接口：Unix环境下的用户接口设计模式
11.2  Unix接口设计的历史
    Unix的出现远在现代倾向图形密集型的软件接口设计之前。在1969年Unix诞生后
的十年里，在电传打字机和文本模式哑终端上的命令行接口（CLI）就是标准。多数Unix
的基本工具（比如Is （1）、cat （1）和grep （1）程序等）仍然继承了这个传统。
    1980年后，Unix逐渐支持在字符阵列终端的屏幕绘图。程序开始混合命令行和可视
接口，常用命令由特定键组合来触发，没有屏幕回显。有些早期使用这类风格的程序（用
屏幕绘图光标控制程序库实现的，称为“curses"程序：第～个使用curses的程序出现后，
则称之为“rogue式’’程序）今天仍在使用；著名的例子包括地下城探险游戏rogue（1），
vi（1）文本编辑器，以及（稍后几年出现的）邮件程序elm （l）及其现代版本mutt （1）。
    几年后，到了1980年代中期，整个计算机世界开始吸收施乐Palo Alto研究中心
（ Xerox's Palo Alto Research Center）从1970年代早期就开始研究的图形用户接口（GUI）
的开拓性工作结果。个人计算机方面，施乐PARC昀工作促成了苹果Macintosh接口并
由此产生了微软Windows设计。而Unix方面，对这些思想的适应过程经历了一条相对
复杂的道路。
    1987年左右，X window系统打败了几个早期的竞争者和原型成果，成为Unix的标
准图形接口。从那时起，这到底是好是坏一直是争论的主题；其它一些竞争对手（著名
的如Sun公司的Network Window System，即NeWS）被公认更为强大和优雅。然而，X
系统存在一个压倒性的优势，那就是开源。X代码一直由MIT的一个研究组开发，他们
更注重去探索问题空间，而不是创造商业产品，并且代码可以自由地重新分配并修改。
这就广泛地吸引了众多开发者和那些不愿意跟在单个公司闭锁产品后面的赞助商。  （当
然，这也昭示了十年后Linux操作系统爆发中的一个重要主题。）
    X的设计者很早就决定了它应该鼓励“机制，而非策略”。他们的目标是把X做得
尽可能的灵活和跨平台，而尽可能少让X程序受到观感的束缚。观感，他们认定，应该
www.pdf365.com
257
由“工具包”，即调用链接到用户程序的X服务库来处理。X的设计也支持多个窗口管
理器1，并且不得要求某个窗口管理器拥有特权或是同X太过亲密。
    这条路完全与Macintosh和Windows商业产品方向相反，这些商业产品将观感强加
进系统里以强迫执行观感策略。方法的差异确保了X拥有长期发展的优势，在接口设计
上保持了对不断涌现的人类新发明的适应性――并确保了X世界被划分成多个工具包、
丰富的视窗管理器和各种观感体验。
    自1990年代中期，X在最低端的个人Unix机器上已经普遍存在。与具备图形能力
控制台相对的Unix文本模式终端的使用，已经快速地消亡并似乎走向绝灭。相应地，
curses风格接口的使用也在消亡之中；多数本来会使用此种风格的新应用程序现在都采
用了X工具包。而Unix古老的CLI设计传统仍然相当有生命力并在许多领域同X卓有
成效地竞争着，注意到这一点十分有意义。
    一些特殊的应用领域，curses风格（或是“rogue式”）字符阵列接口仍1日是标准――
特别是文本编辑器和交互通信的程序，比如邮件程序、新闻阅读器和聊天客户端。注意
到这一点，也是非常有意义的。
    由于历史的原因，在Unix程序中存在丰宫的接口风格。面向行的、面向屏幕字符阵
列的和基于X的――基于X的世界中几个相互竞争的X工具包和窗口管理器已成鼎足之
势（尽管在2003年的五年或三年前，这还不算什么）。
    所有的这些接口风格存活至今，是因为它们适用于不同的任务。对一个项目作出设
计决定，重要的是应该知道如何挑选一个（或组合多个）适合程序应用和受众群体的风格。
    我们将使用五种度量标准对接口风格进行分类：简洁、表现力、易用、透明和脚本
化能力。在本书前面我们已经使用了其中的一些术语，为这里的定义做好了准备。它们
是相比而言的，不是绝对的；它们需要对特定的问题域并结合用户技能基础的一定认知
1窗口管理器处理屏幕上的窗口同运行任务的关联，即处理诸如标题栏、布局、最小化、最大化、移
动，缩放和加阴影等行为。
    UNIX编程艺术
    www.pdf365.com
258    第1 1章接口：Unix环境下的用户接口设计模式
来进行评估。但不管怎么说，这些术语有助于组织我们的思考方式。
    程序接口的简洁是指一个事务处理需要的动作时间及复杂度有较低的上限（可以用
击键量、鼠标手势量和需要多少秒的注意力来衡量）。简洁的接口会以相对较少的比特
或状态变化包装更多的作用效果。
    接口具有表现力是指接口可以触发相当广泛的行为。最具表现力的接口可以启动程
序设计者没有预见的行为组合，并仍然给予用户有用和一致的结果。
    简洁性和表现力之间的区别相当重要。考虑输入文本的两种不同方法：从键盘，或
使用鼠标在显示屏上点选某个字符。这两种方式有相同表现，但是键盘方式更简洁（通
过比较平均操作时间就可以轻易验证）。另一方面，考虑同一编程语言的两种方言，一
个具有复数类型，另一个没有。在相同的问题域，二者的简洁性相同；但是对数学家或
电子工程师来说，具有复数数据的语言更富有表现力。
    接口易用性同接口要求用户记忆的东西成反比――为了使用接口，用户需要特别记
忆多少东西（命令，鼠标手势，原语概念）。编程语言的记忆负荷愈高、易用性愈低；
菜单和屏幕上标记良好的按钮就较为简单。
    回顾早些时候我们为“透明度’’花费了整整一蕈。在那一章中，我们接触到了接口
透明度的概念，并且将“audacity"音频编辑器作为一个优秀的范例。然而那时我们更关
注另外一种透明度，是关于代码结构，而不是关于用户接口。因此我们用来描述UI透明
度的是它的效果（问题域和用户之间毫无障碍），而不是产生这种透明度的专有特征。
现在，是瞄准这些特征的时候了。
    接口透明度是用户在使用接口时，几乎没有什么问题、数据或程序的相关状态需要
记忆。一个高度透明的接口，对于用户动作的效果，能够自然地给出中间结果、有用反
馈和错误通知。所谓的所见即所得（WYSIWYG，What You See Is \Vhat You Get）的接
口试图将透明度做到极致，但有时适得其反――尤其是对于定义域视图过度简化时。
    相关的可显性概念同样适用于接口设计。一个可显的接口向用户伸出学习的援手，
比如指向上下文帮助的提示消息，或是一个说明性的弹出式气球。尽管对于可显性，将
www.pdf365.com
11.4 CLI和可视接口之间的权衡
259
要支持的不同接口风格的实现可能大有不同，但是所能够获得的可显程度大部分独立于
接口风格。由此，在本章的讨论中，我们并不把可显性作为衡量标准。
    请注意，代码和设计的透明并不是就自然而然意味着接口也透明，反之亦然。指出
只具备其中一个品性的代码再容易不过了。
    脚本能力，是指接口能够容易地为其它程序所使用（例如，第7章讨论的IPC机制）。
可脚本化的程序通常被其它程序作为组件使用，从而减少了定制代码的昂贵需求并使得
重复任务的自动化相对容易。
    最后一点――自动完成重复的任务――比以往更值得注意。Unix程序员、管理员和
用户养成了一种思考习惯，即他们使用常规例程，然后将其封装，以后就再也无需手工
执行，甚至无需再挂在心上。当然，这个习惯依赖接口的可脚本化能力。这是种对生产
力无言但巨大的支持，而在其它大多数软件环境中却无法获得。
    关于这些度量标准，人类和计算机程序有着不同的价值函数，将这一点牢记心中非
常有用。初学者和专家用户在特定问题域上也是如此。我们将探索其间的权衡对于不同
的用户群体有怎样的不同。
11.4 CLI和可视接口之间的权衡
    早期Unix的CLI风格，在电传打字机消七了很久以后，其效用仍得以保留，这有两
个原因。一是命令行和命令语言接口比起可视接口来说，更具表达力，尤其是针对复杂
的任务。另一个是CLI接口具有高度的脚本化能力――正如我们在第七章讨论的一样，
它们很容易就能支持程序的搭配。通常（但并不总是）CLI在简洁性上也占据优势。
    当然了，CLJ风格的劣势在于，几乎总是需要费劲地记忆（易用性低），并且透明
度通常也很低。多数人（尤其是非技术型摄终用户）认为这种接口相对神秘、难以学习。
    另一方面，其它操作系统中“用户友好”的GUI，也存在自身的问题。找到
正确的按钮来按简直就像是在玩冒险游戏：接口同任何Unix的命令行接口一样令
人烦累，找得多了总能找对地方。而在Unix中，人们只需查手册。
-Brian Kernighan
UNIX编程艺术
    www.pdf365.com
260
第1 1章接口：Unix环境下的用户接口设计模式
    数据库查询就是此类接口的～个很好的例子，这里，点击按钮不仅累人，而且能力
非常有限。无论是全屏字符接口的击键命令，还是在图形显示器上的GUI手势，都不如
直接向服务器键入SQL语句那样简洁和富有表现力，在表示问题域的一个典型活动。毫
无疑问，让客户端程序直接说出一个SQL查询语句要比让它的模拟用户在GUI上点来点
去容易得多。
    另一方面，许多非技术型的数据库用户不愿记忆SQL语法，而宁愿选择一个相对不
简洁、表现力较差的全屏或GUI接口。
    SQL还适合作解说另～个问题的例子。最强大的CLI并不是命令的专门集合，而是
如我们在第八章所描述的方式设计的命令式微型语言。这些微型语言在命令行接口范畴
上属于最强大、最复杂的～端；它们的表达力最强，但是易用性最低。它们难以使用，
往往需要小心谨慎地对普通的终端用户隐藏，但是当接口能力和灵活性至关重要时，它
们的威力就无与伦比。如果设计得当，在脚本化能力方面它们也可以得到高分。
    有些应用，与数据库查询不同，天然就是可视的。绘图程序、网页浏览器和幻灯演
示软件是三个典型例子。这些应用程序定义域的共同之处是（a）透明性有极端偷值，和
（b）问题定义域的原语操作本身就是可视的：“画这个”、“显示所指物’’、“把它放
到这儿”等等。
    绘图程序的另一面是难以找到所操作图片之间的关系。例如，要让用户能以重复的
元素来处理图像的结构，程序就必须经过小心谨慎地设计。这是可视接口的普遍设计问
题。
    在第六章，我们检视了Audacity声音文件编辑器。它的接口设计是成功的，因为它
在音频应用定义域和一套简单视觉表示之间做了一个相当干净的映射（借鉴音响上的均
衡器显示）o能够做到这完全是因为通过一个简单转换的结果：声音到波形图。视觉操
作并不只是低级调整的拼凑，而是与那个转换紧密相关。
    然而，在那些并不是天然可视的应用中，可视接口最适用于初学用户简单一次性的
或者很少发生的任务（这一点数据库例子已经阐明了）。
    随着用户变得越来越熟练，对CLI接口的抵触也越来越少。在许多问题定义域上，
用户（特别是常用的用户）往往会达到一个交叉点，CLI的简要性和表达力变得要比避
免记忆负担更有价值。这样，例如，计算机初学者倾向于易用的GUI桌面，而老手常常
逐渐发现他们更愿意在shell中键入命令。
www.pdf365.com
11.4 C LI和可视接口之间的权衡
261
    当问题规模变大、程序行为日趋单一、过程化和重复时，CLI也常能发挥效用。例
如，创作诸如商业信函之类相对较小而无结构的文档，～个所见即所得的桌面发布程序
通常是晟容易的方式。但是如果文档达到一本书的规模，由数个部分组成，并且在写作
时需要许多全局的格式变更或是结构操控，这时，一个微型语言的格式化器比如troff、
TeX或某个XML标记处理器通常是更有效的选择（关于这个权衡更多的讨论请参考第
1 8章）。
    甚至在天然可视化的定义域中，问题规模的增大也会使天平向CLI风格倾斜。如果
需要从指定的URL获取和保存网页，指向十点击（或输入十点击）可以用。但是对于网
页表单，就要使用键盘。并且如果需要获取和保存50个URL的相关页面，那么一个可
以从标准输入或命令行读取URL的CLI客户端就能够节省许多不必要的操作。
    另外一个例子，考虑修改图像的颜色表。如果想要改变～种颜色（即，加亮图像但
效果只有看后才能知道），一个可视的颜色选取对话框几乎是必须的。然而想象一下，
需要用特定的一组RGB值来替换整个颜色表，或需要创建或索引大量缩略图。对于这些
操作，GUI的表现力往往就欠缺。即伎这样可行，调用～个设计得当的CLI或者过滤器
来完成这项任务则要简洁得多。
    最后（正如我们早些时候观察的一样），CLI风格在方便其它程序使用方面非常重
要。一个GUI图形编辑器如果要为～堆文件成批生成缩略图，往往是通过脚本语言编写
的插件去调用一个内部CLI图形编辑器（如GIMP中的“script-fu”）。Unix环境凸现了
CLI的价值，因为Unix的IPC方法多样，开销也低，并且还容易在用户程序中使用。
    1984年后对GUI兴趣的爆发，很不幸地掩盖了CLI的优点。尤其是消费类软件的设
计，已经变得严重倾向于GUI。尽管对于由初学者和随意用户构成的大多数消费市场来
说，这未尝不是个好的选择，但同时也被迫支付隐性成本，当有经验的用户遇到GUI表
达限制时，成本随着用户处理要求更高的问题而稳步上升。这么多的代价都来自于GUI
根本就不能脚本化――所有交互都需要由人来驱动。
    Gentner&Nielsen在《反Mac接口》  （The A，zti-Mac Interface）[Gentner-Nielsen]中
很好地总结了这种权衡：“（可视接口）在处理小数量物体简单行为的情况下，工作得很好，
但是当行为或是物体的数目螬加时，直接操作很快就变成了机械重复的苦差。一个可以
直接操作的接口，其缺点是一切都必须亲自操作。同一个发布高级指令的执行者相反，
UNIX编程艺．术
    www.pdf365.com
262
第1 1章接口：Unix环境下的用户接口设计模式
用户降格成了装配工，必须一遍又一遍地执行同样的任务”。著名科幻小说家，Neal
Stephenson，在《一开始就是命令行》（肪the Beginning Was the Command Line）这篇精
妙散文中，同样指出了这一点，只不过没有直截了当，而是调侃而谈。
    从不太理论的角度，一个典型的Unix老手这样阐述这个问题：
    商业世界通常一窝蜂地支持初学者模式，因为（a）购买决定基于冲动，和（b）
  仅仅有个傻愣愣的GUI，用户支持工作得以降到最少。我发现许多非Unix系统常
  常令人沮丧，因为，比如，它们不提供对成百上千的文件进行某种处理的方法；
  想写一个脚本，又不支持。实质的问题是他们已经假定所有的用户总是入门级的，
  然后非难Unix，因为Unix并不迎合这种模型。
-Mike Lesk
    既然如此，长远来看――为了既能服务一般用户又能服务有经验的用户，为了同其
它的程序交互，不管问题定义域是不是天然可视化――既支持CLI又支持可视接口都是
非常重要的。在展示一个实例分析后，我们将检视Unix传统发展出来适应各种需求的特
征设计模式。
11 .4.1  实例分析：编写计算器程序昀两种方式
    让我们具体一点，对比一下GUI和CLI风格如何有效地应用于一个简单交互程序的
设计：桌面计算器。我们用来对比的例子是dc （l） lbc （1）和xcalc（1）。
    原始的Unix桌面计算器程序，是最先随版本7-起发布的dc （l）――逆波兰标记
法计算器，可以处理无限精度的算术运算。后来，代数（中缀标记法）的计算器语言，
bc （1），是基于dc上实现的（作为实例分析，这两个程序的关系我们在第7章和第8
章先后进行了讨论）。两者都使用命令行接口。可以在标准输入键入一个表达式，按下
回车后，表达式运算结果打印到标准输出上。
    另外，xcalc（1）程序，视觉上就是仿真一个简单的计算器，具有可点击的按钮和普
通计算器般的外观。
    xcalc这种方式更容易描述，因为它效仿的是一个即使初学者也熟悉的接口；实际上
其手册页干脆就说“数字键，正负号键，并且加减乘除等于这些符号都与人们所预想的
别无二致”。程序的功能通过按钮上的可见标签表露无疑。这是最小立异原则的最强烈
www.pdf365.com
11.4 C LI和可视接口之间的权衡
263
因田田回田
围围曰围困
口回回回围
口田口口口
回口田田口
回口田田口
回口口口口
回田口田口
图11.1  xcalc图形接口
表现形式，对于并不常用和新进的用户来说，不需要阅读手册就可以使用这个程序，在
这方面，拥有真正的优势。
    但是，xcalc同样几乎完整继承了计算器的不透明性；当求解一个复杂的表达式时，
无法看到击键的过程并进行验证――这可能是个问题。假如，在表达式（2.51+4.6）木0.3
中，弄错了一个小数点。没有历史纪录，所以无法检查。当然可以得到一个结果，但并
不是想要算式的结果。
    另一方面，在dc （1）和bc （1）程序中，可以一边键入表达式，一边剔除其中的错
误。它们的接口透明得多，冈为可以看到每～步计算的结果。这也更富有表达力，因为
dclbc解释器并不受限于适合通常大小计算器的可视模拟，还能包括许多更大的函数指令
（以及比如if/then/else、存储变量和迭代等功能）。当然了，这也导致了更高的记忆负
担。
    简洁性更难以定夺；打字好的人会发现CLI更简洁，但打字不好的会认为点击更
快。脚本化能力不难定夺；dc/bc可以轻易地用作过滤器，而xcalc根本就不具备脚本
他能力。
UNIX缩程艺：术
  www.pdf365.com
264    第1 1章接口：Unix环境下的用户接口设计模式
    在这里，初学者要求易用性和经验用户要求功用性之间的权衡清晰可见。对于随意
使用的情形，心算检查并非难事，xcalc当然具有优势。而对于更复杂的计算，不仅仅需
要步骤是正确的，还需要其正确性可见，或者在尽可能便利其它程序来驱动方面，dc/bc
胜出。
11.5透明、表现力和可配置
    Unix程序员继承了一个强烈的偏爱，愿意使接口富有表现力和可配置。就像其他传
统的程序员一样，他们考虑怎样将他们的接口同目标受众相匹配――但是在处理目标受
众不确定性时有所不同。经验主要来自客户端操作系统的软件开发者自然而然地会使得
接口简单：他们愿意牺牲表现力来获取易用性。Unix程序员默认地使得接口富有表现力
和透明，并且更愿意牺牲易用性来换取这些品质。
    这种态度常常被描述成，接口是“程序员写给程序员的’’。但这过度简化了事情的
某～重要方面。当Unix程序员倾向可配置能力和表现力而不是易用性时，并不是想当然
地认为他的日标受众仅仅由其他程序员构成，他们深入骨髓的本能反应是，如果不了解
终端用户的意图，最好不要迁就或者放马后炮。
    这种态度（也是“机制，而非策略”的近亲）的不利方面是遮种倾向：当高
度可配置和富于表现力的接口完成后，任务就算完了……即使其结果就是除他自
己外的所有人不经长期学习几乎就无法使用。可配置能力的另一面，就是迫切需
要良好的默认值和简单恢复所有默认值的方法。表现力的另一面就是需要指导一
在程序本身或者在文档中一如何开始使用、以及如何取得通常最期望的结果。
-Henry Spencer
    透明原贝0也有～个影响。对于定义了一套控制选项的RFC或其它标准，当Unix程
序员在编写符合它们的程序时，往往会假定他要为所有选项提供一个完整透明的接口；
给定的任何选项用不用得上实际倒在其次。他的工作就是建立机制：而策略方面的任务
则属于用户。
    这种思路导致了对于标准一致性组成方面一个更苛刻的态度，不完全的支持是难以
容忍的。也许一个Macintosh或Windows开发者会说“我们不需要支持标准的所有特征：
www.pdf365.com
11.5透明、表现力和可配置
265
多数用户不会在意，而且对他们来说太复杂了”，而一个Unix开发者可能会说“我们并
不知道是不是有人永远都不会需要这种功能或者选项，所以我们必须支持它。’’
    当Unix程序员和其他程序员～起工作时，这些态度会导致冲突，因为其他程序员可
能会把这种设计认为是～种冒失的主观意愿，将用户置于对他们而言含混、无意义、甚
至是吓人的技术细节的负担之中。Mac或Windows的程序员害怕只是因为少数人的高级
需求而吓跑大多数用户。
    相反，Unix程序员更愿意认为对表现力的忽视是一种逃避，或者甚至是一种对未来
用户的背叛，这些未来用户对于他们自己的需求实际上会比现在的实现者还要清楚。具
有讽刺意味的是，尽管Unix的这种态度常常被视作是程序员的一种傲慢，但它实质上是
谦逊的另一种形式――往往伴随着好多年的战争创伤而获得。
    Unix这种态度的适应范围是不同的。读者如你，无论这种划分会把你归属到哪一方，
学会倾听他人的声音都是明智的，而理解对立观点的前提无疑同样明智。这样，就有可
能建立～种透明的接口，既具备高级功能又不碍眼，从而避开落入不是胁迫用户就是迁
就用户的陷阱。第6章audacitv和kmail裎序的实例分析就是很好的例子。
    最后是关于为非技术型终端用户设计接口的注意事项。这是一个要求颇高的艺术，而
Unix程序员也没有一个擅长于这方面的传统。但是拥有从Unix传统讨论中已经揭示出来
的思想，我们可以给出一个强力而有用的表述。那就是：当人们说一个用户接口是直观的，
他们的意思是（a）它是可显的，  （b）用法是透明的，  （c）遵循最小立异原则2。在这三
条原则中，最小立异原则是最弱的约束；可显和透明带来的长期使用回报完全可以消融
最初的讶异。
    今天移动电话（例如）用户接口记忆负荷相对较高，至少在大脑中需要有一个关于
接口菜单的大概轮廓，这样可以很快的使用它们而无需花费注意力研究到底处于哪一级
菜单。然而设计更好的接口很快就可以成为对用户而言的“直观”设计，因为他们具备
前述的三项品质。
    直观并不是同易用性一样的品质，因为（正如手机的例子所示）人们可以培养出任
何他们认为有关透明接口的“直观性’’。虽然那种接口有着相当规模的记忆负担，然而
2这种领悟来自于一个非技术型最终用户，恰好是作者的妻子Catherine Raymond。
UNIX 41S程艺-术
  www.pdf365.com
266    第1 1章接口：Unix环境下的用户接口设计模式
只要基本操作是容易的，并且存在一个发现路径，允许通过简单操作让隐藏在更深角落
的功能能够一次到位地触发。
11.6  Unix接口设计模式
    在Unix传统中，已经形成了良好的接口设计模式，可以完成以上讨论的权衡。下面
是这些模式及其分析和例子的传集。再接下来，我们会讨论如何应用这些模式。
    注意到这个传集并未包括GUI设计模式（尽管包括了一种能够将GUI作为组件使用
的设计模式）。没有原生的来自Unix的图形用户界面设计模式。关于GUI设计模式的
讨论《经验――用户界面设计的模式描述》  （Experiences-A Pattem Language for User
InterfaceDesign）[Coram-LeeJ，是一个颇有前途的起点。
    另外要注意程序的适用模式可能不只一个。例如，一个类似编译器的程序，当在命
令行没有指定文件参数时，其行为就像一个过滤器（许多格式转换器都是照此工作的）。
过滤器模式
    与Unix相关的最经典的接口设计模式非过滤器莫属。过滤器程序接受标准输入的数
据，转换成某种格式后，再将结果发送到标准输出端。过滤器不是交互的；也许会查询
启动环境，并且通带由由命令行选项控制，但并不要求用户在输入流中输入命令或给出
反馈。
    过滤器两个经典的例子是tr （l）和grep （l）。tr （I）实用程序以命令行指定的转
换原则将标准输入端的数据转换成标准输出端的结果。grep （l）程序根据命令行指定的
匹配表达式从标准输入端选出匹配行；并将结果送到标准输出端。第三个是sort （l）实
用程序，依照命令行指定的原则将标准输入端的数据排序，并将结果显示到标准输出端。
    除此之外，grep （1）和sort（1）  （但非fr（1））还可以从命令行指定的文件（或
是一组文件）接受输入，在这种情况下，它们并不从标准输入读取，代替的是按照出现
的顺序连续读取命名的文件。  （在这种情况中，也可在命令行将“一，，作为文件名，这会
明确告知程序，从标准输入读取数据。）“catlike”的过滤器程序，其原型就是cat（1），
www.pdf365.com
267
过滤器一般都应该按这样的方式运作，除非应用程序有特别的理由将命令行中给出的文
件区别地对待。
    当定义过滤器时，最好在心中牢记一些附带的原则，其中一部分曾经在第一章提到
过：
    1．牢记Postel原则：宽进严出。也就是说，尽可能自由宽松地接受输入格式，并
输出结构良好的严谨输出格式。前者的做法减少了过滤器在面对非预期输入时出错的可
能性，以及在某种情形下（或是在某一工具链中间）崩溃的可能性。后者提高了过滤器
终有一天能够作为其它程序有用输入的可能性。
    2．在过滤时，不需要的信息也决不丢弃。这也提升了过滤器将来能够成为其它程序
有用输入的可能。丢弃的信息，在管线后面就再也不能使用了。
    3．在过滤时，绝不增加无用数据。避免增加不必要的信息，避免以可能让管线下游
程序难以解析的格式输出。最常见的违例通常是修饰，比如页眉、页脚、空行／标尺行、
摘要、增加列对齐，或者把系数因子“1.5”写成“15096”等等。时间和日期尤其麻烦，
因为它们比较难以被下游的程序解析。任何这样的附加物都应该是可选、并由开关控制
的。如果程序需要输出日期的话，良好的实践是增加～个开关以强制转换成IS08601标
准的YYYY-MM-DD和hh:mm:ss-成者，更好是将标准格式作为默认的选项使用。
这种模式下的术语“过滤器”是Unix历史悠久的行话。
    “过滤器”确实历史悠久。在管道出现的时候就有了。这个术语是从电子工
程借用：数据从源头经过滤器流向接收器。信息源或者接收器可以是进程或文件。
既然已经很自然地把数据流比喻成管道，人们于是从未考虑过使用电子工程术语
“电路（ circuit）’’
    -Doug Mcllroy
    一些程序有着类似过滤器的接口设计模式，但更简单（当然，重要的是更容易脚本
化）。它们是“cantrip"模式、源模式和接收器模式。
UN/X编程2
  www.pdf365.com
268
第1 1章接口：Unjx环境下的用户接口设计模式
11.6.2 Cantrip模式
    cantnp接口设计模式是其中最简单的。没有输入，没有输出，只被调用一次，产生
退出状态数值。一个cantnp程序的行为只能由启动条件来控制。没有任何程序会比这种
方式更具备脚本能力。
    这样，如果程序在运行时除了简单地在启动时设置初始条件或者控制信息之外，并
不需要同用户交互，那么cantnip设计模式就是一个优秀的默认选择。
    事实上，因为可脚本化能力非常重要，Unix设计者学会了当cantrip模式足以应付需
要时，绝不编写更具交互性的程序。一组应用cantrip模式的程序总是从一个交互的包装
器或是shell程序驱动，但是交互的程序比较难以脚本化。良好的风格总是要求在受诱惑
而编写一个难以脚本化的交互接口之前，尝试为程序找到一个cantnp模式的设计。当交
互看来必须时，记住Unix从接口分离引擎的特征设计模式；通常，正确的做法是用脚本
语言编写一个交互的包装器，调用一个cantrip程序完成真正的工作。
    简单的控制台清屏实用程序clear （1），可能是最纯正的cantrip模式；它甚至没有
命令行选项。另外的经典例子是rm （l）祁touch（1）。用来启动X的startx（1）程序
则是一个复杂的例子，是整个一类守护程序使用cantrip模式的典型。
    这种接口设计模式，尽管相当普遍，然而传统中并没有命名；术语“cantnp”只是
我的发明。  （在辞源上，这是个苏格兰方言词，一种魔咒，被一个流行的魔幻角色扮演
游戏选中，命名一种咒语，可以随时发出，只需要很少或根本不需要准备。）
11.6.3源模式
    “源”是一种类似过滤器的程序，不需要输入；它的输出只能在启动条件中控制。
可以作为例证的程序是厶（l），Unix的列举目录命令。其它经典的例子包括who （l）
和ps （1）。
    在Unix中，报表产生器比如ls（1）、ps（1）和who （l）强烈地遵循源模式，所
以标准工具可以过滤它们的输出。
    术语“源”，正像Doug Mcllroy所指的那样，非常传统。但是并非想象中那么普遍，
因为“源”有其它更重要的意思。
www.pdf365.com
1 1。6 Unix接口设计模式
269
11.6.4接收器模式
    接收器是一种类似过滤器的程序，只接纳标准输入而不发送任何东西到标准输出。
同样，它对输入端数据的作用行为只能在启动条件中控制。
    这种接口模式较少用到，众所周知的例子很少。一个是lpr （1），Unix打印假脱机
程序（ spooler）。它将标准输入传来的文本编入打印队列，同许多接收器程序一样，它
也可以处理命令行指定的文件。另一个例子是在邮件发送方式下的mail （1）程序。
    许多第一眼看似接收器的程序，从标准输入获取信息或数据，但它们实际上是ed模
式（见下）的实例。
    术语“海绵（sponge）"有时也用来表示如同sort（1）类的接收器程序，这些程序在
做任何操作之前必须读入完整的数据。
    “接收器”术语传统而普遍。
    类似编译器的程序既无标准输出也无标准输入；然而它们会将错误信息发送到标准
错误端。相反的，一个类似编译器的程序从命令行接受文件或资源名，以某种方式转换
这些资源，然后再以改变后的名字输出。如同cantrip模式，类似编译器的程序在启动后
并不需要用户的交互。
    如此命名这种模式是因为其典范是C编译器，cc （l）（或是在Linux和其他许多现
代UnixT的gcc （l））。但是它也广泛地使用在其它的一些（例如）图像转换或者压缩
／解压程序上。
    前者的例子是用来将GIF（Graphic Interchange Format，图形交换格式）转换成PNG
（Portable Network Graphics，可移植网络图形）格式的gif2png （1）程序。后者的例子
是gzip（”和gunzip （1）3，GNU的压缩程序几乎一定能在你的Unix系统中找到。总
的来说，当程序经常需要处理多个命名资源，并且能够以较低的交互性来实现（它的控
制信息可在启动时提供）时，编译器接口设计模式就是一个不错的模型。类编译器的程
序可以很容易地脚本化。
3这个程序的源码以及类似接口的转换程序可以在PNG网站<h七七p：／／www．cdrom．com／
pub/png/>处获得。
www.pdf365.com
270    第1 1章接口：Unix环境下的用户接口设计模式
这种模式的术语“类编译器接口”被Unix社区广泛理解。
11.6.6 ed模式
    所有前述的模式都只有极低的交互能力；这些程序仅仅使用启动时传入的控制信息，
并且同数据是分离的。然而许多程序，在启动之后需要由与用户持续的会话来驱动。
    在Unix传统中，最简单的交互设计模式以Unix的行编辑器ed （1）程序作为代表。
其他这种模式的例子包括ftp （1）和sh （1） （Unix的shell）等等。ed （1）程序需要～个
文件名作为参数；然后可以修改那个文件。在输入端，它接受命令行。一些命令的结果
输出到标准输出端，作为与程序对话的一个部分，可以立即为用户所见。
    ～个实际的ed对话示例包含在第13章里。
    许多Unix下类似浏览器和编辑器的程序都遵循这种模式，甚至当所编辑的命名资源
并不是一个文本文件时也是如此。考虑gdb （1），GNU的符号调试器，就是这样一个例
子。
    遵循ed接口设计模式的程序并不像过滤器之类简单接口类型的程序那样容易脚本
化。命令可以在标准输入端流入，但比起只需设置环境变量和命令行的选项来说，要产
生一序列命令（或是解释任何回传的输出）就需要更多的技巧，如果命令的行为不可测，
运行状态不能没有监控（例如，行连续字符文档（here document）作为输入并且忽略输
出），所以，在调用过程中，驱动ed模式的程序就需要一个协议和相应的状态机。这就
引发了我们在第7章讨论从进程控制时需要注意的问题。
    不管怎么说，在支持完全交互的程序当中，这种模式最简单、也最具有脚本化能力。
相应地，作为我们下面要讨论的“引擎和接口分离’’模式的一个组成部分，这种模式仍
有相当作用。
11.6.7 Roguelike模式
    V
    Roguelike模式的名字来自这种模式的第一个例子：BSD下的地牢探险游戏rogue（1）
（参看图111.2）；以形容词“roguelike"来命名这种模式已经广泛地为Unix传统所接受。
Roguelike程序是设计来运行在系统控制台、X终端模拟器或视频显示终端上的游戏，使
用全屏幕、支持可视界面风格，但使用字符阵列显示，而非图形和鼠标界面。
www.pdf365.com
11.6 Unix接口设计模式
271
                                                                       a）  some food
                                                                               b） +1 ring mail [4] being worn
                           I                      e） 28 +0.+0 arrows
                               -十-                                f） a short bow
                          #                                 i） a magnesium wand
                            #                                 g） a magnesium wand
                        ###                            - j> a potion of detect things
1） a scroll of taleportation
-press space to continue-
 I               #
 I        ##
    图11.2  Rogue游戏最初版的屏幕截图
    尽管可以打开一个命令窗口（常常但并不总是，在屏幕的最后一行）来键入更复杂
的命令，但命令通常是单键触发而且不回显给用户（正好同ed模式的命令行相反）。命
令体系常常大量使用箭头键来选择屏幕或行位置以进行操作。
    这种模式的程序常常以Vi（1）或emacs（1）来作为模型，并且（遵循最小立异原
则）使用它们的命令集来作为如获取帮助或是终止程序之类的常规操作。也就是说，例
如，使用“x"、“q"或是“C-x C-c”来终止～个程序的方法也可以在这种模式中找到。
    其它有关这种模式的接口特征包括：  （a）使用每项一行的菜单，并且当前选中项加
粗或反白显示，和（b）“模式行”――程序状态摘要由一介高亮的屏幕行显示，常常在
屏幕的底部或者顶部附近。
    Roguelike模式是在一个视频显示终端的世界里发展而来的，很多中断没有箭头键和
功能键。在有图形能力的个人电脑世界里，字符阵列终端已经是一个褪色的记忆，很容
易遗忘了这种模式在设计上产生过的影响；但是早期的roguelike模式范本程序产生在
1981年IBM将PC机键盘标准化之前的好几年。结果，roguelike模式存在一个现在已成
为陈旧部分的传统，那就是任何时候，只要不作为编辑窗口中的待插入字符解释，  “h，
j，k，I”键便固定作为光标键来使用；而且总是“k”上，“j”下，"h”左和“l，，右。这
UNIX编程艺术
    www.pdf365.com
###
    #
    抖
    #
    梓
    拌
    #
秤###
4t:    捧
替    捧
#    社
#    #co
粹    社r-
    ###    ／
    #    4
    #
    “丌    ：
    #    p
    #    X
    #    E
    #
    井
    拌    4
    #
    一 -+J．-
    一    一  m
    一    一  r
    一    一  A
    一    一
    一    一，
    一    1  6
    1    1rl
    ―    f  t
    一    1  4
    1    1  l
    一    一
    一    一    ：
    一    一  r
    一    一  t
    一  +  -  I  rn
    ##
    #
    捧
    捧
    #    6
    #    3
    #    （
    社    6
    #rti
    #
    #
    捧    p
    替    H
    #
    捧
    社
    #
一-+--
一  t．  ．    1  3
1  ．  ．  ．  ．  ．  1  7
1    ．    t    ．    ．    一  一
一  @ dP  ．  ．  ．  1  ：
一  ．  ．    一  d
一  ．  ．  -  ．  ．  一   r-l
一    ．    ．    一  o
一  ．  ．    一  G
一    ．    ．    一
+    -    ．    一
一  ．  ．  ．  -  -      1  3
1    t    -    ．    ．    ．  一
一    ．    -    ．    ．    ．  一    ：
一  ．  ．  ．  -  -     l  l
一    -  ．    一  e
―- - - -- -一V
    e
    -7
272    第1 1章接口：Unix环境下的用户接口设计模式
个历史也可以解释为什么老式的Unix程序常常用不到ALT键，对功能键的使用也非常
有限。
    遵循这种模式的程序如过江之鲫：vi （1）文本编辑器及其所有变种，和emacs （1）
编辑器；elm （1）、pine（1）、mutt（1）和多数其它Unix邮件阅读器；tin （l）、slrn
（1）和其它Usenet新闻阅读器；lynx（1）网页浏览器；还有很多。大多数Unix程序员
很多时候都是与这种接口的程序打交道。
    Roguelike模式的程序难以脚本化：实际上，甚至连脚本化的意图都很少有。另外，
这种模式使用原始方式的逐字符输入，这对脚本化来说并不方便。也很难以编程方式解
析其输出，因为它通常由一序列递增的屏幕绘制动作组成。
    在可视性方面，这种模式远没有鼠标驱动的完整GUI那般流畅。虽然使用全屏界面
是为了支持简单类别的直接操作和菜单接口，但roguelike程序仍然要求用户学习～个命
令集。的确，以roguelike模式构建的界面昭示了一种退化成令人迷惑的原始模式和使用
偏僻字符作为命令的趋势，只有硬派黑客才喜欢。这种模式似乎两方面都做得很差，既
不可脚本化，又下符合为终编用户设计这个新潮流。
    然而这种模式自有一定价值。Roguelike式邮件程序、新闻阅读器、编辑器和其它程
序仍然相当流行，甚至即使存在同类的GUI竞争程序，人们也总是愿意通过X显示模拟
终端来运行它们。更进一步，roguelike模式在Unix下非常普遍，甚至GUI程序也常常
模仿，虽然给命令和显示界面增加了鼠标和图形支持，但是看起来仍然像是roguelike程
序oX方式的emacs（1）和xchat （1）客户端就是这种改编的良好示例。那是什么使得
这种模式如此持久地流行呢？
    效率，可以察觉的效率，似乎是个重要的因素。Roguejike程序相对于GUI对手而言
常常更快捷轻巧。在Xterm中，考虑启动和运行速度，执行一个roguejike程序无疑比调
用一个消耗大量资源来建立显示并且响应更慢的GUI程序更为可取。同时，roguelike程
序可以使用在根本就不需要X的telnet连接或低速拨号连接中。
    指法熟练的人常常更喜欢roguelike程序，因为他们可以不用把手从键盘上挪开去移
动鼠标。可以选择的话，这类人更喜欢尽可能少用那些远离中间键位的键；这也许可以
说明vi （1）流行度为什么那么高。
    也评更重要的是，roguelike式的接口对于X显示上的有限屏幕空间，其使用量是可
以预计的，而且非常节俭；它们不使用多窗口、框架部件、对话框和其它GUI累赘。这
使得此种模式能够很好地适用于必须与其它程序频繁共享用户注意力的程序（尤其是在
www.pdf365.com
273
编辑器、邮件程序、新闻阅读器、聊天程序客户端和其它通讯程序的情况下）。
    最后（可能也是最重要的），roguelike模式常常更吸引重视命令集简要性和表现力
的人群，他们能够容忍记忆负担的增加。我们在上面已经看到这种偏爱的理由很充分，
尤其当任务更复杂、使用更频繁和用户经验更丰富时愈加普遍。Roguelike模式在迎合这
种偏爱的同时，也支持了ed模式无法提供的类GUI元素的直接操作。这样，rougelike
接口设计模式丝毫没继承两个世界的糟粕，反而是吸收了最精华的部分。
11.6.8  “引擎和接口分离’’模式
    在第七章中，我们反对将程序编制成单个庞然大物般的单进程，并且说明了将程序
分解成几个相互通讯的进程常常可以降低整体复杂度。在Unix世界中，这种策略的应用
方式通常是：将程序的“引擎’’部分（程序定义域的核心算法和逻辑规格）从“接口”
部分（接受用户命令、显示结果、或者提供交互帮助和命令历史记录）分离。实际上，
这种引擎接口分离模式可能是Unix最具特色的接口设计模式。
    （另一个更显然胜任于此的模式是过滤器。但是比起数据双向流动的引擎，接口组合
来说，过滤器在非Unix环境中更为常见。模拟管线很容翁；而IPC机制越复杂，引擎／
接口组合就越难以实现。j
    Owen Taylor，作为X下广泛用来编写用户界面的GTK+库维护者，在笔记《为什么
GTK_MODULES不是个安全漏洞》  （Why GTK- MODULES is not盘security hole）
<http：／/www．gtk．org／setuid．html>的末尾漂亮地给出了这种划分对工程的好
处；他这样结束到“安全可靠的setuid程序是一个500行规模的程序，只做该做的事，
并非～个500，000行规模、只做了用户界面的程序。”
    这并不是一个新想法。在施乐PARC图形用户接口的早期研究中，就提出了将“模
型一视图一控制器’’模式作为GUI原型的建议。
●  “模型”在Unix世界里通常称为“引擎”。模型包含了应用程序专用定义域的
    数据结构和逻辑。数据库服务器是模型的原型例子。
●  “视图”部分将定义域的对象渲染成可视形式。在一个真正分离得当的模型／视
    图／控制器应用程序中，视图组件由模型通知更新，并且自身作出相应反应，而
UNIX编程艺术
    www.pdf365.com
274    第1 1章接口：Unix环境下的用户接口设计模式
不是由控制器或被显式更新请求来同步驱动。
    ●  “控制器’’处理用户的请求并将它们作为命令传递给模型。
    在实践中，视图和控制器部分结合常常比两者同模型部分的结合更为紧密。例如，
多数GUI，组合了视图和控制器行为。而往往只在应用程序需要模型的多重视图时才把
它们分开。
    在Unix下，模型／视图／控制器模式比起其它领域都更为普遍，这恰恰因为Unix中存
在“只做一件事并做好”的牢固传统，同时IPC方法既灵活又易于实现。
    这种技法尤为强大的一种形式是将策略接口（通常是结合了视图和控制器功能的
GUI）和包含了一个专用定义域微型语言解释器的引擎（模型）相连。我们在第8章讨
论过这种模式，当时侧重微型语言的设计，现在看看这样的引擎是如何以各种不同方式
形成大型代码系统的组件的。
    下面是这个模式的几个变种。
11.6.8.1  配置者／执行者组合
    在配置者／执行者组合中，接口部分控制运行时无需用户命令的过滤器或者类似守护
进程的启动环境。
    fetchmail（1）和fetchmailconf（1）程序（我们已经作为可显性和数据驱动编程的分
析实例讨论过，并且还会在第14章语言的实例丹析中遇到）就是一个配置者／执行者组
合的很好例子。fetchmailconf是一个随fetchmail -起发布的交互式点文件配置器。同时，
fetchmailconf也可以作为一个GUI包装器以前台或者后台的模式运行fetchmail。
    这种设计模式让fetchmail和fetchmailconf可以让它们的专工发挥用武之地，并且也
确实根据任务定义域的不同而使用不同的语言写成。fetchmail，通常作为一个后台邮件
程序，不需要臃肿的GUI代码。相反的，fetchmailconf可以醉心于精致的GUl，而无需
被迫支付fetchmail已经耗费的规模和复杂度成本。最后，因为它们之间的信息通道定义
严谨得法，所以仍然保留了从命令行或脚本中，而不是用fetch，naitconf启动fetchmail的
能力。
术语“配置者／行动者”是我的发明。
www.pdf365.com
275
11.6.8.2
    在批处理模式需要序列化访问共享资源的情形下，一个配置者／执行者组合的轻微变
形非常有用；也就是说，当一个定义得当的任务流或申请序列需要访问某些共享资源，
又没有单个任务要求用户交互的情形下，这种变形十分有效。
    在这种假脱机／守护进程（ spooler/daemon）模式中，spooler或者前端仅仅简单地将
工作请求和数据放到待处理区域。工作请求和数据是简单的文件；spool区域典型上就是
一个目录。这个目录的位置和作业请求格式由spooler和daemon协商。
    守护进程永远在后台运行，不断轮询spool目录，看看那里是不是有工作可做。当它
发现一个作业请求，就会尝试处理相关数据。如果成功，作业请求和数据就会从spool
区域删除。
    经典的例子就是Unix打印服务系统，lpr（1）/lpd（1）。前端是lpr（1）；简单地将要
打印的文件放入spool区域供tpd定时扫描。lpd的工作仅仅就是序列化访问打印机设备。
    另一个经典的例子是at （1） latd （l）组合，按照时间表在指定的时间运行程序。第
三个例子，虽然现在使用不多，但在历史上很重要，就是UUCP-Unix到Unix的拷贝
程序（Unix-to-Unix Copy Program）．在1990年代互联网大爆炸之前，通常应用于拨号连
接上的邮件传输。
    Spooler/daemon模式在邮件传输程序（天然就是批处理方式）中仍然很重要。邮件
传输的前端比如sendmail（1）和qmail （1），常常只是经过SMTP通往外部的互联网连
接直接试发送邮件一次。如果失败，邮件便会放进一个spool区域：由一个后台版本或者
运行于邮件传输者模式的程序在稍后重发邮件。
    典型地，一个spooler/daemon系统具有四个部分：～个作业发布者、一个队列列表
器，一个作业撤销功能和一个带spooling的守护进程。实际上，前面三个部分就是明显
的线索，表明了在它们幕后某处一定有个后台spooler发送器。
    术语“spooler”和“daemon’’都是Unix的老行话。（“spooler，，实际上可以追溯到
早期的大型机时代。）
11 .6.8.3驱动／引擎组合
    在这个模式中，同配置者／执行者或spooler/server组合不同，组合的接口部分需要向
引擎提供命令并在启动后解释引擎的输出；而引擎的接口模式很简单。所使用的IPC方
法只是实现的具体细节：引擎可烈是驱动的一个从属进程（这方面我们在第7章有所讨
论）或者引擎和驱动可以通过套接字、共享内存或其它IPC方法进行通信。关键是（a）
两者的交互性，和（b）引擎以自身接口单独运行的能力。
UNI×编睡；艺术
  www.pdf365.com
276
第1 1章接口：Unix环境下的用户接口设计模式
    这样的组合写起来要比配置者／执行者组合更费脑筋，因为它们结合得更紧密且错
综复杂；驱动器不仅仅必须知道引擎期望的启动环境，还必须知道它的命令集和响应
格式。
    当引擎设计便支持脚本化时，驱动部分在很多情形中是其他人而不是引擎作者来编
写，一个给定引擎有不止一个前端驱动的例子不少见。程序gv （1）和ghostview（1）提
供了一个很好的例子，它们都是Ghostscript解析器gs（1）的驱动。GhostScript把PostScript
转换成各种各样的图形格式和底层的打印机控制语言。gv和ghosfi，i已w程序为GhostScript
提供GUI包装，以避免使用特殊的调用开关和命令格式。
    这种模式的另一个范例是xcdroast/cdrtools组合。cdrtools发布包提供～个命
令行界面的cdrecord（1）程序。而cdrecord程序代码专职于与CD-ROM硬件相关的所
有工作。xcdroast则是一个GUI:专门用来提供一个舒适的用户体验。xcdroast程序大部
分工作是通过调用cdrecord（1）来完成的。
    xcdroast也调用其它CLII具：cdda2wav（1）（一个声音文件转换器）和mkisofs
（1）（从一组文件中创建IS0-9660格式CD-ROM文件系统映像的工具）。如何调用
这些工具的细节被隐藏起来不为用户所见，所以用户可以更集中精力在制作CD的任务
上，而无需直接知道关于声音文件转换的奥秘或文件系统结构。同样重要的是，这些
工具的每一个实现者都能够集中精力在他们擅长的特定领域，而无需成为一个用户界
面的专家。
    驱动／引擎模式一个关键的缺陷是，通常驱动必须知道引擎的状态以便能反馈
给用户。如果引擎的动作非常快，就不存在问题，但如果引擎可能需要花费较长
时间（比如，当访问许多URL时），反馈的缺乏就会是个严重的问题。对错误的
响应也类似。例如，传统（尽管不太像Unix方式）的是否成功覆盖一个文件的确
认询问，要在驱动器／引擎世界中表现出来就相当困难；发现问题的引擎不得不请
求驱动提示确认信息。
-Steve Johnson
    设计引擎，重要的是不仅要让它能够正确地完成任务，还要通知驱动它在做些什么，
这样驱动才能表现为一个具有恰当反馈信息的优雅接口。
术语“驱动”和“引擎”使用并不普遍，但是在Unix社区已经习用。
www.pdf365.com
鹫1{，3  ×ogroa虢图澎器露
莲孽。6游；尊客户端／服务器缝叁
    客户端绸篓务器缀合类似驱动，弓|鬻，然而引擎部分是……个不需要交互、运行在螽台、
不需自费翔户界面的程序。邋常，设~'“后台程序来溺度对某种共享爨源的访闻――数据
库、事务流，戴专门的共享硬件，如声音设备。男一个这样设计的理由憝可以避免在程
序每次稿动时的操俸过j于复杂。
    过去的实际例子是却（i）抑露（i）程序对，它们实现了霹笋，（文件传输协议我i棼
T谶ns诧f驴簟。￡◇#◇{）；又或者是两个髫榭西辩群i“1）的运行实例，发送端在翦瑞，监听端在
后台，以此传输电子邮件。如今，任何浏览器／网页服务器组合都是这种模式。
    然而，这种模式不仪仅局限‘F通篱程序；另…‘4个重要的情况怒数据库，例如尹蓐∥（{）
勿甜㈤琏s据r（1）程序对。这：蘩，妒。9鸟萝连续谤阀…个由尹秽s氇㈨s瑟台程序管理的共享鼗据
库，传送SQL请求并显示网传的响应数据。
www.pdf365.com
278    第1 1章接口：Unix环境下的用户接口设计模式
    这些例子说明了这种配对的一个重要特性，那就是它们之间保持通信协议的简明清
晰处于第一重要地位。如果协议定义得当，并且由～个开放标准所描述，那么客户端程
序极有可能完全与服务器资源管理无关，并同时允许客户端和服务器端半独立发展。当
然，所有引擎，接口分离的程序都有可能从清晰的功能分离中获益，但在客户端朋艮务器情
况下，正因为管理共享资源在本质上相当困难，所以正确分离倾向的权重往往特别的高。
    消息队列和成对的命名管道也可以用作前端／后端的通讯，但是能够在与客户端不同
种类的机器上运行服务器的好处非常巨大，所以如今几乎所有现代的客户端／服务器都使
用TCP/IP套接字来完成通信。
11.6.9  CLI服务器模式
    在Unix世界中，统一掌控程序启动服务器进程是很平常的4，比如inetd（1）等，
它们通常的工作方式是：服务器从标准输入接收命令，然后将响应发送到标准输出；然
后掌控程序负责确保服务器的stdin和stdout连接到专用的TCP/IP服务端口。这种功能
划分的好处之一是针对所启动的全部服务器程序，守护程序都可以作为一个独立的安全
门卫。
    CLI服务器是经典的按口设计模式之一。这种程序以前端方式触发时，有一个简单
的CLI界面读取标准输入而写入标准输出；以后台方式运行时，一旦程序检测到这种方
式就将标准输入和标准输出连接到专门的TCP/IP服务端口。
    在这种模式的一些变体中，默认方式就是服务器后台运行，而当需要用前端方式运
行时应在命令行选项中指明。这是个细节；关键是多数代码的书写号既不知道也不关心
它是运行在前端还是在一个TCP/IP控制程序中。
    POP、IMAP、SMTP和HTTP服务器程序通常都遵循这种模式。这种模式可以和本
章早些时候讨论的任何服务器／客户端模式结合使用。  ．个HTTP服务器也能够作为一个
掌控程序运行；网页上提供大多数实况内容的CGI脚本运行在由服务器提供的特殊环境
4统一掌控程序是一个包装器，它的工作是让某种资源可以被它调用的程序访问。这个术语最通常用
来指测试掌控程序，它为当前需要被检验的输出获取测试负荷和（常常）正确的示范输出。
www.pdf365.com
279
中，在那里，它们可以从标准输入接受输入（表单参数），并且可以将生成的HTML输
出到标准输出。
  尽管这种模式有古老传统，但术语“CLI服务器”却是我的发明。
11.6.10基于语言的接口模式
    在第八章我们讨论了专用定义域微型语言，它把程序的规格说明提升到一个更高的
层次，从而更具灵活性、bug更少。这些优点使得基于语言的CLI成为Unix接口的一个
重要特点-Unix的shell本身即是一例。
    这种模式的威力，在本章稍前比较dc （l） lbc（1）和xcalc（1）的例子中表现得淋
漓尽致。我们原先评述过的优点（在表现力和脚本化能力方面的收益）是微型语言特有
的优点；并可以推广至其他情形，比如在一个专门的问题域里不得不将复杂操作序列地
进行组织。通常，与计算器例子不同的是，微型语言在简洁性方面也有明显优势。
    最有力的一种Unix设计模式，就是GUI前端同CLI微型语言后端的组合。这种类
型的优秀设计实例相当复杂，但是比起只涵盖微型语言小部分功能，而使用大堆专门代
码的做法，要简单灵活得多。
    当然，这种通用模式，并不为Unix所独有。例如现代几乎任何数据库套件都由一个
或几个GUI前端和报表生成器构成，这些前端仝部使用诸如SQL查询语言与一个统一的
后端通讯。但是这种模式主要在Unix下发展起来，并且比在其它任何地方都得到了更好
的理解和更广泛的应用。
    当实现这种模式的系统前端和后端在一个单一程序中结合起来时，程序往往被称为
拥有一个“内嵌脚本语言”。在Unix世界里，Emacs是这种模式最著名的范例之一；其
优点可以参考我们在第8章的讨论。
    GIMP的script-fu功能是另外一个范例。GIMP是一个强大的开源图形编辑器，拥有
一个类似Adobe Photoshop的GUI界面。Script-fu允许GIMP以Scheme（Lisp的一种方
言）进行脚本化；也可以使用Tc!、Perl或Python编写脚本。通过插件接口，用上述任
何语言编制的程序都可以调用GIMP内部函数。这项功能的示例应用就是一个网页-，该
 Script-Fu网页<ht七p : / /www . xc f . berkeley . edu／～gimp/ s cript - fu/scrip七- fu . html>。
UNIX绸睡；艺术
    www.pdf365.com
280
第1 1章接口：Unix环境下的用户接口设计模式
网页通过CGI接口给一个GIMP实例传递生成的Scheme程序，然后返回处理好的图像，
从而允许人们构建简单的1090和图形按钮。
11.7  应用Unix接口设计模式
    要促进脚本化和管道线能力（参考第7章），最好就是尽可能地选择晟简单的接口
设计模式――牵扯环境因素最少、交互最少的模式。
    在上述单个组件模式中，特别强调了该模式在启动之后是否需要和用户交互这一点。
当经常希望“用户”是另外一个程序（这样的“用户”当然缺少人脑的认知范围和灵活
性）时，脚本能力达到最大化就是一个很有价值的特征。
    我们已经看到了在各种不同情况下针对不同价值特征进行优化的各种接口设计。特
别地，在适合初学者和非技术型终端用户的GUI及其设计模式（这是一方），以及服务
于专家用户和最大化脚本能力（另一方）之间，存在一个强烈的与生俱来的冲突。
    摆脱这种两难境地的方法之一就是让程序能够以不止一种方式运行。一个优秀的例
子就是网页浏览器lynx （1）。对于交互式使用，它通常有一个roguelike式的接口，但
是调用时使用- dump，又以源模式工作，指定的网页被格式化为文本在标准输出端输出。
    然丽，当程序需要一个真正的GUI时，一般都不会尝试这样的双重接口。部分原因
是历史造成的，但最重要的原因是控制整体复杂度。GUI往往要求复杂的启动配置和大
量的专用代码：这些特征难以与简单模式共存。在最坏的情形下，一个双重模式的GUI/
非GUI程序需要两个独立的命令解释循环，这就意味着代码膨胀和潜在的不一致性。
    这样，当“选择最简单的模式”同生成一个GUI的需求相抵触时，Unix的方法是将
程序一分为二，这样“分离引擎和接口”设计模式派上用场。
    事实上，将这种思想同第7章的主题相结合，我们也许可以命名一种在Linux和其
他现代开源Unix中出现的新设计模式，尤其当GUI并不仅仅只是一个勉强的附属品，
而是一个众多开发工作的活跃焦点时。
www.pdf365.com
11.8网页浏览器作为通用前端
281
多价程序模式
    一个多价程序（polyvalent，多角色程序）有以下特征：
    1．程序的应用定义域逻辑封存在一个文档化的API库中，该库可被其它程序链接。
程序同外部的接口逻辑是一个基于库的薄胶合层。或者有几个不同风格的UI层，每一个
层都可以链接该库。
    2．一种UI方式是cantrip，类似编译器或以批处理方式执行交互命令的CLI模式。
    3．-种UI方式是GUI，可直接链接到核心库，或者作为一个独立进程来驱动CLI
接口。
    4．-种UI方式是脚本接口，使用现代的通用脚本语言，如Perl、Pvthon或Tcl。
    5．额外可选的一种UI方式是使用curses （3）的roguelike式接口。
    注意，GIMP事实上满足此种模式。
11.8网页浏览器作为通用前端
    自从1990年代中期万维网引起计算机世界天翻地覆的变化以来，将CLI后端从GUI
界面中分离出来已经成为一个愈来愈具吸引力的策略。对于一大类的应用程序，这种策
略使你根本无需编写一个定制的GUI前端，而是征用网页浏览器来扮演该角色。
    这种方法有许多优点。最明显的就是不必非要编写GUI程序代码――而可以用专擅
于此的语言（HTML相JavaScript）描述GUI。这就避免了许多昂贵、复杂、用途单一的
代码，无需为此花费整个项目一半的时间和精力。另外，这使得程序可以立即用在互联
网上；前端和后端既可以在同一个机器上，又可以远隔千里。此外，程序的所有次要表
现细节（比如字体和颜色）都不再是后端需要处理的问题，实际上可以由用户自己通过
一些像浏览器设置和级联样式单之类的机制按自己的口味定制。最后，网页界面的统一
元素充分减少了用户的学习负担。
    这种方法当然也有缺点。最重要的是（a）网页强迫以批处理风格处理交互操作，（b）
使用无状态协议管理持久会话非常困难。尽管这些并不是Unix专有的问题，但我们还是
UNIX奎静呈艺术
  www.pdf365.com
282
第1 1章接口：Unix环境下的用户接口设计模式
The program
    图11.4在多价程序中调用者／被调用者的关系
要在这里讨论――因为对于在设计层面思考清楚何时值得接受或绕开这些限制是非常重
要的。
    CGI-公用网关接口（Common Gateway Interface），通过它，浏览器可以调用服务器
主机上的程序，但它并不支持精细粒度的交互性。渐渐取代它的模板系统、应用服务器
和内嵌服务器脚本（我们将在本节使用CGI代表所有这些语言滥用）也不行。
    通过CGI网关并不能实现逐字符或逐GUI手势方式的v0;相反的，必须填完HTML
表单并且点击提交按钮才能将表单内容发送给CGI脚本。之后运行CGI脚本并由服务器
回传其产生的HTML页（可能本身也是另一个CGI表单）。
    这本质上是一种交互的批处理风格，不是那种早已消失的在输入口放入打孔带然后
得到打印输出的观念。使用JavaScript同用户交互，将事务批量处理成消息发送给服务器，
这种方法更为方便。
    Java小应用程序可以建立自己的字符流回连接服务器，以支持更平滑的交互行为。
但是Java还存在技术问题（仅仅只能在页面上使用固定的显示区域，并且不能够改变显
www.pdf365.com
11.8网页浏览器作为通用前端
283
示框之外的显示部分）以及更糟的政策问题（来自Sun公司的专利许可权耽误了Java的
部署，而且别人不愿意用它；不能指望所有的浏览器都支持Java小应用程序）。
    Java和JavaScript都会遇上浏览器不兼容问题。微软坚持不在Intemet Explorer上实
现JDK l.2和Swing，这对于Java小应用程序来说是个严重问题，而JavaScript版本的差
异也同样会崩掉程序（尽管JavaScript的bug比较容易纠正）。然而，处理这些问题通常
都不会比编写和部署一个定制的前端需要更多的努力。较难以处理的是越来越多世故的
用户，出于安全性问题和避免界面的滥用，惯例地将他们浏览器中的Java甚至JavaScript
功能都禁用了。
    另一个不相干的问题是，维护跨越多重CGI表单的会话信息需要太多技巧。服务器
不能够保留客户端同CGI事务处理之间的对话状态，所以不能依赖它将同一用户的前后
表单提交相关联。有两种方法来规避这个问题：链式表单和浏览器cookie。
    当使用链式表单时，必须安排CGI在第一个表单的不可见字段中为第二个表单产生
一个唯- ID，而第二个表单和所有后画的表单都将这个ID传递给它们的后继者。Cookie
以不太直接的方式达到同样的效果，有点像环境变量（细节参考关于众多CGI设计书籍
中的任何一本）。随便哪一种情形，CGI都必须使用ID作为一个会话索引（或是cookie
来直接缓存状态）和显式地处理复用会话。
    通常情况下，这些限制可以忍受。许多非平凡的应用程序，用单个表单和响应就可
以满足，从而可以规避那两个问题。即使这不现实，程序要求多重表单，但编制和发布
一个专门前端的复杂度和成本巨大，节省下来，完全可以轻易写出足够聪明的CGI来跟
踪自身对话。
    会话管理问题可以由应用服务器例如Zope或Enhydra来解决，它们提供了一个会话
抽象，并且为嵌入它们的程序提供了诸如用户验证的服务。这些程序的缺点也是它们的
优点：它们可以轻易地在服务器上保留每个用户的状态。但这可能会成为一个问题；它
消耗资源，必须设置超时，因为在事务处理之间没有方法可以知道用户是不是还在线上
的那一端。
    通常，最好的建议是尽可能选择最简单的模式。当简单的CGI和cookie就足以应付
工作时，要抵挡住靠Java或应用服务器来编写重量级设计的诱惑。
    浏览器作为通用前端的方法还存在一个问题，那就是CGI盾端不是立即可以从浏览器
环境中分离的，所以难以脚本化或是将事务自动化到后端。Unix的解法是三层结构――
UNIX编陋；艺_术
  www.pdf365.com
284
第1 1章接口：Unix环境下的用户接口设计模式
网页窗体调用CGI，CGI调用命令。而命令集就是自动化的接口。
    浏览器解开前端和后端耦合的方式具有重大意义。在网络上，随着网络的发展趋势，
将用户锁进某个封闭专属协议和API集变得越来越困难也越来越缺乏吸引力。软件开发
的经济大潮也越来越倾向于HTML、XML和其它开放的、基于文本的互联网标准。这种
趋势也以有趣的方式增强了开源开发模式的发展，这一点我们将在19章给予讨论。在网
络正在创造的世界里，Unix的设计传统――包括本章讨论的接口设计――看起来比以往
更加亲切。
11.9沉默是金
    在没有涉及缄默原则，这个Unix中最古老最持久的设计比喻之前，我们还不能就这
样抛开用户接口交互性这个主题。我们在第一章提到过如果程序没有什么有趣的或是惊
奇的东西要说就应该闭嘴，并且有充分的理由相信：它比Unix诞生时出现的缓慢电传打
字机还要长命。
    理由一：喋喋_小休的程序往往不能跟其它的程序很好地合作。如果CLI程序向标准
输出发送状态信息，那么尝试解析这个输出的程序就会落入是解析还是丢弃这些信息的
两难境地（即使一切都不会出错）。较好的方法是只把真正的错误信息发送到标淮的错
误输出端，而不要发送任何未请求的信息。
    理由二：用户屏幕的纵向空间是宝贵的。程序每产生一行垃圾，用户可见的信息就
少了一行。
    理由三：垃圾信息是对用户带宽的无谓消耗。在屏幕上，这又增加了一个分心的来
源，往往让人们不得不在处理更重要的前台工作（例如同他人的交流）的同时耗费心力。
    长时间的操作要提供进度条。这是个好传统――帮助用户有效地分时利用他的大脑，
暗示在等待完成的过程中可以离开去阅读邮件或是干点儿别的。不要杂乱地让GUI界面
弹出确认消息除非必要的警示而且进一步，父窗口最小化时应隐藏这些信息，又如果焦
点不在父窗口时，应避免这些信息。2界面设计师的工作是方便用户，而不是在用户面前
碍眼。
2如果你的窗口系统支持在用户和程序之间产生较少妨碍的半透明弹出框，那就使用它们。
UN/X编程艺术
    www.pdf365.com
11.9沉默是金
285
    通常，老是告诉用户他们已经知道的事情是非常糟糕的风格（“程序<foo>正在启
动…”，或是“程序<foo>正在退出”就是两个经典违例）。接口设计作为整体应该遵从
最小立异原则，但是信息内容应该符合最大惊奇原则――仅仅对偏离通常期望的情况详
加说明。
    这个原则对于确认提示有着更强的力量。不断询问的答案几乎都为“是”的请求确
认会造成用户根本不假思索就点击“是”，这个习惯会带来非常不幸的结果。程序应该
只在有足够理由怀疑答案可能是“不不不！”的时候请求确认。并非意外却要求确认是
糟糕设计的显著标志。任何确认提示本质上也许就是接口实际上需要一个撤销命令的标
志。
    如果为了调试，需要喋喋不休的进展消息，添加默认情况下禁用的高详细度（verbosity）
选项。在发布产品时，尽可能多地将需要显示的正常消息转移到启用高详细度选项开关
下。
UNIX编程艺术
  www.pdf365.com
www.pdf365.com
1 2
优化
Optimization
Premature optimization is the root of a// evil.
    过旱优化乃万恶之源。
    -C．A．R．Hoare
    这将是很短的一章，因为关于性能优化，Unix的经验告诉我们最主要的就是如何知
道何时不去优化。其次，最有效的优化往往是优化之外的其它事情，如：清晰干净的设
计。
12.1  什么也别做，就站在那儿
    程序员工具箱中最强大的优化技术就是不做优化。
    有几个理由支持这项禅式的忠告。其中一个是摩尔定律的指数效应――最聪明、最
便宜、常常也是最迅速的性能提升方法，就是等上几个月，期望硬件性能更好。考虑到
硬件和程序员时间成本比率，总是有更值得打发时间的事，别去优化一个工作中的系统。
    这是有数学上的理由的。如果仅仅只是为了减少资源使用的一个常数部分而优化，
那是很不值得的。更明智的做法是集中精力将时间复杂度或空间复杂度从O（n2）降至
UNIX编腥艺：术
  www.pdf365.com
288
第1 2章优化
O（n）或O（n log n）l，或者类似地，从一个更高次的指数降下来。线性性能增益往往很快就
会被摩尔定律覆盖了。2
    另一个非常有建设性的“无为”方式就是不写代码。程序性能不可能因不存在的代
码而降低。而存在、但不如所设想那样高效的代码可能会降低程序的性能――但那是另
一码事了。
12，2先估量，后优化
    如果有真凭实据证明应用程序运行缓慢，这时（仅当此时）才可以考虑优化代码。
但付诸实施前，要先估量。
    回顾第一章Rob Pike的六条法则。最初的Unix程序员最先学到的经验之一就是要
明确瓶颈所在，直觉实在是个糟糕的向导，即使特别熟悉可疑代码的人也不例外。Unix
同多数其它操作系统不一样，它通常带有性能剖析程序（profiler）；要善加利用。
    阅读profiler诊断的结果是一门学问。存在几个经常出现的问题：一是工具误差，二
是外部强加的延迟，三是过度调用图中顶部节点。
    根本的问题是工具误差。Profiler靠插入指令来工作，这些指令可以报告子程序入口
和出口之间、以及程序内嵌代码中固定间隔的执行时间。这些指令的执行同样需要时间。
结果就是减少了调用时间的差量：很短的子程序往往看起来较实际费时，茌相当的调用
时间中，存在大量工具噪声，而对于长一些的程序，工具的额外开销是很难察觉的。
1对于不熟悉O记法的读者，这是一种表示一个算法的平均运行时间如何随着输入量大小而变化的
方法a一个o ci）的算法，其运行时间是常数。一个O（n）的算法，其运行时间可以预测为An+
C，这里，A是某个待定的比例常数，而C是某个未知常量代表启动时间。线性链表查找的时间复
杂度是0 （n）。一个O（n2）算法的运行时间是An2加上低次项（可能是线性的、对数的，或任何其
它低于二次的函数项）。链表中重复值的查找（不经排序的简单方法）就是0（112）的。同样的，O（n3）
算法的平均运行时间可以用问题规模的三次方来预测，这对于实际用途往往过于缓慢。树查找是典
型的O（Iog n）算法。对算法的明智选择常常可以将运行时间从O（n2）降至O（log n）。有时我们希望蓣
测算法的内存利用量时，也可以注意到同样有0（1）或O（n）或O（f12）的区别；总的来说，空间复杂度
是O（F12）或更高的都是不适用的算法。
2引用摩尔定律：每十八个月性能翻一番。这暗示晚六个月买新机器就可以获得26%的性能提升。
UNIX编程艺术
www.pdf365.com
12.2先估量，后优化
289
    谨记工具误差，明智的做法是假定在最快和最短子过程的执行时间中，存在不少泡
沫。频繁调用会耗去大量时间，所以，要特别注意统计它们调用次数。
    外部延迟问题也是根本的。在profiler背后，会有许多不同种类的延迟和畸变。最简
单的带有不预期延迟操作的额外开销――磁盘和网络访问、缓存填充、进程切换等等。
如果仅仅是这些那还好了――也许你刚要检测它们，特别地，如果想检测整个系统的性
能而不仅仅只是某个关键的内部循环。问题是它们存在随机的因素，那意味着任何单一
的profiling结果并没有多大用处。
    将这些误差源影响降到最低的一个方法，就是综合多次profiler结果，可以在一般情
况下得到更好的运行时间图。有不少充足理由支持在优化之前为程序编制测试工具和测
试负载；这远比性能调整重要得多，在程序改变之后，可以进行回归测试以检验其正确
性。一旦这样做了，就可以对相同负载的重复测试运行profile，这是一个很好的副作用，
能够获得更有用的信息比单独手动的几次profiling强。
    各种各样的效应常常导致时间耗费在调用例程而不是例程本身上，从而造成调用图
中项部节点负担过重。例如，函数调用开铛，就常常算到调用例程上（这一点部分依赖
于机器体系以及profiler工具是不是允许插入探针（probe））。如果编译器支持的话，
宏和内联函数，根本不会在profiling报告中显示；它们耗费的每一份时间都算在了调用
函数的头上。
    更重要的是，许多时间分析工具都将子程序的时间开销加到了调用程序中。  （随开
源Unix -道发布的gprof（1）就是如此。）如果同一过程有不止一个调用者，简单地从
调用程序开销中减去被调用程序开销的结果用处不大――这样会人为缩小两者的时间
差距。尤其麻烦的是如下这种常见情况：一个公用函数存在多个调用点，其中一些是简
单调用，而其它地方却产生～些复杂的调用。
    为了得至Ⅱ更透明的结果，分解代码，让高级例程尽可能多地调用底层例程、而不是
内嵌代码。如果能够保持高层控制逻辑的开销最小，代码的这种调用结构往往可以让
profile报告相对来说更容易阅读一些。
    使用profiler，并不只是简单收集孤立的性能数字，更应该把它当作一个具备许多有
趣参数的函数（例如，问题规模、CPU速度、磁盘速度、内存大小、编译优化，或其它
相关因素）来研究性能是如何随之变化的，这样，才会有更多领悟。接着可以使用开漂
UNIX编腥艺-术
    www.pdf365.com
290
第1 2章优化
的R软件或是高质量的专有软件比如MATLAB，试着将这些数据拟合成一个模型。
    在模型模拟中，自然平滑的数据往往集中在大的效应上，小的有噪声的常常
  被忽略。例如，用MATLAB模拟立方体的矩阵翻转例程，来处理10×10到1000
  ×1000的随机矩阵，很明显地，我们的情况正好具备清晰定义的边界，大致对应
  “在缓存中’’、  “在内存中但不在缓存中”和“不在内存中”。即使目的并不在
  此，但数据仍向我们揭示了这种效应，你只需看看与最好的拟合曲线有多少偏差。
12.3非定域性之害
-Steve Johnson
    最有效的代码优化方法就是保持代码短小简单。我们在本书的前半部分已经给出了
许多保持简单的良好理由。这儿还有个新的：永远不要将核心数据结构和时问关键循环
抛出缓存。
    把目标机器看成一个存储类型的分层结构，按照距离处理器的远近来排列：处理器
自身的寄存器；指令管线；一级缓存（LI）；二级缓存（L2）；可能还有三级缓存（L3）：
主存（Unix老手仍然别致地称之为“核心”）；以及交换空间所在的磁盘驱动器。诸如
对称多处理SMP、共享内存集群和非均匀存储访问（NUMA）之类的技术给这个图增加
了更多的层次，但仅仪增加了总体的延展宽度。
    每一种对此栈的访问方式变得越来越快。处理器周期几乎不用考虑，除了一些苛刻
的应用，例如核爆炸建模和实时视频压缩等等。但是，随着处理器速度的提升，别的也
发生了，那就是存储层级间的速度比率也上升了。这样，缓存未命中的相对成本也提高
了。
    所以我们有一个有趣的悖论。随着机器资源成本的直线下降，庞大数据结构的平均
开销也随之而降――但是因为相邻级别缓存的切换开销上升了，大型结构突破缓存容量
对性能的影响也就增加了。
    因此在这里，  “小即是美”的建议比以往更有用，尤其是考虑到核心数据结构必须
留在最快的缓存里。该建议也同样适用于代码；通常，指令加载要比执行花费的时间更
多。
www.pdf365.com
12.4吞吐量和延迟
291
    这彻底推翻了某些传统的建议。编译器优化，如循环分解，去掉相对昂贵的机器指
令而增加代码的总行数，那是不值得的。另一个例子是预先计算的小型表格――例如，
在3D图形引擎中，优化旋转操作的sin（x）函数表在现代机器中占据365 X4字节的空间。
在处理器缓冲速度没有内存查询快时，这显然是个速度优化。但是现在，比起函数表产
生的附加缓存击不中的可能开销，每次重新计算可能更快。
    但在将来，也许随着缓存的增大又会反过来。更普遍的是，不妨悲观地认为，许多
优化方法都是暂时的而且常常随着成本比例而变化。唯一可去了解的方法就是衡量后再
看。
12.4吞吐量和延迟
    快速处理器的另一个效应是性能经常受限于1/0以及――尤其是网络程序――网络
事务的开销。所以要知道为得到良好性能而进行网络协议的设计是非常有价值的。
    最重要的问题是尽量避免协议的往返。每个要求握手的协议事务都有可能从任何连
接延迟发展到潜在的严重降速。避免这样的握手并不是Unix传统做法，但需要提及，因
为许多协议设计在这个问题上造成大量性能损失。
    延迟问题怎么说都不够。X1I在避免请求来回上比X10做得好：Render扩展
  就做得更好。X（及观在的HTTP/1.I）是流协议。例如，在我的手提电脑上，每
  秒中可以运行4百万绘制lxl矩形的请求（8百万无操作请求）。但是往返请求
  的代价比这要昂责成百上千倍。如果任何时候能让客户端不用连接服务器就可以
  工作，你就成功了。
    -Jim Gettys
    实际上，经验法则是尽可能低的时延设计，和忽略带宽成本，除非profiler明白无误
地告知应该反其道而行。带宽问题可以在开发的后期通过一些技巧，比如现场压缩协议
流等等来解决，但是要在已有的设计中去除高时延则要困难得多（往往根本就不可能）。
    而这种效应在网络协议设计中最为明显，吞吐量和延迟时间的权衡就是更为普遍的
现象。在编写应用程序时，对于昂贵的计算操作，通常面临这样的选择，是一次计算反
复使用，还是按需计算（即使那意味着要经常重新计算）。在多数情况下，如果面临如
UNIX编腥艺术
    www.pdf365.com
292
第1 2章优化
此的选择，正确的做法是偏向低时延。也就是说，不要预先计算昂贵的操作，除非存在
吞吐量的要求，并且通过测量确切知道吞吐量确实很低。预先计算看起来似乎很有效率，
因为它最小化了处理器周期的使用，然而处理器周期是廉价的。除非在做计算密集的应
用程序，例如数据挖掘、动画渲染或前面讲到的爆炸模拟，否则，更好的选择是短暂的
启动和快速的响应。
    在Unix早期的日子里，这个建议也许会被视作是异端邪说。那时，处理器慢得多、
成本比例大不一样；并且，Unix的模式更倾向于强大的服务器操作。提出低延迟价值，
部分也是因为即使是新兴的Unix开发者有时也继承了旧的文化而偏向于吞吐量的优化。
但是，现在世道变了。
    有三种常规的策略来减少时延，  （a）对可以共享启动开销的事务进行批处理，  （b）
允许事务重叠，和（c）缓存。
12.4.1  批操作
    通常图形API是基于更新物理屏幕的固定配置成本非常大而编写的。因此，写操作
实际上改变的是内部缓冲区。最终还是程序员来决定什么时候将这些更新累积到可以成
批处理，然后调用某个操作来更新物理屏幕。选择正确的物理刷新间隔可以在图形客户
端产生非常不一样的感觉。Roguelike程序使用的X server相curses（3）库就是这样组织的。
    持续的服务守护进程是更典型的Unix式批处理实例。编写持续的守护进程（与每次
启动带来全新会话的CLI服务器相反）有两个理由，一个是显然的，一个有点深奥。显
而易见的理由是控制共享资源的更新。不太明显的理由，即使后台程序并不是处理更新，
也可因此分期偿还通过多请求读取后台数据库的成本。一个完美的例子是DNS后台服务
程序named（8），它有时必须处理每秒上千万的请求，每个请求都可能会阻塞用户的网页
载入。named（8）高速的原因之～就是访问保持在内存中的缓存，而不应对磁盘上描述
DNS区文本文件的昂贵解析操作。
www.pdf365.com
12.4吞吐量和延迟
293
12.4.2重叠操作
    在第五章中我们比较了查询远程邮件服务器的POP3和IMAP协议。注意到IMAP
请求（与POP3请求不同）被打上了由客户端产生的标记：服务器发送响应时，也含入
了属于该请求的标记。
    POP3请求必须由客户端和服务器端一步接一步地处理：客户端发送一个请求，等待
该请求的响应，只有在此之后才能准备并发送下～个请求。另一方面，IMAP请求是带
标记的，因此可以相互重叠。如果IMAP客户端希望获取多条消息，它可以将好几条读
取请求（每一条都有不同的标记）以流方式发向IMAP服务器，而不需要等待每条请求
的响应。每个响应也做了同样标记，当服务器就绪时，传送回来；所以，先前请求的响
应很有可能在客户端发送后续请求时，就回来了。
    这种策略在比网络协议更广泛的领域里也适用。对于减少延迟来说，阻塞或等待中
间结果都是致命的。
12.4.3缓存操作结果
    有时，按需计算出昂贵的结果，再缓存起来为以后使用，通过这种方法可以兼得鱼
和熊掌（低延迟和高吞吐量）。我们先前提到过的named程序通过批操作降低延迟：其
实，它也通过缓存先前同其它DNS服务器的事务结果的方式来降低延迟。
    缓存有其自身的间题和权衡，可以由一个应用程序很好地阐明：二进制缓存的使用
可以消除有关文本数据库文件解析的开销。一些Unix变种已经使用这种技术来加速口令
信息的访问速度（特别巨大站点的通常目的就是降低登录时的时延）。
    这种方法要想实施，所有涉及二进制缓存的代码必须检查两个文件的时间戳，如果
主文本更新了，则必须相应更新缓存。换句话说，主文本的所有变化都必须通过一个能
够更新二进制格式的包装器来完成。
    ～旦采用了这种方法，SPOT原则会引导我们发现它所有的缺点。重复的数据表明
这种存储不具备经济性――这是一个纯粹的速度优化。但真正的问题是确保缓存和主文
本一致的代码非常容易产生漏洞和bug。频繁更新的缓存文件仅仅因为秒级的时间戳分
辨率就会导致难以捉摸的竟态条件。
    ～致性在简单情况下可以保障。看看Python解析器，当第一次导入Python库文件时，
编译文件将p-code以扩展名．pyc的形式存放在磁盘上，以后都是运行p-code的一份缓
UNIX编腥艺．术
    www.pdf365.com
294
第1 2章优化
存拷贝，除非源码发生改动（这就避免了每次运行都要重新解释库源码）。Emacs Lisp
以.el和．elc文件使用同样的技术。这种技术能起作用，是因为缓存的读写访问都通
过一个简单的程序来实现。
    主文本的更新模式越复杂，同步代码就越容易产生漏洞。几个Unix变种，使用缓存
技术来加速关键系统数据库访问速度，以频发系统管理员恐怖事故而臭名昭著，恰好反
映了这一点。
    总的来说，二进制缓存文件是一项不稳定的技法，应尽量避免。在某种情况下为降
低延迟而进行的专门优化工作，常常可以更好地改善应用程序设计，从而不再有这样的
瓶颈――或者甚至可以转而加速文件系统或是虚拟内存实现。
    认为迫切需要缓存的时候，明智的做法是能够从更深层次来考虑，并问问为什么缓
存是必须的。这比将缓存的所有边界条件都考虑到要容易得多。
www.pdf365.com
1 3
复杂度
尽可能简单，
但别简单过了头
Complexity: As Simple As
Possible， but No Simpler
Everything should be made as simple as possible，but no simpler.
    事情要尽可能简单，但别简单过了头。
    -Albert Einstein
    在第1章末，我们概括Unix的哲学为“Keep It Simple，Sfupid!”。贯穿整个“设计”
部分的不变主题就是尽可能保持简单设计的重要性。但什么是“尽可能的简单’’？又如
何断定？
    这个问题的讨论一直拖延到现在，因为对“简单”的理解是复杂的。需要某些在“设
计”部分讨论的思想，尤其是第4章和第1 1章的思想，作为背景。
    本章的大部分问题都是Unix传统的核心问题，有一些甚至触发了造成数十年混乱的
内战。本章从已形成的Unix实践和专业术语出发，然后走得比本书剩下部分稍微更深入
一些。我们并不是简单地尝试给出这些问题的答案，因为根本没有答案――我们希望你
能够在概念上有所收益，从而挖掘出自己的答案。
UNIX编程艺．宋
  www.pdf365.com
296
第13章复杂度：尽可能简单，但别简单过了头
13.1  谈谈复杂度
    如同前述讨论的模块化和接口设计问题，Unix程序员往往有某种发自本能、得于经
验的反应，然而却无法清晰表述。所以，我们需要先给出一些术语。
    首先我们将定，义什么是软件复杂度。然后我们会横向比较几种不同复杂度之间的差
别，比较过种中有时免不了顾此失彼。最后我们会进行更重要的纵向比较：哪些是我们
不得不与之共处的，哪些则可以去除。
13.1.1  复杂度的三个来源
    对于简单性、复杂度和软件最佳规模的疑问，Unix世界注入了极大的热情。Unix程
序员已学到了～种世界观：简单即美即雅即善，而复杂即丑即怪即恶。
    Unix程序员追求简单的激情，源自注重实效的事实：复杂度就是成本。复杂的软件
更难于开发，难于测试，难于调试，难于维护――最重要的，难以学习和使用。而复杂
所带来的成本，开发时便汹涌而来，部署后更变本加厉。复杂是bug滋生的温床，在整
个的软件生存期，世界都将不得安宁。
    所有种种压力将程序员拖进复杂度的泥沼中。在前面的几章里，我们已经审视了这
些祸害；其中两个最臭名昭著的就是功能蠕变和过早优化。传统上，Unix程序员以一种
宗教般的热忱来抵御这种趋势．即谴责所有复杂度都非好事。
    那我们所说的“复杂度”究竟是什么？这～点必须板上钉钉，因为不同人有不同的
看法。
    Unix程序员（像其他程序员一样）往往注重于实现的复杂度――基本上，也就是程
序员为了能够试图理解一个程序，从而建立其思维模型并调试该程序的困难程度。
    另一方面，顾客和用户往往从程序界面的复杂度来看待这个问题。在第1 1章，我们
讨论了易用性及其对立面――记忆负担。对用户而言，复杂度与记忆负担紧密关联。而
如果一个拙劣的界面强迫用户进行许多易错或仅仅是冗长的低级操作，而不能进行高级
操作，那么低下的表现力和简洁也脱不了干系。
www.pdf365.com
13.1谈谈复杂度
297
    同时受这两者驱使的第三个度量标准就简单多了：系统中的代码行总数，即代码量。
用生命期成本的话来说，这通常是最重要的衡量方式。理由也许能从软件工程最重要的
经验主义结论中找回，我们以前也曾经引用过：代码的缺陷密度，每百行代码出错率，
往往是一个与实现语言种类无关的常量。更多行的代码意味着更多的bug，而调试常常
是开发中最昂贵、最耗时的部分。
    代码量、接几复杂度和实现复杂度可能同时上升。这就是功能蠕变的通常结果，所
以程序员对其特别恐惧。过早的优化并不增加接口复杂度，但是对于实现复杂度和代码
库规模有着负面的影响（常常特别糟糕）。这种防御复杂度方式相对容易实现；困难在
于，必须在这三者之间进行权衡。
    我们已经提到过两种尺度会导致不同方向变化的情况：用户界面，如果设计时首先
考虑容易实现或代码规模，可能就会简单地将许多底层任务都抛给用户。（对Unix程序
员是难以想象的，但在别的系统中普遍存在的一个拙劣的例子，就是一个缺乏全局替换
操作的编辑器。）尽管这种设计失误实在很普遍，但传统上，却没有一个名称。我们将
称之为“manularity’’（人力尺度）陷阱。
、    迫于保持代码库适度规模的压力，下得不使用极端晦涩复杂的实现技法，这往往会
导致系统实现复杂度的层层叠加，成为无法调试的一团乱麻。这种情况经常发生在程序
为适应极小规模系统而必须用汇编语言写成，或需要自修改代码之类的技巧的时候：如
今，这种情况在嵌入式系统之外难得一见，就算在嵌入式系统中，也变得愈加稀少。这
种设计失误传统上也没有一个名称，但有人会称之为“blivet"（硬撑）陷阱，这个词语
来自于军队，原本描述把十磅马粪硬塞进五磅麻袋里的行为。
    我们预先定义“blivet"陷阱，是为了与其对立面对比之用，但它并不出现在我们的
实例分析中。如果项目设计者对实现复杂度特别敏感，而拒绝使用统一但复杂的方式来
解决一整类问题，相反地更愿意对问题个体编写重复、专用代码，  “blivet，，便会出现。
其结果就是代码库尺寸暴涨，而维护问题远较使用统一方法严重。例如，一个网站工程，
其页面背后其实需要一个集中式的关系数据库，可能反而却采用几个不同的关键数据文
件，在页面生成时将它们包含的信息聚齐。这种失误太过普遍。它没有传统叫法；我们
将称之为“adhocity"（过专用）陷阱。
UNI×编程艺术
  www.pdf365.com
298
第1 3章复杂度：尽可能简单，但别简单过了头
    这就是复杂度的三个面孔，以及一些设计者有时往往为了规避反而掉进的陷阱。1本
章稍后我们在实例分析中将审视更多的例子。
13.1.2  接口复杂度和实现复杂度的折中
    一篇极透彻的关于Unix传统的观察来自Unix世界以外-Richard Gabriel的论文
《Lisp:好消息，坏消息以及如何获得大胜》（Lisp: Good News，Bad News，and How to Win
Big》> [Gabriel]。Gabriel是Lisp社区的长期领导者，此论文最初是作为Lisp独特设计风
格的一个论证，但是作者自己承认文章被人记得的主要原因是“The Rise of Worse Is
Better（‘差即是好’的兴起）”一节。
    文章认为：Unix和C语言有病毒般的特性；在软件设计发展过程的奋斗中，那些促
成快速传播（传染）的特征，如实现的简单性和可移植性等，比起设计的正确性和完备性更
为有效。Gabriel几乎预见了开源软件“多眼球”效应，而开源社区在1997年后的回顾
中，也将他视为他们中的一位理论家。
    较少为人所记的是，Gabriel的中心论点是关于实现和接口复杂度间的一个精准权衡，
宦正好就是我们在本章中检视的分类。Gabriel在更关注接口简单性的“MIT”哲学和更
重视实现简单性的“New Jersey’’哲学之间进行了比较，然后提出，尽管MIT哲学能够
引导软件在抽象上做到更好，但New Jersey模型（差者）更具传播特质。随着时间的推
移，人们更多的注意力都集中到了New Jersey风格，所以它提高得更快。差的变成了好
的。
    实际上，MIT和New Jersey哲学同Unix设计传统自身冲突的趋势有些相像。Unix
思想中的一个主题就是强调工具小巧锐利，设计从零开始，接口简单一致。这种观点最
著名的支持者是Doug Mcllroy。另一种思潮则强调创作简单的可工作实现，然后快速发
布，方法笨无所谓，边界情况不妨搁置。Ken Thompson的代码和他关于编程的信条常有
这种倾向。
    这两种方法间的平衡恰恰是因为有时可用复杂度换来更简单的接口，或者反之。
Gabriel最初的例子，耗时运算系统调用如何处理无法保留或屏蔽的中断，仍然是最好的
‘我们为这三个陷阱创造的名称，听起来虽然像，但是均非出自[Raymond96]中描述的已确定的黑客
行话。
www.pdf365.com
13.1谈谈复杂度
299
实例之一。在MIT哲学中，应该暂停系统调用，伺中断处理完成之后自动恢复之――这
较难实现，但接口更为简单；而在New Jersey哲学下，系统调用会返回一个错误表明已
被中断，用户必须重新执行――这实现起来非常简单，但编程接口却较难使用。
    两种方式都历经考验。Unix老手当会想起System V和BSD处理软件信号的风格，
后者追随MIT哲学，而前者来源于New Jersey思潮。在它们之间作出选择的根本迫切问
题与软件的感染性并无直接关系：如果目标是抑制整体复杂度，最愿意牺牲的是什么地
方？什么地方又最该被牺牲掉？
    一个Garbiel文章中没有提到的划时代实例来自于分布式超文本系统。早期的分布式
超文本工程，诸如NLS和Xanadu，严重局限于MIT哲学的假定：无被指物的链接在用
户界面上是一个不可接受的障碍；这就限制了系统要么只能在一个受控制的闭集文档中
浏览（例如在单个CD-ROM上），要么必须实现各种曰益复杂的复制、缓存、索引方法
来防止文档的随机丢失。Tim Bemers-Lee转而用经典的New Jersey方法解决了这个疑难
杂症。他所采用的简单实现就是允许“404: Not Found～可以作为一个响应，这使得万维
网非常轻便，并获得了广泛的传播和巨大的成功。
    Gabreil自己尽管坚持“坏的”更具感染性而往往能取得最后胜利，但关于其潜在复
杂度的相关问题是否确实是一件好事，他已经数次公开地改变了意见。他的不确定性恰
好反映了许多在Unix社区中正在进行的设计争论。
    我们并不能提供一个放之四海而皆准的答案。对于本章大多数的问题，良好品味和
工程判断力要求，情况不同，则答案不同。重要的是要培养斟酌每一个设计的习惯。正
如我们在讨论软件模块性之前的建议一样，复杂度的算盘必须打好。
13.1.3本质的、选择的和偶然的复杂度
    在理想世界，Unix程序员只愿意手工打造小巧完美的软件宝石，每个都那么小巧、
那么优雅、那么完美。然而现实中很不幸的是，太多复杂问题需要复杂的解决方案。仅
UNIX编腥艺l术
  www.pdf365.com
300
第13章复杂度：尽可能简单，但别简单过了头
仅十行的程序，再优雅也无法控制喷气客机。那儿有太多的装备、太多的通路和界面，
太多不同的处理机――太多不同操作人员定义的子系统，他们甚至连基本的约定都无法
统一。即使能够成功地将航空控制系统所有的个体软件部分都做得优雅，但拼装结果很
有可能是一堆庞大、复杂、糟糕的代码，当然（希望如此）也有个优点，就是确实能够
工作。
    喷气客机的复杂是必然的。过去有个相当尖锐的观点，不能为简单性而牺牲掉功能，
因为飞机必须要能飞。正是这个事实，航空控制系统并不会产生关于复杂度的圣战――
Unix程序员往往敬而远之。
    喷气客机当然不会对因过度复杂而导致的系统故障有免疫功能。但是在需求较灵活
的软件中，设计问题更容易辨别和考虑，也容易在预期的功能性和复杂度中做出权衡。
（此处，以及本章的剩余部分，我们从总体方面使用“功能”来包括诸如性能提升或是
接口整体修饰之类的东西。）
    为了看得更敏锐，我们需要从注意偶然复杂度和选择复杂度的区别开始。2偶然复杂
度的产生是因为没有找到实现规定功能集合的最简方法。偶然复杂度可以由良好的设计
或重新设计来去除。另一方面，选择复杂度，同某个期望的功能相关联．只能由改变工
程的目标来去除。
    当无法区分选择和偶然复杂度时，设计争论就会变得异常混乱。“什么是工程目标”
的夹杂着简单即美的问题，也会牵扯到人们是不是足够聪明。
13.1.4映射复杂度
    迄今为止，我们已经发展出考虑复杂度的两个不同等级。这些等级实际上彼此正交。
图13.1或许可以帮助澄清它们之间的关系。该图共有九个方框，每一个都列出了某种特
殊复杂度种类的常见来源。
2偶然和选择复杂度的差别意味着我们在此处讨论的分类跟Fred Brooks文章No Silver Bullet（没有银
-）[Brooks]中的本质和偶然有所不同，但是它们在哲学上都有同样的祖先。
www.pdf365.com
13.1谈谈复杂度
301
复杂度
种类
偶然复杂度
选择复杂度
本质复杂度
代码库规模    实现复杂度    接口复杂度
复杂度来源
图13.1  复杂度种类及其来源
    在本书的稍早部分我们已经接触过各类复杂度，特别是属于偶然复杂度的那种。在
第4章中，我们注意到偶然复杂度常常缘于接口设计并非正交――即没有仔细地分解接
口操作以使得每个操作只完成一件事情。偶然代码复杂度（比能够完成工作所需的更复
杂）常常来自于过早的优化。臃肿的偶然代码库往往缘于对SPOT原则的违背、重复的
代码或糟糕的组织，以至于重用机会渺茫。
    本质接口复杂度通常无法去除，除非调整软件的基本功能需求（在本章的实例分析
中我们会更多地展开这个主题）。代码库的本质大小同选择的开发工具有关，因为如果
功能清单固定不变，决定代码库规模大小最重要的因素可能就是实现语言的选择（正如
我们在第8章暗示的一样）。
    选择很难地有效的归纳可能复杂的来源，因为它们往往依赖于值得为何种功能付出
复杂度代价的精微判断。可能接口复杂度往往缘于让用户感觉更加好用、而非程序基本
功能的附加便利性。代码库规模大小的可能增涨（假设用户可视的功能和采用的算法固
定不变）通常来自于使其更具可维护性的不同实践――增加吏多注解，使用更长变量名
称等等。工程所涉及的任何方面均可产生可能实现复杂度。
    复杂度的不同来源必须以不同方法应对。代码库规模可以采用更好的工具来解决。
实现复杂度可以选择更好的算法来处理。接口复杂度必须着眼于更好的交互设计，一种
UNI×编腥艺术
  www.pdf365.com
302
第13章复杂度：尽可能简单，但别简单过了头
考虑了人类工程学和用户心理学在内的技能。这种技能，比编码能力更为少见（并可能
更加困难）。
    另～方面，处理各种复杂度，必然更仰赖于见识而非方法。通过发现更简单的方法，
可以去除偶然复杂度。依赖上下文环境判断哪些功能值得去做，可以去除选择复杂度。
而要去除本质复杂度，就只能通过对现实真谛的洞察和顿悟，从根本上重新定义所要解
决的问题。
13.1.5当简洁不能胜任
    对于Unix坚持简单的传统，往往伴随着一种错误的理解模式，Unix程序员常常认
为（有时甚至依此行事）似乎所有的可能复杂性都是偶然复杂性。更为甚者，在Unix传
统中存在一个强烈的偏好，宁可去掉功能，也不接受可能复杂性。
    这种态度的例子很容易产生（的确，本书大部分内容就是防止这个的）。干净的简约
主义让我们在多个层面上感觉良好，为此设计也是非常有价值的防范措施，能够防止软件
系统表面光鲜但内里功能不足的自然趋势。但是，计算资源以及人类的思考，同财富一样，
不是靠储藏而是靠消费来证明其价值的。同其它美学形式一样，我们需要注意何时设计上
的简约已经不再是有价值的自律形式，而开始成为一件伪装的苦行者外衣――一种实陈上
把美德作为借口来敷衍工作的纵容方式。
    这是一个危险的问题，确实太容易变成支持彻底抛弃良好设计准则的论据。Unix老
手常常羞于谈及，害怕防范复杂臃肿可能的最坚固阵线无法扼守，会将我们推向无情的
毁灭。但它避无可避。我们会在分析本章的研究实例中直接处理它。
13.2五个编辑器的故事
    现在我们将使用五个不同的Unix编辑器来作为案例。在检视这些设计时，在心中牢
记以下基准任务会非常有用：
●  纯文本编辑。即操作纯ASCII（在如今这个国际化的时代，也许是Unicode）文
  件，编辑器只知道其字节或者行结构。
www.pdf365.com
13.2五个编辑器的故事
303
●  富文本编辑。即编辑带有属性的文本：这些属性可以包括字体的变化，颜色或
    者其它类型的文本内属性（比如一个超链接）。具备这种能力的编辑器必须能
    够在某个用户界面的属性表示同磁盘上的数据表示之间进行转换（例如HTML、
    XML或其它富文本格式）。
●  句法感知。一个句法感知的编辑器知道输入事件存在语法，在识别出编程语言
    中一个范围块的开始或结束时能够自动更改缩进级别，或其它类似动作。一个
    句法感知的编辑器一般也能够以不同的颜色或特别的字体加亮文本。
●  批命令输出的输出解析。Unix世界最常见的情况就是从编辑器内运行一个C编
    译器，捕捉其错误信息，从而无需离开编辑器就能够跳至任何出错地点。
●  同辅助子进程交互。这些子进程在不同的编辑器命令间保留和维护状态。当具
    备这种能力时，会产生以下强大的结果：
    ●从编辑器内部可以驱动版本控制系统，无须离开编辑器到～个shell窗口或
    独立的公用程序就可以实施文件的检入检出（checkin/checkout）。
    ●编辑器可以作为符号调试器的前端，当发生那些诸如调试程序运行停止在
    某个断点上之类的情况时，编辑器可以自动访问恰当的文件及其文本行。
    ●通过识别指商另一个主机的文件名  （比如符合
    /us-er@host：/path/to- firle语法），可以在编辑器内编辑远程文件。
    假设拥有访问权，这类编辑器可以自动运行诸如scp （1）或ftp （l）的公
    用程序获取本地的一个拷贝，然后在保存文件时自动地将编辑后的版本传
    回远程位置。
    我们分析的所有实例都可以编辑纯文本。  （读者不应该把这种能力视作理所当然――
还有许多称之为编辑器的东西，比如“字处理器”，就太过于专用化而无法编辑纯文
本！）下面我们就开始来了解这些编辑器在处理更复杂任务时产生的不同程度的选择
复杂度。
UNIX编鼹艺-求
  www.pdf365.com
304
第13章复杂度：尽可能简单，但别简单过了头
13.2.1  ed
    ed （l）是真正Unix简约主义者编辑纯文本的方式。它自电传打字机时代就存在。3它
有一个简单俭朴的CLI:没有屏幕显示。在接下来列出的实例中，着重突出计算机输出。
ed sample．tx匕
sample. txL:  No  such  file  or directory
#这是注释行，不是命令。
抖上面的信息警告sample．txt是新创建的。
a
the quick lorown fox
jumped over the lazy dog
{}那是一个追加命令，表示向文件加入文本。
}}一个点号占据一行表示追加文本的结束。
1s/f[a-z] x/dragon/
#在第一行，用‘dragon’替换第～个匹配f后接任意a-z的小写字母再后接x的字符串。
样lowercase  alphabetic  followed  by x with  'dragon..  The
样substi七ute comrnand accepts baslc regular expressions.
}}替换命令接受基本的正则表达式。
l，$p
the quick brown dragon
jumped over the lazy dog
#从头到尾打印所育的行。
W
5 1
}}将文件写到磁盘上。‘q’命令结束编辑对话。
# editing session.
q
    对于现代读者来说这似乎难以置信，绝大多数Unix的最初代码都是用这个编辑器编
写的。有DOS经历的读者在这儿可能会辨认出这是行编辑器EDLIN的粗糙原型。
    如果把编辑器的工作定义为仅仅让用户创建和修改纯文本文件，那么ed （1）足堪
使用。从Unix设计有关正确性的观点来说，重要的是它不做别的任何事情。许多1日学派
的Unix程序员半认真地坚持所有功能比ed更多的编辑器都是臃肿的――并且少数仍然
～丝不苟的坚信这个观点。
实际上，ed是Ken Thompson对早期qedRitchieQEDl编辑器的有意简化，qed编辑
3年轻读者可能不会知道那些终端是打印的。在纸上打印。非常慢。
www.pdf365.com
13.2五个编辑器的故事
器――跟ed非常相似（而且是第一款以Unix特有方式使用正则表达式的编辑器）但具
备Ken故意放弃的多缓冲区能力。Ken认为它不值得付出更多复杂度。
    ed （1）及其所有衍生品最显著的特征就是命令的对象操作格式（上述对话实例展示
了’p’命令作用的明确指定行范围）。可以有相对强大的语法来指定行范围，或者以数字
形式，或者用正则表达式来模式匹配，或者用当前行和末行的简捷表示方式。多数编辑
操作都可以在任何范围起作作。这是一个良好的正交性实例。
    今天，耐（1）主要作为在脚本中由程序驱动的编辑工具来使用――具有更复杂交互
模式的编辑器并不适合此用。有～个很相似的称为e（1）的变种，增加了一些例如命令
提示之类的交互特性；在一些非常罕见的情况下，例如必须通过非常缓慢的串行线来完
成编辑，或者在某个不同寻常的崩溃恢复情况下，程序库支持需要运行的其它编辑器无
法访问，ed （1）就有用武之地了。正是这些原因，每个Unix版本都包含了一个ed的实
现，而多数Unix版本也同样包含了ex。
    sed（1），这个在第9章提到的流编辑器也与ed紧密相关；许多基本命令完全一样，
但sed设计为通过命令行开关调用，丽非读取标准输入。
    几乎所有的Unix程序员都已经偏离了苦行和简约主义的美德，通常使用至少拥有
roguelike这种面向屏幕界面的编辑器。4然而，坚持ed的虔诚道出了许多值得关注的Unix
思想。
13.2.2  vi
    最初的vi（1）编辑器是将可视的roguelike界面套到ed （l）命令集上的首次尝试。
与ed一样，它的命令通常是单键式，特别适合可以盲打的人使用。
    鼠标支持、编辑菜单、宏、指定键盘绑定，或是任何形式的用户定制在最初的VI中
都没有。追随ed的信仰，VI的信徒认为这些功能特性的缺乏恰恰是个优点。从这个角度
来说，Vl编辑器最重要的一个美德就是，在新的Unix系统上可以立刻开始编辑，而无须
转移原来的定制或担心默认的命令绑定会危险地与习惯相悖。
    Vi使初学者饱受挫折，这是由于其简明扼要、单键击发式命令所致。它有一个模式
界面――或者处于命令模式，或者处于文本插入模式。在文本插入模式，可用的命令仅
4著名的一个Usenet帖子就是ed信仰的例证之一，读者可以通过网络搜索“Ed is the standard editor”
找到这个a尽管都知道这是个调侃，但毫无疑问这决不是完全的玩笑话。多数黑客都会将此认作是
”Ha ha，only serious”的实例。
UNIX编，程之≥长
    www.pdf365.com
306
第13章复杂度：尽可能简单，但别简单过了头
仅只有使用ESC键退出该模式以及（在新版本中）光标移动键。在命令模式，键入的文
本会被解释成各种命令，而且还会给文本内容带来奇怪的（可能是毁灭性的）后果。
    另一方面，VI拥趸特别吹捧的一个命令集特性就是继承来自ed的对象操作格式。大
多数扩展的命令也可以自然地用于任何行范围。
    年复一年，vi已经相当庞大了。现代的版本加入了鼠标支持、编辑菜单、无限撤销
操作（最初的Vi仅仅只支持撤销最近的一次命令），独立缓冲区的多重文件，以及用运
行控制文件进行定制。然而，运行控制文件很少使用，与Emacs相比而言，内嵌通用脚
本的使用也不流行。相反的，通过加入C代码到编辑器本身，VI实现已经发展出独立完
成任务的能力，例如C代码的语法感知以及C编译器错误信息的输出解析。VI编辑器不
支持子进程的交互。
13.2.3 Sam
    Sam编辑器5在八十年代中期由Rob Pike在贝尔实验室编制而成。Sam是为我们将在
第20章讨论的Plan 9操作系统而设计的。虽然Sam编辑器在贝尔实验室外并不广泛为
人所知，但许多参与了最初Unix设计而后来又继续用Plan 9工作的开发者都很喜欢，包
括Ken Thompson奉人。
    Sam编辑器是ed -个相当直接的后裔，比VI更接近它们的父辈ed。Sam仅仅只加
入了两个新观念：curses风格的文本显示和能够用鼠标选中文本。
    每个Sam对话都只有一个命令窗口，以及一个或多个文本窗口。文本窗口编辑文本，
命令窗口接受ed风格的编辑命令。鼠标用来在两个窗口间进行切换，以及用来在文本窗
口内选择文本区域范围。这是个干净、正交、无模式的设计，避免了VI的大部分接口复
杂度。
    绝大多数命令操作默认地施用在一个可以由鼠标拖拽操作绘出的选中区域上。一个
命令的选中区域也可以用ed方式的行范围指定来设置，但Sam允许用户选择比行单位
更精确的粒度，这让Sam获得了相当可观的威力。因为可以通过鼠标选择和快速地在缓
冲区（包括命令缓冲区）间切换，所以Sam不需要和vi编辑器等价的默认（命令）模式。
许多VI的扩展命令都成为多余，而在Sam中被删除了。总之，Sam编辑器只在ed命令
5  ht t-p : / /plan9 . bell-labs _ com/ sys/doc/sam/ sam . h七ml
UNIX编I程艺：术
www.pdf365.com
13.2五个编辑器的故事
307
集的17个命令中增加了12个，总共加起来不超过30个。
    Sam编辑器的四个新命令加上两个继承自ed （1）和vi （l）的命令，作为应用正则
表达式的方法来完成施用在选定文件或文件区域上的任务。这些为命令语言提供了有限
的但是有效的循环和条件功能。然而没有方法可以命名或给命令语言过程加上参数。语
言同样不能交互控制一个子进程。
    Sam -个有趣的特点是它被分成了两个部分，将处理文件和搜索的后端从处理屏幕
界面的前端分离开来。这个“分离引擎和接口”的实例拥有立杆见影的实践收益，尽管
程序具有GUI部分，但仍然可以很容易地通过一个低带宽的连接就可以编辑远程服务器
上的文件。同样，前端和后端可以相对容易地重新改用。
    Sam编辑器，像Vl的最近版本一样，支持无限撤销操作。Sam编辑器被设计为既不
支持富文本编辑，也不支持输出解析，还不支持子进程交互。
13.2.4  Emacs
    Emacs无疑是现存最强大的程序员编辑器。它是一个庞大的、功能丰富的程序，具
有强大的灵活性和可定制能力。正如我们在第14章Emacs Lisp部分描述的一样，Emacs
拥有一个完整的编程语言，可以编写出任何强大的编辑器功能，
    与vi不同，Emacs没有各种界面模式；相反地，命令通常都是以控制字符或者ESC
在前引导。然而，在Emacs中，可以将任意的命令绑定到任何的按键序列，而且命令可
以是库中的或定制的Lisp程序。
    Emacs可以编辑多个文件，每个置于独立的缓冲区内，同时支持在这些不同的缓冲
区内移动文本。在X下的版本本身具有鼠标支持。
    绑定在Emacs按键上的Lisp程序可以在～个缓冲区里执行任意的文本变换。这种功
能频繁使用，尤其是在为许多不同语言和标记格式（正如从VI开始支持的C代码颜色加
亮，但并不仅限于此）定义语法感知和富文本编辑模式中。每种模式都是简单的Lisp代
码库文件，可以在需要时加载。
    Emacs Lisp程序也可以交互地控制任意子进程。这种能力的一些明显结果已经在早
些时候列出：可以作为版本控制系统、调试器等前端服务的能力。
UNIX编睡；艺术
  www.pdf365.com
308
第13章复杂度：尽可能简单，但别简单过了头
    Emacs的设计者建立了一个可编程的编辑器，6可以将与任务相关的知识定制进去，
以针对数以百计的不同类特殊编辑任务。设计者赋予了它可以驱动其它工具的能力。结
果就是Emacs支持在一个共享的上下文环境中处理所有的文本操作――文件、邮件、新
闻、调试符号。它可以用作任何拥有交互文本界面命令的定制前端。
    有个流行的笑话，Emacs的支持者和批评者都知道，在这个笑话中，Emacs被描绘
为伪装成编辑器的操作系统。这有些过于夸大，但Emacs当然完全成功扮演了非Unix
操作系统上集成开发环境（lDE，我们将在第15章回头讨论这个议题）的角色。
    这种强大来自于复杂度的代价。要使用一个定制化的Emacs，就必须携带定义个人
Emacs参数选项的Lisp文件。学习如何定制Emacs简直就是门学问。Emacs因此要比V1
更维学习。
13.2.5  Wily
    Wily编辑器7是Plan 9 acme编辑器的一个翻版8。它有些功能同Sam编辑器相似，但
目的是提供一个全然不同的用户体验。尽管Wily可能是所有这些编辑器使用范围晟小的
～个，但仍相当有趣，因为它展示了～种不同的、存在争议晌、更Unix的方式来实现类
似Emacs的可编程编辑器。
    Wily可以视作是满足最低要求的IDE，可以视作是Emacs风格可扩展性的～个实现，
而无伴随Emacs数十年之久的累赘。在Wily中，甚至作为Unix编辑器要素的全局搜索
和替换，都由外部程序提供。内建的命令几乎毫无例外地同窗口操作相关。Wjly设计之
初就完全支持尽可能多地使用鼠标。
    Wily并不仅仅试图取代常规的编辑器，同时试图取代诸如xterm（1）的终端窗口软
件。在Wily中，主窗口（其中包含多个不重叠Wily窗口）中的任何文本都可以是一个
行为或搜索表达式。使用鼠标左键来选择文本，使用中键将文本作为～个命令执行（内
6 Emacs的设计者是Richard M. Scallman. Bemie Greenberg和Richard M. Stallman。原始Emacs是
Stallman发明的，第一个拥有内嵌Lisp的版本出自Greenberg，而现在的权威版本是Stallman继承自
Greenbergo在2003年，t，macs的设计历史还没有完整的档案，但Greenberg的Multics Emacs: The
History， Design， and Implementation （Multics Emacs:厉史、设计和实现）有些说明，通过网络上的关键
字搜索可以很容易地找到。
7  http:／/www. cs .yorku. ca/~oz/wily
8  http:／/plan9. bell-labs. com/ sys/doc/acme/acme. ht ml
UNIX绸翻呈艺术
www.pdf365.com
13.3编辑器的适当规模
309
建的或者外部的），使用右键来在Wily的缓冲区或文件系统中搜索文本。不需要主菜单
或弹出菜单。
    在Wily中，键盘仅仅就是为输入文本而用的。快捷方式不使用键盘的特殊用法，而
是采用同时按下不止一个鼠标键的方式。这些快捷方式总是等价于使用鼠标中键激发某
个内建命令。
    Wily也可以作为C、Python和Perl程序的前端使用，无论何时一个窗口改变了，或
一个执行、搜索命令通过鼠标完成后，都可通知那些程序。这些插件功能很像Emacs的
模式，但和Wily并不运行在统一地址空间；相反地，它们通过一个非常简单的远程过程
调用集合同Wily通讯。Wily编辑器常常打包了一个类似xterm的程序并使用它作为编辑
前端的邮件工具。
    因为Wily太过于依赖鼠标，所以它不能使用在仅仅只支持字符阵列的控制台显示
上；也不能使用在没有X转发（X forwarding）的远程连接上。作为一个编辑器，Wily
是为编辑纯文本而设计的；它只有两种字体（一种比例字体和一种等宽字体），也没有
可以支持富文本编辑或语法感知的机制。
13.3编辑器的适当规模
现在让我们用本章开头展示的复杂度分类来研究这些案例。
13.3.1  鲰别复杂度问题
    每款文本编辑器都有一定量的本质复杂度。至少，它必须支持文件或多个文件的内
部缓冲区拷贝。最低要求是文件数据的导入导出功能（通常是磁盘存取，尽管流编辑器
sed（1）是个有趣的例外）。某种修改缓冲区的方法必须支持，但是没有功能描述的话，
我们无法指定用何种方法。而我们四个例子展示的各种可能偶然复杂度级别非常宽泛，
不限于此。
    在几个编辑器当中，ed （l）复杂度最低。在其命令集中，不正交的功能特性也就是
许多命令接受“p"或“l"的后缀来打印或是列出命令结果。即使这三十年来功能不断
增加，编辑命令还是少于三十个，而大多数用户常用的命令～般也少于十二个。编辑器
没有太多的选择复杂度可以去除，也根本难以确定任何偶然的复杂度。ed的用户接口非
常紧凑。
UNIX编程艺l术
  www.pdf365.com
310
第13章复杂度：尽可能简单，但别简单过了头
    另～方面，ed接口并不真正适合完成编辑任务，甚至包括快速翻看文本文件这样的
基本任务。对于交互编辑，要让ed作为可接受的解决方案，就不得不严格限制编辑目标。
    如果我们加入“支持可视化浏览／编辑多个文件’’的目的又如何昵？通过最小的ed
扩展而达到目标，Sam编辑器似乎与此需求很接近。显然，其设计者并未改变继承自ed
命令集的语义；他们保持了现有的、正交的命令集合，同时增加了一个相对较小、自身
也是正交的能力集合。
    复杂度的巨大增涨可能（实现）源于Sam编辑器的无限撤销能力。另一个显著的增
涨是命令语言中新增的基于正则表达式的循环和迭代功能。这些，加上鼠标能够作为选
取设备使用的事实，使得Sam编辑器同一个即使具备了鼠标和窗口界面的ed编辑器仍
有显著差别。
    任何Sam编辑器中的偶然复杂度，如果没有全盘的代码审计，都难以确认；而在设
计层面，也确实难以甄别。接口至少是半紧凑的，至于严格的紧凑则存有争议。这个编
辑器做到了最高级别的Unix设计标准――想想它的出身，这并不奇怪。
    比较而言，VI看起来相当臃肿而不紧凑。存在上百条命令，许多都是重复的。这些
复杂度充其量只足可能性或偶然性的。据推测，多数用户知道的命令集不会超过5%。由
于在我们面前有Sam的例子，当然会奇怪Vl的接口复杂度为什么会如此之高。
    在第1 1章我们讲述了早期roguelike程序由于缺乏标准箭头键所带来的后果：VI程
序正是这当中的一员。在编写Vl的时候，作者知道许多用户需要能够使用Unix“玻璃电
传打字机”上传统的光标移动键。这使得模式接口无法避免。一旦hjkl键在编辑缓冲区
中的意义依赖于模式，就实在太容易陷入以专用方式增加新命令的习惯。
    Sam编辑器，既然依赖于兼具箭头键和鼠标的位图显示，自然可以简洁得多。也确
实如此。
    但是VI命令的杂乱只是一个相对表面的问题。VI存在接口复杂度，没错，却是那种
多数用户确实可以忽略的（从第4章我们所述的角度来说，接口是半紧凑的）类型。深
层次的问题是个专用陷阱。历经多年，VI已经日益拴合了越来越多的C代码来执行某些
任务，而这些任务，Sam编辑器拒绝完成，Emacs编辑器以Lisp代码模块和子进程控制
来解决。在Vl中，扩展并不象Emacs中一样作为扩展库需要时才载入进来；用户始终必
须为随之而来的臃肿代码付出代价。结果，现代Vl和现代Emacs之间的规模差剐远非人
们想象的那般大；在2003年中期，在Intel体系的机器上，vim有1500KB，而GNU Emacs
是900KB。在这900KB中还有～大堆选择和偶然复杂度。
www.pdf365.com
13.3编辑器的适当规模
31 1
    对于vi信徒，没有一个内嵌的脚本语言――不是Emacs-已经成为一致性问题，
成为VI是个轻量级编辑器这个共享传奇的核心部分。虽然Vl发烧友喜欢讨论用外部程序
以及脚本过滤缓冲区来达到Emacs内嵌脚本所能完成的事情，但现实是Vl的“！”命令
不能够在比行范围更高级别的粒度上对选择的缓冲区进行区域过滤（Sam和Wily，尽管
并没有比V1更多的子进程控制，至少能够在文本的任意范围上进行过滤，而不仅仅只是
行范围）。所有在一个更小粒度上有所区别的文件格式和语法知识（大多都有区别），
如果V1编辑器需要能够访问，都必须编写进C代码中。这样在Emacs和V1代码库规模
大小的比例上，几乎没有希望能在V1方面得到改善：的确，这似乎可能更糟。
    Emacs十分庞大，其历史也十分夹杂不清，所以如果要将它的选择复杂度从偶然复
杂度中分离出来是一个相当大的挑战。但我们至少可以把Emacs设计中可有可无的偶然
复杂度从不可或缺的本质复杂度中分离出来作为起点。
    也许Emacs设计中最可有可无的部分就是Emacs Lisp。我们今天称之为内嵌脚本语
言的特性对Emacs而言是必要的，但如果那个语言是Python成Java或Perl的话，Emacs
在能力上也不会有什么不同。然而在1970年代进行tmacs设计的时候，Lisp是唯一拥
有某些特征（包括类型种类无限以及垃圾收集）、适合完成这项任务的语言。
    大部分Emacs事件处理以及位图显示器驱动（包括国际化支持）的特殊方式都属于
偶然复杂度。在其历史上最大的分裂（GNU Emacs和XEmacs分支）就涵盖了这个问题，
并且也展示了余下的设计并不是非优选或要求哪种事件驱动模式不可。
    另一方面，把任意事件序列绑定到任意内置或用户定义功能的能力是不可或缺的。
脚本语言可以换掉，事件模型也可以改变，但是如果不是任何对象都因连接方式不同而
呈现不l刊面貌，Emacs设计就不成气候也不成其为自身了。这样，扩展模式不得不为了
有限事件集的所有权而彼此斗争，而且激活同一缓冲区的多重协作模式也十分困难或者
根本就不可能。
    随着Emacs -道发布的巨大扩展模式库也同样属于偶然复杂度。构建这种扩展的能
力也许是必要的，然而某个专用集合却是历史和偶然的产物。全部扩展都可以不同或被
替换；Emacs结果还是Emacs，面貌依旧。
    但是子进程交互是不可替代的。没有它，Emacs模式就不能够怍为各种不同工具的
IDE环境或前端。
    一些小型的编辑器复制了默认的键盘绑定以及Emacs的外观，但没有模仿它的扩展
能力，这样的经验是很有意义的。已经有好几个这样的克隆，其中最著名的大概非
UNIX编程艺术
  www.pdf365.com
3 12
第13章复杂度：尽可能简单，但别简单过了头
MicroEmacs和pico莫属，但都没能获得大量的追随者。
    鉴别Emacs设计中哪些本质、哪些偶然，可以帮助我们理解它的复杂度哪些是可能
性、哪些是偶然性的。然而，更重要地，这帮助我们透过上述三个编辑器表面的不同，
而直达关键之处：事实上Emacs设计的目标非常宽泛。Emacs想要成为所有文本处理工
具的统一接口。
    Wily跟Emacs形成有趣的对比。同Sam -样，选择复杂度含量很低；Wily用户接
口仅用一页纸就可以简明扼要地描述清楚。
    但是优雅是有代价的；除了有限的鼠标组合动作之外不可能将功能绑定在任何的按
键或是输入手势。除了基本的文本插入和删除之外的任何编辑功能都必须以外部的程序
来代替实现：一个独立的脚本，或是一个可以侦听Wily输入事件的专用共生进程。（前
者技术上依赖于外部程序的启动必须非常迅速、不会产生可觉察的界面延迟，这在诞生
Emacs的环境中或是首次移植到的各种Unix下都绝对不成问题。）
    Emacs因采用Lisp扩展模式实现而导致的选择复杂度，在Wily中相应地分布在专
门化的共生体中；每个共生体都必须知晓Wily特殊的消息接口。这种有式的一个优点就
是这样的共生体可以由用户选择的任何语言来编写。另外，共生体（因为它们在外部运
行）不会彼此影响或危害Wily核心（Emacs的各种模式并非如此）。这种方式的一个缺
点是Wily自身不能直接与普通的Unix工具进行予进程交互。
    在这个或其它方式上，wily的分布式脚本机制并不如Emacs的内嵌脚本那样强大有
效。Wily的目标范围相对狭窄；作者放弃了在感知语法编辑或富文本编辑方面的功能，
例如，Wily以及它Plan 9的祖先acme都不处理这些事情。
    这里以一种更尖锐的方式来提出本章的中心问题：什么时候一个庞大程序的宏伟目
标是正当而有效的？
13.3.2折中无用
    Sam和VI的比较，显著昭示了至少在涉及编辑器方面，试图在简约主义的ed和无
所不能的Emacs之间进行折衷是达不到好效果的；Vl尝试这样去做，结果两头落空，而
掉进了过度专用的陷阱。Wily则规避了这个陷阱，但是威力无法跟Emacs相比，并且为
www.pdf365.com
13.3编辑器的适当规模
3 13
了无论在何处都能结合紧密，每个交互的共生体必须提供一个定制的进程接口。
    显然有关编辑器的某些方面往往将其推向更高复杂度。在vi的例子中，这不难甄别；
那就是对便利性的渴望。尽管ed或许在理论上是够用的，但是很少有人（也许除了Ken
Thompson自己）会为了声讨软件的臃肿而放弃面向屏幕的编辑。
    更普遍地，在用户和外部事务间调和的程序往往加入各种功能，这一点臭名昭著。
不仅是编辑器，网页浏览器、邮件和新闻组阅读器以及其它通讯程序，所有这些软件的
发展都遵循“软件信封定律”，即Zawinski定律：  “每个程序都试图扩展直到能够阅读
邮件。不能如此扩展者，将被能者取代。”
    Jamie Zawinski，定律的发明人（Netscape和Mozilla网页浏览器的主要作者之一），
主张更一般的情况：所有真正有用的程序都想变成瑞士军刀。在Unix世界外大型的成功
商业整合应用程序套件通常也证实了这～点，而且直接挑战了Unix的最简哲学。
    某种程度上，Zawinski定律是正确的。它表明有些程序需要小巧，有些程序需要庞
大，但中间道路是行不通的。V1编辑器的表面问题可以归咎于历史，然而更深层欢的问
题应该追溯到增加功能的压力同vj信徒，往往由此联系到过度规模，而拒绝增加与内嵌
脚本语言和子进程控制功能的结合。在～个不同的级别上，接受了接口中存在两种方式
（插入和特性运动），将会捅到马蜂窝――添加新功能很容易根本考虑不到对整体设计
的复杂度影响。
    Emacs和Wily的例子进一步表明，为什么有些程序需要做得如此庞大：这样几个相
关任务就可以共享环境。从实现者的角度，编辑和版本控制（或者编辑和邮件操作，编
辑和符号调试等等）是独立的――但是用户经常更愿意有一个大的环境让它们能够指向
文本部分，无需花费时间和精力在拥有相同文件名或是相同剪切内容的程序之间切来切
去。
    更普遍地，让我们假设整个Unix环境可以视作是社区的单一设计工作。那么“小巧
锐利工具”的教义，降低接口复杂度和代码库规模的压力，可能正好会导向过手工
（ manularity）陷阱――用户不得不自己维护所有共享的上下文环境，因为工具并不会为
他完成此项工作。
    返回编辑器的特定背景，Sam向我们展示了V1是个错误。Wily是避免巨大Emacs
的勇敢尝试，但却因功能不足不能感知语法。但是Wily，或者某个彻底卸掉了历史包袱
的Emacs设计思想实现舨本，也许是正确的。选择复杂度的价值依赖于对目标的选择，
UNIX编曜艺l宋
  www.pdf365.com
314    第13章复杂度：尽可能简单，但别简单过了头
而在所有与任务相关的面向文本工具间共享上下文环境的能力是非常有价值的。
13.3.3  Emacs是个反Uni×传统的论据吗
    传统的Unix世界观，极其依恋简约主义，所以并不擅长区分VI的专用陷阱问题和
Emacs的选择复杂度。
    Vi和Emcas在老派的Unix程序员中从不流行的原因是丑陋。这个抱怨也许
是“老Unix”的话语，但如果不是老Unix的单一风味，  “新Unix”就不会存在
-Doug Mctlroy
    VI用户对Emacs的攻击――同仍旧依恋ed的旧学派中坚分子对vj的攻击一道――
是一个更大争论的一段情节，～场富有和俭朴之间的品德角逐。这个争论同新老学派Unix
风格之间的冲突有关。
    “老Unix的单一品味”部分是同日本简约主义一样贫穷的结果――学会在无法获得
更多条件的情况下最有效地以少量资源完成更多任务。但是Emacs（以及在威力强大的
PC机和快速网络上重新发明的新学派Unix）却是财富之子。
    同旧学派的方式不一样。贝尔实验室资源丰富，所以Ken不会被受限去写一
个过时产品。想想Pascal因为没有足够的时间写封短信而抱歉信写长了。
    -Doug Mcilroy
肌那时起，Unix程序员就一直维持着在过度花费上追求一流的传统。
    另一方面，Emacs的庞大，并非源自Unix，而是由于Richard M. Stallman在一个不
同的文化中发明了它-1970年代繁荣的MIT的人工智能实验室。这个实验室是计算机
科学院校最富裕的地方之一；那里的人们学会了把计算资源当作廉价资源，并预测了一
种在别处直到十五年后才可行的态度。Stallman可不关心简约主义；他追求的是代码最
大功用和最广适用范围。
www.pdf365.com
13.3编辑器的适当规模
315
    少吃多干还是多吃多干，～直是Unix传统的主要冲突。这个冲突在许多不同的背景
下重现，往往在不断地挣扎在具备干净简约主义品性的设计和不惜以高昂复杂度代价而
选择表达力范围和威力的设计之间。自从1980年代初期Emacs第一次引入Unix之时起，
便有了支持与反对的冲突双方。
    诸如Emacs那样既有用又庞大的程序会使Unix程序员极不舒服，恰恰因为它们强迫
我们面对这种冲突。这些程序表明，旧学派Unix的简约主义作为一个原则虽然有其价值，
但我们可能已经陷入教条主义的错误之中。
    Unix程序员可以有两种方式解决这个问题。一种就是否认：大实际非大。另一种就
是发展出一种考虑复杂度的不是教条的方法。
    替换掉Lisp和扩展库的实验思想赋予我们一个新的角度，来看待对Emacs由于扩展
库庞大而臃肿的再三控诉。抱怨Emacs大，和把系统中所有shell脚本都算上而抱怨
／bin／sh大，同样是不公平的。Emacs可以视作是一个围绕在小巧锐利工具集合上的虚
拟机或框架，只不过这个工具集恰好是用Lisp编写罢了。
    从这个角度，shell和Emacs的主要区别就在于Unix发布者并没有把所有的shell踯
本都同shell -起发布。因为Emacs内置了感觉臃肿的通用语言而反对Emacs，就像因为
shelll具有条件和for循环而拒绝使用shell脚本一样无聊。如同并非必须学习shell脚本才
能使用shell -样，使用Emacs也不是非学习Lisp不可。如果Emacs存在设计问题，与
其说是Lisp解释器的问题，还不如说是模式库历史性增长成为一堆乱麻的问题――然而
这是一个用户可以忽略的复杂度来源，因为用不到的部分并没有影响。
    这种论证方式非常令人鼓舞。可以应用到其它的工具整合框架中，例如（令人不舒
服的庞大的）GNOME和KDE桌面项目。这种方式在那里也有效（说服力）。而且，同
样地，我们必须怀疑任何可以如此优美地解决所有疑问的“观点”；它只能是个合理原
则，而不是基本原则。
    因此，让我们避免否认或接受Emacs既有用又庞大――这其实是反对Unix简约主义
的论据。在我们对Emacs复杂度种类和动机的分析中，还有什么更意味深长的暗示？又
有什么理由相信那些从教训归纳出来的东西？
UNIX编程艺l宋
    www.pdf365.com
3 1 6
第13蕈复杂度：尽可能简单，但别简单过了头
13.4软件的适度规模
    小巧锐利工具的Unix教义隐藏着二重性；许多Unix从业者都没有注意到，一个十
分不明显的背景，就像鱼没有注意到它游着的水一样。这就是框架的存在。
    Unix风格的小巧锐利工具存在数据共享的困难，除非它们能生存在彼此之间通讯便
利的框架结构之中。Emacs就是这样一个框架，而对共享上下文环境的统一管理正是其
选择复杂度换来的。共享上下文统一管理的实际效果就是用户不需要负担底层的命名和
资源管理问题。
    在旧学派的Unix中，唯一的框架就是管道、重定向以及shell;整合工作由脚本完成，
而共享上下文环境（本质上）就是文件系统本身。但这并不是进化的终点。
    Emacs将非常多的文本缓冲区和援助进程同文件系统统一在～起，大大超越了shell
框架。Wily也有缓冲区和援助进程，但将shell框架也并进了自身。现代的桌面环境为
GUI提供了一个通讯框架，也大大超越了shell框架。每种框架都有自身的优点和缺点。
而框架成为了各种工具生态系统之家――例如shell之于脚本，Emacs之于Lisp模式，或
者桌面环境之于众多通过拖放以及诸如对象代理（object broker）乏类更为复杂的GUI
通信方式。
    最简原则暗示：选择需要管理的上下文环境，并且按照边界所允许的最小化方式构
建程序。这就是“尽可能简单，而不过于简单”，集中关注选择共享上下文环境。实际
上，这并不仪仅适用于框架，也适用于应用和程序系统。
    然而，究竟共享上下文环境该有多大实在很容易草率对待。隐藏在Zawinski定律后
的压力往往驱使应用程序需要为便利性而共享上下文环境。很容易因为负载太多任务、
太多需求设想而最终失败，也很容易就把程序编制得过于复杂、臃肿和庞大。上世纪九
十年代的例证是，“mailto:URL"导致了越来越多网页浏览器中内嵌了庞大的邮件客户
端。
    矫正这种趋势的方法直接来自于旧学派Unix的赞美诗集。这就是吝啬原则：只有实
证了其它方法行不通时才写庞大程序――也就是，已经尝试过分解问题但遭到失败。格
言表明了对待庞大程序的～种严谨怀疑态度以及一种谨慎的策略方法：首先寻找小巧程
序的解决方案。如果单个小程序无法完成这项工作，尝试在现有框架结构内构造一个协
作小程序工具包来解决问题。如果两者都失败了，才可以自由地构建一个巨型程序（或
一个新框架），而不会觉得已经完败于设计挑战。
www.pdf365.com
13.4软件的适度规模
3 17
    当编制一个框架时，牢记分离原则。框架是机制，尽可能少地包含策略。在多数情
况中，根本就不需要什么策略。尽可能多地将行为分解到使用框架的模块中去。编制或
重用框架的好处之一，是能够有益于将“不这样做会是大块策略”的东西分离到独立的
模块、模式或工具――可以有效地同其它程序重新组合起来的部分中去。
    这些准则是颇有价值和启发性的方法，但是Unix传统深处的这种矛盾冲突，并不能
将任何给定的工程划为合理的最佳规模，并分而治之。具体情况具体分析，而锻炼良好
的判断力和品味恰好是软件设计者所追求的。正如曹洞禅所说，行程才是目的；顿悟在
每日的实践中。
UNIX鳎翻星YaC
    www.pdf365.com
www.pdf365.com
PartⅢ
Implementation
www.pdf365.com
www.pdf365.com
1 4
  r  C还是非C
、五言．
口亡=I．
Languages: To C or Not To C
14.1  Unix下语言的丰饶
The limits of my language are the limits of my world.
    Tractatus Logico-Philosophicus 5.6， 1918
    我语言的极限便是我世界的极限。
    《逻辑哲学论》5.6， /9/8
    一路德维希-维特根斯坦
    Unix所支持的应用程序语言，其范围比当今其它任何一种操作系统的都要广泛：事
实上，Unix上运行的语言种类完全可能超过计算史上其它所有操作系统的总和1。
    至少有两个充分的理由造成了这种巨大的多样性。一是Unix广泛用于研究和教学平
台。另外一个事实（同程序员更加密切的）是，应用设计和实现语言的合理搭配对生产
力有极大促进。因此，Unix传统鼓励专门领域语言的设计（正如我们在第7章和第9章
所述）和现在…般称为“脚本语言”的东西――为了把其它应用程序和工具胶合起来而
专门设计的语言。
1详情参见  Free  Compiler and  Interpreter List  （自由编译器和解释器总表）
<f tp:／/f tp. idiom. com/pub/   compilers-list/free-compilers>。
UNIX缟程艺．术
  www.pdf365.com
322
夸占1』音0E言．广、节K量j-Fr、
，由l叶早k]口：  o Zl二天E_'卜U
    术语“脚本语言’’可能源自术语“脚本”，它用于为一个通常情况下的交互
程序提供简短输入，特别是sh或ed-这个术语比我们从Unix前辈CTSS那儿
继承下来的术语“runcom”更合适。  “脚本”最早出现在V7手册（1979年）中。
我不记得是谁造就了这个字。
    -Doug Mcllroy
    说实话，  “脚本语言”是个有点蹩脚的术语。很多通常这么称呼的主要语言（ Perl、
Tcl、Python等）都已经超越了最初意义的脚本用途，已经成为威力相当强大的独立通用
编程语言。一些语言，特别是Lisp和Java，在风格上与脚本语言非常相似，但是这个术
语模糊了两者间的区别。继续使用这个术语的唯一理由是还没人想出更好的。
    把所有这些语言都纳入“脚本语言”的部分原因在于，这些语言都具有非常～致的发
展历程。在运行期完成解释使得动态存储管理的自动化相对容易，而这几乎要求采用引
用（存储地址不透明且无法进行运算）而不是传值或显式指针。使用引用可使下一步更
容易实现运行期的多态性和00。瞧！这就是现代的脚本语言！
    要有效应用Unix哲学，在工具包中就不能只育C语言，必须学会使用Unix的其它
语言（特别是脚本语言），并且学会如何在大型程序系统中把担任各个专门角色的多个
语言轻松自在地融合在一起。
    本章我们要分析C语言及其最重要的替换语言，讨论各种语言的长处、不足以及它
们最适合的任务类型。涉及的语言包括C、C++、shell、Perl、Tcl、Python、Java和Emacs
Lispo每段分析将包括由该语言编写的应用实例，同时也引用了其它例子和指导材料。
所有使用这些语言实现的高质量开源实现都可以在Intemet上获得。
    警告：对应用程序语言的选择是InterneUUnix世界中应该认真考虑的原型问题之一。
人们太爱某些工具，有时会不顾～切维护它们。如果本章达到了目的，也许会冒犯各种
语言的狂热支持者，但其他所有人肯定都能从中受益。
www.pdf365.com
14.2为什么不是C
323
14.2  为什么不是C
    C是Unix的母语。自1980年代早期起，C语言几乎就垄断了计算机工业中所有的
系统编程。除了Fortran在科技和工程计算领域内不断缩小的空间和COBOL在银行和保
险公司大量外人无法得知的财务应用外，C和C的后代C++迄今为止（2003年）垄断应
用编程超过了整整10年。
    因此，作为对新应用程序开发工具的选择，现在断言C和C++几乎～定是蹩脚的似
乎理由不足。然而事实如此；C和C++以增加实现时间和（特别是）调试时间为代价来
优化效率。尽管以C或C++编写对时间要求极高的系统程序或应用程序内核似乎还有意
义，然而自从这些语言在1980年代崛起，世界已经发生了很大变化。在2003年，用几
乎同样的价钱能够买到的处理器快了1000倍，内存大了1000倍，而磁盘容龟也大了10000
倍2。
    急剧下降的成本从根本上改变了编程的经济含义。大多数情况下，和C-样节约机
器资源已经不再有任何意义。相反地，经济方面的最优选择已经变成尽可能减少调试时
间、尽可能延长人类对代码的长期可维护性。因此，用较新一代的解释语言和脚本语言，
能够更好地为绝大多数种类的应用实现（包括应用程序酌原型设计）服务。这种转变和
历史车轮中上一次C/C++崛起而汇编语言衰落的情况类似。
    C和C++的中心问题在于它们要求程序员自己完成内存管理――声明变量、显式管
理链表、设置缓冲大小、检测或防止缓冲溢出，以及分配和回收动态存储。这些任务部
分可以通过不自然的方法来自动化，例如，给C配备Boehm-Weiser实现之类的垃圾收
集器，但C本身的设计使它无法成为一个完整的解决方案。
    C的内存管理是复杂性和错误的渊薮。对于处理复杂数据结构的程序而言，有研究
（据（Boehml称）估计30%～40%的开发时间都用于存储管理。这个估计甚至还没有包
括对调试成本的影响。尽管缺乏确凿坚实的数据，但很多经验丰富的程序员都相信，内
2在Unix世界外，这种硬件性能三个数量级提升的效果很大程度上被软件性能的相应下降所掩盖。
    UNIX编陛艺：术
    www.pdf365.com
324
第1 4童语言：C还是非C
存管理产生的bug是真实代码持续产生错误的最大单体来源3。缓冲溢出是产生崩溃和安
全漏洞的常见原因。动态内存管理造成诸如内存泄漏、指针失效问题等阴险、难以跟踪
的bug，特别臭名昭著。
    就在不久前，手动内存管理还有意义。但现在再没有“小型系统”了，至少在主流应
用编程中没有了。在今天的条件下，自动化内存管理（并以使用更多的时钟周期和内存
为代价而减少一个数量级的bug）的实现语言更有意义。
    最近一篇论文[Prechelt】为一个观点收集了一系列惊人的统计数据，但在两个世界
都有经验的程序员可能会发现这个观点似是而非：同C或C++相比，使用脚本语言的
生产力可以提高1倍。这个观点完全和前面提到的30%～40%的损失估计加上调试开
销后一致。使用脚本语言的性能损失对真实世界的程序来说经常微不足道，因为真实
世界的程序往往受I／0事件等待、网络延迟以及缓存列填充等限制，而非CPU的自身
效率。
    Unix世界在实践中慢慢意识到了这个观点，尤其是在1990年前后，Perl和其它脚本
语言越来越流行。但是实践（到2003年中期）还没有发展为自觉地产生巨变；许多Unix
程序员仍然在汲取Perl，Python的经验。
    我们可以在Unix世界外看到同样的趋势，尽管速度更慢――例如，在Microsoft
Windows和NT的应用开发中从C++到Visual Basic的明显转变以及大型机世界中向Java
的转变。
    反对C和c++的论据同样适用于其它传统的编译语言，例如Pascal、Algol、PUI、
FORTRAN和编译Basic等。尽管偶有壮举，如Ada，但这些传统语言在基础设计时把内
存管理留给程序员，因此其间的差别几乎无关紧要。尽管绝大多数传统语言在Unix下都
有高质量的开源实现，但在Unix或Windows世界中应用很窄；这些语言都因为得到C
3这个问题的严重性可以通过Unix中描述各式各样问题所形成的大量行话来证明：“aliasing bug，，（别
名错误）、“arena corruption”（内存分配区无效）、“memory leak”（内存泄漏）、“buffer overflow”
（缓冲区溢出）、“stack smash”（堆栈崩溃）、“fandango on core”（内核混乱）、“stale pointer”（指
针失效）、“heap trashing”（堆破坏）以及可怕的“secondary damage“（二次损伤）等。具体说明参见
行话文件<http：//www_ catb．org／―esr／j argon>。
www.pdf365.com
14.4语言评估
325
和C++的好处而被废弃。因此，我们不在此分析这些语言。
14.3解释型语言混合略
    避免手工管理内存的语言通过在运行期可执行体中嵌入一个内存管理器来完成内存
管理。通常情况下，这些语言的运行环境分成程序部分（运行脚本本身）和解释器部分，
解释器管理动态存储。在Unix（以及其它现代操作系统）中解释器内核由多个程序部分
共享，减少了各个程序的实际开销。
    脚本在Unix世界中从不是新概念。早在1970年代中期，在机器能力弱得多的时代，
Unix shell（Unix控制台的输入命令解释器）就是作为一个完全解释型编程语言设计的。
即使在那时，这样的实践也很普通，完全用shell编写程序，或者用shell编写胶合逻辑、
把现有的公用程序同C编写的定制程序结合成比各部分总和更大的整体。对Unix环境的
经典介绍（如Unix Programming Environment （Unix编程环境）[Kernighan-Pike84]）非常
详细地描述了这个策略，理由就是：它是Unix最重要的创新之一。
    高级shell编程可自由混合语言编程，从数种或更多语言中为子任务开发二进制
和解释型组件。每种语言都完成自己最擅怅的任务，每个组件都是具有同其它组件间
狭窄接口的模块；整体的全局复杂度要比使用某个通用语言编制的单个的庞然大物低
得多。
  14语言t'
  混合语言足一种知识密集型（而不是编码密集型）的编程。要让它能够工作，我们
不仅应该具备相当数量的多种语言应用知识，并且还必须具备能够判断这些语言在什么
地方最适合、以及怎样把它们组合在一起的潜经验。本部分，我们将尽量帮助大家认识
各种语言，然后再纵览那些潜经验。对于每种语言的分析，我们都会用成功的程序实例
来说明这种语言的长处。
UNIX编程艺．术
    www.pdf365.com
326
第1 4章语言：C还是非C
14.4.1  C
    尽管存在内存管理问题，但C语言还有一些仍然可以在其中称王称霸的生态环境。
要求速度最快并且具有实时需求的程序，或者与OS内核紧密联系的程序非常适合用C
编写。
    必须在多个操作系统上移植的程序也非常适合用C编写。然而，以下将要讨论的某
些其它替代语言不断打入主流的非Unix操作系统；也许在不久的将来，C的可移植性优
势将不复存在。
    有时，从现有程序中，诸如可以生成C代码的词法分析生成器或GUI构建器之类，
可以获得相当大的借力；完全值得用C语言编写除此以外并无太多工作的小型应用程序。
    当然，已经证明了，对于所有C的替换语言开发者来说，C都是不可或缺的。此处
要分析的其它任何一种语言，透过实现层深究下去都可以发现用可移植纯C语言实现的
内核。这些语言继承了C语言的许多优点。
    在现代条件下，也许最好把C视作适用Unix虚拟机的高级汇编器（回顾一下第4
章作为实例分析的、对C成功之处的讨论）。C语言的标准已经把这个虚拟机的很多功
能，比如说标准I／0库，引出到其它操作系统之中。C语言就是既要尽量接近裸机又要
仍然保持稳定的最佳选择。
    即使更高级的语言能够满足编程的要求，我们仍然耍学习C，其中一个充分理由就是C
能帮助我们学会在硬件体系层次上考虑问题。对于已经是程序员的人来说，学习C的最好参
考和指导仍然是《The CProgramming Language》  （C编程语言）[Kemighan-Ritchie]。
    在Unix变种之间移植C代码几乎总是可行的，通常也很容易，但在一些特殊的变化
领域（例如信号和进程控制）可能非常需要技巧才能做对。我们将在第19章重点讨论这
些问题。尽管Windows NT至少在理论上支持符合ANSI/POSIX标准的C语言API，但
其它操作系统上C的不同约定肯定会导致一些移植问题。
    高质量的C编译器的开源软件可以在网上找到；其中最著名、使用最广泛的是自由
软件基金会的GNU c编译器（GCC （GNU Compiler Collection/GNU编译器集合）的组成
部分），GCC已经成为所有开源Unix系统、甚至很多闭源世界中Unix系统自带的C实
现。甚至Microsoft操作系统也有GCC。GCC的源码可在FSF的FTP站点
<ftp://ftp. gnu.org/pub/gnu>获得。
    总结：C语言最佳之处是资源效率和接近机器语言。而最糟糕的地方是其编程简直
就是赍源管理的炼狱。
www.pdf365.com
14.4语言评估
327
14.4.1.1  C实例分析：fetchmail
    C语言最好的案例分析是Unix内核本身，对于Unix内核而言，一个自然支持硬件
层操作的语言实际上就是～个巨大优点。但fetchmail是那种最适合使用C编写的用户态
实用程序范例。
    fetchmail只完成最简单类型的动态内存管理：它仅有的复杂数据结构是邮件服务器
控制块的单向链表，只在启动时创建，之后发生相当微小的变化。这避开了C的最大弱
点，从而大大削弱了并不适用C的情形。
    另一方面，这些控制块相当复杂（包括所有的字符串、标记和数字数据），在一个
缺乏C struct对应特征的实现语言中，很难将这些控制块作为一致的常规访问对象进行处
理。在这方面，绝大多数代用品都比C弱（Python和Java是明显的例外）。
    最后，fetchmail要求能够解析针对邮件服务器控制信息的、相当复杂的规格说明语
法。在Unix世界中，这类任务的经典解法是使用C代码生成器，C代码生成器从声明的
说明规格中为标记器（ tokenizer）和语法分析器生成源码。Vacc和lex的存在是使用C
语言编程的有力支持。
    fetchmail完全有理由使用Python编写，尽簪可能产生显著的性能损失。其规模大小
和复杂的数据结构可能马上就排除了shell和Tcl编程，Perl也非常不适合，其应用领域
也不在Emacs Lisp的自然范围内。Java实现本可以成为一个合理的方法，但Java面向对
象的风格和垃圾收集针在fetchmail的具体问题中并不会获得太多收益，简单的内存管理
用C就已经足够解决了。C++也没有办法可以更简化fetchmail相对简单的内部逻辑。
    然而，fetchmail成为C程序的真正原因是，fetchmail其实是从一个原本使用C编写
的前辈程序逐渐演化而来的。现有的实现已经在许多不同的平台和稀奇古怪的服务器上
进行了广泛的测试。把所有这些隐性的知识贯穿到用不同语言的重新实现中会非常棘手
和困难。更何况，fetchmail的一些功能（如NTLM认证）取决于外来代码，而这些代码
只在C版本才有。
  fetchmail的交互式配置器并没有C的遗留问题，所以使用Python编写；我们将在讨
论Python时分析该实例。
14.4.2  C++
当C++在1980年代中期首次公布于世时，面向对象（00）语言正被大肆吹捧为解
UNIX编震，艺术
    www.pdf365.com
328
第1 4章语言：C还是非C
决软件复杂度问题的“银弹”。C++面向对象的特性对于其前辈C而言是个压倒性的优点，
其拥趸期望C++能够迅速废掉更古老的C语言。
    这种情况当然并没有发生。部分可归因于C++本身的问题；对向后兼容C的要求迫
使C++在设计中做出了许多妥协。而且这个要求阻碍了C++完全自动化动态内存管理，
从而无法解决C语言最严重的问题。后来，薄弱、不成熟的标准化努力，并不能限制各
个不同编译器实现者之间的功能特征竞赛，C++变得过份精微复杂了。
    另外一部分原因必须归咎于00本身并没有达到期望值。我们已经在第4章分析了
这个问题，阐述了00方法往往导致厚重胶合层和维护问题。今天（2003年），对开源
文档（在这些文档中，语言的选择反映了开发者的判断而不是企业行政命令）的分析表
明C++的使用仍然大量集中于GUI、多媒体工具包和游戏（00设计的主要成功领域），
而在其它地方用得很少。
    也可能C++对00的实现特别容易产生问题。有证据表明C++程序比等价的C、
FORTRAN或Ada程序具有更高的生存期成本。这是00的问题还是C++特有的问题或
者是两者共同的问题，答案还不清楚，尽管有理由怀疑两者都牵涉萁中[Hatton98]。
    近年来，C++已经包含了一些重要的非00概念；它具有和Lisp类似的异常；也就
是说，在被处理程序捕捉之前可以沿调用栈向上抛出值或对象。STL（标准模板库）提
供了泛型编程；也就是说，可以编写独立于数据结构的算法并将其编译而在运行期完成
任务o  （只有执行编译期静态类型检验的语言需要它；更动态的语言只传递无类型的引
用，而在运行时支持类型识别。）
    高效的编译型语言；对C的向上兼容；面向对象的平台；STL和泛型等最前沿的技
术工具-C++试图满足所有人的所有要求，但代价是C++比任何一个程序员所能处理
的复杂度都要高。正如我们在第4章指出的～样，这个语言的主要设计者已经承认他不
指望任何一个程序员能够完全掌握C++。Unix黑客对此并没有很好的反应；一段匿名但
非常著名的评论这样描述“C++:狗被钉上软肢而变成的章鱼”。
    然而，说白了，C++最根本的问题还是在于它根本上只是另外一种传统语言。在标
准模板库发明后，C++的内存管理控制有所改善，比C好得多，但仍然十分脆弱；除非
代码仅使用对象，否则控制仍1日无用。对许多类型的应用而言，C++的00特性并不重要，
www.pdf365.com
14.4语言评估
329
没有带来多少优势，徒增复杂度而已。尽管存在不少开源的C++编译器；
确比C高级，那C++现在肯定占尽优势了。
    总结：C++的最佳之处是编译效率以及面向对象和泛型编程的结合。
非常怪异复杂，往往鼓励过分复杂的设计。
    如果现有的C++工具包或服务库为应用程序提供了强大有效的方法，
用领域正是上述00语言具有巨大优势的领域，可以考虑C++。
但如果C++的
最糟之处是它
或者所在的应
    C++的经典参考资料是Stroustrup的The C++ Programming Language （C++编程语言）
【Stroustrup]。有关C++和00基本方法的优秀入门指导是C++:A Dialog[Heller]。《C++
详注>  （C++ Annotations）[Brokken]则是针对C专家程序员的简明介绍。
    GCC包含一个C++编译器。因此这个语言广泛应用于Unix和Microsoft操作系统：
前面对C提出的有关说明在此处同样适用。非常强大的开源支持库可从
<http：／／www．boost．org／>获得。C++的ISO标准草案（到2003年中）正处于准
备期，而实际的C++实现往往遵循其相差甚大的子集．正是这个事实恰恰损害了C++
的可移植性4。
14.4.2.1  C++实例分析：Qt工具包
    Qt界面工具包是C++在当今丌源世界中最成功的故事之一。它提供了在X下编写图
形用户界面的窗口构件和API，是为了仿效Motif、MacOS Platinum或Microsoft Windows
界面的可视化观感而专门设计的。实际上，Qt不仅提供GUI服务；也提供了可移植应用
层，具备众多类库，可供完成XML、文件访问、套接字、线程、定时器、时间／日期处
理、数据库访问、各种抽象数据类型和Unicode处理。
    在开源世界中，有两项工作创造了有竞争能力的GUI和集成桌面生产工具包，KDE
是其中资格较老的一个，而Qt工具包则是KDE项目中关键的可视组成部分。
    Qt的C++实现展示了00语言在封装用户界面构件方面所具有的优势。在支持对
象的语言中，通过类实例的分层可在代码中清楚表达出界面窗口部件的可视化分层。
尽管这类任务在C中可以通过手动书写方法列表进行明确的转向调用来模拟，但用C++
编写的代码要干净得多。将此同C编写的、非常复杂的Motif API比较非常具有启发意
义。
4最近的一个C++标准从1998年开始，实现甚广，但仍旧根弱，特别是在代码库领域。
UNIX -4iO&-'2t肴
  www.pdf365.com
330
第14章语言：C还是非C
Qt的源码和参考文档可在Trolltech站点<http：／/www．trolltech．com/>获得。
14.4.3  Shell
    Unix版本7的“Bourne shelr'（ sh）是Unix第一个（而且在很多年中也是Unix唯
一的）可移植的解释型语言。今天，最先的Boume shell很大程度上已经被向上兼容的
Kom Shell （ksh）的各种变种所替代；其中最重要的一个变种是Boume Again Shell，
即bash。
    也存在其它一些shell、也可交互使用，但这些语言不足以作为编程语言：其中最著
名的恐怕就是C shell即csh了，csh以不适合编写脚本而出名5。
    简单shell程序的编写极其容易和自然。Unix使用解释型语言的快速原型设计传统就
始于shell。
    我用1 50行shell脚本编写了第一版netnews。它支持多个新闻组，可以交叉
  发贴；新闻组是目录，交叉发贴则以对文章的多个链接来实现。虽然用于实用太
  过缓慢，但其灵活性允许进行无穷的协议设计试验。
-Steven M. Betlovin
    然而，随着程序规模越来越大，这些程序往往变得非常专用。部分shell语法（特剔
是其引用和声明语法规则）变得十分混乱。为了shell作为交互式命令行解释器的实用性，
而在设计中对语言部分做了折中，这些缺点就是这么来的。
    即使程序不完全使用shell编写，但包含人量对sort“／）之类的C过滤器或sed （1）、
awk （1）之类的标准文本处理微型语言的使用，则也可称为“用shell”编写而成。然而，
这类程序在过去数年内逐渐式微，现在此类复杂的胶合层通常用Perl或Python编写，而
shell只是为最简单的包装器（那些语言使用在包装器上是大材小用）和系统启动时的初
始化脚本（不能假设已经安装了什么语言）而保留。
5参阅Tom Christiansen的文章Csh Programming Considered Harmful （Csh编程有害论），网上很容易
搜索到。
www.pdf365.com
14.4语言评估
331
    任何入门级Unix书籍都对此类基本的shell编程作了充分的说明。The Unix
Programming Environment （Unix编程环境）[Kernighan-Pike84]仍然是最好的中高级shell
编程参考书之～。每个Unix上都有Kom shell的实现或翻版。
    复杂的shell脚本经常产生可移植性问题，主要原因并不在于shell本身而在于shell
使用了某些它假定存在的程序。尽管偶尔可在非Unix操作系统中发现Bourne和Kom
shell变种，shell程序（实际上）根本无法移植到Unix之外。
    总结：shell的最佳之处在于书写小型脚本非常自然快捷。最糟之处在于大型shell
脚本必须依靠大量辅助命令，而这些辅助命令不一定在所有目标机器上都表现～致甚至
不一定存在。要在大型shell脚本中分析依赖关系并不容易。
    既然所有的Unix系统和Unix仿真器都配置了shell，因此几乎从来不需要编译或安
装shejl。在Linux和其它先进的Unix变种上的标准shell已经是bash了。
14.4.3.1  案例分析：xml七。
    xmlto是一个驱动脚本，调用所有必要的命今将XML-DocBook文件转换成HTML、
PostScript、纯文本或其它格式中的任何一种（我们将在第1 8章具体分析DocBook）。
它用bash编写而成。
    xmlto使用恰当的样式表处理XSLT引擎的调用细节，然后把结果传递给后续处理
器。对于HTML和XHTML，XSLT转换完成全部的工作。对于纯文本，XML也先处理
成HTML，然后传递给后续处理器――以- dump模式调用lynx（1），它把HTML转换
成纯文本。对于PostScript，XML转换成XML FO（formatting objects，带格式对象），
由后续处理器将其映射成TEX宏，通过tex（1）转换成DVI格式，最后由众所周知的
dvi2ps（1）工具转换成PostScript。
    xmlto是单体前端shell脚本。它调用某个根据目标格式命名的脚本插件。每个插件
都是一个shell脚本。根据调用方式的不同，xmlto提供一个样式表供前端使用，或者以
各种预置的参数调用适当的后续处理器。
    这种架构意味着特定输出格式的所有信息都存放在一处（相应的脚本插件），因此
根本无需涉及前端代码就可以增加新的输出类型。
    xmlto是中型shell虚用程序的范例。由于C或C++都难以编写脚本，因此不适用。
本章描述的其它脚本语言虽可以用于此，但由于它只是简单的命令分派，没有内部数据
结构或复杂的逻辑，因此shell就足够了。而使用shell的重要优势就是在预期的目标系
UNfX编程艺术
  www.pdf365.com
332
第1 4章语言：C还是非C
统中shell普遍存在。
    理论上这个脚本可在支持bash的任何系统上运行。真正的限制是系统必须存在某个
XSLT引擎以及所有后处理器。实际上，除了现代的开源Unix，这个脚本不大可能运行
在其它任何地方。
14.4.3.2  实例分析：Sorcery Linux
    Sorcerer GNU/Linux是一个Linux发布版本，作为一个小型可启动简单系统而安装，
但它足以运行bash （1）和其它一些下载程序。一旦代码就绪，就可以启用Sorcery，即
Sorcerer包系统。
    Sorcery处理各种软件包的安装、卸载和完整性检验。输入指令后，Sorcery下载源
代码，对其进行编译和安装并保存安装的文件（以及编译日志和所有校验文件）。安装
好的软件包可删除或卸载。也可以列举软件包和进行完整性检验。更多详情参见Sorcery
项目竭}点<hLtp：//sorcerer .wox - org>。
    Sorcery系统完全使用shell编写而成。安装程序往往是很小的简单程序，shell对此
最为合适。在这个具体应用中，因为Sorcery的作者可以确保需要的辅助程序都在这个简
单系统中，所以shell的主要缺蠃被抵消了。
14.4.4  Perl
    Perl是增强了的shell。它为代替awk （l）而专门设计，并扩展用来代替shell作为
混合语言脚本编程的“胶合剂”使用。Perl首次发布于1987年。
    Perl最强功能是其内置的对文本、面向行的数据格式进行模式导向的处理功能。比
起shell，Perl包含更加强大的数据结构，包括混合元素类型的动态数组和支持名一值对的、
查找方便迅捷的散列（字典）类型。
    此外，Perl还包括一个完备的、经过深思熟虑的全套Unix API的内部支持，显著减
少了对C的需求并使其非常适合完成简单的TCPfIP客户端甚至是服务器端的工作。Perl
的另外一个优势在于围绕Perl已经形成了一个强大的开源社团。社团在网络上的主页是
Perl综合典藏网（Comprehensive Perl Archive Network） <http：／/WWW - cpan．org>。
献身于Perl的黑客们已经编写了成百上千个自由重用的Perl模块，可完成多种不同的编
程任务，从目录的结构遍历树、用于GUI构件的X工具包，到HTTP机器人和CGI编
程。
www.pdf365.com
14.4语言评估
333
    Perl的主要缺点在于某些部分丑陋到无法补救，某些部分过于复杂，某些部分必须
谨慎地、～成不变地使用以防出错（Perl的函数参数传递约定就是所有这三个问题的典
型例子）。同shell相比，Perl较难起步。尽管使用Perl编写的小型程序能够特别有效，
但随着程序规模越来越大，要遵守严格约定才能保持模块性和设计的可控性。由于无法
推翻Perl历史上一些限制性的设计决定，许多更高级的功能都具有一种脆弱、拼凑的感
觉。
    Perl的权威参考是Programming Perl （Perl编程）[Wa112000]。该书几乎包含了需要了
解的一切内容，但其结构出名的差；必须从中挖掘出要了解的知识。Leaming Perl（学习
Perl） [Schwartz-Christiansen]则提供了更有叙述技巧的入门级内容。
    Perl在Unix系统非常普遍。主版本相同的Perl脚本往往在各种Unix版本之间可以
直接移植（前提是这些Perl脚本不使用扩展模块）。Microsoft操作系统和MacOS上也
有Perl实现（甚至具备很好的文档）。而Perl/Tk提供了跨平台GUI能力。
    总结：Perl的最佳之处是作力强力工具以供大量涉及正则表达式匹配的小型胶合脚
本使用。最糟之处在于当程序很大时Perl会变得非常丑陋、刻板，几乎无法维护。
14.4.4.1  小型Perl程序案例分析：blq
    blq脚本是查询拒收列表（网站列表，已经确认为未经请求就大批量发送邮件，即
垃圾邮件的惯常发布源）  的工具。现行源码可在bla项目主页
<http：//www．unicom．com/ sw/blq/>上获得。
    blq是小型Perl脚本的范例，说明了Perl语言的优点和缺陷。它大量使用正则表达
式匹配。另一方面，Net::DNS Perl扩展模块可能需要额外安装，因为无法保证它在指定
的Perl安装上已经存在。
    blq和其它Perl代码一样特别干净和规范，因此我推荐其为良好风格（blq项目主
页引用的其它Perl工具也是好例子）的典范。但除非熟悉Per】具体的语法风格，否则有
部分代码是无法读懂的――代码的第一行，即$o=。8 1．★／！！j，就是个例子。尽管所
有的语言都有这类晦涩，但Perl是其中最晦涩的。
    Tcl和Python也非常适合编写这种类型的小脚本，但这两种语言都缺乏blq中大量
使用的正则表达式匹配，这在Perl中非常简便；采用任何～种语言来实现也许都有理由，
UNIX编罹艺I术
  www.pdf365.com
334
第1 4章语言：C还是非C
但可能都不如Perl紧凑和富有表达力。Emacs Lisp实现甚至可能比Perl实现编写更快、
更紧凑，但可能使用起来是令人痛苦不堪的慢。
14.4.4.2  大型PerI实例分析：keeper
    keeper是在ibiblio站点为大型Linux自由软件档案归档外来包并维护FTP和WWW
索引文件而使用的工具。可以在ibiblio档案站点<http：／/www．ibilolio．org>的搜索
工具子目录中找到源码和文档。
    keeper是大中型交互式Perl应用程序范例。命令行界面是面向行，并以专门的shell
或目录编辑器的面貌出现：内嵌的帮助功能值得注意。工作部分大量使用文件目录处理、
模式匹配和模式导向编辑。注意，keeper从程序模板生成网页和电子邮件通知非常便
利。也请注意，它使用白带的Perl模块来自动化在目录树不同功能之问的遍历。
    这个应用程序大约有3300行，町能提升了我们对~个Perl程序应有规模大小和复杂
度的期望极限。尽管如此，这个程序大部分在六天之内编写完成。如果使用C、C++或
Java，至少可能需要六周，而且完成之后特别难以调试或修改。这个程序对纯Tcl来谠过
大了。Python编写的版本可能在结构上更干净、更可读、而且可维护性也更好――但可
能也更冗长（特别是在模式匹配及相关部分）。Emacs Lisp模式也完全可以胜任编写工
作，但Emacs不太适合在telnet连接上使用，因为它经常因为服务器拥挤而速度慢得像
蜗牛。
14.4.5  Tcl
    Tcl（工具命令语言）是一个设计来连入C编译库的小型语言解释器，提供C代码的
脚本控制（扩展脚本）。Tcl的最初应用是控制电子仿真器所用的程序库（SPICE之类的
应用程序）o Tcl也适用于内嵌脚本――即从C程序内部调用脚本然后返回值。Tcl于1990
年首次发布。
    在Tcl之上构建的一些功能在Tcl社区以外得到了广泛的使用。其中最重要的两个功
能是：
●  Tk工具包，一种更亲切和更友好的X接口，便于快速构建按钮、对话框、菜单
    和滚动文本窗口并从这些构件中收集输入信息。
www.pdf365.com
14.4语言评估
335
    ●  Expect，一种更容易编写具有更多种响应纯交互程序的语言。
    Tk工具包如此重要，使得这个语言经常被称作为Tcl/Tk。Tk也频繁用于Perl和Python
中。
    Tcl自身的主要优势在于它特别灵活而且本质上非常简单。语法非常奇特（以位置分
析器（ positional parser）为基础），但整体上是统一的。没有保留字，在函数调用和内置
语言特性间也没有语法区别；这样，Tcl语言解释器本身就可以在Tcl内部有效地重新定
义（这就是象Expect之类程序的合理性所在）。
    Tcl的主要缺点在于纯Tcl语言只有十分薄弱的命名空间控制和模块性功能，而且如
果使用不当，其中两个（upvar和uplevel）相当危险。同时，除了关联列表以外，
Tcl也没有数据结构。因此，很难扩展Tcl-即使是中等大小（超过几百行）的纯Tcl
程序也很难在不绊倒自己的前提下进行组织和调试。在实践中，几乎所有大型的Tcl程
序都使用其00扩展。
    语法的怪异最初也是个问题：字符串引号和括号之间的区分可能让人头疼一阵，何
时使用引号、何时使用括号也需技巧。
    纯Tcl只提供对Unix API相对较小的常用部分的访问（基本上只是丈件处理、进程
生成和套接字）。实际上，Tcl具有～种实验的意味，看看一个脚本语言究竟变到多小还
依然有用。Tcl扩展（与Perl模块类似）提供了更为丰富的能力集，但（和CPAN模块
一样）不能保证处处都有安装。
    Tcl最早的参考资料是Tcl and the Tk Toolkit （Tcl和Tk工具包）[Ousterhout94]，但这
本书大部分已经被Practical Programming in Tcl and Tk （Tcl和Tk实用编程）[Welch]所替
代了o  Brian Kernighan对现实世界中的Tcl项目进行了一番描述[Kemighan95]，总结了
Tcl作为快速原型设计和开发工具的长处和不足；其中与Microsoft Visual Basic的对比非
常客观并具有指导意义。
    同Perl、Python不一样的是，Tcl世界并没有一个由核心团体管理的中央资料库，但
有几个优秀的网站互相链接并涵盖了大部分的Tcl工具和扩展开发。首先看以下的Tcl
Developer Xchange<ht tp：／／www. tcltk．com>;这个站点除了其它内容外，还提供了
一个交互式Tcl指导材料的来源。在SourceForge站点<ht七p：／／sourceforge．ne七
／foundry/tcl-f oundry/>上也有一个Tcl资料库。
    Tcl脚本也具有和shell脚本类似的可移植性问题；这个语言本身非常适于移植，但
它调用的组件未必如此。Microsoft操作系统、MacOs和许多其它平台也存在Tcl实现。
任何具有GUI能力的平台都可以运行Tcl/Tk脚本。
UNI×编翟艺术
  www.pdf365.com
336
第14章语言：C还是非C
    总结：Tcl的最佳之处在于它节俭、紧凑的设计和Tcl解释器的可扩展性。最糟之处
在于其古怪的位置分析器和孱弱的数据结构及命名空间控制――这个缺陷使其很难适用
于大型项目。
14.4.5.1实例分析：TkMan
    TkMan是Unix手册页和Texinfo文件使用的浏览器。这个程序大约1200行，使用
纯Tcl编写，应该说相当庞大，但代码出乎寻常地成熟和模块化。它使用Tk来提供GUI
界面，比原有公用程序man门j或xman（，，j支持的GUI界面更加友好。
    TkMan是个很好的研究实例，充分展示了Tcl的全套技法。突出表现在Tk集成、脚
本控制Unix的其它应用（如Glimpse搜索引擎），以及解析Texinfo标记的Tcl使用上。
    在其它任何一种语言中，都不可能用类似于它的代码产生如此直观的Tk GUI界面。
    在网络上查找关键字TkMan可以找到一些源码和文档。
14.4.5.2  Moodss:大型Tcl案例分析
    Moodss系统是一个系统管理员使用的图形界面监控应用程序。它可以监控系统日
志，为MySQL、Linux、SNMP网络和Apache等收集统计信息，并通过称为“dashboardw
的类似电子表格的GUI控制面板提供这些统计信息的摘要。监控模块也可象Tcl -样使
用Python、Perl等编写。这段代码非常精美、成熟，被视为Tcl社区中的典范。项目网
站为<http://j￡ontain.free.fr/moodss/>.
    Moodss内核包含18，000行Tcl代码。它使用了数个Tcl扩展，包括一个定制对象系
统：Moodss的作者承认，如果没有这些扩展的话，“编写如此巨大的一个应用程序是不
可能的”。
    再一次，在其它任何一种语言中，都不可能用类似于它的代码产生如此直观的Tk
GUI界面。
14.4.6  Python
    Python是一种脚本语言，设计本意是与C语言紧密集成。它既可以从动态载入的C
库程序中接收数据也可以向其传输数据，它也能够在C中作为嵌入脚本语言调用。Python
的语法介于C语言和Modula系列语言之间，但有个非常罕见的特征，即代码块结构实
www.pdf365.com
．-月月lE言{∞t七
I't．叶  匝口阡『口
337
际上用缩进来控制（没有明确的begin/end或C花括号之类的东西）。Python最早公开
发布于199 1年。
    Python语言的设计是非常干净优雅，具有非常出色的模块化特性。它提供了设计者
用面向对象风格编码的可能，但并不把这个选择强加于设计者（可以用更加经典的类C
方式编码）。它的类型系统，其表达力和Perl系统相当，包括动态容器存储对象和关联
列表（ association list），但并非那样怪异（实际上，Perl对象系统模仿了Python对象系
统是有案可查的）。它甚至因为具有匿名lambda对象（以函数为对象值，可在迭代器之
间传递并被迭代器使用）而迎合了Lisp黑客。同Python -起发布的一般还有Tk工具包，
可以非常方便地构建GUI界面。
    Python标准发布包括大多数重要网络协议（SMTP、FTP、POP3、IMAP和HTTP）
的客户类以及HTML生成器类。因此它非常适合构建协议机器人和网络管理工具。它也
非常适合Web CGI任务，并能在这个高复杂的领域中同Perl竞争，并取得一席之地。
    对于扩展需要协同开发的大型复杂项目，在我们描述的所有觯释型语言中，Python
和Java无疑是两个最佳的语言。在很多方面Python都比Java简单，并且它对快速原型
设计的亲和性，使它独立使用在那些既不太复杂又不要求速度致胜的应用程序中并优于
Java。Java实现的Python，其设计目的是为了促进这两种语言的混合使用，目前已面世
了并用于开发；称之为Jython。
    Python在纯执行速度方面无法同C或C++竞争（尽管在现今快速处理器上应用混合
语言策略使这点已经相对不那么重要）。实际上，人们通常认为Python是主要脚本语言
中效率最低、速度最慢的语言，这是它为运行期类型多态付出的代价。然而当心，别因
为这些原因而拒绝Python，Python能够提供的性能实际上已经满足人多数应用程序，即
使那些似乎需要更好性能的程序通常也受到网络等待或磁盘等待等外部延时的限制，从
而完全抵消了Python解释型开销产生的影响。作为补偿，Python特别容易和C结合起来，
因此性能关键的Python模块可以很方便地转换成C语言来显著提高速度。
    对于小型项目和大量依靠正则表达式能力的胶合脚本，Python不如Perl的表达力强。
对于太小的项目，Python是大材小用了．shell或Tcl也许更适合。
    同Perl -样，Python也形成了一个组织良好的开发社区，其核心站点
<http：／/www．pyt hon．org>包含大量有用的Python实现、工具和扩展模块。
    Python的权威参考是《Programnung Python》（Python编程）[Lutz]。Python网站上也
有关于Python扩展的大量在线文档。
    Python程序往往可在各种Unix之间移植，甚至可以移植到其它操作系统；标准库非
UNIX编瞬l艺．宋
    www.pdf365.com
338
第1 4章语言：C还是非C
常强大，显著减少了对不可移植的辅助程序的使用。Microsoft操作系统和MacOS上也
有Python实现。只要有Tk或其它两种工具包就可以跨平台实现GUI开发。Python/C应
用程序可以被“冻结”（frozen），准编译成纯C源码，这样就可以移植到没有安装Python
的系统上。
    总结：Python的最佳之处在于它鼓励清晰、易读的代码，易学易用，又能够扩展到
大型项目。最糟之处在于，不仅相对于编译语言，而且相对于其它脚本语言，它也是效
率低下、速度缓慢的。
14.4.6.1  小型Python案例分析：imgsizer
    imgsizer是一个改写www网页的公用程序，能够在图像标记中加入图像的正确尺
寸（这提升了在很多浏览器上的网页载入速度）。可以在ibiblio档案站点
<ht tp：／／mⅢ．ibiblio．org>的URL WWW工具子目录下找到源码和文档。
    imgsizer最初使用Perl编写，几乎是Perl擅长的那种小型、模式驱动的文本处理
工具的理想实例。后来为了利用Python对HTTP获取的库支持优势而转化成了Python；
这消除了对外部网页获取程序的依赖。注意宦使用了file（1）和ImageMagick identify（1）
作为提取图像像素大小的专用工具。
    动态字符串处理和复杂正则表达式匹配的需求让使用C或C++来编写imgsizer变
得异常痛苦；而且相应的版本也会更加庞大、更加难读。Java当然也可以解决隐含的内
存管理问题，但在文本模式匹配方面几乎不会比C或C++更有表达力。
14.4.6.2  中型Python案例分析：fetchmailconf
    在第II章，作为分离实现和接口的例子我们分析了fetchmaiUfetchmailconf程序对。
fetchmailconf很好地展示了Python的优势。
    fetchmailconf使用Tk工具包来实现多面板GUI配置编辑器（Python中也有GTK+
和其它工具包的，但每个发布Python解释器中都包含Tk工具包。）
    在专家（expert）模式，GUI支持编辑六十个左右的属性，分成三个面板。属性窗口
部件包括复选框、单选按钮、文本框和滚动列表栏。尽管这样复杂，但配置器的第一个
全功能版本只花了我不到一周的时间就完成了设计和编码，其中还包括学习Python和
Tk的四天时间。
www.pdf365.com
339
    Python擅长GUI界面的快速原型设计，而且（正如fetchmailconf所示）此类原型通
常也是可交付的。Perl和Tcl在此领域也有类似的优势（包括为Tcl编写的Tk工具包），
但很难控制到fetchmailconf的复杂度（大约1400行）级别上。Emacs Lisp不适合GUI
编程。而选择Java会提高复杂度开销，且不会为这个非速度致胜型程序带来显著收益。
14.4.6.3  大型Python案例分析：PIL
    PIL，即Python Imaging Library （Python图像库），支持位图图像处理。它支持许多流
行的格式，包括PNG、JPEG、BMP、TIFF、PPM、XBM和GIF。Python程序可用它来
转换图像；支持的变换包括裁剪、旋转、缩放和切变：也支持像素编辑、图像卷积和色
彩空间转换。PIL发布包括从命令行运行这些功能的Python程序。这样，PIL可用于批
处理模式的图像转换或作为一个强力工具包执行由程序驱动的位图图像处理。
    PIL的实现表明Python能够直接使用可装载的目标码扩展模块增强Python解释器。
为了提高速度，在位图对象上执行基本操作的库内核是用C编写的。上屡和前后逻辑则
是用Python编写的，速度慢，但更容易阅读、修改和扩展。
    使用Emacs Lisp或shell编写类似的工具包会非常困难，甚至不可能。因此Emacs Lisp
或shell根本没有C扩展接口，而如果用Tcl编写的话，PIL会大得令人不舒服。Perl具
有类似的功能（Perl XS），但同Python相比，它过于专用，文档不全，十分复杂，也不
稳定，因此使用得少之又少。Java的本地方法接口（Native Method Interface）似乎能够
提供和Python大致相当的功能；PIL可能成为～个相当合理的Java项目。
    在项目站点<http：／/www．pythonware．com/produc tS /pil/>可获得PIL的
代码和文档。
14.4.7  Java
    Java编程语言的设计目标是“wnte once，run anywhere（-次编写，到处运行），，，
并且支持网页中嵌入交互程序（即applets），可在任何一个浏览器中运行。由于其所
有者Sun Microsystems的一系列技术和战略失误，Java没有实现这两个最初的设计目
标。但它在系统编程和应用编程方面仍然十分强大，足以挑战c和C++c， Java岔布于
1995年。
UNIX编窿艺-术
    www.pdf365.com
340
第1 4章语言：C还是非C
    尽管远比C++小巧简单，但Java设计非常聪明地抓住了自动管理内存的巨大优势，
也抓住了支持00设计这一虽小却并非不重要的优点。Java保留了大量的类C语法，大
多数程序员对此感觉非常舒服。它也包括支持动态载入的C调用并支持在C中把Java
作为嵌入语言调用。Sun公司在网上提供良好Java文档的工作完成得非常出色，这一点
作用也不可小觑。
    Java的负面，我们可以说（例如，同Python相比较）有些部分显得过于复杂，而另
外一些部分则不够完善。Java中，类的可见／不可见区域的规定非常复杂。接口功能虽然
避免了多继承产生的复杂问题，但理解和使用并不会简单多少。内部类和匿名类等特征
可能会导致非常混乱的代码。而缺乏可靠的析构方法则意味着内存以外的其它资源，例
如互斥（ mutex）和文件锁定等，难以保证得到正确管理。Unix操作系统的重要功能也
无法从Java主体中访问，包括信号、poll和select等。尽管Java的1/0功能非常强大，
但文本文件的简单读取并不简单。
    Java库存在一个特别令人反感的问题，和Windows DLL hell问题非常相像。Java没
有管理不同库版本昀方法气这在应用服务器之类的环境中会产生巨大的问题，因为服务
器可能配置的是（比如说）某XML库版本，但应用程序却随另外（通常是较新的）版
本一起发布。对此类问题的唯一处理是使用CLASSPATH环境变量，但却是不断产生配
置问题的错误来源。
    更进一步，Sun公司对Java语言的处理无论在政策上还是在技术上都十分迟钝。Java
的第一个GUI工具包AWT一团糟，必须完全替换掉。而把该语言从ECMA/ISO标准中
撤出进～步激怒了早已为Sun Community Source License（SCSL）感到恼火的众多开发人
员。SCSL的限制还妨碍了Java l.2的开源实现和J2EE（Java 2 Enterprise Edition/Java 2
企业版）规格说明。这损害了Java普遍移植的初衷。
    悲哀的是，浏览器applets已经消亡了。Microsoft在IE中不支持Java l.2的决定实
际上绞杀了它们。然而，Java似乎在计算业中发现了一个安全的生存空间，让“servlets"
在网页应用服务器的内部运行。Java也经常用于不和数据库或网页服务器直接相连的企
业内部编程。它也已经成为Microsoft的ASP/COM乎台和Perl CGI的主要竞争者。最后，
作为初级编程（Java特别适合这个角色）的教学语言，Java的使用越来越广泛。
    总而言之，我们可以认为，对于除系统编程以及大多数速度关键的应用程序外的一
切编程而言t  Java比C++高级（C++复杂得多，而且没有为解决内存管理问题作出多少
努力）。经验似乎表明，和C++程序员相比，Java程序员掉进过度00分层这一陷阱的
可能性似乎要小一点，尽管这仍然是个大问题。
www.pdf365.com
14.4语言评估
341
    如何权衡Java和我们本章描述的其它语言，目前还不清楚，可能主要取决于项目
的规模。我们可以设想Java的正确使用范围和Python比较相近。同Python -样，Java
无法和C或C++在原始执行速度方面竞争，也无法和Perl在大量使用模式引导编辑的
小项目竞争。Java对小项目是大材小用（这一点比Python更确定）。我们可以认为，
Python在小一些的项目上具有优势，而Java在大一些的项目上具有优势，但这并非定
论。
    最好的参考书可能是Java In A Nutshell （Java技术手册）Flanaganjava】，但这不是最好
的入门级指导材料；最好的入门级指导可能是Thinking in Java Clava编程思想）[Eckel]。对
全球所有Java网站的链接始于Sun公司的Java站点<http：／／j ava．sun．com>，该站点
也具有可免费下载的完整HTML文档。开源目录Java网页（Open Directory Java Page）
<ht tp：／/dmoz．org/Computers/ Programming/Languages/Java/>也汇集了许
多有用的Java键接。
    所有的Unix操作系统、Microsoft操作系统、MacOS和其它很多平台都有Java实现。
    可在Kaffe项目站点<http：／/www．kaffe．org／>获得Kaffe（ -个开源Java实现，
类库符合大多数JDK l.1和部分JDK l.2的要求）的源码。
    GCC也有一个Java前端。GCJ可以把Java代码编译成Java bytecode或本机码，
也可以把Java bytecode编译成本机码。它配置了执行大部分JDK l.2要求的开源类库・
和一个称为gij的Java bytecode解释器。  详情参见GCJ项目网页
<http: //gcc. gnu. org/j ava/>。
在JDEE项目站点<ht tp：／／jdee．sunsite．dk/>有基于Emacs的Java IDE。
    Java语言本身的可移植性非常优秀。但不完整的库实现（特别是不支持新JDK l.2
的老JDK l.1库）是个问题。
    Java的最佳之处在于它非常接近“…次编写、到处运行”的目标，作为～个独立于
操作系统的环境非常有用。最糟之处在于Java l/Java 2的分裂令人沮丧地损害了这个目
标的实现。
UNIX编程艺_术
    www.pdf365.com
342
第1 4章语言：C还是非C
14.4.7.1  案例分析：FreeNet
    Freenet足一个对等网络项目，目的是创建没有审查和内容禁止的网站6。Freenet开
发者设想了以下应用：
    ●  争议信息的不审查分发：Freenet保护言论自由，范围从民间另类新闻到受禁曝
    光材料的林林总总，都可以不经审查地匿名发表。
    ●  高带宽高效内容发布：用Freenet的适应性高速缓存（adaptive caching）和镜像
    来发布Debian Linux更新软件。
    ●．通用个人发布：Freenet让任何人都能够拥有没有空间限制和强制性广告的网站，
    即使没有电脑而想成为网站管理员的人也能如愿以偿。
    Freenet通过提供一个虚拟空间来达到这些目标，在这个虚拟空间中发布的文档不与
任何具体的机器相关。发布信息和Freenet内部数据索引通过网络进行复制分发，即使是
Freenet管理员在任何给定时间里也不清楚所有的物理文档会在哪里。Freenet浏览者或信
息提交者的隐私通过强密码系统加以保护。
    Java作为这个项目的上上之选至少有两个理由。首先：项目目标非常重视最广泛的
实现兼容性，因此Java的高度可移植性成为一个主要优势。其次：这个顼目的本质促使
网络API变得非常重要，而Java恰好内置了一个强大的API。
    C通常用于对性能要求很高的基础项目上，但缺乏标准的网络API使移植变得非常
困难。C++也存在同样的困难。Tcl、Perl或Python可以减轻移植负担，但代价是牺牲太
大的性胄皂。Emacs Lisp速度缓慢得令人痛苦因而完全不适用。
14.4.8  Emacs Lisp
    Emacs Lisp是一种脚本语言，用于Emacs文本编辑器的行为编程。它首次发布于1984
年。
    从本章其它语言分析的相同角度来说，Emacs Lisp并不是一种通用语言：尽管它足
够强大，理论上可以作为通用语言使用，但传统上，它只用于为Emacs编辑器编写本身
的控制程序，并不像现代脚本语言那样能和其它软件顺畅通讯。
6 Freenet项目的网站：<http：//freenetproj ect .org>。
www.pdf365.com
14.4语言评估
343
    尽管如此，在相当范围的应用中，Emacs Lisp比其它语言更为有效。这些程序大多
都与为开发工具提供一个前端有关，包括C编译器和链接器、make （l）、版本控制系
统和符号调试器等等；我们将在第15章讨论这些内容。
    更一般的是，Emacs之于模式导向或语法导向的爻互编辑，就如同Perl之于模式导
向的批处理编辑一样。任何涉及交互编辑特定文件格式或文本数据库的应用程序，使用
Emacs模式（一种定制编辑器行为的Emacs Lisp程序）进行原型设计（甚或交付）都是
上佳的选择。
    Emacs Lisp也非常适合构建必须和文本编辑器紧密整合在～起的应用程序，或是主
要作为文本浏览器而兼具某些编辑功能的应用程序。email和Usenet新闻的用户代理就
属于此类。一些数据库前端也是如此。
    Emacs Lisp是一种Lisp语言。它自动进行内存管理，就像黑夜之后是白天一样自然，
因而比大多数传统语言更雅致、更有效，或者，确切地说，也比大多数新兴语言都更雅
致、更有效；在这个方面它可以同Java或Python竞争，更远超C/C++、Perl、shell或
Tclo Lisp缺少标准的可移植OS规范，这个老毛瘸已由Emacs内核解决，实际上Emacs
内核就是其OS规范。
    Lisp另外一个老毛病――狂吃资源一一在现代机器上也不再是个问题。  “Emacs
Makes A Computer Slow"  （Emacs让计算机变慢）和“Eventuallv Munches All Computer
Storage"（最终吃光所有计算机内存）之类的调侃曾经非常流行（实际上Emacs发布本
身就包含这样的一个笑话列表）。但现在其它许多经常使用的程序（如网页浏览器）都
比Emacs更大、更复杂，所以比较而言，反而Emacs似乎变得比较适中了。
    Emacs Lisp的权威参考是The GNU Emacs Lisp Reference Manual （GNU Emacs Lisp
参考手册），可在Emacs的"info"帮助系统中浏览。如果没有，可从FSF的FTP站点
<ftp：／／ftp．gnu．org/pub/gnu>下载。如果觉得太深，《Writing GNU Emacs
Extensions》（编写GNU Emacs扩展编写）[Glickstein]可能会有帮助。
    Emacs Lisp程序的可移植性非常卓越。所有的Unix操作系统、Microsoft操作系统和
Mac搡作系统都有Emacs实现。
    总结：Emacs Lisp的最佳之处在于结合了非常优秀的基础语言Lisp，其域原语对文
本操作非常有效。最糟之处在于性能较差，难以和其它程序通讯。
更多详情参阅后续章节“选择编辑器”中对Emacs的讨论。
UNIX编霜已艺：习}
    www.pdf365.com
344
第1 4章语言：C还是非C
14.5未来趋势
    表14.1大致表明了当今语法使用的分布情况。我们给出了来自SourceForge7和
Freshmeat的数据8，这是到2003年3月为止两个最重要的新软件发布站点。
    SourceForge的数字在几个方面有所欠缺：最明显的，SourceForge的查询界面不允
许同时将OS和语言作为过滤条件，所以其中部分数字代表的是MacOS和Windows项目。
其结果可能就是C++和Java的份额相对会放大一些。然而，基于Unix的项目充分地占
据了垄断地位（大概是3:1的比例），所以除了上述两个语言，其它语言的数据可能并
没有多大的变形。
    Freshmeat的样本数据较小，但是站点本身只发布基于Unix的项目――而且统计的
是确确实实的发布版本，不像SourceForge -样包括大量失败的、停顿的项目。有趣的是
同SourceForge相应统计相比，其比率几乎都是1:2，当然正好也要除去一些情况（C++
和Java），我们可以认为那不成比例，是因为Freshmeat缺少基于Windows的项目。
    本章最初在1997年起草；在2003年年中完成。这足一个相当长的时间段，趼以上
述我们检视的语言，自从第一次写作以来，其相对地位已经发生了改变，并显现出一种
采用趋势，而这趋势恰好昭示了其语言特征。  （对于这些最常使用语言的开源实现，其
提高和改善工作，社区规模就是一个重要的质量和数量因子；而其增长和衰落往往更增
加了说服力。）
    宽泛地说，C、C++以及Emacs Lisp在1997 - 2003时间段保持稳定，在2003年与
1997年一样，吸引着相同数量的支持者。C得到缓慢增长，占据了如FORTRAN更古老
传统语言的份额：另～方面，C++被Java夺取了些许阵地。
    Perl使用的增长非常可观，但语言本身在一段时间已停滞不前。Perl内部非常糟糕；
认识到语言实现需要推倒重来已经有好几个年头，但在1999年的努力却以失败告终，而
在2003年中的另一努力似乎也停滞了。不管怎样，Perl仍然还是八百磅巨型猩猩式的脚
本语言，并且在网页脚本和CGI方面占据主导地位。
    Tcl已经处于一个相对衰减的时代，或者至少是出镜次数逐渐减少的时代。在1996
7勿0计q次字来自<hLtp：／/sourcef orge．net/sof twaremap/Lrove_list．php?form_cat=160>，
8*TCj+4~~来自<ht tp：／／freshmeat.net/browse/160／?topic_id=160>.
www.pdf365.com
14.5未来趋势
345
年一个广泛流传的看似真实的估计中，就社区规模而言，每有一个Python使用者，对应
就有5个Tcl使用者，12个Perl使用者。今天，SourceForge的数据表明这个比率大概是
3:1:7。然而，据说Tcl被广泛使用在好几个工业领域的专门化脚本组件方面，包括电子
设计自动化（EDA），广播电视业以及电影业等。
表14.1  语言选择
┏━━━━━━━━┳━━━━━━┳━━━━━━━┓
┃    语言        ┃SourceForge ┃    Freshmeat ┃
┣━━━━━━━━╋━━━━━━╋━━━━━━━┫
┃    C           ┃    10296   ┃    4845      ┃
┣━━━━━━━━╋━━━━━━╋━━━━━━━┫
┃    C++         ┃    9880    ┃    2098      ┃
┣━━━━━━━━╋━━━━━━╋━━━━━━━┫
┃    Shell       ┃    1058    ┃    487       ┃
┣━━━━━━━━╋━━━━━━╋━━━━━━━┫
┃    Perl        ┃    4394    ┃    2508      ┃
┣━━━━━━━━╋━━━━━━╋━━━━━━━┫
┃    Tcl         ┃    649     ┃    328       ┃
┣━━━━━━━━╋━━━━━━╋━━━━━━━┫
┃    Python      ┃    2222    ┃    948       ┃
┣━━━━━━━━╋━━━━━━╋━━━━━━━┫
┃    Java        ┃    8032    ┃    1 900     ┃
┣━━━━━━━━╋━━━━━━╋━━━━━━━┫
┃    Emacs Lisp  ┃    '       ┃    3 1       ┃
┗━━━━━━━━┻━━━━━━┻━━━━━━━┛
    Python随着Tcl的衰落而迅速崛起。尽管Perl社区的规模仍然有Python的两倍大，
但一个明显的趋势是，最精明的Perl黑客都流向了Python，这对Perl语言是相当不利的
――尤其是根本就没有反向迁移。
    Java在已经投入Sun Microsvstem技术的站点中广泛使用，也作为大学生计算机科学
课程的指导性语言而广泛部署。然而在别的地方，只比1997年稍微流行一些。Sun -意
孤行的所有权许可模型妨碍了许多当年评论家预浏的主要突破；而在Linux和更广泛的
开源社区，Java对C并没有获得像在别处取得的那种进展。
    还没有出现新型的通用语言，对已经在此讨论的语言构成严重的挑战。PHP正在侵
蚀网络开发，挑战Perl CGI（以及ASP和服务器端Java），但是几乎从未使用在单机编
程中o Non-Emacs Lisp方言，一个曾经十分有前途的语言在上世纪九十年代似乎能够驶
向辉煌，但最终还是淡出了。最近的成果，例如Ruby（日本人开发的Python-Perl-Smalltalk
杂交体）和Squeak（～个开源的Smalltalk移植）看起来似乎很有前途，但至今既没有吸
引到除自身开发组之外的用户，也没有展示出持久力。
www.pdf365.com
346
第1 4章语言：C还是非C
14.6  选择X工具包
    同选择开发语言相关的问题是选择GUI编程工具包。回顾一下第一章中关于X如何
    分离机制和策略的讨论。每个可能选择的工具包都将带来些许不同的观感。
    X工具包的选择在两方面影响着同开发语言的选择：首先，有些语言的本身就绑定
    了某个偏爱的工具包，其次，一些工具包可以绑定进的语言是个有限的集合。
    当然，Java存在本身内建的跨平台工具包，所以选择只会落在AWT（普遍都有配置）
    和Swing（更强大、更复杂、更缓慢，仅仅在JDK l.2/Java 2中支持）之间。所以这部分
    余下的内容集中在我们已经讨论过的其它语言中。类似的，如果使用Tcl，Tk是捆绑而
    来的。没什么其它选择的余地了。
    曾经无处不在的Motif工具包实际上已宣告死亡。它已经跟不上无发布限制和无需
    许可费用的新兴工具包。这些新兴的工具包吸引了更多开发者的努力，无论在能力和特
    性方面都淹没了老旧的闭源工具包。现在，竞争全部来自开源阵营。
    在2003年，有四个工具包值得认真考虑，分别是Tk、GTK、Qt和wxWindows，  当
    然GTK和Qt无疑是领跑者。所有四个T具包都移植到了MacOS和Windows中，所以
    迭择其中任何一个都具备跨平台开发能力。
    Tk工具包是四个中最悠久的一个，优势当然是资历深厚；该工具包原生于Tcl，Python
    接口随Python本身一起发布。也有供C和C++程序库使用的Tk语言接口。不幸的是，
    Tk在其标准的窗体构件集方面也老态毕现，既有限又丑陋。另一方面，其它工具包要达
    到Tk中Canvas控件具备的能力还有些困难。
    GTK生来就是为了取代Motif，并且支持GIMP。现在是GNOME工程项目酷爱的
    工具包，为成百上千的GNOME应用程序所使用。原生API是C的；也有C++、Perl、
    Python接口，但并没有包含进语言的主发布。GTK是四个工具包中唯一的C原生接口。
    Qt工具包被KDE工程所使用，是原生的C++库，也有Python和Perl接口但并不同
    解释器本身一同发布。Qt获得了四个工具包中最佳设计和最具表达力API的声誉，然而
    早先许可授权版本的争论阻碍了它的广泛采用，C接口总是迟迟不予以发布的事实也进
    一步延缓了它的广泛采用。
    wxWindows是原生的C++库，同时可以获得Perl和Python接口。wxWindows开发
    者着重强调它们的跨平台开发，也以此作为工具包的主要卖虑。另一个卖点是
    wxWindows实际上是基于每个平台上原生（GTK、Windows和MacOS 9）窗体构件的包
UNIX编程艺术
    www.pdf365.com
14.6选择X工具包
347
装器，这样使用该工具包编写的应用程序保留了原味观感。
    在2003年年中，几乎没有各种工具包的详细对比说明，但是网络搜索“X toolkit
companson”或许能得到一些有用的采样数据。表14.2汇总了各种工具包的状态。
表14.2  X工具包总结
┏━━━━━━┳━━━━━━┳━━━━━━━┳━━━━━━━━━━━━━━━━━━━┓
┃    工具包  ┃  原生语言  ┃  发布对象    ┃    绑定接口                          ┃
┣━━━━━━╋━━━━━━╋━━━━━━━╋━━┳━━━┳━━━┳━━━┳━━━━┫
┃            ┃            ┃              ┃  C ┃ C++  ┃Perl  ┃ Tcl  ┃ Python ┃
┣━━━━━━╋━━━━━━╋━━━━━━━╋━━╋━━━╋━━━╋━━━╋━━━━┫
┃    Tk      ┃    Tcl     ┃  Tcl， Python ┃  Y ┃  Y   ┃  Y   ┃  Y   ┃    Y   ┃
┣━━━━━━╋━━━━━━╋━━━━━━━╋━━╋━━━╋━━━╋━━━╋━━━━┫
┃    GTK     ┃    c       ┃  Gnome       ┃  Y ┃  Y   ┃  Y   ┃  Y   ┃    Y   ┃
┣━━━━━━╋━━━━━━╋━━━━━━━╋━━╋━━━╋━━━╋━━━╋━━━━┫
┃    Qt      ┃    C++     ┃    KDE       ┃  Y ┃  Y   ┃  Y   ┃  Y   ┃    Y   ┃
┣━━━━━━╋━━━━━━╋━━━━━━━╋━━╋━━━╋━━━╋━━━╋━━━━┫
┃  wxWindows ┃    C++     ┃              ┃    ┃  Y   ┃  Y   ┃  Y   ┃    Y   ┃
┗━━━━━━┻━━━━━━┻━━━━━━━┻━━┻━━━┻━━━┻━━━┻━━━━┛
    架构方面，这些程序库都是在同一抽象层次上编写的。GTK和Qt都使用类似的接
收／发送信号的事件处理机制，所以移植起来据说几乎是小菜一碟。因此，在几个工具包
间选择，其它都没问题，最主要的局限是它们提供何种语言的接口。
UNIX编腥艺-术
  www.pdf365.com
www.pdf365.com
1 5
    I    _    ●
    l■I一．
    ●    _  ■  ●
    _―L_-●
．-―■．-．，、●
开发的战术
Tools: The Tactics of Development
Unix is  user-friendly-it rS just choosV about who  its friends are.
Unix对用户是友好的一只不过是挑剔的友好。
    一佚名
15.1  开发者友好的操作系统
    Unix作为一个良好的开发环境长期以来享有盛誉。许多程序员为程序员而写的工具
使它配备精良。这些工具自动完成了不少琐碎的工作，从而让人心无旁骛地专注于开发
中最重要（也是最享受）的部分――设计。
    尽管所需要的工具都是现成的，文档也做得很棒，但并没有通过一个集成开发环境
（IDE）结合在一起。所以往往需要花费相当的努力才能找到它们，装配起来，从而形成
～套适合需要的工具。
    也许读者过去习惯于一个完备的IDE-在Macintosh和Windows系统中常见的、
配备了编辑器、配置管理器、编译器和调试器的GUI系统――那么Unix的方法似乎显
得随意、含混、太过简陋。但那确实是Unix中的方法。
    IDE对于缺乏工具的单一语言编程非常有意义。如果所作所为仅限于机械地以手工
作坊式地研磨出C或C++代玛，IDE就相当适合。然而在Unix下，语言和实现的选择广
泛多样。所以同时使用多个代码生成器、定制配置器以及许多其它标准定制工具就是司
UNIX Sga艺-宋
  www.pdf365.com
350
第1 5章工具：开发的战术
空见惯的事情了。
    在Unix中也有IDE（有数个开源实现，包括Macintosh和Windows上主要IDE的模
拟器）。可是它们难以控制编程工具开放的多样性，因此并未广泛使用。Unix提倡一种
更灵活的风格，一种以编辑／编译／调试循环为中心、排它性更少的风格。
    在本章中我们将介绍Unix下的开发策略――编译代码、管理代码配置、性能分析、
调试以及自动完成各种脏活累活，而让人更专注于有趣的部分。同以往～样，说明更注
重整体结构、而不是具体做法。如果需要了解这方面的细节，本章介绍的大多数工具在
《Programming with GNU Software》（用GNU软件编程）[Loukides-Oram]中都有很好的
叙述。
    当然这些工具自动完成的许多事情都可以手工解决，但这只会更慢，错误率也只会
更高。攀爬学习曲线的～次性付出，得到的是更有效编写程序的能力；精力也可以更多
地放在设计层面而不是低层次的细节操作。
    传统上，Unix程序员就从其他程序员那里学习如何使用这些工具，潜移默化、悉心
钻研。如果你是位新手，请特别留意；我们将一开始就通过展示正确做法来让你完成Unix
学习曲线上最大的～跳。如果你是位忙碌的有经验的Unix程序员，可以跳过本章――但
也许不该如此。这儿的一些有用知识可能恰好你并不知道。
15.2编辑器选择
    首要和最基本的开发工具是一个适合修改和编写程序的文本编辑器。
    一一数来，在Unix下有十几种文本编辑器；编写一个文本编辑器似乎是入门级开源
玩家标准的练手程序之～。这些编辑器多数都暂如朝露，除了作者之外并不适合其他任
何人扩展使用。有些模拟了非Unix系统的编辑器，对于习惯其它操作系统的程序员，可
以作为转换的帮助。在SourceForge或ibiblio或其它主要的开源档案站点有种类繁多的
编辑器。
    对于严肃的编辑工作，两款编辑器完全统治了Unix编程界。两者都有几个次要的变
种实现，有一个标准版本，可以毫无疑问地在任何现代Unix系统上找到。它们是vf和
Emacs。我们在第13章关于软件的适当规模～节中讨论过。
www.pdf365.com
15.2编辑器选择
351
    正如我们在第13章注意到的一样，这两款编辑器在设计哲学上表现出尖锐的对立，
但两者都极端流行并且赢得了可观的核心用户群。Unix程序员民意调查～直表明两个阵
营大约对等，而其它所有的编辑器几乎都排不上号。
    在我们先前对vi和Emacs的检视中，主要关心的是可能复杂度以及相关的设计哲学
问题。此外值得去了解的，是它们蕴含的工程实用精神和Unix文化修养。
15.2.1  了解vi
    VI这个名字是“visual editor（可视编辑器）”的缩写，发音为/vee eVe/（不是/vie/并且
绝对不是/ iks/!）。
    Vf并不是最早的面向屏幕编辑器；那是Rand editor，即re的荣誉，它在1970年代
运行在Unix版本6上。但V1是最长寿的、仍在使用的、为Unix编写的面向屏幕编辑器，
而且已经成为Unix传统中的一个神圣部分。
    Vi的原始版本在1976年随最早的BSD软件发布；现在已经废弃了。替代的是随着
4.4BSD -起发布的“新VI”，也可以同时在一些现代的4.4BSD变种诸如BSD/OS、FreeBSD
和NetBSD系统中找到。还有几个具有扩展功能的变种，著名的有vzm、vile、elvis祁xvi;
在这些版本中，vim可能是最流行的，可以在许多Linux系统上找到它。所有的这些变种
都十分相似，并且共享～个从最初vi版本以来就没有变化过的核心命令集。
也有移植到Windows操作系统和MacOS上的Vl编辑器。
    多数介绍Unix的书籍都会用整整一章来描述基本的Vl用法。关于VI的常见问题解
答可以在Editor FAQ/vi<ht tp：／/WWW．faqs．org/faqs／editor- faq/vi/>处获得；
以包含“VI”和“FAQ”网页名称为关键字做WWW搜索，可以找到许多其它资料。
15.2.2  了解Emacs
    Emacs代表“Editing MACros”（宏编辑，发音为/eemaks/）。最初是在1970年代
作为一个叫做TECO编辑器的一套宏而编写的，随后又以不同的方式重新实现了好几次。
一个意想不到的有趣转变是，现代的Emacs实现包含有～个模拟TECO的模式。
    在早些时候讨论编辑器和可能复杂度时，我们注意到许多人都认为Emacs太过沉重。
然而，花时间学习它可以获得很大的生产力回报。Emacs支持许多威力强大的编辑模式，
能够为输入各种编程语言和标记语言提供语法上的帮助，我们在本章稍后部分可以看到
UNIX编程艺术
  www.pdf365.com
352
第1 5章工具：开发的战术
Emacs是如何同其它开发工具组合起来，从而获得并不逊于常规IDE（在许多方面甚至
超过）的能力。
    在现代Unix中普遍存在的标准Emacs是GNU Emacs;在Unix shell提示符下键入
emacs通常都会运行它。GNU Emacs源码和文档可以在自由软件基金的存档站点
<ftp：//gnu．org/pub/gnu>处获得。
    唯一的主要变种叫做XEmacs；它有着更好的X界面，但在功能上非常相似（它派
生自Emacs 19）。XEmac.s的主页是<http：／／www. xemacs．org>。Emacs（连同Emacs
Lisp）在现代的Unix中通常都可以获得。同时也已经移植到MS-DOS（那里工作得很差）
和Windows 95以及NT中（在那儿据说运行得相当好）。
    Emacs包含自带的交互教程以及非常完备的在线文档；可以在Emacs的默认启动屏
幕中找到调出它们的说明。《Leaming GNU Emacs》（学习Emacs）【Cameron]是一本优秀
的参考书。
    在Netscape/Mozilla的Unix版本和Internet Explorer的文本窗口（表单和邮件发送器]
中使用的键盘命令拷贝自Emacs中绑定的基本文本编辑命令。这些绑定最适合作为跨平
台编辑器的键盘命令标准。
15.2.3非虔诚的选择：两者兼用
透。
许多人经常规则地使用Vi和Emacs来做不同的事情，并且认为非常值得把两者都摸
    总的来说，V1最适合用来完成小型任务――邮件的快速回复、系统配置的简单调整
等。尤其是正在使用一个新系统（或者通过网络的远程系统）而自己的Emacs定制文件
又无法唾手可得时特别有用。
    在处理复杂任务、修改多个文件、需要使用其它程序结果扩展编辑时，Emacs开始
显现威力。对于在控制台使用X的程序员（这在现代Unix上非常典型），一登录通常
就启动一个Emacs窗n，并一直运行下去，然后可能会在多个Emacs子窗口访问十几个
文件甚至运行程序。
15.3专用代码生成器
Unix长期存在一个宿主工具的传统，这些工具明确设计来生成不同专门目的的代码。
www.pdf365.com
15.3专用代码生成器
353
这种值得尊敬的传统典范，需要追溯回到版本7甚至更早的日子-1970年代用来编写
原始可移植C编译器的lex（1）和Vacc （1），它们作为GNU工具包的一部分，今天仍
被大量使用，而它们向上兼容的现代后继者是flex （l）和bison（1）。这些程序已经树
立了一个榜样，并在诸如GNOME的Glade界面构建器项目中发扬光大。
1 5.3.1     yacc ~O lex
    vacc和lex是用来生成语言词法分析器的工具。我们在第8章叙述过，通常自己的
第一个微型语言可能确实是出于偶然而不是一个明确的设计。这个偶然很可能需要一个
手工编码的词法分析器，这会花费非常非常多的维护与调试时间――尤其是如果还没有
意识到它是个词法分析器，不能正确地将其从应用程序的其余部分独立出来时。词法分
析器的生成器是个工具，可以比偶然专用的实现做得更好；它们并不仅仅只是在一个更
高的层次上表达规格说明的语法，同时也能够将词法分析器的所有实现复杂度从其它代
码中隔离出来。
    如果有需要计划从头开始实现一门微型语言，而不是扩展和内嵌一个现有的脚本语
言或者解析XML，那么vacc和lex也许就成为仅次于C编译器的最重要工具，
    Lex和yacc两者分别为一种单一功能生成代码――“从输入流中获取标记符号”和
“解析一系列标记符号来检查是否符合某个语法”。通常地，yacc生成的语法分析功能
在每次需要得到另一个标记符号时会调用一个lex生成的tokenizer功能。如果yacc生成
的语法分析器中根本不存在用户编写的C回调函数，所做的一切就是语法检查：返回值
将告诉调用者输入是否匹配预期的语法。
    更通常地，在生成的词法分析器中内嵌的用户C代码，在解析输入时会附加地生成
～些运行期数据结构。如果微型语言是声明式的，应用程序可以直接使用这些运行期数
据结构。如果设计是命令式的，数据结构也许会包含一个分析树，传给某种求值函数。
    yacc的接口相当丑陋，通过前缀为yy-的形式导出全局变量名。这是因为yacc的产
生还在C struct之前；事实上，还在C语言产生之前；yacc的第一个实现是用C语言的
前任B语言编写的。yacc生成的词法分析器校正解析错误时的算法（直到一个显式的生
成错误得到匹配才弹出标记符），尽管有效但很粗糙，还会导致包括内存泄漏在内的一
些问题。
    如果正在构造分析树，并使用malloc分配节点，在勘误过程中如果开始将数
据出栈，兢不可能恢复（释放）内存。yacc不能完全知道栈中究竟有些什么，因
UNIX编程艺术
  www.pdf365.com
354
第1 5章工具：开发的战术
此它无法做到这一点。如果yacc用C++写成，可以设想值是某个类从而“析构’’
它们。而在“真正的”编译器中，分析树节点由使用基于分配区（ arena-based）
的分配器生成，所以节点不存在泄漏，但无论如何在工业强度的勘误时总有逻辑
的遗漏需要考虑。
-Steve Johnson
    lex是一个词法分析器的生成器。它是grep （l）和awk （1）功能族的一员，但是更
强大，因为它可以为每个匹配安排执行任意的C代码。它接受声明式微型语言作为输入
并且生成C语言代码骨架。
    对于lex生成的符号分析器究竟做些什么，有种粗略但有效的解释：把其视作grep
（1）程序的逆操作。grep （1）接受单个正则表达式、返回输入流中所有匹配的列表，
而每次调用lex生成的符号分析器则是接受一批表达式并标明在数据流中出现了哪～个。
    即使不用Yacc和Lex，并且所处理的“标记符号”同编译器的大不一样，将
  输入分析分解成符号化输入和解析符号流也是个十分有用的策略。不止一次地，
  我已经发现，尽管分解本身会增加复杂度，但将输入处理分解成两个层次确实可
  使代码更简单也更容易理解。
-Henry Spencer
    lex是缟写来为编译器自动生成词法分析器（tokenizer）的。但最后却令人惊讶地广
泛适用于其它种类的模式识别，并且从此被描述为“Unix编程的全能瑞士军刀”，。
    如果正在处理某类模式识别或状态机问题，并且可能的输入可用一个字节描述，lex
生成的代码比手工编制的状态机代码更为有效和可靠。
    Holmdel（AT&T的一个实验室）的Jahn Jarvis使用lex来寻找电路板中的疵
点，扫描电路板，使用链编码技术来表示电路板上的边界区域，然后使用Lex来
定义可以捕获一般制作错误的模式。
-Mike Lesk
    最重要地，lex规格微型语言比等价的手工C语言编码层次更高也更紧凑。Perl（网
上搜索“lex perl”）也有可以使用flex开源版本的模块，Python中作为PLY的一个部分，
也有类似的实现。
1后来Perl的“瑞士军链锯（Swiss-army chainsaw）”这个常见说法其实是个派生。
www.pdf365.com
15.3专用代码生成器
355
    lex生成的解析器一般比手工编码的解析器慢一个数量级。这并不就是采用手工编码
的好理由，相反，这是个明证，应该使用lex进行原型设计，然后只有当原型确实存在瓶
颈时再进行手工编码。
    yacc是一个词法分析生成器。当然，也是为了自动化编译器的部分编制工作而编写
的程序。同BNF（Backus-Naur Form，巴科斯一诺尔范式）类似，将输入作为一个说明
性微型语言的语法规格说明，而语法的每个元素都有相对应的C代码。它生成一个分析
器函数，调用时，从输入流中接受匹配语法的文本。一旦识别出任何一个语法元素，函
数就执行相应的C代码。
    lex和yacc的组合使用对编写任何种类的语言解析器都特别有效。尽管大多数Unix
程序员从不会写一个通用语言编译器（这两个工具的本来目的），但是将它们当作解析运行
控制文件语法和域专用微型语言的解析器也十分好用。
    lex生成的符号分析器在识别输入流中的低级模式相当快速，但是lex能够了解的正
则表达式微型语言却不擅长统计事物，或是识别递归嵌套结构。为了能够解析这些，就
需要yacc。另一方面，尽管理论上可以编写vacc语法来完成自身的符号收集解析，但其
说明面能非常臃肿并且解析速度非常缓慢。从输入中萃取符号标记需要lex。这两个工具
是相辅相成的。
    如果能够在比C语言更高的语言级别实现解析器（我们推荐如此：参见第14章的讨
论），那就参考其它等价的工具，例如Python的PLY（包含lex和yacc的功能）2或者
Perl的PY和Parse::Yapp模块，再或者Java的CUP3、Jack4或Yacc[M5模块包。
    同宏处理器一样，这些代码生成器以及前处理器的问题之～是编译时如果在生成码
中有错，其行号是生成代码的（并不想编辑这里）而不是生成器的输入代码（这才是需
要修正的）的。yacc和lex通过生成同C预处理器一样的#line结构来解决这个问题；
2 PLY可在<http：／／systems．cs .uchicago．edu/ply/>处下载。
3  CUP可在<http：／／www．cs．princet on．edu/-appel/modern/j ava/CUP／处出下载。
4 Jack可在<http：／／www.]avaworld. com/j avaworld/jw-12 -1996/jw-12 -j ack.html>
处下载。
5 YaccfM可k<ht tp：//david。tribble．com/yaccm_ html>处下载。
UNIX编暖；艺：术
    www.pdf365.com
356
第1 5章工具：开发的战术
该结构为错误报告设置当前行号，这样出来的行号就是正确的。任何生成C或C++代码
的程序都应该如此。
    更普遍地，良好设计的程序代码生成器，应该永不需要用户手动地改变甚至查看到
自动生成的部分。把这些做好，是代码生成器的本分。
15.3.2  实例分析：f etchmailrc的语法
    规范的示例似乎在曾经编写的每个lex和yacc教程中都有：玩具型交互式计算器，
用来解析和对用户输入的算术表达式求值。我们还是省省这个重复的老调吧；如果确有
兴趣，参考GNU项目中的bc （1）和dc （1）计算器的实现，或是[Kernighan-Pike84]中
的"hoc”范例6。
    为了取而代之，fetchmail运行控制文件的语法解析器提供了一个关于lex和yacc用
法的中等规模实例分析。有几点十分有趣。
    在rcfile_l.1中的lex规格说明，是非常典型的shell式语法实现。注意同时支持
单引号和双引号字符串的两个补充规则；这种做法普遍适用。接受（可能带符号的）字
面整数的规则和抛弃注释的规则也相当通用。
    在rcfile_y -y中的yacc规格说明，虽然有些见长但很直白。它并不进行任何
fetchmail昀动作，仅仅只是在内部控制块的列表中设置标记。启动之后，fetchmail的普
通模式操作仅仅就是反复遍历这个列表，对每个记录在其远程站点收取会话。
15.3.3实例分析：Glade
    我们在第8章将Glade作为一个说明性微型语言的范例审视过。我们也注意到它的
后端可以产生几种语言中任意一种的代码。
    Glade是应用程序代码生成器的当代范例。使它具备Unix精神的那些功能特征，绝
大多数的GUI构建器（特别是专有的GUI构建器）都没有，可以总结如下：
    ●  并不是胶合成一个大个单体，Glade的GUI和Glade代码生成器遵循分离原则
    （遵从“分离接口和引擎’’设计模式）。
6见http : / /cm . bell-labs . com/cm/cs/upe/>。
www.pdf365.com
15.4 make:自动化编译
357
●  GUI和代码生成器由（基于XML的）文本数据文件格式相连，可以由其它工
    具浏览和修改。
●  支持多个目标语言（相对仅支持C或C++而言）。要增加目标语言也很容易。
这种设计意味着，完全可以替换Glade GUI编辑器组件，而且决不会痛苦不堪。
15.4  ma始：自动化编译
    程序源码自身并不能形成一个应用。如何将它们装配在一起以及如何打包成发布版
本的方式才真正重要。Unix提供一个半自动化这些过程的工具；这就是make （l）。绝
大多数介绍Unix的书籍都涵盖了make。作为真正详尽的参考书，可以查阅《Managing
Projects with Make》（使用Make管理项目）[Oram-Talbot]。如果使用GNU的make（最先
进的make，通常伴随开源Unix -起发布），《Programming with GNU Software》  （用
GNU软件编程）[Loukides-Oram]在某些方面的处理可能会更好一些。多数预装GNU make
的各种Unix都同时支持GNU Emacs:如果你的Unix也是如此，那通过Emacs的信息文
档系统可能会找到完整的make在线手册。
GNU make豹DOS和Windows移植的版本可以从FSF获取。
15.4.1  make的基本理论
    如果使用C或C++进行开发，构建应用程序的一个重要部分是将源代码变成二进制
可运行文件的编译和链接命令集合。输入这些命令是枯燥乏味的细活，多数现代的开发
环境都包含有某个方法将它们放入命令文件或数据库中，可以自动地重复执行以编译应
用程序。
    Unix的make （1）程序，是所有这些程序的鼻祖，专门设计来帮助C程序员管理这
些命令。可以在一个或多个makefile中书写项目文件之间的依赖关系。每个makefile都
由一组“生成物’’构成；其中每项都告知make给定的某个目标文件会依赖哪些源文件集，
并且告知．malce如果那些源文件比目标文件更新时该做什么。实际上并非必须将所有的依
赖关系都写下来，make程序可以通过文件名和扩展名推导出一些显然的依赖关系。
    例如：如果需要在makefile中说明二进制可执行文件“myprog’’依赖三个目标文件
myprog．O、helper．o和stuff．。。如果确实存在文件myproq．c、helper．c和
stuff．c，不用说，make也会知道每个．。文件都依赖相应的．c丈件，并且应用它自己
UNl×编睡；艺．莱
    www.pdf365.com
358
第15．章工具：开发的战术
的标准解决方案将．c文件编译成，。文件。
    Make程序最初来源于Steve Johnson（yacc等程序的作者）的一个拜访，那天
他风风火火的闯进我的办公室，诅咒命运女神让他浪费了一个早上来调试一个正
确的程序（bug改了但是文件还没有编译，因此CC★．o无效）。而我也花了前
一晚上的部分时间在我参与的项目中解决同样的灾难，这样，编写一个工具来解
决这个问题的想法就诞生了。最开始是精细的依赖关系分析器，浓缩为更简单的
东西后，周末就出炉了Make。新兴工具的使用也是Unix文化的一个部分。Make
文件都是文本的，不是神秘的二进制编码，因为这就是Unix的精神：可打印、可
调试、可理解。
-Stuart Feldman
    如果在项目的目录中运行make，make程序会查看所有生成物及时间戳，然后做需
要的最少工作来确保派生出的文件能够更新。
    作为一个中等复杂的范例，可以读读fetchmail源文件中的makefile。在下面的部分，
我们还会引用到它。
    非常复杂的make文件，尤其当它们还要调用附加的make文件时，往往将编译过程
复杂化而不是简单化。一个当代的经典警示来自Recursive Make Considered Harmful【递
归Make有害论）7。这篇文章中的论证自从1997年问世以来已经广泛为人接受，而且几
乎颠覆了以前的社区实践。
    如果不认同make （1）中包含了Unix有史以来最糟糕的设计修补，那么我们的讨论
就不完整。Tab字符（制表符）作为关联生成物命令行的引导符使用，而它和空白符的
视觉区别无法令人觉察，这可能导致对makefile解释的灾难性不同。
    为什么在第一列需要tab? Yacc是新的，Lex更是崭新的。我两者都没有用过，
所以我认为这是个学习的好借口。在我跟Lex首次受挫的纠缠后，我就使用更简
单的换行+tab模式。它工作了，就那样了。而几个星期以后，make有了十几个用
户，大多数都是朋友，而我又不愿意纠正我的基本错误。余下的，很不幸，成为
了历史。
-Stuart Fefdman
 7可以访问网页<http：／/www．tip．net．au/-millerp/rmch/recu-make-cons -harm．html>
阅读本文。
www.pdf365.com
15.4 make：自动化编译
359
15.4.2  非C/C++开发中的make
    make并不仅仅只是对C/C++的有用。如同在第14章所述的一样，脚本语言可能并
不要求传统的编译和链接步骤，但是也常常有其它的依赖关系，make（l）正好可以有帮助。
    例如，假设使用第9章中的某个技法，确实从规格说明文件中生成了部分代码。就
能够使用make来将规格说明文件和生成的源码文件结合在一起。这会确保无论何时修改
规格说明之后重新make，生成码都会自动重新编译。
    和编程一样，使用makefile来完成制作文档的任务也非常普遍。经常会看到使用这
种方法从一个某标记语言编写的主文本（比如HTML或是我们将在第1 8章讨论的Unix
文档宏语言）来自动生成PostScript或其它派生文档。实际上，这种用法相当普遍，值得
我们用一个案例来演示。
15.4.2.1  案例分析：make用于文档转换
    在fetchmail的makefile中，例如，会发现三个生成文件，名为F'AQ、FEATURES和
NOTES，同HTML的源文件fet chmail- FAQ．html、fetchmail- features .html
和design-notes。html相关。
    HTML文件是从fetchmail的主页上阅读的，但是不使用网页浏览器浏览那些HTML
标记非常别扭。因此FAQ、FEATURES和NOTES纯文本文件在需要阅读fetchmail源码
本身（或者，可能在并不支持网页访问的FrP站点）时，可以通过编辑器或分页程序来
快速阅览。
    纯文本格式可以使用普通的开源hnx ci）程序从它们的HTML主文本生成；lynx
是只显示文本的网页浏览器，但是当以- dump选项调用时，同样可以作为HTML到ASCII
的格式转换器使用。
    当生成文件就位，开发者就可以编辑HTML的主文本，而不需要牢记事后必须人工
更新纯文本格式文件，就能够确保FAQ、FEATURES和NOTES都能够在任何需要的时候
得到更新。
15.4.3通用生成目标
很多常用的典型makefile中根本没有文件依赖关系。它们是将某些开发者想要自动
UNIX箱睡；艺术
  www.pdf365.com
360
第1 5童工具：开发的战术
化的小过程捆绑在一起的方法，例如制作一个发布包或者在编译源码时去除所有中间生
成的目标文件．
    生成目标非文件，这早已有之。  “make all"和“clean”是早些日子我自己的
    习惯。有一个老Unix笑话，输入“make love”，输出是“Don't know how to make
    love”  。
    -Stuart Feldman
    关于通用生成目标应该表示什么，以及它们该如何命名已经有了一组良好的约定。
遵从这些会让自己的makefile更容易理解和使用。
a//
    生成工程中所有可以执行者。通常全部产品并没有明确的定义；往往指工程中高阶
的目标文件（并且，并非偶然地，常常有文档说明会包括哪些）。它通常应该是makcfile
的第一个生成目标，因此它往往是开发者不带参数键入make就执行的那一个。
test
    运行程序的自动测试套件，典型地，包括一组单元测试（Unit Test）8来查找递归、
bug，或是其它在开发过程中偏离预期行为的误差。“test”目标也可以由软件的最终用
户来确保安装程序能够正常工作。
cZP以咒
    删除make all时产生的所有文件（例如二进制可执行文件和目标文件）。make
clean虚该将软件的编译过程重置到良好的初始状态。
dist
    制作源文件档案（通常使用tar （1）程序归档），它可以作为在另一台机器上重新
编译的单元。该目标应该同make all做同样的依赖关系检测，这样make dist可以
8单元测试就是同某个模块关联、用来验证执行是否正确的代码。使用术语“单元测试”表明测试是
由代码开发者并发编写的，也形成了模块发布必须附带测试码才算完整的纪律。术语和概念源自Kent
Beck大力推广的“极限编程（Extreme Programnung）”，但大概自从2001年来，也在Unix程序员
中得到了广泛的接受。
www.pdf365.com
15.4 make:自动化编译
361
在制作发布包之前自动重新编译整个工程――这是一个良好的避免最后一分钟困境的方
法（例如，在fetchmail中实际上是从HTML文件产生纯文本README文件）。
distclean
    删掉所有的文件，除了那些使用make dist打包时指定包含的文件。它和make
dist效果一样，它可能和make clean相同，但是需要独立存在，并以文档说明。当
与make clean不同时，通常是会删除make all编译过程部分之外的本地配置文件
（例如autoconf（1）生成的文件，关于autoconf（1），我们将在第17章讨论）。
reafCZ已髓n
    删除所有用makeile构建的文件。这有可能同make distclean的作用完全～样，
但无论如何，应该作为单独的目标，并且以文档说明。当与make distclean不同时，
它删除的文件往往可以用其它文件生成，但（因种种原因）又需要同工程源码一起发布。
install
    在系统目录中安装项目工程的可执行文件和文档（通常需要root用户权限）以让普
通用户访问。同时初始化或更新启动执行文件所需的任何数据库或库文件。
uninstall
    删除白make install安装在系统目录中的所有文件（一般要求root用户权限）。
这应该是make inatall彻底完美的逆过程。uninstall的存在显示了一种人性化的设置，
有经验的Unix用户常常认为是周到的设计；反之，如果没有uninstall，软件做得再好充
其量也是粗枝大叶的，  （例如，软件安装创建了庞大的数据库文件）甚至是考虑欠佳、
相当粗糙的。
    所有这些标准目标的可工作的范例在fetchmail的makefile中都可见到。作为整体研
究时，就会看到一个模式的出现，而且（并不是偶然地）会学到更多fetchmail的打包结
构。使用这些标准目标的好处之～就是其项目路线不言自明。
    但是不要局限在这些通用目标上。一旦掌握make，就会越来越频繁地使用makefile
机制来自动化那些依赖项目文件状态的小任务。makefile就是一个方便存放完成这些小
任务脚本的重要地方；而使用make可以在检视如何完成这些小任务时一目了然，并且避
免了小脚本将项目工作空间弄得凌乱不堪。
UNIX编健艺-术
  www.pdf365.com
362
第1 5章工具：开发的战术
15.4.4生成Makefile
    较之于许多内嵌从属数据库的IDE来说，Unix make明显的优势之一就是makefile
是简单的文本文件――可由大多数程序生成。
    在1980年代中期，对于庞大Unix程序的发布来说，包含一个精致的可以探测环境
并收集信息构建来定制makefile的用户shell脚本相当普遍。这些定制配置器的规模甚至
达到了荒唐的程度。我曾经编写了3000行shell脚本，几乎是它所配置程序任何单个模
块的两倍――而且这并不少见。
    社区最后说“够了！”，而许多人开始着手编写工具来自动维护makefile的部分或
全部过程。这些工具一般试图解决两个问题：
    一个问题是可移植性。Makefile生成器通常为不同的硬件平台和Unix变种编制。它
们往往试图推断出本地系统的信息（包括从机器字大小到机器可以获得的工具、语言、
服务库甚至文档格式化器等一切）。它们常常尝试使用这些信息编写makefile，以利用
本地系统的功能，或是补偿本地系统的欠缺。
    另一个问题是派生依赖关系。分析源文件本身可能推导出大量C源码文件间的依赖
关系（尤其是它们使用和共享了哪些包含文件）。许多makefile坐成器这样做就是为了
能够机械地生成make依赖关系。
    每种不同的makefile生成器以不同的方式来解决这些目标问题。可能有十几个或更
多的生成器，但大多数都被证明功能不足或难以使用或两者兼有，但是有些还在现实中
使用。我们将在这里研究其中几个主要的。所有这些工具都可以在互联网上获得其开源
版本。
15.4.4.1makedepend
    几个小工具都可以分别处理问题的规则自动化部分。这一个，随着MIT的X window
系统一起发布，是其中最快、最有用的。在所有现代的Unix下，包括所有的Linux下都
有预装。
    makedepend收集C源码集合，然后从它们的#include指令中为相应的．。文件生
成依赖关系。这些可以直接追加到makefile中，而实际上，makedepend也正是这样做的。
    makedepend只对C项目有效。它并不试图解决除了makefije生成以外的问题。但是
它做的事相当漂亮。
www.pdf365.com
15.4 make：自动化编译
363
    makedepend的手册页文档充分。在终端窗口键入man makedepend可以很快地了
解调用它所需要知道的一切。
15.4.4.2Imake
    Imake是为了X window系统机械化生成makefile而编写的。它基于makedepend并
且既可处理依赖派生，又可处理移植性问题。
    Imake系统有效地使用Imakefile代替了传统的makefile。Imakefile采用更紧凑更强
大并（有效地）以makefile的表示法编写。编译过程使用规则文件，该文件专门针对目
标系统并且包含了许多关于本地环境的信息。
    Imake非常适合X特有的移植性和配置困难，并且通常使用在X系统某个部件项目
中。然而，在X开发者社区之外它并不流行。它难以学习，难以使用，难以扩展，而且
产生的makefile生成文件，其复杂程度和庞大规模令人刚磴口呆。
    Imake工具可以在任何支持X的Unix上获得，包括Linux。有个创举[DuBois]尝试
让丰申秘的Imake能够为非X编程者所知。如果打算进行X编程，学习这些当然值得。
15.4.4.3  autoconf
    见识了Imake却又拒绝Imake万法之后，有人编写了autoconfo它为每个工程生成类
似旧有的客户脚本配置器的configure shell脚本。这些confiaure脚本能够生成
makefile（和其它的东西）。
    Autoconf着重于可移植性并且根本就没有内置派生依赖。尽管它可能同Imake般复
杂，但是它更灵活也更容易扩展。不是依赖每个系统的规则数据库，autoconf生成“配
置’’shell代码去搜索系统以获得信息。
    每个c。nfigure shell脚本来自于必须事先编写的项目模板，称为configure．in。
它一旦生成，c。nfigure脚本就是独立的，可以在任何本身并不存在日“toconf（1）程
序的系统上配置项目。
    au！toconf生成makefile的方法就像在imake中为项目开始编写一个makefile模板一
样。但是口“toconf的Makefile．in文件基本上就是makerile文件，只不过多了用于简
单文本置换的占位符；不需要学习另外的表示法。如果需要依赖派生，必须显式地调用
makedepend（1）或相类似的工具――或者使用automake（1）。
UNIX编程艺|术
  www.pdf365.com
364
第1 5章工具：开发的战术
    autoconf文档以GNU信息格式的在线手册存在。脚本源码可以从FSF存档站点获得，
但是在许多Unix和Linux版本上都有预装。应该可以通过自己的Emacs帮助系统浏览其
手册。
    尽管缺乏对依赖派生的直接支持，并且尽管它的方法很特殊，但在2003年年中，
autoconf毫无疑问地是最流行的makefile生成器，并且已经流行了数年。它已经蚕食了
Imake的份额，并至少废掉了一个主要竞争者（metaconfig）。
    参考书籍请阅《GNU Autoconf， Automake and Libtool [Vaughan]》。另外，我们将
在第17章从一个略微不同的角度讨论autoconf更多的细节。
15.4.4.4  automake
    automake尝试在autoconf（l）上增加一个fmake式的依赖派生关系。用广泛的Imake
式的表示法编写Makefile．am模板；automake（l）编译成Makefile．in文件，然后该
文件供autoconf的conf igure脚本操作。
    在2003年年中，automake仍然是一项相对较新的技术。好几个FSF项目使用了这
项技术，但足别的地方并没有广泛采用。尽管它的生成方式似乎很有前景，但还是相当
脆弱――按规则使用时能够工作，但如果想用来做点儿别的，就会失败得很惨。
    完整的在线文档随同automake -起发布，并可以在FSF档案站点处下载。
15.5版本控制系统
    代码在发展。项目从原型的第一笔到交付使用的过程中，要经过多个周期，其中新
问题的探索、调试、把已经完成的东西稳定化。这种发展历程在第一次发布产品时并不
会停止。绝大多数项目在1.0阶段后，都需要维护并增强，会存在多次再版。而追踪所
有那些细节恰恰是计算机而非人类所擅长的事情。
1 5。5.1  为什么需要版本控制
    代码的不断发展产生了好几个实际问题，可能成为主要的阻碍和难题来源――这当
然会严重耗费生产力。耗费在这些问题上的每～刻，都无法投入到项目设计和使功能正
确的工作中。
www.pdf365.com
15.5版本控制系统
365
    也许最重要的问题就是回归。如果改变了代码却发现并不可行，如何恢复到一个已
知的良好版本？如果回归是困难的或不可靠的，改变代码就太过冒险（有可能会崩掉整
个项目，或者为自己凭空增加许多小时的痛苦工作）。
    几乎同样重要的是变化追踪。知道代码已经发生了改变；但知道为什么吗？稍后再
看它们却很容易就忘记了改变的原因。如果项目存在合作者，又如何知道在自己不注意
时合作者改变了什么，另外，每个修改该由谁负责？
    常常令人惊奇地发现，即使没有合作者，问问自己从上一个已知的良好版本
  后改变了什么也非常有用。这也常常会揭露不必要的改变，例如被遗忘的调试码。
  我现在在检入（ check in）变化前，一般就会做这项工作。
-Henry Spencer
    另一个问题是bug追踪。在代码经历了相当的变化后得到一个新的bug报告相当普
遍。有时能够立即发现bug已经被解决了，但通常不能。假设在新版本中bug并没有显
现。但为了重现和理解bug，如何恢复到代码的旧版本？
    为了解决这些问题，需要能够保留项目历史，并且加上注释来解释它。如果项目不
止一个开发者，同时还需要一种机制能够确定开发者不会覆盖彼此的版本。
15.5.2手I版本控制
    最原始（但仍旧很普遍）的方法是全手工的操作。定期手工地将一切文件复到～个
备份以作为项目的快照。当然可以在源文件中包含历史评注。也可以通过口头的或邮件
的安排让其他开发者在自己修改时不要动那些文件。
    这种手动方式的隐性成本非常高，尤其（也常常发生）当时间不允许的时候。而整
个过程异常耗费时间和精力；容易出错，在压力之下或项目处于水深火热时又往往会被
遗忘――而这正是最需要版本控制的时候。
    如同多数的手动修改一样，这种方式很难用在大规模项目中。变化追踪的粒度也十
分有限，而且细节经常丢失：比如变化次序、谁做的、为什么等。恢复一大批变化的过
程极度乏味又耗费时间，而在尝试某些并不能很好工作的修改后，开发者往往不情愿地
继续回退到更老的版本。
UNIX编曜艺术
  www.pdf365.com
366
第1 5章工具：开发的战术
15.5，3自动化的版本控制
    为了避免上述问题，可以使用一个版本控制系统（ version-control system VCS），这是
一组程序套件，能够自动化保存项月的历史评注，并避免修改冲突。
    多数VCS共享同样的基本逻辑。使用时，一开始先注册源文件集合――也就是说，
告知VCS开始记载这些存档文件的变化史。因此，在需要编辑这些文件中的某一个时，
必须检出（ check out）这个文件――在其上声明一个排它锁。修改完成之后，检入（check
in）这个文件，把变化加入存档中，释放锁定，并且说明修改了什么东西。
    项目的历史变化不一一定是线性的。实际上所有常用的VCS允许维护不同版本的树型
结构（比如不同机器架构间的移植版本），并提供工具来将不同的分支合并回主要的“主
干”版本。随着开发小组规模和分散性的增长，这个功能特征会变得越来越重要。然而
需要谨慎使用；具有多重活动版本的代码库特别容易混淆（例如，仅仅将bug报告同正
确版本相关联就非易事），同时各分支的自动归并不能保证结合的代码就一定能够运行。
    VCS余下所做的一切比较容易：标注，并报告与这些基本操作的相关特征，提供工
具允许查着不同版本间的差别，或者将给定的各个版本文件聚合在一起作为统一命名发
布，以便任何时候在可以不丢失后续改动前提下，进行检查或恢复。
    VCS自身存在一些问题。最大的问题就是每次使用VCS编辑文件时都需要涉及额外
的步骤，这些步骤如果是手工操作的话，匆忙的开发者都想跳过它。本章接近结尾的地
方，我们会讨论解决这个问题的方法。
    另一个问题是，某些很自然的操作往往会弄乱VCS。文件改名就是～个臭名昭著的
问题源；当～个文件改名时要自动地确保文件的版本历史还能够随之而在，这并不容易。
特别当VCS支持分支版本时，这个问题尤其难以解决。
    尽管存在这些麻烦，VCS仍然在许多方面对生产力和代码质量都带来巨大的实惠，
甚至对于小型单开发者项目也是如此。它们自动化了许多乏味的过程。对从错误中恢复
过来大有帮助。而可能最重要的是，可以确保很容易地恢复到一个已知的良好状态版本，
解放了程序员，从而可以自由地不断实验与探索。
    （VCS，顺便提一下，并不仅仅针对程序代码有效；本书原稿在写作的过程中就是
作为RCS下的文件集来维护的。）
www.pdf365.com
15.5版本控制系统
367
15.5.4  Uni×的版本控制工具
    在历史上，Unix世界中，三个VCS占据了重要的地位，我们将在此检阅。对于更多
的介绍和指导，参考《Applying RCS and SCCS》（RCS和SCCS应用）[Bolinger-Bronson]。
15.5.4，Il  源码控制系统（Source Code Control System，SCCS）
    第一个这样的系统是SCCS，最初在1980年前后由贝尔实验室开发，并在System IIl
Unix中出现。SCCS似乎是第一个在统一源码控制系统的重大尝试；由它开拓的观念在
某些层次上仍然可以在后来所有的版本控制系统中见到，包括诸如ClearCase在内的Unix
和Windows商业产品。
    然而SCCS本身现在已被废弃；它是贝尔实验室的专有软件。更好的开源替代品已
经开发出来，而且Unix世界中的大多数都已经转而采用了它们。SCCS在一些商业公司
中仍然用于管理某些古老的项目，但新项目并不推荐使用。
    SCCS没有完整的开源版本实现。存在一个克隆产品，叫做CSSC（ Compatibly Stupid
Source Control）在FSF的赞助下进行开发。
15.5.4.2  停订控制系统（Revision Control System， RCS）
    更好的开源替代品从RCS（修订控制系统）开始，在SCCS的几年后在普渡（Purdue）
大学诞生，最初发布在4.3BSD Unix上。它在逻辑上与SCCS相似，但是具有更简洁的
命令接口，还可以通过符号名将整个项目发布组合在一起。
    RCS现在是Unix世界中使用得最为广泛的版本控制系统。一些其它Unix版本控制
系统则使用它作为后端或底层。它非常适用于单一开发者或小型团队。
    RCS源码由FSF维护和发布。也可以找到Microsoft操作系统和VAX VMS的免费
移植版本。
15.5.4.3  并发版本系统（Concurrent Version System， CVS）
    CVS（Concurrent Version System/并发版本系统）是作为一个RCS的前端开始其生
命的，在】990年代早期开始开发，然而其使用的版本控制模型与原版本大相径庭，所以
立即具备了成为一个新设计的资格。现代的实现版本并不依赖RCS。
    同RCS和SCCS不一样，CVS在检出（check out）时并不排它地锁定文件。相反，
在检入（check in）回来时，它尝试自动地调和雨相冲突的改动，同时让人来帮助仲裁冲
UN）×编程艺-术
    www.pdf365.com
368
第1 5章工具：开发的战术
突的变化。这种设计是有效的，因为修改中的冲突远比直觉想象中的要少得多。
    CVS的接口比RCS要复杂得多，也需要更多的磁盘空间。这些性质使其作为小项目
的选择并不明智。另～方面，cvs非常适合庞大的多开发者项目，开发者分布在由互联
网连接在一起的好几个开发站点。客户端机器上的CVS工具可以很容易地对另外主机上
的代码库进行操作。
    开源社区在项目中大量使用CVS，例如GNOME和Mozilla。典型地，这些CVS代
码库允许任何人从远端机检出源码。因此任何人都可以制作项目的一份本地拷贝并进行
修改，然后将改动补丁邮寄给项目的维护者。代码仓库的实际写访问权存在更多的限制，
必须明确得到项目维护者的授权。拥有这种权利的开发者可以选择直接从本地的修改拷
贝上实施提交，这样本地的改动会直接并入到远程代码库之中。
    在GNOME CVS站点<http：／／cvs．gnorne．org>可以看到一个运行良好的、通过
互联网访问的CVS代码库实例。这个站点说明了诸如Bonsai等支持CVS的浏览工具的
用法，这在帮助一个庞大分散组织中的开发者彼此协调工作时非常有用。
    伴随使用CVS产生的人文方法和哲学踉工具的细节同等重要。它们假定，项目将是
开放和分散的，而且代码主体需要经过同行的复审和检验，甚至由那些并非项目组正式
成员的开发者完成。
    同样重要地，CVS非锁定的哲学意味着如果一个程序员在改动的中途离去时，他的
锁定不致于阻塞整个工程。CVS因此能够让开发者免于“单点失败”的问题；反过来，
这也意味着项目的边界可以是流动的，随意贡献相对容易，并且项目不要求有一个精心
的控制层级。
CVS源代码由FSF维护和发布。
    cvs也存在某些重大问题。有些仅仅只是实现中的bug，但有一个基本问题：项目
的文件命名空间并不能像对文件本身的改动那样可以进行版本控制。这样，CVS很容易
就被文件的改名、删除和增加给弄混。同时，CVS的变化记录基于每个文件，而不是针
对多个文件的改动集。这就难以恢复到某个特殊的版本，也难以处理部分检入操作。幸
运地，这些问题并不是非锁定风格固有的问题，而且已经由新的版本控制系统成功解决
了。
15.5.4.4其它版本控制系统
    CVS存在的设计问题足够引发对更好开源VCS的需求。在2003年中，有数项工作
在进行中。其中最著名的是Aegis和Subversion。
www.pdf365.com
15.6运行期调试
369
    Aegis<http：／/WWW.pcug.org.au/-millerp/aegis/aegis.html>在这些
候选者中历史最长，自从1 991年就已经开始开发了，而现在是个成熟的产品系统。它的
特点是非常强调回归测试和合法性确认。
    Subversion<http：／/subversion．tigrls．org/>完全解决了已知的种种问题，
确定了“把CVS做对”的地位，而且在2003年看来，也许是近期最有希望取代CVS的
软件。
    BitKeeper<h七tp：／/www．bltkeeper．com>项目开拓性实验了某些有趣的设计思
想，如“改动集”以及多个分布式代码仓库。Linus Torvalds使用BitKeeper来开发Linux
内核源码。然而，BitKeeper的非开源许可，引起了争议，并且严重地延缓了接受该产品
的过程。
15.6  运行期调试
    只要拥有超过一星期编程经验的人都会知道，让程序符合正确的语法是调试中相对
容易的部分。凼难的是在这之后，需要r解为什么语法正确的程序并不如期望的那样运
行。
    Unix传统提倡开发者通过透明性设计先人一招地解决这个问题――特别在程序设计
对，考虑内部数据的流向容易被人眼和简单工具审视，并且易于建模。我们已经在第6
章详细地涵盖了这个议题。透明设计在防止bug和减轻运行期调试任务两方面都是非常
有价值的。
    然而，透明性设计本身还不够。当需要在运行期调试一个程序时，能够检查运行期
的程序状态、设置断点以及以一种可控的方式执行某个低至单～语句层次部分是极其有
用的。Unix存在一个提供工具来帮助完成这些任务的长期传统。多数开源Unix都拥有
威力巨大的gdb（也是一个FSF项目）支持C和C++调试。
    Perl、Python、Java和Emacs Lisp都支持设置断点、控制执行以及一般的运行期调试
操作的标准软件包或程序（包含在基本发布版本中）。Tcl，这个设计用来为小型项目开
发的小巧语言，没有这方面的功能（尽管它存在可以在运行期监视变量的跟踪功能）。
    牢记Unix哲学。将时间花费在设计质量上，而不是低层次的细节上，尽可能地自动
化一切――包括运行期调试的细节工作。
UNIX编程艺：术
    www.pdf365.com
370
第1 5章工具：开发的战术
15.7性能分析
    作为通用法则，程序90%的执行时间都耗费在lO%的代码上。性能分析软件（profilers）
可以帮助确定那10%抑制程序速度的区域。这可以让程序跑得更快。
    但在Unix传统中，profiler有个更为重要的功能。它能够让人不去优化其余90%的
代码。这很棒，并不仅仅由于这样节省了工作。其实不去优化余下90%代码真正有价值
的效应是降低了整体复杂度，减少了bug。
    有人可能会回忆起我们在第1章引用的Donald Knuth评论“过早优化乃万恶之源’’，
以及Rob Pike和Ken Thompson关于这个论题的尖锐观点。这是经验之谈。做好设计。
首先考虑什么是正确的。然后再调整效率。
    Profiler帮助完成这一切。如果养成使用它们的好习惯，可以改掉过早优化的坏习惯。
Profiler工具不仅改变工作的方式，也改变思考的方式。
    编译型语言的profiler工具依赖于度量对象代码，所以它们比编译器更依赖于平台。
另一方面，编译型语言的profiler并不关心其衡测程序的实现语言。所以在Unix下，一
个profiler程序gprof （1）就可以处理C、C++和其它所有韵编译型语言。
    Perl、Python和Emacs Lisp在它们的基本发布版本中都包含有自带的profiler程序；
这些程序都可以移植到其宿主语言可以运行的所有平台上。Java有内建的profiler。但Tcl
至今还没有profiling支持。
15.8  使用Emacs整合工具
    Emacs编辑器非常擅长的事之一就是作为其它开发工具的前端（我们在第13章已经
从～个哲学的角度讨论过这个问题）。实际上，几乎本章讨论的所有工具都可以在Emacs
编辑器对话中使用Emacs作为前端驱动，而相比这些工具单独运行来说，这个前端往往
更为易用。
    为了展示这一点，我们以典型的编译／测试／调试循环来一起审视Emacs与这些工具
的组合使用。但对于它们的细节，请参考Emacs本身的在线帮助系统：本部分仅仅只是
给出一个总揽以激发学习热情。
    读然后学――这并不仅仅针对Emacs，也是培养在程序之间寻找协作方法的思想习
惯，以及培养创造这些协作方法的思想习惯。尝试以哲学指导来看待这一节，而不局限
在技术层面。
www.pdf365.com
15.8使用Emacs整合工具
371
15.8.1   Emacs和 make
    输入Emacs命令ESC-x compile，回车后就可以启动Make。这将在当前目录运
行make（1），截获Emacs缓冲区的输出。
    这粗看用处不大。但是Emacs的make模式了解Unix C编译器和许多其它工具产生
的错误信息格式（均带有源文件名和行号）。
    如果任何由make运行的程序产生错误，命令Ctl-x、（control-X-backquote）将尝试
解释它们、依次定位每个错误，并弹开一个窗口载入错误文件并将光标定位至发生错误
的行上9。
这就可以很容易一步步浏览整个编译过程，并纠正任何自上次编译后的语法错误。
15.8.2  Emacs和运行期调试
    为了捕获运行错误，Emacs提供了类似的对符号调试器的集成――即可以使用某个
Emacs模式在程序中设置断点并检视程序运行时的状态。通过Emacs窗口传送命令就可
以运行调试器。无论何时调试器停止在断点上，Emacs将解析调试器回传的源码位置相
关信息，并在源码断点附近弹出窗口显示。
    Emacs的Grand Unified Debugger模式支持所有主流的C调试器：gdb（l）、  sdb（l），
dbx（1）和xdb（l）o使用perldb模块的话还可支持Perl符号调试，同时支持Java和Python
的标准调试器。内建于Emacs Lisp本身的功能也支持Emacs Lisp代码的交互调试。
    在本书创作（2003年年中）期间，Emacs还不支持Tcl的调试。Tcl的设计似乎决定
了这种特性不太可能加入到Emacs之中。
15.8.3  Emacs和版本控制
    - Ea完成了程序的语法错误修订和纠正了运行期bug之后，也许会要把改动保存到
版本控制文档中。如果只能从shell运行版本控制工具，就不好责备自己忘记了这个重要
的步骤。谁记得住每次编辑操作之后都必须运行checkouUcheckin命令昵？
9更多的信息以及编译控制命令可以参考Emacs help菜单下的p+processes->compile。
UNIX编腥艺：术
  www.pdf365.com
372
第1 5章工具：开发的战术
    幸好Emacs在这方面也提供了帮助。Emacs内建代码实现了SCCS、RCS、CVS或
Subversion的简易使用前端。单一命令Ctl-x v v在正访问的文件上进行下～步的逻辑
版本控制操作。这些操作包括注册～个文件，检出（check out）和锁定，以及将文件检
入（checkin）回去（同时允许在弹出窗口中加入修改注释）10。
    Emacs同时也帮助用户浏览受版本控制文件的变化历史，而且还可以撤销不想要的
改动。Emacs使得对整个文件集合或项目文件目录树进行版本控制也非常容易。总之，
Emacs做得非常好，让版本控制操作不再是件痛苦的事。
    除非用惯了，不然这些功能的意义要比你所能想象的深远得多。一旦习惯了快速方
便的版本控制，才会发现真正得到了自由。而正是因为知道总是可以恢复到已知良好的
状态，才可以更自由地以一种灵活的探索方式进行开发，才可以试验多种变化来查验它
们不同的效果。
15.8.4   Emacs和 Profiling
    令人惊奇……这也许是唯一一个开发周期中Emacs前端不能提供实质性帮助的阶
段。Profiling本质上是个批操作――衡测自己的程序，运行它，查看统计数据．用编辑
器对代码进行速度调整，然后重复整个过程。在整个开发周期中的专用于profiling的部
分并没有太多的余地留给Emacs来发挥作用。
    然而，对于我们思考Emacs和profiling之间的关系有个良好的指导性理由。如果发
现自己需要分析众多profiling报告，也许值得编写一个模式可以在profile报告某行上点
击鼠标或敲下键盘，就可以访问源文件的相关函数部分。其实使用Emacs的“tags”代
码，这相当容易实现。事实上，在阅读到本文的时候，也许某个读者已经编写了这样的
一个模式，并且把它贡献到了公共的代码库之中。
    这里所谓真正的要点同样是一个哲理。别蛮干――这会浪费时间和生产力。如果发
现在低层次的机械开发部分花费了太多时间的话，先站住。应该运用Unix哲学。使用工
具自动化或半自动化地完成任务。
    然后，作为对所有继承的回报，将自己的解决方案作为开源软件放置在互联网上。
帮助把程序员同行们从蛮干中解放出来。
10参考Emacs在线文档中标题为“版本控制”一小节，以获取这些相关命令更多的细节。
UNIX编程艺：求
www.pdf365.com
15.8使用Emacs整合工具
373
15.8.5像IDE一样，但更强
    本章稍早时，我们断言Emacs具备类似那些常规集成开发环境的能力，而且只会更
强。现在，已经有足够的事实证明所言非虚。可以在Emacs中运行整个的开发项目，敲
几下键盘就可以完成底层的技术性细节，从而减少了不断切换环境的脑力开销和那种不
连贯的感觉。
    Emacs带来开发风格舍弃了某些高级IDE的功能，例如像程序结构的图形视图。但
那些都是些虚饰。Emacs相应赋予的是灵活性和控制力。你不会被IDE设计者的想象局
限：使用Emacs Lisp，可以调整、定制以及增加与任务相关联的知识。同时，比起常规
的IDE来说，Emacs在支持混合语言开发上做得更好。
    最后，可以并不局限于某组IDE开发者所认为适合支持的事物。通过密切注意开源社
区，可以从千万的同行、以及面对同样挑战的Emacs使用开发者中受益。这更有效――也
更有趣。
UNIX编睡；艺术
    www.pdf365.com
www.pdf365.com
1 6
重用：论不要重新发明轮子
Reuse:
On Not Reinventing the Wheel
When  the superior man  refrainsfrom acting，  his force isfeltfor n thousand miles.
    不言之教，无为之益，天下希及之。
    -Tao Te Ching （as popularly mistranslated）
    一《道德经》
    不愿做不必要的工作是程序员的一大美德。如果中国圣人老子活到今天并仍然还
在传道的话，他可能会被错解为：不编之码，天下希及之。事实上，近来的译者已经
建议，传统上认为等价于“不作为”或是“节制行为”的中国专有名词“无为”，或
许应该解释成“最小行为’’、  “最有效行为”或是“按自然法则行为”，这更适合描
述良好的工程实践。
    牢记经济原则。每个新项目都从刀耕火种开始干起简直就是极端的浪费。请想想：
和其它耗在软件开发的花费比起来，时间无疑是最宝贵和最有价值的；所以相应地，应
该耗费在解决新问题，而不是对那些已存在确切解决方案的问题老调重弹。这种态度对
于开发投入来说，无论是在人员资本的“软”含义，还是在投资经济收益的“硬”含义，
都可以收到最好的回报。
UNI×编睡；艺-莱
  www.pdf365.com
376
第1 6章重用：论不要重新发明轮子
    重新发明轮子之所以糟糕不仅因为浪费时间，还因为它浪费的时间往往是平
方级。走捷径往往产生粗糙、未经思考的版本，长期而言这是假性节约，但通过
这种方式来节省重新发明时间的诱惑几乎总是无法抵抗的。
-Henry Spencer
    避免重新发明轮子的最有效方法是借用别人的设计和实现。换句话说，重用代码。
    下到单个库模块，上到整个程序，在各种级别上，Unix都支持重用，它帮你实现脚
本化和重组合。系统级的重用是Unix程序员区别于其他程序员的最重要行为特征；Unix
的经验是，养成良好的习惯，尝试通过最少的新发明，组合现有组件以形成原型，而非
匆忙地编写独立的、只能使用一次的代码。
    代码重用的品质是软件开发中如同苹果派和母爱般基本的主要美德。但是许多有其
它操作系统经历的开发者进入Unix社区后从未学会（或者从未学好）系统级重用的习惯。
浪费和重复工作相当普遍，尽管这种行为似乎既侵害代码生产者也侵害代码购买者的利
益。为什么这种病态行为会持续存在？知道了原因，就走出了改正的第一步。
16.1  猪小兵的故事
    程序员为什么会重新发明轮子？原闪很多，从狭隘的技术原因到程序员心理状态，
再到软件生严系统的经济学，方方面面都会导致如此行为，这种特有的顽疾正在肆虐。
    猪小兵是个刚走出大学的程序员，拿到了第一份正式工作。让我们假设他（或她）
已经知道了代码重用的价值并且满怀青春激情地准备大干一把。
    小兵的第～个项目是随团队编制一个大型应用。为了实例说明的方便，让我们认为
那是一个帮助终端用户能够智能构造查询和浏览庞大数据库的GUI。项目经理已经组合
了他们认为适合的工具和组件集，不仅包括开发语言，也包括许多程序库。
    那些程序库对于项目来说至关重要。它们包装了许多服务――下到窗口构件和网络
连接，上至诸如交互帮助的整个子系统――否则需要特别大量的额外编码，会严重影响
工程预算和发布时间。
www.pdf365.com
16.1猪小兵的故事
377
    小兵有些担心发布时间。他或许缺乏经验，但他看过Dilbert（呆伯特）漫画，还从
有经验的程序员那儿听过一些传说。他知道管理上有个趋势，说得好听点儿，进度上比
较“积极”。也许他已经读过Ed Yourdon的Death March（死亡之旅）【YourdonJ，那书
早在1996年就注意到，绝大多数项目的时间和资源预算都至少缩水了一半，并且会越缩
越厉害。
    然而小兵聪明伶俐，精力充沛。他想像出最可能成功的机会：学习分配到他手上的
工具和程序库，还得机灵点儿。他活动了～下打字的手指，一头猛扎进挑战之中……然
后就进了地狱。
    一切都要比他想的费时和痛苦。在程序库表面光鲜的示例程序下，正在重用的组件
似乎在一些边界情况下表现得无法预料或具有破坏性――而这些边界情况在他的代码中
常常遇到。小兵经常奇怪写程序库的家伙究竟是怎么想的。但他没法知道，因为组件的
文档不全――那些文档是技术文员写的，他们既不是程序员，想问题的方式也不像程序
员。他也不能通过阅读源码来了解程序库究竟是干什么的，因为程序库是处于专有许可
证下不透明的目标码。
    小兵不得不为组件问题不断地编写复杂的迂回代码，使用程序库已经到了得不偻失
的地步。迂回方法使得他的代码越变越糟。他碰到了程序库的软肋，库无法简单地像其
规格说明那样完成某些至关重要的任务。有时他也确信肯定有某种方法可以让这个黑盒
跑起来，但却无法断定究竟是什么方法。
    小兵发现，随着在程序库上花费的精力越多，他的调试时间就越成指数级地上升。
代码处于崩溃和内存泄漏的痛苦之中，追下来又往往发觉祸根就是那个程序库，或者是
某些他无法查看和修改的代码。小兵知道再追也许会追回到自己的代码，但是没有源代
码，就算想追回到自己代码也是不可能的。
    小兵开始沮丧了。大学里他曾经听说在业界，一个星期完成一百行代码就可以视为
是良好的业绩。那时他狂笑不已，因为在班级项目和写着玩的代码中，他的生产力是这
个的许多倍。现在这不再好笑。小兵不仅仅同自己的经验缺乏斗争，也同由别人的粗心
或者不胜任所制造的积压问题而斗争――这些问题他改不了，只能绕开。
    项目进度在变缓。梦想成为架构师的小兵发现，自己简直成了砖瓦匠，正在试图用
堆不起来的砖盖房，而且压力一大就会塌掉。而经理并不想听到新手的借口；大声地抱
怨组件质量太差，那些选择组件的经理和高级人员之间肯定会找他的麻烦。而且即使能
UNIX编程艺：术
  www.pdf365.com
378
第1 6章重用：论不要重新发明轮子
够成功说服他们，改换组件也将是一个复杂的提议，牵涉大群紧盯许可证法律条款的律
师。
    除非小兵非常、非常幸运，他不可能在项目的有生之年修正程序库的bug。在清醒
的时候，他也意识到库里面也有许多能工作的代码，他太注意那些bug和疏漏了。他
很愿意能够坐下来同组件的开发者好好谈谈，他们又不是白痴，从他们的代码能看出
来，他们一样是程序员，也工作在～个令人受挫的系统中。但是小兵甚至不知道他们
是谁――而且即使能知道，他们就职的软件商也多半不会让他们同他讨论这个问题。
    绝望中，小兵开始打造自己的砖块――用较稳定的库模拟不太稳定的库，并且开始
从零编写自己的实现。用来置换的代码是他自己的，思维模式他一清二楚，并且能够反
复阅读，更新认识，比起被替代的不透明组件和迂回方法所混合的代码，往往工作得相
对更好也更容易调试。
    小兵学到一个教训：越少用别人的代码，他的代码产量越高。这个经验满足了他的
自尊。像其他所有年轻的程序员一样，在思想深处都觉得自己比别人都聪明。他的经历
也似乎在表面上证实了这一点。所以小兵开始构建属于自己的工具包，一个自己用起来
更顺手的工具包。
    不幸的是，小兵此时获得的白己动手的习惯性思维，是一个短期的局部优化，会引
发长期的问题。他或许可以编写更多行的代码，但是如果不能重用，这些代码产生的实
际价值很可能会相当大幅度地降低。代码多并不等于代码好，至少在编写低层次代码和
大量重复投入时是如此。
    在换工作时，小兵至少还得准备经历～个挫折。他很可能发现带不走他的工具包。
如果他带着在公司编写的代码走出公司大门，其1日雇主就有理由认为他侵犯了知识产权。
如果承认重用了旧代码，新雇主如果知道了，也大有可能很不爽。
    即使小兵能够偷偷摸摸地在新工作中使用原先的代码，他也会发现自己的工具包用
处不大。新雇主也许使用一套不同的专有工具、语言和程序库。极有可能的是，在每个
新项目中，小兵都不得不学习一个稍微新～点的技术并重新发明一套轮子。
    这样，程序员重用代码（以及其它诸如模块性、透明性等随之而来的良好实践）便
是技术问题、知识产权壁垒、行政问题以及个人自我意识的综合。成千上万的小兵们，
年复一年地随着年龄的增长，变得越来越愤世嫉俗，也越来越习惯那种系统。对于多数
www.pdf365.com
16.2透明性是重用的关键
379
软件行业的现状，这就是巨大的时间、资本和人力资源浪费――这还没算上商家市场策
略、管理缺乏竞争、不可能期限以及所有其它阻碍工作的压力因素。
    小兵经历反映的职业文化可以折射出大部分的情况。软件公司有种“非自己做不可”
的强烈情结。他们对于代码重用是矛盾复杂的，一方面为了赶进度逼迫程序员使用功能
不足但很有市场的商业组件，同时又拒绝重用程序员自己经过良好测试的代码。这些软
件公司费力生产的是大量专用重复的软件，其实编制软件的程序员知道结果会是垃圾，
但除了自己的代码，别的哪儿也动不了。
    代码好不容易写出来了就决不能扔，只有不断地修修补补，即使所有的人都知道扔
掉重写会更好些，这个教条，就是在这种文化里形成的最接近代码重用的对等物。这种
文化产生的产品，即使其中涉及的每位人员都尽最大努力做好工作，随着时间的推移，
写出的程序还是会变得越来越臃肿，bug也越来越多。
16.2透明性是重用的关键
    我们埘许多有经验的程序员讲述了猪小兵的故事。如果读者本身正好是位程序员，
我们相信你会和他们一样有感同身受的无奈。如果你不是程序员却管理着一群程序员，
我们真诚地期望你能从中得到启发。这个故事试图谠明，反对重用的压力来自各个层面，
无法预料那一大堆问题究竟出自哪个原因。
    因此，对于大多数已习惯了软件行业背景的我们，常认为把这个问题的主要原因从
叙述的故事中提炼出来要花费相当大的努力。但最后，这些原因其实并不十分复杂。
    猪小兵的多数麻烦（也意味着大规模质量问题）归根结底是透明性――或者更确切
地说，是缺乏透明性。无法修正不通内情的东西。实际上，任何具有非平凡API的软件，
如果无法深入肌理，甚至无法正确使用。只有文档，不仅在实践上不足，在原则上同样
不够；文档并不能传达代码具现的所有细微差别之处。
    在第6章，我们评述了透明性对于优秀软件是何等的重要。只有目标码的组件破坏
了软件系统的透明性。如果在尝试重用时，其源码可以被阅读或修改，那么代码重用失
败的那种刺痛感要少得多。注释良好的代码本身就是良好的文档。源码中的bug也可以
UNtX编腥艺术
  www.pdf365.com
380
第1 6章重用：论不要重新发明轮子
改掉。有了源码，可以装备程序来进行衡测，可以通过编译来进行调试，这样在晦涩模
糊的情况下就更容易探询程序的行为。而如果需要改变程序的行为，当然也可以做到。
    需要源码还有另外一个重要的原因。Unix程序员在几十年中学到了“只有变化才是
永恒的”，经验是，源码可以永续，目标码则不行。硬件平台改变了，支持库的服务组
件改变了，操作系统发展了新的API并废弃旧的API。一切都变了――但是不透明的二
迸制执行码却无法适应变化。它们是脆弱的，不能够可靠地向前移植，不得不靠日益庞
大和错误百出的环境模拟代码层来支持。二进制可执行码将用户桎梏在编译构建者的设
想中。源码是必需的，因为即使不想或不需要改动软件，可能还得在新的环境中重新编
译以保证它能继续运行。
    透明性的重要，以及代码遗留问题，是要求重用代码开源以供检验和修改的两个理
由。但这并不是需要“开放源码”的完整论据；因为“开放源码”具有更深远的意义，
而不仅仅只是简单地要求代码是透明的和可见的。t
16.3从重用到开源
    在Unix的早期时代，操作系统组件、函数库以及相关实用程序都是随源码一起发布
的；这种开放性是Unix文化的生命力历在。在第2章我们描述了这种传统在1984年中
断以后，Unix是如何失去了它的原动力。我们也描述了再十年后，GNU工具包和Linux
是如何促使人们重新发现开放源码的价值。
    今天，开源代码又一次成为所有Unix程序员工具箱中最强大的工具之一。相应地，
尽管“开源”的明确观念以及最广泛使用的开源许可证要比Unix iS身晚数十年，但要在
如今的Unix文化中进行前沿开发，理解这两者是非常重要的。
    开放源码和代码重用的关系，在许多地方很像浪漫爱情和有性生殖的关系；你可以
用后者的术语来解释前者，但这样做就忽略了前者的趣味。开放源码并不能仅仅归纳为
一个在软件开发中支持重用的策略。它是一种自然而然发生的现象，是开发者以及用户
1  NASA（美国国家航空航天局）有意识地编制具有数十年服务期的软件；它已经意识到，需要坚决
要求所有空间航空电子学软件的源码都可获取。
www.pdf365.com
16.4生命中最美好的就是“开放”
38 1
直谏，为了保护透明性相关优势的社会契约。同样地，存在好几种方法来促成这种理解。
    本书早些时候在相关历史的描述中，我们选定的视角，集中在Unix和开源之间随意
的文化上的关系。我们将在第19章讨论开源开发的规则和策略。在讨论代码重用的理论
和实践时，更明确地考虑开放源码，非常有助于直接回应猪小兵故事中戏剧性表现出来
的问题。
    软件开发者希望他们使用的代码是透明的。更进一步，他们在换工作时不希望失去
他们的工具包以及他们的专有经验。他们厌倦了成为受害者，腻烦了被生硬的工具和知
识产权壁垒弄得灰心丧气，受够了不断地重新发明轮子。
    这些就是开放源码的动力，从猪小兵痛苦的初步重用经历中产生的动力。这其中涉
及了自我意识：设计最好的实践需要情感的投入，而不是冷漠无聊的过程。软件开发者，
同其它任何类型的工匠和技师一样；他们想要成为艺术家，这并不是什么私密。他们有
艺术家的动力和需求，也有拥有听众的欲望。他们不仅仅希望重用代码，他们也希望自
己的代码得到重用。这种势在必行的意念驱动，超越和颠覆了任何短期经济目标的达成，
也不是闭源软件生产所能够满足的。
    开放源码是种从意识形态上解决这些历有问题的优先方法。如果猪小兵在重用过程
中的多数问题的根源都在于闭源代码的不透明性，那么生产这种闭源代码的体制构想就
应该被击个粉碎。如果还考虑商家的领域地位，就必须抨击或直接绕过，直到公司意识
到它们的领域性习惯思维应该自我毁灭。代码重用竖起大旗并得到拥护者之后，开放源
码就是接下来自然而然要发生的事。
    相应地，自从1990年代晚期，在介绍代码重用的策略和战术时，如果不讨论开放源
码、开源实践、开源许可证以及开源社区，就毫无意义。当然，尽管这些问题在别处可
以分开讨论，但是在Unix世界中，它们已经无法避免地要绑在一起。
    在本章的余下部分，我们会纵览有关重用开源代码的几个不同问题：评估、文档和
许可证。在第19章，我们将更广泛地讨论开放源码开发模型，并研究向他人发布代码时
所必须遵从的约定。
16.4生命中最美好的就是“开放”
    在Intemet上，可以利用的Unix源代码，包括各种系统软件、应用软件、服务程序
库、GUI工具包以及硬件驱动等等确切地需要以TB来计算。大多数都可以使用标准工
UNI×编程艺术
  www.pdf365.com
382
第1 6章重用：论不要重新发明轮子
具在几分钟内编译并运行起来。只要念个咒：，/configure; make; make install;
当然，通常情况下必须在root用户下才能做安装部分的操作。
    来自Unix世界以外的人们（特别是非技术人员）往往倾向于认为开源（或“自由”）
软件必然比商业软件差，是假冒伪劣的，不可靠的，带来的麻烦只会比所能免除的更多。
但这遗漏了重要一点：一般来说，编写开源软件的人都很在乎它，也需要它，自己使用
它，而且通过发布这个软件在同行中赢得个人声誉。他们的时间也往往更少地耗费在会
议、反馈设计更改或是各种官僚的开销中。他们也因此具有更强的动力和更好的立场来
完成卓越的工作，远远超过那些薪水的奴隶，他们只会在专有软件公司大厦的小隔断里
费力地做着呆伯特似的工作，来迎合无法达成的最终期限。
    此外，开源用户社区（那些同行）不会羞于抓bug，而且他们的标准很高。发布不
够格软件的作者会承受许多的社会压力来修正或撤回代码，如果需要的话还能得到许多
专家级的帮助。结果，成熟的开源软件包一般都是高质量的而且常常在功能上比任何专
有等价物都要高级。这些开源软件或许看起来并不漂亮，想看懂文档或许也下容易，但
其至关重要的部分通常都会工作得相当漂亮。
    在同行评审效应之外，另外一个可以推测出质量上佳的理由是：在开源世界的开发
者，从来不会受最终期限的压迫，不会一闭眼、一拍脑门就发布软件。因此开源实践同
其余地方的一个区别就是，l.0级别的版本实际上意味着软件可以使用了。事实上，0.90
或者更高的的版本号就相当可靠，表明代码已经是成品了，但是开发者还是不敢拿这个
软件来赌自己的声誉。
    如果是来自Unix世界以外的程序员，也许很难相信这种主张。如果是这样，想想看：
在当代各种Unix上，C编译器本身几乎总是开放源码的。自由软件基金的GCC （GNU
Compiler Collection，GNU编译器集）是如此的强大可靠，文档又是如此的完善，专有的
Unix编译器根本没有市场空间，所以Unix的某些商家将GCC移植到他们自己的平台而
不是自己开发内部的编译器就再正常不过。
    评估开源软件包的方法是阅读其文档和快速浏览它的部分代码。如果所见的代码编
写恰当，文档完备，那么鼓励使用。如果能够证明软件包已经有些年头并且存在实质具
体的用户反馈，就可以断定它是相当可靠的（无论如何还是测测为佳）。
www.pdf365.com
16.4生命中最美好的就是“开放”
383
    在README文件以及项目新闻或源码发布历史文件中，所提到的除原作者之外的人
数，是度量成熟度以及用户反馈量大小的好方法。很多人呈报修正和补丁本身就是良好
的表征，既表明存在一个相当重要的用户群保持着对软件作者的敦促和警醒，也表明软
件维护者是恪守职责的，能够对反馈作出响应并订正错误。当然，这也是一个暗示，如
果早先的代码是充满bug的雷区，不用等到最近的爆炸，早就有受惊的人群踩得响噼里
啪啦的了。
    如果软件拥有自己的网页，在线常见问题解答（FAQ，Frequently Asked Questions）
列表，以及相关的邮件列表或Usenet新闻组，也是良好软件的表征。这些都是一个鲜活、
充实、有兴趣的社区已经围绕这个软件而成长起来的标志。网页上，最近的更新以及扩
展的镜像站点列表也同样是可靠的标记，表明这个项目拥活跃的用户群体。荒废的软件
包不可能有这种持续的投入，因为不值得。
    已经移植到了多种平台上也是个有价值的表征，说明用户群体多种多样。项目主页
往往明确地大肆宣扬新的移植版本，因为这样表明了软件的可信度。
    这儿是～些有关高质量开源软件的网页的实例：
    ●  GIMP<h七tp：／/www. gimp.org/>
    ●  GNOME<ht tp：／／www.gnome.org>
    ●  KDE<http://www. kde.org>
    ●  Python<http:／/www .python. org>
    ●  The Linux kernel<ht tp:／／www. kernel. org>
    ●  PostgreSQL<http:／/www. postgresql. org>
    ●  XFree86<http:／/xfree86.org>
    ●  InfoZip<http: //www. info- zip. org/pub/infozip/>
    看看Linux的各种发布版本是另一个寻找高质量软件的妙法。Linux和其他各种开源
Unix的发布制造者都拥有许多专业经验，知道哪些项目是最好的――这正是他们的发行
版本中最大的亮点。如果已经在使用开源的Unix，那么需要检查的就是待评估的软件包
是不是已经包含在自己的操作系统版本中了。
UNIX缩程艺_术
  www.pdf365.com
384
第1 6章重用：论不要重新发明轮子
16.5何处找
    因为在Unix世界可以获取的开源软件非常丰富，找到可被重用代码的能力就成为巨
大资本――远远超过其它操作系统的情况。这些代码的来源形式多种多样――独立代码
的摘录和实例，代码库，可以在脚本中重用的公用程序。在Unix下，大多数的代码重用
当然不是在程序中拷贝粘贴――如果发觉自己在这样做，便可以肯定你遗忘了一个更优
雅的重用方式。相应地，在Unix下工作，最管用的技能之一就是熟练地掌握将代码粘合
在一起的各种方法，从而能够应用组合原则。
    寻找可重用的代码，应该从自己的眼皮底下开始。Unix总是以多种多样可重用公用
程序以及函数库的工具包为特征；现代的版本，比如任何当前的Linux系统，包含数以
千计可重用的程序、脚本以及函数库。简单的man -k加上一些关键字进行搜索常常可
以得到很有用的结果。
    要想在此之外看看令人吃惊的丰饶资源，可以浏览SourceForge、ibiblio和
Freshmeat.net。读到此书时，也可能会有类似的其它重要站点出现，但是这三个都在过去
很多年中显示出了持续的价值和声望，并且似乎很有可能维持下去。
    SourceForge<ht tp：／／www. sourceforge．net>是个软件的展示站点，这些软件明
确地设计来支持合作开发，并拥有相关的项目管理服务。SourceForge不仅仅是个存放软件
的地方，还提供自由的联合开发服务，在2003年中期，毫无疑问，是世界上最大的纯开
源活动中心。
    在SourceForge之前，最大的站点是ibiblio<http：／／www - ibiblio．org>的Linux
归档。ibiblio归档是被动的，仅仅是个发布软件包的地方。然而，它确实比起多数被动
站点的网页界面都要好得多（创造其网页外观的程序，是我们在第14章讨论Perl时的一
个实例分析）o这个站点也是Linux文档项目（Linux Documentation Project）的主页，
维护着许多供Unix用户和开发者使用的优秀资源。
    Freshmeat<ht tp：／／www．freshmeat．net>是个专注于提供新软件以及已有软件
新版本发布公告的系统。它允许用户和第三方给这些版本添加评审。
    这三个多用途站点包含许多语言的代码，但是多数是C或C++。还有一些站点专门
针对某些我们在第14章讨论过的解释型语言。
    CPAN archive是Perl话言自由有用代码的重要储存库。可以很容易地从Perl主页
<http：／/v，rww.perl.com/perl>访问。
    Python Software Activity是一个Python软件和文档的归档，可以从Python主页
<http：／/WWW .python．org>访问。
www.pdf365.com
16.6使用开源软件的问题
385
    Java  Applets  Page<ht tp：//j ava．sun．corn/applets/>可以找到许多Java小应
用程序以及指向自由Java软件的站点链接。
    作为Unix开发者，最有价值的时间投资方法之一就是，花时间在这些站点上去了解
可以获得什么东西来重用。节省下来的编码时间就是自己的。
    浏览软件包的元数据（ metadata）是个不错的主意，但别到此为止。也请试验一下代
码。这样能够对代码究竟做些什么会有个更好的领悟，从而更有效地使用。
    更一般地，阅读代码是为未来而投资。可以从中学到甚多――新技术、分解问题的
新方法、不同的风格和手段。使用代码和学习代码都能得到有价值的回报。即使并不使
用所研究代码中的方法，学习他人解决方案中改良的问题定义，也许能够帮助自己发现
一个更好的方法。
    写之前先读：培养阅读代码的习惯。很少有什么彻底全新的问题，所以几乎总是能
够发现非常接近的代码，成为自己需要的一个良好起点。即使当问题真正非常新颖时，
也很有可能与某人之前已经解决的问题相关，而解决方案也很可能是从某个已经存在的
方案发展而来。
16.6使用开源软件的问题
    使用或者重用开源软件存在三令主要问题；质量、文档以及许可证条款。正如我们
上面所看到的～样，如果花一点判断力挑选一下，一般都会发现一个或者更多的软件拥
有令人肃然起敬的上乘质量。
    文档通常是个更严重的问题，许多高质量的开源软件包的应用范围和它们在技术上
的领先不相协调，就是因为它们的文档很糟糕。Unix传统鼓励了太过专门的文档风格，
这种风格（尽管或许会在技术上涵盖软件包所有的功能特征）往往假设其阅读者也相当
熟悉应用程序的定义域，并且阅读得非常仔细。这样做也有很好的理由，我们会在第18
章进行讨论，但这种风格呈现出一种壁垒。幸运地，从这样的文档中提炼有价值的东西，
这个技能值得学习。
    用软件包名字或者主题关键字加上“HOWTO”或“FAQ”字符串，用它作为关键
字在网上搜索。对初学者来说，通常会发现比手册页更有用的资料。
    重用开源软件（特别是在任何商业产品中）最重要的问题是理解软件包的许可证，
如果存在许可证，你就会承担某些义务。在接下来的两个部分，我们将从细节上讨论这
个问题。
UNIX编程艺I术
    www.pdf365.com
386
第1 6章重用：论不要重新发明轮子
16.7许可证问题
    任何非公共领域的东西都有一个或更多版权。在美国联邦法律中，即使一件没有版
权声明的作品，其作者也拥有版权。
    在版权法下确定谁能够成为作品的作者可能非常复杂，尤其是经过多人之手形成的
软件。这就是为什么许可证非常重要的原因。许可证能够授权代码以某种方式使用，否
则在版权法之下是禁止或者需要付费的；许可证同时也保护用户免受版权所有者任意专
断行为的侵害。
    在专有软件世界里，许可证条款是设计来保护版权的。条款是在尽可能地为持有人
（版权所有者）保留领域范围利益，同时也授予用户某些权利的方法。版权所有者非常
重要，而许可证逻辑限制相当严格，所以许可证条款中确切的技术细节通常反而并不重
要。
    正如后面将要看到的那样，许可证可以使人们在版权所有者希望无限期存在的条款
下自由地获取代码，版权所有者多数情况下会使用版权来保护许可证。否则，仅有少数
权利得以保留而多数选择都交给了用户。特别地，对于别人已经拥有的拷贝，版权所有
者不能更改上面的条款。因此，在开源软件中，谁是版权所有者并不重要，但许可证条
款却至关重要。
    一般地，一个项目的版权所有者是该项目的领导者或赞助组织。项曰转让到～个新
领导者时，常常由版权所有者的变动显现出来。然而，这也并不是严格的准则；许多开
源软件都有多个版权所有者，并且这也没有导致法律问题的案例记录在案。一些项目选
择把版权指派给自由软件基金，理论上，自由软件基金确有为开放源码辩护的利益所在，
也有可以利用来进行辩护的律师资源。
16.7.1  开放源码的资格
    出于授权许可的目的，我们需要区分一个许可协议可能传达的几种不同权利。这些
权利包括重新分发权，使用权，供个人使用的修改权，以及修改版本的重新发布权。
    开放源码定义（Open Source Definition） <http：／/www，opensource．org/osd. html>
是思考什么让软件成为“开放源码”或（用旧术语）“自由，，的产物。在开源社区，
这作为开源开发者间社会契约的一个表述而广泛接受。其在许可证上的约束加有如下的
要求：
www.pdf365.com
16.7许可证问题
387
    ●  准予无限的复制权。
    ●  准予以无修改形式重新发布的无限权利。
    ●  准予供个人使用的无限修改权。
    这个方针禁止对二进制软件修改后的重新发布施加限制；这满足了软件发布者的需
求，他们希望能够毫无羁绊地转载可运行代码。这也允许作者要求修改的源码再发布时
以旧源码加补丁的形式发布，这样对于他人的修改，保证了原作者取舍和审查跟踪的权
利。
    OSD是“OS[ Cerifed  Open  Source"认证标志的法律定义，也是任何人所能提出的
最好的“自由软件’’定义。所有的标准许可证（MIT、BSD、Artistic、GPL/LGPL和MPL）
都满足它（尽管有些，例如GPL，具有其它的限制，在选择之前应该有所理解）。
    注意，只允许非商业使用的许可证并不等同于开源许可证，即使那些许可证往往基
于GPL或别的什么标准许可证。这样的许可证有区别地对待特别的行业、个人以及团体，
而这是OSD条款5明确禁止的。
    条款5是在几年的痛苦经历之后而加入的。仅供非商业性使用的许可证带来一个问
题，如何找到一种法律检验来确认某个再发布是“商业的”。将软件作为一个产品来
出售，这种情况当然毫无疑问。但如果以一种名义上的零价格同其它较件或数据一起
发布，而其实际价格以整体收费又该如何？而如果软件对于整体的功用是否关键又如
何区分？
    没人能够回答。仅供非商业使用许可证产生了再发布者认定的不确定性，事实上
恰好是个对它们自身严重的不利因素。OSD的目标之一就是确保处于符合OSD的软件
发布链中的人，不需要咨询知识产权律师来确定他们的权利到底是些什么。OSD禁止
将复杂的限制有区别地加诸于个人、团体以及行业，这样处理软件作品集的人就不需
要面对组合激增的爆炸式问题：这样或那样处理究竟有何微妙的不同（也许甚至是冲
突）。
    这种关心并非没有道理。开源发布链中重要的一环就是CD-ROM发布者，他们收集
许多非常有用的作品，从简单的软件集合CD到可启动的操作系统。如果那样限制，就
会让这些光碟发布商生活困顿窘迫，而其它试图商业传播软件源码的行为，也受到了禁
止。
    另一方面，OSD并没有讨论什么司法权法。有些国家的法律禁止出口某些限制技术
到所谓的“流氓国家”。OSD并不能反对这些，它只是说被许可人不能擅自增加自己的
UNIX编腥艺：术
  www.pdf365.com
388
第1 6章重用：论不要重新发明轮子
限制。
16.7.2标准开放源码许可证
这里是一些你可能碰上的标准开放源码许可证条款。～般而言都使用以下列出的缩写。
MIT <http:／/www. opensource. org/licenses/mit - licenBe. html>
MIT X联盟许可证（如同BSD -样，但是没有广告相关的条款。）
BSD <http:／/www. opensource. org/licenses/bsd- license .html>
版权属于加利福尼亚伯克利大学董事会（使用在BSD代码上）。
Artistic License <http:／/www. opensource. org/ licenses/artistic -
license．html>
同Perl技术许可证完全一样。
GPL <http:／/www. gnu .org/copyleft. html>
GNU通用公共许可证
LGPL  <http:／/www. gnu. org/copyleft. html>
库（或“弱”GPL）
MPL <http: //www* opensource. org/licenses/MPL-1. 1.html>
Mozijla公共许可证
    我们将在第19牵从一个开发者的角度来讨论这些许可证更多的细节问题。就本章目
的而言，它们之间唯一重要的区别就是他们是不是具有传递性。如果许可证要求许可证
软件任何的派生产品也同样置于许可证条款的限制之下，那该许可证就是传递的。
    在这些许可证下，对于使用开放源码唯一真正需要担心的问题就是专有产品结合自
由软件的情形（相对于仅仅使用开源开发工具制作的产品）。倘若许可证不是传递的，
即使是直接的合并，只要在产品的文档说明中准备和包含了对正确许可证的致谢以及所
使用文件的出处，就应该是安全的。
    GPL既是最广泛使用，又是最受争议的传递性许可证。它的条款2（b），要求任何
派生至GPL程序的作品本身也得遵从GPL，就是这引起了争议。  （条款3（b）要求许可
人必须让源码可以在物理媒介上按需索取，曾经也引起了部分争议，但是互联网的爆炸
发展使得按3 （a）要求的源码文件发布极其容易，所以没有人再担心这个要求了。）
www.pdf365.com
16.7许可证问题
389
    没有人能完全确定条款2 （b）中“包含或派生自”的意思，稍后几段关于什么样的
使用受到“纯聚合（mere aggregation）”保护的表述也是如此。有异议的问题包括链接
库以及包含遵从GPL许可的头文件。出现这种问题部分是因为美国的版权法并没有定义
什么是派生；这留给了法庭在判例法中推敲出定义来，而在计算机软件这个领域，这个
过程几乎还没有开始（到2003年中期止）。
    一方面，“纯聚合”确实保证将专有代码同GPL许可的软件一起在统一介质上发布
是安全的，只要它们彼此之间不互相调用和链接。它们甚至是可以处理同～种文件格式
或磁盘结构的工具；在这种情况下，依据版权法，不存在一个派生自另一个的关系。
    另一方面，将遵从GPL的代码摘出，插入在专有代码之中，或是链接遵从GPL的
目标码到专有目标码中，肯定让该代码成为一个衍生产品，从而需要遵从GPL许可。
    通常都认为一个程序将另一个程序作为子进程执行并不会导致其中任何一个程序成
为另一个程序的派生。
    产生争论的情形是动态链接共享库。自由软件基金的立场是，如果一个程序以共享
库方式调用另一个程序，那么这个程序就成为了该库的派生。有些程序员认为这个声朗
过了头。双方都有技术的、法律的以及行政的论据来支持己方的观点，我们在这儿并不
想老调重谈。既然自由基金组织编写并拥有许可证，就当FSF立场是正确的前提下谨慎
工作，直到另有法律条文。
    有些人认为条款2 （b）的表述是故意设计来感染那些商业软件的全部内容的，虽然
它们仅仅只摘用了一小部分遵从GPL的代码：这些人更愿把它称作GPV，或是“通用公
共病毒（General Public Virus）”。另外有些人认为“纯聚合”表述涵盖了所有没有将
GPL或非GPL代码混合在同一个编译或链接单元中的一切。
    这种不确定已经在开源社区造成了太多的不安，所以FSF不得不发展出特别的、稍
微缓和的“Library GPL’’（已经改名为“Lesser GPL”）来打消人们的疑虑以继续使用
随FSF GUN编译器集一起发布的运行库。
    条款2 （b）的解释需要你自己选择；绝大多数律师都不会理解所涉及的技术问题，
而且也没有什么判例法。事实上，经验告诉我们FSF从未（至少从1984年它创建起到
2005年年中）以GPL控告过任何人，但它确实以威胁提起诉讼来强迫实行GPL，且在
所有已知的案例中都获得了成功。同时，作为另外一个经验事实，网景（ Netscape）茌它
的商业Netscape Navigator浏览器中包含了遵从GPL的程序源码和目标码。
    MPL和LGPL具备的传递性比GPL更为有限。倘若GPL或非GPL代码之间所有的
通路都通过一个API或其它良好定义的接口来实现，那么链接进专有代码中并不会让该
    UNIX编l程艺术
    www.pdf365.com
390
第1 6章重用：论不要重新发明轮子
专有代码成为派生产品，这在MPL和LGPL中是明确允许的。
16.7.3何时需要律师
    本节内容专门为那些考虑把纳入以上许可证标准的软件整合进闭源码产品的商业开
发者而设。
    经历了这么多法律措词之后，在此，我们最希望的就是赶紧发表一个严肃的权利放
弃书，说明我们不是律师；如果对于利用开源软件在法律上有任何疑问，最好立即去咨
询律师。
    这是彻底的废话，尽管出于对法律职业的尊重。这些许可证使用的语言同法律术语
一样清晰――就是为了清晰才使用书面表达――而且如果仔细阅读的话应该根本就不难
理解。律师和法庭其实比你还困惑。软件版权法含混不清，在开源许可证上的判例法（在
2003年中期）还不存在；没有人曾经因为这个而被控告。
    这意味着一位律师并不太可能比一个细心阅读许可证的人拥有更好的见地。但律师
常常职业性地对他们不懂的东西患有妄想症。因此，如果咨询律师，他可能更会告诉你
不要随便靠近开源软件，尽管事实上他可能对技术方面根本一窍不通，或者并不见得比
你更能理解作者的意图。
    最后，将作品置于开源许可证之下的人们往往并不是什么大企业，没有那些鸡蛋里
面挑骨头的律师群照顾；他们只是一些个体或志屦群体，主要就是想发布他们的软件。
极少数的例外（那些既在开源许可证下发布软件又有钱雇佣律师的大公司）却常常在开
放源码上有投资，并且也不想挑起法律麻烦，与产生开放源码的开发者社区为敌。所以，
被以无辜的技术侵权罪名拖进法庭的可能性，大概会低于下星期遭雷劈的概率。
    这并不是说应该把这些许可证当作笑话来对待。那对凝结在软件中的创造力和血汗
未免有失敬意，而且官司轻重不说，你恐怕也不会把激怒作者、成为第一被告的经历当
作享受吧。但在缺少权威判例法的情况下，能做的99%就是明确承诺努力满足作者的要
求；另外的或许可以（或许不能）通过咨询律师来达到保护自己的1%的额外努力，而这
又有什么不同呢。
www.pdf365.com
PartⅣ
Community
www.pdf365.com
www.pdf365.com
1 7
可移植性：软件可移植性
与遵循标准
Portability: Software Portability and
Keeping Up Standards
     The realiZation that the operating systems of the target machines were as great an
obstacle to portability as their hardware architecture led us to a seemingly radical suggestion:
to evade thatpart of the problem altogether by moving the operating system itself.
    对于可移植性，目标机器的操作系统和其硬件结构都是障碍，意识到这一点，可能
会导致相当激进的意见：完全规避问题的方法，就是移植操作系统本身。
-Portability of C Programs and the UNIX System  （ 1978 ）
C程序的可移植性和Unix系统（1978）
Unix是第一款移植到不同系列处理器上的生产级操作系统（Unix版本6，1976-
1977）。现今，Unix可以被移植到每一款足够强大可以运行内存簪理单元的新机器上，
这已经毫不稀奇了。应用程序也常常在差异极大的不同硬件上运行的Unix间移来移去；
事实上，还没听说哪次移植失败过。
www.pdf365.com
394
第1 7章可移植性：软件可移植性与遵循标准
    移植性一直是Unix的主要优势。Unix程序员往往设想硬件是易变的，只有Unix API
才是稳定的，尽可能少地假定诸如字长、字节顺序和存储体系等机器的特殊细节。实际
上，在Unix圈中，以任何方式超出C的抽象机器模型而依赖于硬件的代码，都会被认定
为不良的形式，仅允许发生在诸如操作系统内核等极为特殊的情况下。
    Unix程序员已经了解到，一旦设想软件项目的生命期很短，就非常容易犯错。1所以，
Unix程序员往往尽量避免软件依赖于某种特殊易逝的技术，而严谨地遵循开放标准。这
种考虑可移植性的编码习惯在Unix传统中根深蒂固，甚至应用于那些一次性小型单用途
的代码中。这种习惯也始终贯穿于Unix开发工具的设计，以及例如Perl、Python和Tcl
之类在Unix下发展起来的语言中。
    可移植性最直接的效益是工具和应用程序无需每隔几年就重写，因为Unix软件比起
原生的硬件平台来得长久，这是再正常不过的。今天，最初为Unix版本7（1979）所编
写的应用程序，不仅用在其直系后裔中，也用在那些按照Unix规范编写操作系统API，
但并没有从Bell实验室源码树共享代码的交种中，如Linux。
    间接的益处并不明显但可能更为重要。可移植性的戒律往往在架构、接口和实现上
施加了一种简单化的影响。这既提高了项目成功的几率也降低了生命期的维护成本。
    本章概览Unix标准的范围和历史。我们将讨论哪些部分在今天仍然意义重大，并描
述Unix API中或多或少变化的部分。我们将检视某些Unix开发者用来保持代码可移植
性的工具和惯例，同时逐步展示出对良好实践的建议。
7．  C语言的演化
    C语言及其附带服务接口（挑明了，就是标准输入输出库函数及其友元）的稳定性
一直以来都是Unix编程经历的主要核心事。诞生于1973年的一门语言，在三十年来的
频繁使用中，只有很少的变动需求，这真是非常了不起：在计算机科学和工程领域中尚
无人出其右。
    在第4章，我们论述了C语言如此成功是因为它可以作为计算机硬件上的薄胶合层，
近似于【BlaauwBrooks]的“标准架构”。当然，成功的因素并不仅止于此。为了理解其余
的内幕，我们需要简要地回顾一下C语言的历史。
1  PDP-7 Unix和Linux都是持久性出乎意料的例子。Unix最初是作为一个研究玩具由几个研究者在
项目工程间编制而出，一半是为了实验文件系统的创意，一半悬为了运行一个游戏。而Linux则被其
创造者总结为“长了腿的终端模拟器”【Torvalds]。
www.pdf365.com
395
17.1.1  早期的C语言
    C语言诞生在在1971年，最初作为Unix移植到PDP-Il的系统编程语言，基于Ken
 Thompson早期的B语言解析器，脱胎于BCPL （Basic Common Programming Language），
于1966-1967在剑桥大学诞生2。
    Dennis M. Ritchie的原始C编译器（也常常以他名字的首字母称为“DMR”编译器）
在Unix版本5、6、7快速持续增长的社区中都有应用。版本6的C编译器派生了
Whitesmiths C编译器，这个重新的实现成为了第一款商业的C编译器，也是软件通用型
IDRIS的核心。但是多数现代的C语言实现都以Steven C．Johnson的“可移植C编译器
（PCC）"为模型，该编译器在版本7中首次亮相，并在System V和BSD 4.x的发布中
完全取代了DMR编译器。
    在1976年，版本6的C语言引入了typedef、union和unsigned int声明。带初值的
变量初始化语法和一些复合操作符也有改动。
    最初C语言的参考手册是Brian Kernighan和Dennis M. Ritchie原创的《The C
Programming Language》<C编程语言），即《白皮书》[Kernighan-Ritchie]。该书出版于
】978年，同年Whitesmiths C编译器问世。
    白皮书描述了增强的版本6C语言，包含一个涉及公用存储处理的重要例外。基于
任何能够处理FORTRAN语言的机器都可以立即处理C语言的理论，Rithie原意是仿造
FORTRAN语言中“COMMON”声明的规则。在公用块（common-block）模型中，公用
变量也许会被声明好几次；相同的声明由链接器合并。但是两个早期的C移植（ Honeywell
和IBM 360大型机）恰好是那种限制公用存储或链接器较为原始或两者兼有的机器。这
样，C编译器版本6采用了在白皮书中描述的、较为严格的定义引用模型（要求任何公
用变量至多只有一处声明，并在引用处使用关键字extern来标记）。
    许多现存源码都依赖较为宽松的规则，所以这个决定在随着版本7发布的C编译器
中被颠覆了。向后兼容的压力也阻碍了另一个转换尝试（1983年的System V Release l），
直到1988年ANSI标准草案才最终解决了定义引用原则。公用块公共存储依然是标准许
可的变体。
2C语言中的“C’’因此代表“Common[通用）”――或者，代表“Christopher”。BCPL最初表示
“Bootstrap CPL（引导性CPL）”-CPL的一个非常简化的版本，CPL是一种非常有趣但抱负过
大而从未实现的牛津剑桥通用编程语言，也被亲切地称之为“Christopher's Programming Language
（Christopher编程语言）”，以这门语言的主要贡献者，计算机科学的先驱Christopher Strachey命名。
UNIX编程艺术
  www.pdf365.com
396
第17章可移植性：软件可移植性与遵循标准
    C版本7引入了enum，并且将struct和union的值作为第一类对象，可被赋值，可
作为参数传递，也可作为函数的返回值（而不是靠地址传递）。
    V7中的另一个主要变化是Unix的数据结构写在了头文件中，并可以被包含。
原先的Unix将这些结构（如目录）打印在手册中，人们需要将其复制到代码中。毋
庸多言，这是个重要的移植性问题。
-Steve Johnson
    System III C版本的PCC编译器（也随BSD 4.lc -起发布）改变了struct声明的处
理，这样不同struct中的同名成员不会冲突。同时引入了void和unsigned char声
明。函数内的extern声明，其作用域也限制在函数体中，而不再覆盖所有位于声明以
后的代码。
    ANSI C草案提议标准（The ANSI C Draft Proposed Standard）加入了const（只读存
储）和volatile（表明在程序控制的线程中例如内存映射寄存器等需要异步修改的地
方）。unsigned类型修饰符泛化了，可以应用于任何类型，同时加入了一个对称的
signed修饰符。也加入了auto数组、结构初始化器以及union樊型的初始化语法。
最重要的，加入了函数原型。
    早期C语言最重要的变化就是，转型为定义引用和在ANSI C草案提议标准（Draft
Proposed ANSI C Standard）中引入的函数原犁。自从1985-1986年X3JI1委员会关于标
准草案的工作报告将委员会的意向传达给编译器的实现者之后，C语言在本质上一直都
很稳定。
早期C语言更详细的历史，可以参阅其设计者编写的《Ritchie93》。
17.1.2  C语言标准
    C语言标准的发展一直是个保守的过程，原始C语言的精髓得以小心留存，更认可
现存编译器中的实验技术而不是发明新的特征。C9X宪章（charter）3文档很好地表述了这
个任务。
3可- rXib-问网页<http：//anubis．dkuug．dk/JTCI/SC22 /WG14 /www/charter>。
UNIX霸葶醒芝易笊
www.pdf365.com
17.1  C语言的演化
397
    第一个官方C语言标准化工作在X3J1l ANSI委员会的赞助下始于1983年。主要的
功能增加在1986年末就已经解决，在这一点上，对于编程者来说，区别“K&R C”和“ANSI
C”变得很普遍。
    许多人都没有意识到C语言标准化努力的工作是多么的不同寻常，尤其是最
  初的ANSIC工作，它坚持只将经过测试的特征列入标准。很多语言的标准委员会
  把大量时间花在新的语言特性上，而几乎不考虑应该如何实现。确实，极少数凭
  空产生的ANSIC特征――例如，臭名昭著的“三字母操作符（Lrigraphs）”――就
  是C89中最讨厌最不成功的特征。
    -Hen哼Spencer
    标准化努力的部分结果是发明了void指针，并且成为赢家。但是Henry的观
点也被很好地接受了。
-Steve Johnson
    尽管ANSI C的核心早就确定了下来，关于标准库内容的争论还是拖延了好几年。
正式的标准直到1989年末才发布，那是在许多编译器都已经实现了1985年的建议之后。
该标准最初称为ANSI X3.159，但在1990年国际标准组织（ISO）成为新的赞助方后重新设
计为ISO/IEC 9899:1990。该标准描述的语言变体通带称为C89或C90。
    第一本关于C语言和Unix可移植性的书籍，《Portable c and Unix Svstems
Programming》（可移植的C语言和Unix系统编程）[Lapin]，于1987年出版（在那时追
于雇主压力，此书以公司笔名出版）。第二版的《Kernighan-Ritchie》于1 988年出版。
    C89 -个次要的修订，称作修订l/AMI/C93，在1993年付诸实施。该修正增加了对
宽字符集和Unicode更多的支持。这就是ISOfIEC 9899-1:1994。
    C89标准的修订始于1993年。在1999年，ISO/IEC 9899（通常称作C99）为ISO
所采用。该协议集成了修订1并增加了许多次要的特征。其中也许对大多数编程者最重
要的一个就是，具备了像C++一样可以在代码块任意点，而不是仅仅只能在开始处声明
变量。同时也加入了参数个数可变的宏。
    C9X  工作组的网页是<http：／／anubis．dkuug．dk／JTC1／SC22/WG14/
www/proj ects>，但是在2003年中期还没有第三个标准化工作列入计划。正在为嵌入
式系统发展一个C语言的补遗。
    在c语言标准化工作开始烈前，可工作的兼容实现已经运行在广泛的不同系统上，
这个事实极大地协助了c语言的标准化工作。但这也更难以论证究竟哪种特征应该加入
UNIX编翟艺术
    www.pdf365.com
398
第17章可移植性：软件可移植性与遵循标准
到标准之中。
17.2 Uni×标准
    1973年用C语言重写后，Unix史无前例地容易移植和修改。结果，始祖的Unix分
别发展出了一系列早期操作系统。发展Unix标准最初就是为统- Unix系列不同分支的
API。
    在1985年后发展的Unix标准在这方面相当成功――因此而成为了现代Unix实现极
具价值的API文档。实际上，现实世界的诸多Unix都紧密地遵循公开标准，所以开发者
能够（也常常这样做）更依赖诸如POSIX规格说明的文档，而不是手头使用中的变种
Unix官方手册页。
    实际上，在新近的开源Unix（例如Linux）中，就往往使用公开标准作为其操作系
统功能特征的规格说明。我们在本章稍后审视RFC标准化过程时还会回到这一点来。
17.2.1  标准和Unix之战
Unix标准发展的原动力是第2章叙述过的AT&T和Berkeley阵线在发展上的分裂。
    4.x BSD Unix源自1979年的版本7。在1980年4.IBSD发布后，BSD阵线很快赢得
了Unix发展前沿的好名声。重要的新特性包括V1可视编辑器，从单一控制台管理多重
前后台任务的作业控制功能，以及信号的改进[参见第7章）。迄今为止最重要的增加
是TCPfIP网络，但是尽管Berkeley在1980年就获得了该合同，’rCPIP三年内都没能随
对外发布的版本一起交付。
    但是另一个版本，1981年的System III，成为了AT&T后来发展的基础。System III
重编了版本7的终端接口，使之更简洁，更优雅，但同Berkeley的改进完全不兼容。它
保留了老的（无重置）信号语义（也请参考第7章关于这点的讨论）。1983年1月发布
的System V Release 1整合了某些BSD实用程序（如vi（1））。
    在1983年2月，UniForum进行了架通两者的第一次尝试，这是一个很有影响的Unix
用户组。它们的Uniforum 1983年标准草案（UDS 1983）描述了一个“核心Unix系统”，
由System III核心的一个子集和函数库加上文件锁定原语构成。AT&T宣布支持USD 83，
www.pdf365.com
17.2 Unix标准
399
但是标准只是基于4.IBSD的发展实践的不完全子集。在1 983年4.2BSD发布的时候，
这个问题加重了，它为该版本增加了许多功能（包括TCPfIP网络），也引入了许多跟原
先版本7并不兼容的东西。
    1984年Bell运营公司的剥离以及Unix战争的开始（参考第2章）使问题更加复杂。
Sun Microsystems朝BSD方向领导着工作站产业；AT&T甚至一边继续向诸如SUfl的竞
争对手授权操作系统，一边利用对Unix的控制作为战略武器并试图进入商务领域。为了
保持竞争优势，所有商家作出的商业决策都是差异化他们的Unix版本。
    在Unix内战中，在某种意义上，技术标准成为相互合作技术人员奋力推动的东西，
而产品经理不是勉强接受就是积极反对。重大而重要的例外是AT&T，当它在1984年1
月发布System V Release 2（SVr2）时，宣布了同用户组在标准设立上的合作计划。1984
年的UniForum草案标准第二次修订版，追踪和影响了SVr2的APJ。后来的Unix标准中，
除了某些BSD功能在效用上特别领先的领域，均倾向遵从System V（例如，现代Unix
标准描述了System V晌终端控制而不是BSD同样功能的接口，就是这个原因）。
    在1985年，AT＆T发布了System V接口定义（System V Interface Definition，SVID）。
SVID结合UDS84为SVr2 API提供了一个更为正式的说明。后来的版本，SVID2以及
SVID3遵从了System V release 3和4的接口。SVID成为了POSIX标准的基础，而POSIX
最后在系统和C函数库上Berkeley/AT&T的分歧中，大多数都偏向了AT&T。
    但趋势在好几年内都仍不明显；其间，Unix之争仍战事频繁。例如，1985年，网络
共享文件系统就发布了两个竞争的API标准：Sun的网络文件系统（Network File System，
NFS）以及AT&T的远程文件系统（Remote File System，RFS）。Sun的NFS更流行一些，
因为Sun公司不仅愿意共享规格说明还愿意将代码公开。
    这个成功的经验其实更应该值得指出，因为纯粹基于逻辑判断来说，RFS远远更加
优秀。它支持更好的文件锁定语义以及在不同系统用户身份更好的映射，并且总的来说，
作出了相当的努力以期获得Unix文件系统语义更好更淮确的细节，而不像NFS。然而这
个成功的经验却往往被忽略，甚至在1987年，开源X window系统战胜了Sun专有网络
视窗系统（ Networked Window System （NeWS》时，也不例外。
    1985年后，主要的Unix标准化推进传递给了美国的电气电子工程协会（lnstitute of
Electrical and Electronic Engineers，IEEE）。IEEE的1003委员会发展了一系列的标准，
UNIX编程艺-术
  www.pdf365.com
第1 7章可移植性：软件可移植性与遵循标准
通常称作POSIX4。这些标准不仅描述系统调用和C函数库功能，还说明了具体的shell
语义和最小命令集，并具体化了各种非C编程语言的接口。它首次发布于1990年，1996
年发布了第二版。国际标准组织采用其作为ISOfIEC 9945。
    关键的POSIX标准包括：
1003.1 （1990年颁布）
    函数程序库。描述了C系统调用API，大部分同版本7相同，除了信号机制与终端
控制接口。
1003.2 （1992年颁布）
    标准shell和实用程序。Shell语义几乎同System V的Boume shell -模一样。
1003.4 （1993年颁布）
    实时Unix。二元信号量、进程内存锁、内存映射文件、共享内存、优先调度、实时
信号、时钟和定时器、IPC消息传递、同步I/O、异步1/0、实时文件。
    在1996年的第二版中，1003.4分成了1003.lb（实时）和1003.c（线程）两个部分。
    尽管在几个关键的领域里（比如信号处理语义上）说明不足，也遗漏了BSD套接字，
最初的POSIX标准还是成为了所有后来Unix标准化工作的基础。它仍然作为一个权威
被引用，纵使许多都是通过POSIX Programmer's Guide（POSIX裎序员指南）[Lewine】等间
接引用。实际上的Unix API标准仍然是“POSIX+套接字”，以后的标准主要是增加功
能以及在不常见边界情况更紧密的一致性规定。
    下一个参与者是X/Open（后来更名为Open Group），它是在1984年形成的Unix商家
联盟。它们的X/Open Portability Guides （XPGs）最初与POSIX草案平行发展，而在1990
年之后，XPGs整合扩展了POSIX。POSIX试图捕捉所有Unix的安全子集，而XPG更
倾向前沿开发的普遍实现；即使是1985年的XPGI，就跨越了SVr2和4.2BSD，还包含
了套接字。
    1987年的XPG2增加了终端处理API，基本上是System V的curses（3）。1990年的
XPG3融合了XII API。1992年的XPG4完全遵从了ANSI C 1989标准。XPG2、XPG3
4最初1986年的试用标准叫做IEEE-IX。  “POSIX”的名称是Richard Stallman的建议。POSIX.I的
介绍说：  “应该发[pahz-icks】的音，而不是[poh-six】或别的什么，公布发音方式是为了以尝试传播一
种il用标准操作系统接口的标准化方法。”
www.pdf365.com
17.2 Unix标准
401
和XPG4极度关注国际化的支持，并描述了一套详尽的API来处理字符集和消息目录。
    在阅读Unix标准的时候，也许会碰到“Spec 1170"（自1993年）、“Unix95"（自
1995年）和“Unix 98”（自1998年）。这些认证标记都基于X/Open标准；现在仅仅只
是历史的兴趣罢了。但是XPG4完成的工作成为了Spec 1170，而Spec 1170又转变成第
一版的“单- Unix规范’’  （Single Unix Specification，SUS）。
    1993年，包括每个主要Unix公司在内的75个系统和软件提供商对Unix战争作出
了了断，宣布支持X/Open开发出Unix的通用定义。作为协商的一部分，X/Open组织获
得了Unix商标权。整合的标准变成了单- Unix苏磋版本1。接下来就是1997年的版本
2。在1999年X/Open并入了POSIX的活动。
    在2001年，X/Open（现在的The Open Group）发布了单- Unix标准版本
3<ht tp：／/wwW。unlx．org/version3 1>。所有Unix API的标准化流程最终汇合到一
起。这反应了如今的现宴状况；不同种类的Unix已经会聚在～个通用API集合中。并且，
至少对1980年代的动荡记忆犹新的老一辈人来说，这太令人愉悦了。
17.2.2庆功宴上的幽灵
    但很不幸地，有个尴尬的情况――支持整合努力的1日学派Unix商家处于新学派开源
Unix的严峻压力之下，在某些时候不得不抛弃（有利于Linux）已经为确保一致性付出
巨大努力的专有Unix。
    单一Unix规范的一致性验证检测是个昂贵的任务。每个发布都需要做一次，但这超
出了大多数开源操作系统发布者的能力。无论如何，Linux的变化如此之快，任何发布版
本在获得认证时，可能都已经过时了5。
    诸如单- Unix规范之类的标准并没有完全失去实用性，它们仍然对Unix实现者有
很高的指导价值。但是Open Group以及其它旧学派Unix标准化机构如何适应开源发布
的节奏（以及开源开发组低预算或零预算运作），还有待观察。
5有个Linux发布商，英国的Lasermoon，确实获得了POSIX．】FIPS 151-2认证～一它已经倒闭了，
因为潜在用户对此根本不关心。
UNtX编|腥艺术
    www.pdf365.com
402
第1 7章可移植性：软件可移植性与遵循标准
17.2.3开源世界的Unix标准
    在1990年代中期，开源社区开始了自己的标准化努力。这些努力建立在由POSIX
及其继承标准确保的源码级兼容性之上。特别是Linux，它从头到尾都是按POSIX之类
类Unix API标准编写的。6
    在1998年，Oracle把领先市场的数据库产品移植到了Linux上，这场运动正是Linux
被大型机所接受的一次重大突破。在被记者问及Oracle必须战胜的困难是什么的时候，
负责移植的工程师的回应很有说服力：API标准工作完成得相当出色。他回答：  “我们
键入‘make'。
    由此看来，新学派Unix的问题并不是在源码层次上API的兼容性。每个人都理所当
然地认为在不同的Linux、BSD和专有Unix发布之间移植源码是轻而易举的。新问题不
是源码而是二进制的兼容性。因为由于商业PC机硬件的胜利，Unix的底层基础已经发
生了微妙的变化。
    在旧时代，每种Unix都运行在实际上属于它自己的硬件平台上。存在许多种类的处
理器指令集和机器体系，所以应用程序若要移植就必须在源码层次上完成。另一方面，
又只有极少数几个Unix的重要版本，相对来说其有较长的生命期。而诸如Oracle之类的
应用程序提供商能够为三到四个硬件／软件组合分别编译和提供独立的二进制发布版本，
因为他们可以通过大量的使用人群和较长的产品生命期来摊低源码移植的成本。
    但是后来小型机和工作站商家淹没在了基于386廉价的个人机中，而开源Unix改变
了规则。商家发现再也不能找到一个稳定的平台来发售它们的二进制程序。
    首先，表面的问题是，大量的Unix发布者――随着Linux发布市场的统一，越来越
清楚真正的问题是时间变化率。API是稳定的，但是系统管理文件的预期位置、实用程
序以及用户邮箱名和日志文件的前缀路径等常常发生变化。
    首次标准化努力是新学派Linux和BSD社区自身中发展出来（始于1993）的文件系
统层次标准（Fijesystem Hierarchy Standard，FHS）。此标准被集成到Linux标准基础（Linux
Standards Base，LSB）中，它标准化了一套预期的服务库和辅助应用程序库。两个标准
6进一步讨论请参考《Just for Fun》（玩玩而已）[Torvalds]。
www.pdf365.com
17.3 IETF和RFC标准化过程
403
都成为了自由标准组织（Free Standards Group） <http:/／www．freestandards．
org/>的行为，到2001年，该组织已经扮演了在旧学派Unix商家中X/Open的角色。
17.3  IETF和RFC标准化过程
    当Unix社区同互联网T程师文化相结合时，也继承了从互联网工程任务组（Intemet
Engineering Task Force，IETF） RFC标准化过程中形成的思维方式。在IETF传统中，标
准必须来自于一个可用原型实现的经验――但是一旦成为标准，同标准不一致的代码就
被认定是不合规范的，必须无情地抛弃。
    不幸地是，这并不是标准通常发展的方式。计算机历史充满了许多这样的例子，技
术标准是别有企图研究的最糟糕特征与黑暗密室政治结合的产物――这样产生的规格说
明在任何曾经的实现中都找不到踪影。更糟糕的是，许多规范不是严苛得无法实际实现，
就是说明不够充分，解决的问题远不如产生的困惑多。这些规范随之被塞给软件商，它
们如果发现什么地方不易实现，就忽略掉标准。
    标准无用最臭名昭著的例子就是，1980年代同TCP/IP竞争的开放系统互联（Open
Systems  Interconnect）扔议――它的七层模型乍看很优雅，但在实际中却被证明是过度复
杂而不可实现的7。视频显示终端功能的ANSI X3.64标准是另～个恐怖故事：同标准保
持一致的实现版本之间居然存在微妙的不兼容性，真是该死。即使在字符阵列终端大部
分被位图显示终端所替代以后，这些也还是问题（特别地，这就是为什么xterm （1）中
功能和热键偶尔会失效的原因）。串行通讯的RS232标准也是说明不够充分，有时候似
乎没有两个串行线是相似的。关于标准类似的恐怖故事真是可以写一本厚厚的书。
    IETF的哲学已经被概括为著名的“我们反对国王、总统和投票。我们信任大致的共
识和可运行代码”8。首先，要求可工作实现将使其免于最糟的莽撞行为。实际上，它的
规范更严格：
7网络搜索可以找到一个流行的幽默帖子，将OSI七层模型和七层玉米卷比较一一前者还处于劣势。
8这句最初是由IETF的高级干事Dave Clark在混乱的1992年会议上，IETF拒绝OSI协议时所说的。
UNIX编睡！艺I术
  www.pdf365.com
404
第17章可移植性：软件可移植性与遵循标准
    （任何）候选规范在被采用为互联网标准之前，必须得到实现，对操作的正确性
    以及众多独立方的互操作性必须得到测试，以及必须已经使用在要求越来越高的
    环境中。
    互联网标准过程一一修订稿3（ RFC 2026）
    所有的IETF标准都要经过RFC（请求评注）的阶段。RFC的提议过程故意地设置
为非正式的。RFC可以提出标准、调查结果、建议后续RFC的哲学基础，或者甚至是玩
笑。每年4月1日愚人节RFC年鉴的出现就是互联网玩家中最盛大的庆祝仪式，并且产生
许多如宝石般的精华标准，例如Transmission of IP Datagrams on Avian Carriers （IP数据报
的信鸽传递，RFC 1149）9、Hyper Text Coffee Pot Control Protocol（超文本咖啡壶控制协议，
RFC 2324）10、Security Flag in the IPv4 Header （IPv4包头的安全标志位，RFC 3514）。11
    但是搞笑RFC大概是唯一能够立即成为RFC的提议。严肃的提议实际上以“互联
网草案（lntemet-Drafts）"开始，通过IETF在／L个著名主机上的目泵让公众评注。没有
正式身份的互联网草案个体，其提出者在任何时候都可以改动或终止。如果他们既不撤
销也不提升到RFC状态，在六个月后草案将被移除。
    互联网草案并不是规范，而软件实现者和软件商被特别禁止宣称符合某条草案，并
将其按规范对待。互联网草案通常是在一个由电子邮件列表联系在一起的工作组讨论的
焦点。当工作组领导认为适合的话，就把互联网草案提交给RFC编辑，从而被分配～个
RFC号码。
    一旦互联网草案作为一个带编号的RFC发布，就成为其实现者可以宣称与之相符的
规格。接下来，RFC的作者和社区将开始以实际实验来更正规格说明。
    ～些RFC就到此为止了。一个未能吸引用户和经受现场测试的规格可能被默默遗忘
了，而且最后被RFC编辑标记为“Not recommended（不推荐）”或“Superseded（被取代）”。
失败的提议通常认为是进程的日常开销，相关的提议不会因此打上耻辱的印记。
9 RFC 1149见网页<http：／／www. ietf .orgirfc/rfc1149．txt>。不仅如此，其实现参见
<ht tp:  //www. blug. linux. no/rfc114 9 /wri t eup. html>.
10 RFC 2324兄网页<http：／/www.ietf.org/rfc/rfc2324.txt>。
‘1 RFC 3514见网页<http：／／www.ietf.org/rfc/rfc3514.txt>。
www.pdf365.com
17.4  规格DNA，¨油马RNA
405
    IETF的指导委员会（IESG，或者Internet Engineering Steering Group）负责将成功的
RFC推向标准之路。他们将合格的RFC标明为“Proposed Standard（提倡标准）"。对
于具备提倡标准资格的RFC，其规格必须稳定，经过同行评审，并且已经吸引了互联网
社区的极大兴趣。当然，一个RFC成为提倡标准，并不绝对要求存在实现，如果有则最
好不过；如果RFC改变或可能动摇互联网核心协议，IESG则有权要求RFC提供实现。
    提倡标准仍可能被修订，如果IESG和IETF确实有更好的解决方案，甚至还会被撤
消。它们并不推荐在“崩溃敏感环境”中使用――不要将他们使用在空中交通控制系统
或是需要精心照料的设备上。
    对于提倡标准，如果至少存在两个可工作的、完备的、独立发展出来的、可互用的
实现，就能够由IESG提升到“草案标准”状态。如RFC2005所说：  “提升到草案标准
阶段是个重要的进步，表明有充分理由相信规格是成熟而有用的。”
    一旦RFC达到了草案标准状态，就只能更改规格说明中的逻辑错误。草案标准可随
时被部署使用在崩溃敏感环境中。
    当草案标准经道了实现的广泛测试并且达到了普遍接受的程度，就可以成为一个互
联网标准（Internet Standard）。互联网标准保留自身的RFC编号，也可以申请一个STD
序列号。在本书写作时，虽然有3000多个RFC，但仅仅只有60个STD。
    尚未成为标准的RFC被标记为Experimental（实验性）、Informational（资料性）（搞
笑RFC就被赋予该标记），或者Historic（历史性）。历史性的标记被用于过时标准。RFC
2026注释为：  “（完美主义者建议这个词应该是“Historical（历史上的）”；但是，在这
一点上，  “历史性”一词的使用是历史上的原因。）
    IETF标准化过程有意提倡由实践而非理论驱动的标准化过程，并确保标准协议都经
受过严格的同行评审和测试。这种模式的成功结果显而易见――全世界的互联网。
17.4  规格DNA，代码RNA
    甚至在PDP-7的旧石器时代，Unix程序员就比其他业界同行更倾向于认为代码是可
弃的。这无疑是Unix传统注重模块性的产物，使其更容易在无损失的情况下抛弃和更换
UN/X编翟Yae
    www.pdf365.com
第17章可移植性：软件可移植性与遵循标准
系统的各个子部分。Unix程序员已经从经验中认识到补救糟糕的代码或设计比起重新开
始常常更费时费事。在其它编程文化中，被迫弥补大型单个程序是种本能的反应，因为
从头再来需要太多太多的工作，而在Unix文化则主张干脆拆毁重来。
    IETF传统反复教导我们将代码作为标准的从属物来思考。正是标准让程序可以协
作，将各项技术结合起来成为比部分之和更大的整体。IETF向我们展示了，精细的标准
化过程，瞄准获得最好的实践，其实是种强有力的形式，相比于无法实现的完美理想的
信誓旦旦来说，能够获得更大的成功。
    1980年后，Unix社区越发受到这个教训的影响。从1989年以来的ANSI/ISO C标准
虽并非毫无瑕疵，但考虑到其长度和重要性，它的确异常简洁和实用。单- Unix规范在
更广泛的领域中包含三十年来的实验和改进，比ANSI C更为凌乱。但是标准的组成相
当良好。一个强有力的证明就是，Linus Torvalds通过它而成功从头开始编制了一个Unix。
IETF强大的示范给Linus Torvalds的壮举创造了一个关键背景，并使其成为可能。
    尊重已颁布标准和IETF过程已经在Unix丈化中根深蒂固；故意违反Internet STD
就是不妥当的。这一点有时候往往会造成Unix背景的技术人员同其它技术人员之间相互
不理解，其它技术人员往往设想最流行或最广泛配置的协议实现就是定义上的正确――
即使定义严重地违反标准而不能与完全符合标准的软件进行协作。
    Unix程序员可能大力反对其它种类的前规格说明，他们对已颁布标准的尊敬显得很
有趣。当“瀑布模型”（首先详尽说明，然后实现，然后调试，在任何阶段都没有反向
动作）在软件工程学中失宠时，在Unix程序员中成为笑柄其实已经好几年了。经验以及
合作开发的浓厚传统，已经训练了Unix程序员，先原型然后循环不断地测试和演进才是
更好的方法。
    Unix传统清楚地意识到良好的规格说明具有巨大的价值，但是需要像“互联网草案，，
和“提议标准”的方式那样，被视作是暂时的、需要订正的对象，必须通过在现场实验
中的不断改进。在最好的Unix实践中，程序的文档就近似于规范主体的“提议标准”，
需要不断修改订正。
www.pdf365.com
17.4  规格DNA，代码RNA
407
    与其它环境不同，在Unix开发中，文档常常在程序之前，或者至少同程序一
起编写。对于X11，X核心标准在X第一版发布之前完成，并且自从那时起基本
上就没有改动过。不同X系统间的兼容性更进一步地被严格的规格驱动测试所改
善。
    有了良好编写的规格说明，开发X测试套件便更加容易。在X规格说明中的
每一项声明都转换成代码来测试其实现，在这个过程中发现了几个次要的、跟规
格不一致的地方，其最终结果就成为了一个测试套件，覆盖了X实例库和服务器
中重要的代码路径，并且不引用实现源码。
    -Keith Packard
    生成半自动化的测试套件被证实为～个主要优势。尽管图形艺术的现场实验和发展
导致对X设计基础的许多批判，尽管X的某些部分（例如安全和用户资源模型）似乎笨
拙而实现过度复杂，但X在稳定性和跨系统发布的互用性方面达到了非同一般的良好水
平。
    在第9章我们讨论了将编码尽量往上推以最小化常数缺陷密度效应。Keith Packard
含蓄地说明X文档并不仅是期望功能列表，而是以高级代码形式来表述。另外一个X的
关键开发者证实了这一点：
    在X中，规格说明就是一切。有时规格存在缺陷需要修正，但是代码通常此
  规格说明具备更多的bug（对任何值得着墨的规格说明）。
―■im Gettys
    Jim继续阐明X的过程实际很像IETF过程。它的功用并不是仅仅局限于构建优良的
测试套件；它也意味着相关的系统行为争论可以在关于规格的功能层面解决，避免了太
多实现问题的纠缠。
    以考虑周全的规格说明来驱动开发可能会引起“bug还是功能”的小小争论；
但没有正确实现规格说明的系统就是破损不全的，必须得到修正。
我怀疑这在我们当中是如此的根深蒂固，有时反而忽略了它的威力。
www.pdf365.com
408
第1 7章可移植性：软件可移植性与遵循标准
    一个在Bellevue以东一家小公司工作的朋友奇怪，Linux应用程序开发者为
什么可以随着应用程序发布版本同步地进行OS改动。在那个公司里，主要的系
统级API频繁改动以容纳一些古怪念头，所以基本的OS功能必须常常随着每个
应用程序一起发布。
    我向他描述了规格说明所具有的威力以及实现应当如何遵从规格，然后接着
断言，如果一个应用程序按接口文档得到一个非预期的结果，那么不是违反了规
格，就是发现了bug。他认为这个观念非常令人吃惊。
    分辨这类bug再简单不过了，只要检查接口实现是否违反了规格。当然，如
果有实现的源码会更简单。
    -Keith Packard
    这种标准先行的态度对于最终用户同样有益。Bellevue以东的那个小公司变大了，
它难以兼容以前发行的办公软件，而在1988年为X11编写的GUI应用程序在今天的X
实现中仍然没有改变地运行着。在Unix世界中，这种长寿是很正常的――这也就是为什
么将标准视作DNA的原因。
    经验表明，遵从标准、喜欢抛弃重建的Unix文化，虽然花费额外时间，但相比于因
为没有标准提供指导和连续性，而必须不停地对代码基础库缝缝补补，往往熊够产生更
好的互用性。这真的或许是Unix最重要的教益。
    Keith最后的评注直接引出一个问题，也是随开源Unix的成功而提到前台的问题
―二开放标准和开放源码间的关系。我们将在本章末尾讨论这个问题――但在这之前，
是讨论Unix程序员如何能够使用大量的标准和知识来获得软件可移植性的实践问题的
时候了。
17.5可移植性编程
    软件可移植性通常是准空间问题：代码可以从其诞生的环境移到别的硬件和软件平
台吗？但是几十年的Unix经验告诉我们时间上的持久性同样重要，甚至更重要。软件的
未来如果可以详细地预测，最好现在就来预测――然而，在可移植性编程中，我们应该
www.pdf365.com
17.5可移植性编程
409
尝试考虑选定最可能持续的软件环境特征作为构建软件的基础，同时要避免不久的将来
就可能消亡的技术。
    Unix二十年对详述可移植性API问题的关注，在很大程度上解决了这个问题。在单
- Unix规范中描述的功能今天几乎仍然存在于现代的Unix平台中，将来也不会不支持。
    但并不是所有的平台依赖性都同系统和库函数API相关。实现语言也有关系；源系
统和目标系统之间文件系统设计和配置的不同也是个问题。还好，Unix实践已经发展出
解决方法。
17.5.1  可移植性和编程语言选择
    可移植性编程的首要问题是实现语言的选择。所有我们在第14章讨论过的主要编程
语言，从在全部现代Unix上都有兼容实现的角度来说，均具有较高的可移植性；而大多
数在Windows和MacOS下也有实现。在这里，可移植性问题往往并不在于核心的编程
语言，而在于支持库以及同本地环境整合的程度（尤其是IPC、并发进程管理以及GUI
的基础设施）。
17.5.1.1  C的可移植性
    C语言核心的可移植性非常高。标准的unix实现是GNU C编译器，它在开源Unix
和现代专有Unix中普遍存在。GNU C也已经移植到了Windows和古典的MacOS申，
但在那里使用并不普遍，因为缺少对本地GUI的可移植接口。
    标准输入／输出库、数学例程以及国际化支持都可以移植到所有的C实现中。如果小
心谨慎地只使用在“单- Unix规范”中描述的现代API，文件1/0、信号、进程控制也
可以移植到各个Unix;老一些的C代码常常需要经过条件预处理宏才能移植，但使用
POSIX之前接口的代码往往来自于古老专有的Unix，而且在2003年这些Unix如果不是
已经废弃就是接近废弃了。
    对于IPC、线程以及GUI接口，C的可移植性问题开始有些严重了。我们在第7章
已经讨论过IPC和线程的移植问题。真正实际中的问题是GUI工具包。许多开源的GUI
工具包可跨越各种现代Unix使用，还被移植到了Windows和传统的MacOS中-Tk、
wxWindows、GTK和Qt是其中四个最著名的，可以通过网络搜索得到的源码和文档。
但是它们中没有一个随所有平台一起发布，而且（更多的是法律而不是技术因素）没有
UNIX编惺艺术
  www.pdf365.com
410
第17章可移植性：软件可移植性与遵循标准
一个能够提供所有平台原汁原味的GUI观感。我们已在第15章给出了处理这个问题的
指导原则。
    已经有大批关于如何编写可移植性C代码的书了，本书并不想成为其中的一本。我
们推荐阅读Recommended C Style and Coding Standards（C的推荐风格和编码标
准）[Cannon]以及《The Practice of Programming（程序设计实践）》[Kemighan-Pike99]）中关
于可移植性的相关章节。
17.5.1.2 C++的可移植性
    在操作系统层次上，所有C语言的移植性问题C++都有，当然也存在一些自身的问
题。其中一个增加的问题是开源的C++编译器已经落后于专有的实现；这样，在2003年
年中，仍然没有一个统一的像GNU C-样能够成为事实标准的基础。更进一步，仍然没
有一款C++编译器完全实现了C++99 ISO语言标准，尽管GNU C++是最接近的一个。
17.5.1.3 Shell的可移植性
    很不幸，shell脚本的可移植性非常糟。问题不在shell本身．bash（1）（开源的Bourne
Again shell）已经普遍存在，所以纯shell卿本几乎可以到处运行。问题是大多数的shell
脚本大量使用了其它可移植性差的命令和过滤器，而且绝不保证在任意指定的机器上它
们都存在。
    这个问题可以借助一些额外的工作来克服，比如autoconf （l）工具。但是这个问题
很严重，所以大多数在shell中稍重量级的编程都转移到诸如Perl、Python、Tcl等第二代
脚本语言中完成。
    Perl的可移植性良好。Perl的核心版本甚至提供一套支持跨Unix、MacOS和Windows
平台GUI的rk工具包接口。然而也有个问题很讨厌。Perl脚本常常要求来自CPAN
（ Comprehensive Perl Archive Network）的插件库，无法保证它在每个Perl实现中都存在。
17.5.1.5  Python的可移植性
    Python可移植性极其出色。如同Perl -样，Python的主干版本甚至提供一个Tk包
的可移植接口，可支持Unix、MacOS和Windows的GUI。
www.pdf365.com
4l l
    Python主干版本存在比Perl更丰富的标准函数库，但是没有等价于Perl程序员可以
依靠的CPAN;重要的扩展模块常常随主干Python的次要版本的发布一起发布。这是以
牺牲空间来换取时间，使得Python更少成为模块丢失效应的对象，代价是Python的次版
本号要比Perl发布的版本级别重要得多。在实践中，权衡似乎对Python更为有利。
17.5.1，6 Tcl的可移植性
    Tcl的可移植性总的来说不错，但是随着项目复杂度的不同而有极大差异。为跨平台
GUI编程而生的Tk包原生于Tcl。同Python -样，语言核心的发展相对顺利，很少存在
版本不兼容问题。但不幸的是，Tcl甚至比Perl更依赖那些并不能保证随着每个实现一
起发布的扩展功能――也没有像CPAN -样的地方来集中发布这些扩展功能。
    因此，对于不依赖扩展的小项目，Tcl的移植性相当高。但是大项目往往大量依赖扩
展，和（同shell编程一样）调用在目标机器可能存在也可能不存在的外部命令；这些东
西的移植性相当糟。
    具有讽刺意味地，Tcl也许吃够了容易增加扩展的苦头。当一个特殊的扩展开始引人
注目，似乎可以成为标准发布中的一个部分时，一般都已经夺在好几个不同的版本了。
在1995年的Tcl/Tk学术研讨会上，John Ousterhout对为什么没有在标准Tcl发布中加入
00支持而解释道：
    想想五位大学者围坐一圈，一起叫着“杀死他，异教徒”。如果我把某个特
  殊的oo设计加入到内核中，其中一个就会说“祝福你，我的孩子，吻我的戒指
  吧j”，而另外四个则说“杀死他，异教徒”
    语言设计者并不一定愉快。
17.5.1.7 Java的可移植性
    Java的可移植性特别出色――毕竟，它是以“一次编写，到处运行”作为主要设计
目标的。然而，可移植性仍非尽善尽美。麻烦主要是JDK l.1及老AWT GUI工具包（一
方面）和JDK l.2及新Swing GUI包之间的版本兼容问题。这有几个重要的原因：
●  Sun的AWT设计不完善，不得不用Swing来代替。
UNIX编程艺术
  www.pdf365.com
412
第1 7章可移植性：软件可移植性与遵循标准
    ●  微软拒绝在Windows中支持Java开发并试图以C#来取代Java。
    ●  微软决定继续保留IE中对JDK I.I版的小应用程序的支持。
    ●  Sun许可证授权让JDK l.2的开源实现完全小可能，这延缓了它的部署进程（特
    别是在Linux世界）。
    对于涉及GUI的程序，追求移植性的Java开发者在可预知的未来，时常面临一个选
择：采用糟糕设计的JDK l.1/AWT工具包取得最大可移植性（包括移植到Microsoft
Windows），或者采用更好的工具包和JDKl.2功能而牺牲部分可移植性。
    最后，正如我们前面注意到的一样，Java对线程的支持也存在移植性问题。Java API，
不像其它抱负较小语言的操作系统接口，它勇敢地去尝试弥补不同操作系统提供的不同
进程模型之间的差异：但还没有掌握诀窍。
17.5.1.8  Emacs Lisp的可移植性
    Emacs Lisp的可移植性相当好。Emacs安装往往频繁地升级，而严重的过时失效情
况很少出现。相同的Lisp扩展到处都被支持，而所有的扩展都随Emacs本身一起发布。
    而且，Emacs的原语集相当稳定。几年前就获得了一个编辑器应有昀完备性（缓冲
区处理，shell脚本支持）。仅仅只是X的引入损害了这个优点，并且需要感知X的Emacs
模式也非常少。可移植性问题通常表现在操作系统功能C层次接口上的格格不入；例如，
邮件代理模式的从属进程控制大概是唯一这种表征经常出现的地方。
17.5，2避免系统依赖性
    一旦选定开发语言和支持库，下～个可移植性问题通常就是系统关键文件和目录的
放置：邮件池同志文件目录等等。这类问题的原型一般就是邮件池目录到底是
/var/ spool/mail还是/var/mail。
    通常可以通过退一步重新架构这个问题来避免此类依赖性。为什么要打开邮件缓冲
目录下的文件？如果需要写入，简单地触发本地邮件传输代理，来完成以获得正确的文
件锁定不是更好吗？如果需要读入，通过POP3或IMAP服务器查询不是更好吗？
www.pdf365.com
17.6国际化
413
    同类的问题在别处同样适用。如果发现需要手动打开日志文件，为什么不使用
syslog（3）代替？通过C库函数调用的接口比起系统文件定位容易标准化得多。应当利用
这个事实！
    如果必须在代码中使用系统文件定位，最好的选择取决于是发布源码还是采用二进
制形式。如果发布的是源码，我们在下个部分讨论的autoconf工具能够提供很好的帮助。
如果发布的是_进制形式，良好的实践是在程序运行期试探是否可以自动地适应本地条
件――例如，实地检查／var／rnail和／var/spool/rnail是否存在。
17.5.3移植工具
    通常可以使用我们在第15章介绍的开源GNU autoconf（1）来处理移植性问题，进
行系统配置探查，定制出makefile文件。如今，从事源码编译软件的人们往往希望能够
键入  configure;make;make  install  来干净利落地编译。  在
<http：／/seul．org／docs／autotut／>处有这些工具的优秀指导手册。即使是发布二
进制码，autoconf（1）工具也能够帮助自动化处理针对不同平台的条件代码问题。
    其它解决这个问题的工具中，其中两个较为知名的是与X window泵统相关的
Imake（l），以及由Larry Wall（后来的Perl语言发明者）编制的Configure工具，也被许
多项目采用。所有的工具至少都跟autoconf套件一样复杂，使用也不如以往频繁。它们
无法覆盖众多的目标系统。
1 7。6  国际化
    软件代码的国际化设计使得接口容易适应多种语言和各种字符集，对于这方面的深
入讨论超HJJ了本书的范围。然而，在Unix经验中有一些良好实践的突出事例。
    首先，分离信息库和代码。良好的Unix实践应把程序使用的消息字符串同程序代码
分离开来，这样不用修改代码就可以增加其它语言的消息字典。
    完成此项工作最知名的工具就是GNU的g已ttext，这个工具要求把需要进行国际化的
原生语言字符串包装在一个特殊的宏中。该宏使用各个字符串作为各文件提供的各种语
UNIX编腥艺_术
    www.pdf365.com
414
第1 7章可移植性：软件可移植性与遵循标准
言字典主键。如果某种语言的字典不可访问（或者存在该字典但查询没有匹配返回），
那么宏就简单地返回其参数，也就是隐式地退回到代码的本地语言。
    尽管在2003年中期，gettext本身一团乱麻，但其总体指导思想却是可靠的。对于许
多项目，使用这种思想可以手工打造出这种国际化设想的轻量级版本，并收到良好的效
果。
    其次，在现代Unix中有种清晰的潮流：抛弃所有历史上与多字符集相关的记法而让
应用程序原生地使用UTF8，八位移位Unicode编码字符集（或者相反地说，让他们原生
地使用1 6位宽字符）。UTF-8的前128个字符就是ASCII，前256个字符是Latin-I，这
就意味着它向后兼容使用得最广泛的两个字符集。XML和Java事实上促进了这种选择，
但是即使没有XML和Java，趋势也会如此。
    第三，使用正则表达式时，当心字符的范围。【a―z】元素并不必然包含所有的小写
字母，如果脚本或是程序应用于（比如说）德语，B被认为是小写字母但并没有包含在
上述范围之内；法语中的重音字母也存在类似的问题。安全的方式是使用【[．lower：】】，
以及其它在POSIX标准中拙述的符号范围。
17.7可移植性、开放标准以及开放源码
    可移植性需要标准。无论是发布传播一项标准还是敦促专有软件商遵循标准，开放
源码基准实现都是已知最有效的方法。而对于开发者，已颁布标准的开源实现既极大地
减轻了编码负担，也允许产品（有意或意外地）从他人的劳动中获益。
    让我们设想，例如，为数码相机设计一个图像捕捉软件。既然存在（正如我们第5
章所提到的）功能齐全经过良好测试的PNG读写开源库，那为什么要编写自己的格式来
存储图像数据或是购买专有代码呢？
    开放源码的新生（重生）同样给标准化过程带来了重要的影响。尽管并非正式要求，
IETF自从大约1997年前后，愈发抵制连一个开源基准实现都没有的RFC成为预备标准。
将来与某标准是否一致，似乎愈发有可能以“是否同已经得到标准作者们认可的开源实
现相一致（或者完全使用该实现）”来判定。
www.pdf365.com
17.7可移植性、开放标准以及开放源码
415
暗含的意思就是，成为标准的最好办法就是发布一个高质量的开源实现。
-Henry Spencer
    最后，确保代码移植性最有效的一个环节就是不要依赖于专有技术。永远不会知道
所依赖的闭源库／工具／代码生成器或网络协议何时会结束生命，接口何时会以某种非向后
兼容的方式改变，从而崩溃掉已有的项目。而使用开源代码，即使前沿版本的改变方式
足以崩溃已有的项目，也有前行之路；因为可以获取源码，如果需要，就可以向前移植
项目到新的平台。
    直到1990年代晚期，这个建议都还是不切实际的。少数几个代替依赖专有操作系统
和专有开发工具的软件还只是昂贵的实验品、学术上有待证实的观点或者小玩意。但互
联网改变了一切；在2003年中期，Linux和其它开源Unix不但存在，并且已经证明了自
身完全可以是出产高质量生产级软件的平台。现在开发者有了更好的选择，而不是依赖
于为垄断而设计的短期商业决策。实施防御性设计――基于开放源码编程，便不会束手
无策。
UNIX编程艺术
  www.pdf365.com
www.pdf365.com
1 8
文档：向网络世界阐释代码
Documentation: Explainin  Your
Code to a Web-Centric World
    I've never met口human being who would want to read J 7:000 pages of documentation，
    and if there was，，fd kill him to get him out西the gene pool.
我从没见过一个愿意阅读1 7000页文档的人，如果有，我会杀了他，这样人的基因
    必须抹去。
    -Joseph Costelio
    在1971年，Unix的第一个应用，是作为文档整理的平台-Bell实验室用来整理专
利文件以进行归档。那时，计算机驱动的照排还是新颖的想法，但几年后，1973年Joe
Ossana的troff（1）格式器出台，一举决定了这门艺术的地位。
    自那时起，各种复杂精致的文档格式器、排版软件、版面设计程序就已经成为了Unix
传统中的一个重要主题。尽管troff（1）令人吃惊地持久耐用，Unix还是在这个应用领
域中促生了许多其它具有突破意义的软件。现在，由万维网的发明而触发了文档实践的
深远转变，Unix开发者和Unix工具正站在这种转交的前沿。
    在用户表示层，自从上世纪九十年代中期以来，Unix社区的实践已经迅速地朝着“一
切皆HTML，所有引用都是URL”的方向发展。越来越多的现代Unix辅助浏览器完全
可看做解析确定特殊种类URL的网页浏览器（例如，“man:ls（l）”将ls（l） manpage转换
UNIX编腥艺-术
    www.pdf365.com
41 8
第1 8章文档：向网络世界阐释代码
成HTML）。这解决了不少因为主文档格式太多而产生的问题，但并不彻底。文档编辑
器仍然挣扎在哪种主格式最适合需求的权衡中。
    本章，我们将讨论许多种不同的文档格式，以及经受了几十年考验而传承下来的文
档工具，  “太多”意味着“不幸”。当然，我们也会逐步发展出良好实践和风格的指导
准则。
18.1  文档概念
    我们要讨论的第一项区分，就是“所见即所得”（WYSIWYG）的文档程序同以标记
为中心的工具之间的差异。大多数的桌面出版程序和字处理器都属于前者：具备图形用
户界面、键入的文字可以直接插入到文档在屏幕上的表示之中，并尽可能地接近最终的
打印版本。在以标记为中心的系统中，相对应地，主文本通常就是包含明确可见控制标
记的纯文本，跟期望的输出完全不同。标记的源文件可以由普通的文本编辑器修改，但
必须传入某个格式器程序来渲染输出以供打印或显示。
    界面可视的、WYSIWYG的风格对于早期的计算机硬件来说太昂贵了，直到1984年
Macintosh个人机问世前一直都很稀有。在当今非Unix的操作系统中，WYSIWYG的风格
完全占据了统治地位；而另一方面，Unix的原生文档工具，几乎都是以栎记为中心的。1971
年的Unix troff （1）就是个标记格式器，而且很可能是现在仍在使用的程序中最古老的一
个。
    以标记为中心的工具依然扮演着重要角色，因为实际上，WYSIWYG风格的实现往
往在很多情况下工作得并不好――有些是表面的，有些是深层次的。我们在第11章讨论
过GUI的一般问题，WYSIWYG的文档处理器也不可避免；任何事的结果都能看得到，
就意味着任何事都得看着做。所以，即使在屏幕和打印输出达到一致了，这个问题依然
存在――何况这两者从来没一致过。
    实话实说，WYSIWYG的文档处理器并不真正所见即所得。大多数程序的界面，并
没有真正消除屏幕显示和打印输出的差异，只是让你看不出来而已。这样做其实违反了
最小立异原则：界面的可视部分鼓励将程序作为打字机使用，但实际上并不能这么用，
而你的输入又时不时地产生无法预料或是非期望的结果。
    再实事求是点，WYSIWYG系统实际依赖的是标记码，只不过额外支付了巨大的努
力以期将此隐藏在一般使用中。这又违反了透明原则：因为无法了解所有的标记，就难
以标记位置错误的损坏文档。
www.pdf365.com
419
    尽管存在这些问题，但如果仅仅只是想把一张图片往右拖三个字宽，把它放到～
个四页小册子的封皮上，WYSIWYG的文档处理器可以干得非常漂亮。然而一旦需要
对三百页手稿的版面设计做出整体更改，便会有巨大的不便。WYSIWYG的用户面对
此类的挑战必须放弃，或是忍受要命的千百次鼠标点击的痛苦；在这样的情形中，编
辑明确标记的能力是无可替代的；此时，以标记为中心的Unix文档工具提供了更佳的
解决方案。
    今天，当全世界都受到了万维网和XML的影响，把表现方式和结构标记在文档中
区别开是再正常不过的了――前者是关于文档外观的指令，而后者是关于文档如何组织、
有何用意的指令。这种差异在早期的Unix工具中并没有得到清晰的理解和遵从，但是理
解这种设计差异非常重要，正是它导致了那些工具发展为如今的继承者。
    表现级标记在文档本身中携带所有的格式信息（例如希望的空白布局和字体变化）。
而在～个结构标记系统中，文档必须和～个样式单相结合，它告知格式器如何将文档中
的结构标记转换为物理的版面布置。最后两种标记一起控制打印和浏览文档的物理外观，
但是，如果希望既能为打印又能为网页生成良好的输出结构，结构标记有必要通过一个
更高级剐的间接层完成。
    大多数以标记为中心的文档系统都支持宏。宏是用户定义的命令，可以由文本替换
来扩展成内嵌的标记请求序列。通常，这些宏为标记语言增加了结构特征（例如声明小
节标题的能力）。
    troff宏集合（mm、me和我的ms包）实际上是设计来将人们从面向格式的
编辑推动到面向内容的编辑。这种思想就是将语义部分进行分类标记，以各种风
格包来确定在这种样式中标题是否应该大写或者居中等等。这样，一套宏可以尝
试模仿ACM刊物的风格，而另一套使用基本-ms标记的宏则模仿Physical Review
（物理评论）刊物的风格。然而对于既要集中精力构建文档内容，又要注意控制
外观，所有的宏都不好使，就如同网页陷入到底是读者还是作者应该控制外观的
争吵一样。我常常发现那些秘书仅仅为了产生斜体而使用.AU（作者名）命令，
因为发现它能产生斜体，该命令的附加效应将使他们无比烦恼。
-Mike Lesk
最后，我们注意到对于小文档（商务和私人信函、小册子以及时事通讯）和大文档
UN/X编腥艺l术
  www.pdf365.com
420
第1 8章文档：向网络世界阐释代码
（书籍、长文、技术论文以及手册）之间，作者所期望处理的事情存在重要差异。大文
档往往需要更多的结构，需要一部分一部分地结合在一起，而又能够单独改动，同时需
要一些自动生成功能，例如内容的目录；这些特点都倾向于以标记为中心的工具。
18.2 Unix风格
    Unix风格的文档（以及文档工具）具备几个技术和文化特征，使之有别于其它地方
的实现。首先熟悉这些鲜明的特征，便能够打下良好的背景基础，从而理解为何文档有
那样的实际外观，为何文档有那样的阅读方式。
18.2.1  大文档偏爱
    一直以来，Unix文档工具主要是为应对创作庞大复杂文档的挑战而设计的。最初
是专利申请和文书工作；后来是科技论文，以及各式各样的技术文档。结果，大多数
Unix开发者渐渐喜欢上了以标记为中心的文档工具。与时下的PC用户不同，尽管在
1980～1990年代早期，WYSIWYG的字处理器非常普遍，但在Unix文化中并没有留下
什么印记――即使在今天，年轻一辈的Unix玩家中，也很少发现有谁真正地喜欢那种
工具。
    对不透明二进制文档格式的厌烦情绪―～尤其是不透明的专有二进制格式――也在
拒绝WYSIWYG工具的过程申起到了一定作用。另一方面，PostScript（图像打印机的现
行控制语言标准）刚可以使用，Unix程序员就投入了极大的热情；这门语言整洁优美地
符合Unix传统的域专用语言。现代的开源Unix系统都有优秀的PostScript和可移植文档
格式（ Portable Document Format，PDF）工具。
    另一个历史结果就是，Unix的文档工具对于包含图像的支持往往相对较弱，但
是对图表、图形和数学方面排版的支持却很强――这些都是在技术论文中常常需要用
到的。
    Unix对于以标记为中心系统的依恋常常被讽刺为一种偏见或是顽固的特性，但是实
际上并不真的女日此。同Unix被公认为“原始”的CII风格在许多地方比GUI更能适应高
www.pdf365.com
18.2 Unix风格
421
级用户的需要一样，诸如troff（1）等以标记为中心设计的工具，比起WYSIWYG的程
序更能适应高级文档管理者的需要。
    偏爱大文档并不仅仅让Unix开发者继续对诸如troff程序等以标记为核心的格式器
保有依恋，也激发了对结构标记的兴趣。Unix文档工具的历史，是一场步履蹒跚、充满
困惑、左右摇摆的运动，虽然总方向是从表现性标记转到结构性标记。在2003年年中，
这个旅行仍未结束，但放眼放去，终点已不远。
    万维网的发展意味着在大概1993年以后，文档工具面临的主要挑战是提高描绘多媒
体文档（或者，至少是为了打印和HTML显示）的能力。同时，即使是普通的用户，在
HTML的影响下，也变得更加适应以标记语言为中心的系统。这直接导致了在结构性标
记上浓厚兴趣的爆发以及1996年后XML的发明。突然间，1日时代Unix对以标记为核
心系统的依恋开始变得不再是反动，而是具有先见之明的了。
    如今，在2003年年中，多数基于XML使用结构性标记文档工具的前沿开发正在
Unix下进行。但是同时，Unix文化并没有放弃古老的表现级标记系统的传统。HTML和
XML只在部分场合取代了嘎吱嘎吱作响的、穿若笨重铠甲大恐龙般的troff。
18.2.2文化风格
    绝大多数软件的文档都是由技术人员写给可能连最小公分母都不知道的普通大众的
――渊博者写给无知者。但是同Unix系统一起发布的文档传统地是由程序员写给程序员
的。即使不是写给同行的，但在风格和格式上，也往往受到大量同Unix系统一起发布的、
程序员写给程序员的文档所影响。
    这种思想产生的差异可以用一个观察来总结：Unix手册页传统上也包含一个叫做
BUGS的部分。在其它地方，技术作者为了让软件产品看起来更漂亮，常常省略或一笔
带过那些已知的bug o而在Unix文化中，同行彼此互相事无巨细地揭露软件的已知缺陷，
而用户也认为一个简单但详细的BUGS部分是高质量软件的表征。隐瞒了BUGS部分，
或是改头换面为诸如LIMITATIONS或ISSUES或APPLICATION USAGE等轻描淡写词
语、从而打破这个约定的商业Unix发布版本，无一例外地走上了不归之路。
    多数其它软件的文档往往总是在高深莫测和过度简化间摇摆，而经典的Unix文档则
简洁而完善。虽然并非手拿把教，但通常指明了正确的方向。这种风格设想的读者积极
UNIX编程艺．术
    www.pdf365.com
422
第1 8章文档：向网络世界阐释代码
而进取，愿意并能够举一反三。
    Unix程序员往往擅长于编写参考书籍，而大多数Unix文档也带点参考书籍或辅助
备忘录的味道，这是为那些能够象文档作者一样思考但对软件还称不上专家的人编写的。
答案看起来常常比实际上的隐秘和匮乏得多。然而，仔细逐字逐句地阅读，因为想知道
的一切就在那里，或者可以从那里推导。仔细逐字逐句地阅读，因为话很少会说两遍。
18.3各种Unix文档格式
    所有主要的Unix文档格式，除了最近的，都具有宏扩展包支持的表现级标记。我们
将按照从老到新的时间顺序讨论。
18.3.1    troff fo Documenter*s Workbench Tools
    在第8章，作为如何整合一个多微型语言系统的实例，我们讨论过Documenter's
Workbench的体系和工具。现在，我们转过来讨论这些工具用作排版系统的角色。
    troff格式器可看作是一个表示层的标记语言。最近的实现版本，诸如GNU项目groff
（1）之类，默认情况下生成PostScript输出，当然也可以通过选择适当的驱动来得到其
它格式的输出。参看实例18.1，是几行可能会在文档源文件中碰到的troff代玛。
例18.1  groff （1）标记实例
This is riinning text.//这是运行文本
．＼”Conunents begin with a backslash and doulole quota.//注解以反斜扛加双引号开始。
．ft B
This text will be in bold font.／／这里的文本字体为粗体。
．ftR
This text will be back in the default  （Roman）  font．／／这里的文本又回到默认的（Roman）
字体
These lines， going back to 'fThis is running text"， will
be formatted as a filled paragraph.//这几行，回溯到“This is running text”被格
式化为…‘个加载段。
．bp
The bp request forces a new page and a paragraph break.//bp请求生成新页结束段落。
This line will be part of the second filled paragraph.  ／／这一行属于第二加载段的
部分。
.sp 3
The .sp request emits the number。f blank lines given as argument//sp谙求生成
给定参数数量的空行。
www.pdf365.com
18.3各种Unix文档格式
423
．nf
The nf request switches off paragraph filling.//nf请求取消段落加载。
Until Lhe fi request switches it back on  ／／直到fi请求切换回来
whitespace and layout will be preserved.  ／／空白和版面继续保留
One word in this line will be in \fBbold\fR font.//该行的一个字将是＼fBbold\ fR
字体。
．fi
Paragraph filling is back on.//切换回段落加载。
troffl1）有很多其它的请求命令集，但是人们通常都不会去直接阅读它们。几乎没有
文档直接用troff编写。troff支持宏，通常都使用五六个宏命令包。在这些当中，压倒性
最普遍的是man（7）宏命令包，用来编写Unix手册页。例18.2作为一个样本供参考。
例18.2 man标记实例
. SH  SAMPLE  SECTION
The SH macro starts a section，  boldfacing  the  section  title. //SH宏标志一个部分
的开始，并使标题的字体为粗体。
.p
The p request starts a new paragraph.  TheIrequest sets its//pj青求开始一个新
的段落，工请求将字体设置为其后指定的参数
argumentln
．工i七alics.／／在该例中为斜体。
．IP  ★
This starts an indented paragraph with an asterisk label.//从此开始一个以星号为
前标的缩进段落。
More text for the first bulleted paragraph.//段落更多的文本，每行以星号为前标。
.TP
This first line will become a paragraph label/／这第一行成为新段落的标记
This will be t-he first line in the paragraph， further indented
relative to the label.／／这将是新段落的第一行，相对标记有更多的缩进。
The blank line just above this is treated almost exactly like a
paragraph break （actually， like the troff-level request .sp l）．／／知上的空行几
乎总是当作段落的结束（实际上，像troff层次的.sp 1请求）。
．SS A subsection
This  is  subsection text，／／这是子段文本，标题为“A subsection"
在历史上其它五六个rroff宏指令库中，ms （7）和mm （7）是仍在使用的两个。BSD
Unix含有自身精心制作的扩展宏指令集，mdoc （7）。它们在风格上与man宏集相似，
但更精致，并且倾向于生成排版输出。
www.pdf365.com
424
第1 8章文档：向网络世界阐释代码
    troff（1）是一个叫做nroff（1）的小变种，它为诸如行式打印机和字符元终端等只支持
定宽字体的设备生成输出。在终端窗口浏览的Unix手册页正是nroff程序提供的。
    Documenter's Workbench的工具被设计来完成技术文档工作，它在这方面做得相当
漂亮，这就是为什么尽管三十年间计算机能力提高了千倍，而它一直还被人们使用的原
因。这些工具在图像打印机上生成可靠质量的排版文本，也可以在屏幕上显示虽不完美
但可忍受的格式手册页。
    在好几个领域中，这些工具也做得很糟糕。可供选择的主要字体是有限的。图像处
理得不好。在页面里很难精确地控制文本、图像或图表的位置。多语言文档的支持也不
存在。还有不少其它问题，有些由来已久但不太重要，有些绝对是为了特殊目的而仓促
写就的。但大多数严重的问题都是因为标记仅仅处于表示层，所以不加修改的troff源文
件很难生成效果良好的网页。
    无论如何，在编写本书时，manpage仍旧是唯～虽重要的Unix文档形式。
18.3.2  TEX
    TEX（发音为/teH/，浊音h就像口含着水发音一样）是个威力强大的排版程序，如
同Emacs编辑器一祥，最初也来自Unix文化之外，但现在却在Unix文化中落地生根。
它是由著名的计算机科学家Donald Knuth在1970年代晚期发明的，那时的他腻烦了印
刷排版的――特别是数学方面的――排版质量。
    TEX，同troffll）一样，是以标记为中心的系统。TEX的请求语言比troff更具威力：
就其它而言，在处理图像，准确的内容页面定位，以及国际化方面都做得较好。TEX特
别擅长处理数学方面的排版，基本的字距调整，线填充以及连字符等问题也做得非常优
秀，难以超越。TEX已经成为了众多数学刊物的排板标准。现在实际上已作为开源软件，
由美国数学学会（ American Mathematical Society）维护。它也常被用于科学论文。
    同troffll）相似，人们通常也不需要手工编写大量原始的TEX宏；而是使用宏命令包
以及各式各样的辅助程序。一个特别的宏命令包，LATEX，几乎无所不能，而且大多数
人所谓在使用TEX创作时实际上几乎总是指用LATEX编写。与troff的宏命令包一样，
许多请求都是半结构性的。
www.pdf365.com
18.3各种Unix文档格式
425
    TEX -个通常用户不可见的重要用法就是，其它文档处理工具宁愿生成LATEX来
转换成PostScript，而不是尝试自己生成PostScript，因为那样做更困难。我们在第14章
作为shell编程而讨论的xmlto（1）前端使用的就是这个策略；我们稍后要讨论的
XML-DocBook工具链也如出一辙。
    TEX比trofj（1）有着更广的应用范围，而且在很多地方有更好的设计。在愈发倾向以
网络为中心的世界里；TEX存在同troff -样的基础性问题；其标记更接近表示层，而要
从TEX源文件中自动生成网页很困难，很难不出错。
    TEX从未被Unix的系统文档使用，也很少使用在应用程序的文档中；对于这些任
务，troff就足够了。但是一些源自Unix社区之外的学术界已经引入了TEX作为文档的
主要格式，例如Python语言就是个典型的例子。如上所述，它也大量地使用在数学和科
学论文中，而且还会在那个小环境中占据好几年的统治地位。
18.3.3  Texinfo
    Tcxinfo是由自由软件基金发明的文档标记，其目的是为了管理GUN项目文档――
包括诸如Emacs和GUN编译器集之类基本工具昀文档。
    Texinfo是第～个为既支持排版纸面输出又支持可供浏览的超文本输出而设计的标
记系统。尽管那种超文本格式并不是HTML，而是一种更原始的类型，叫做“info，，，
它最初是设计在Emacs中浏览的。在打印方面，Texinfo先转换成TEX宏然后再转换为
PostScript。
    Texinfo工具现在可以生成HTML。但并不能很好地完整地完成这项工作，而因为许
多Texinfo的标记都是处于表现级别，真有可能永远无法达成目标。在2003年年中，自
由软件基金正在开发从Texinfo到DocBook的启发式转换器。在一段时间里，Texinfo将
可能继续作为一个有用的格式而存在。
18.3.4  POD
    Plain Old Documentation是Perl支持者使用的标记系统。它生成手册页，具备所有表
示层标记的相似问题，包括不能生成良好HTML的顽疾。
UNIX编程艺术
  www.pdf365.com
426
第1 8章文档：向网络世界阐释代码
18.3.5  HTML
    自从万维网在九十年代早期进入主流社会以来，一小部分但比例越来越高的Unix项
目直接使用HTML来编写文档。这种方式的问题是难以从HTML中生成高质量的排版输
出。也存在特殊的索引问题：需要生成索引的信息在HTML中并不存在。
18.3.6  DocBook
    DocBook是为大规模、复杂技术文档而设计的SGML和XML文档类型定义。在Unix
社区中使用的标记格式中这是唯一的纯粹结构性的标记语言。在第14章讨论的xmlto（l）
工具，支持转换到HTML、XHTML、PostScript、PDF、Windows帮助以及其它几种次重
要的格式。
    几个主要的开源项目（包括Linux文档项目、FreeBSD、Apache、Samba、GNOME
和KDE）已经使用DocBook作为首要格式了。本书也是用XML-DocBook编写的。
DocBook是个大话题；我们将在总结Unix文档当前状态的问题之后再回来讨论。
18.4  当前的混乱和可能的出路
    Unix文档管理，目前，是一团乱麻。
    在现代的Unix系统中，文档的首要文件形式散布在man、ms、mm、TEX、Texinfo，
POD、HTML和DocBook之间。没有统一的方法来浏览所有的描绘版本。它们不能通过
网络访问，也不能交叉索引。
    Unix社区的许多人已经意识到这是个问题。在本书写作时，大多数朝着解决这个问
题方向的努力都来自于开源开发者，比起那些专业Unix的开发者来说，他们更积极地关
心是否能够赢得非技术终端用户的接受。自从2000年来，实践的方向转向使用
XML-DocBook来作为文档的交换格式。
    目标虽然可望，但需要许多的努力才可及，那就是在每个Unix系统上都装上软件作
为系统范围内的文档登记库。当系统管理员安装某个文档软件包时，需要有个步骤，将
该软件包的XML-DocBook文档注册到登记库中去，并被转换成一个通用的HTML文档
树，并且交叉链接到已经存在的文档上。
www.pdf365.com
18.5  DocBook
427
    文档登记库软件的早期版本已经可以运行。但从其它格式到XML-DocBook的转换
是个巨大而繁杂的步骤，当然转换工具将很快就位。其它的行政和技术问题有待解决，
但这是可以解决的。而在2003年年中，旧格式是否必须被抛弃，并没有一个全社区的一
致意见，其实那似乎是最有可能的解决方式。
    相应地，我们接下来将详细讨论DocBook及其工具链。可以把它当作Unix下的XML
介绍，当作一个对实践的实用指导以及一个重要的实例分析来阅读。同时，也是在Unix
社区背景下，不同项目组开发者之间，如何围绕共享的标准进行合作的上佳实例。
18.5  DocBook
    许多重要的开源项目都趋于使用DocBook作为文档的标准格式。基于XML标记的
提倡者似乎已经赢得了理论上的胜利，支持结构层标记，反对表示层标记，并日．一条高
效的XML-DocBook工具链也有了开源实现。
    然而在DocBook以及支持它的程序中依然被很多问题缠身。其支持者满口甚至被计
算机科学标准禁止的暗语，弄出许多缩写词，而都跟编写标记以及从中生成HTML或
PostScript所需要做的事并没有明显的关系。XML标准和技术文章声名狼藉她晦涩不清。
在余下的部分，我们将试图驱散笼罩在暗语行话上的这层迷雾。
．1 Q只1 tT赴址米并II，{，W
 I o.J．I）0，IIj犬刍芭人匕）0
    （注：为了叙述上的简便，这部分叙述有些偏颇，主要是省略了大部分的历史。在
下一个部分会侧回来完整地讨论。）
    DocBook是个结构级标记语言。特别地，是XML的一种方言。一份DocBook文档
其实也是XML文档，使用了XML标签作为结构标记。
    对于一个文档格式器，如果需要将样式单应用到文档，并让它美观大方，就必须知
道文档的整个结构。例如，为了能够正确地格式化章节标题，就需要知道书稿通常包含
哪些前言、章节和附录。为了让格式器知道这些东西，就需要指定一个文档类型定义或
DTDo DTD告诉文档格式器文档结构中有哪些元素，以什么样的次序出现。
UNIX编曜艺术
  www.pdf365.com
428
第1 8章文档：向网络世界阐释代码
    DocBook被称作XML方言，这句话的含义是，DocBook实际上是个DTD--个
相当庞大的DTD，大概有400个左右的标签。1
    隐藏在DocBook后的一类程序叫做验证解析器。如果格式化一个DocBook文档，第
一步就是将其传递给一个验证解析器（DocBook格式器的前端）。这个程序检查文档是
否符合DocBook DTD以确保没有违反任何DTD的结构规则（否则，格式器的后端，应
用样式单的部分，会变得无所适从）。
    验证解析器要么抛出错误并给出文档哪处结构违反了规则，要么将文档转变成XML
元素和文本流，并由解析器后端将样式单的信息整合在一起产生格式化后的输出。
    图18.1揭示了整个过程。
格式器
图18.1  结构化文档处理过程
    图中虚线框内的部分就是格式化软件或工具链。除了明显可见的输入以外（待格式
化的文档原件），请牢记：格式器还需要两个隐含的输入（DTD和样式单），这样才能
理解随后的过程。
18.5.2  其它DTD
    先扯远一点，说说其它的DTD，这样可能有助于澄清上一节中哪些部分是DocBook
独有的，哪些部分是所有结构性标记语言‘所通用的。
1用XML的话来说，我们斫谓的“方言”其实应该叫做“应用”；我们避免这种用法，是因为跟这
个词另一个更常用的意思有些混淆。
www.pdf365.com
18.5  DocBook
429
    TEkhttp：／／www. tei-c．org／>（Text Encoding Initiative）是个大型精细的DTD，
主要使用在学术界书稿文本的计算机电子稿件。TEI基于Unix的工具链，使用了许多类
似于DocBook中的工具，但是样式单（理所当然）和DTD截然不同。
    XHTML，最新版的HTML，也是由DTD描述的一个XML应用，阐明了XHTML
和DocBook标记之间的家族相似性。XHTML工具链包含可以将HTML格式化成纯ASCII
文本的网页浏览器，也整合了许多专用的HTML打印功能程序。
    许多其它的XML DTD在维护着，它们是用来在诸如信息生物和银行等领域进行结
构化信息交换的。可以参阅<http：／/www．xml．com/pub/rg/DTD_Repositories>
的列表，以对这些有个概念。
18.5.3  DocBook工具链
    通常要从DocBook源文件生成XHTML，需要使用xmlto（l）前端。命令看起来像这
样：
    本例将把具有三个主体部分的XML-DocBook文档foo.xml转换成目录页和内容页两
部分。生成一个长页面只需：
最后，可以这样生成PostScript卧各打印：
bash$  xmlto ps  foo.xml           #  To  make  Pos七Script  #生成 PostScript
bash$ Is *.ps
foo.ps
    将文档转换成HTML或者PostScript，需要一个引擎，将DocBook DTD和针对文档
的恰当样式单组合起来，应用到你的文档上。图18.2说明了开源工具是如何完成协作过
程的。
    有三个程序可以解析文档并应用样式单进行转换。最常用的是xsltproc，同Red Hat
Linux -起发布的解析器。剩下的两个是Java程序，．Saxon和Xalan。
UNIX编腥艺：术
    www.pdf365.com
           ><
            r0
                         . rl
           rJ
               o
                H
               o
       ' r0
i-l    l
 x    七
 .     J:
 o     .
f       O
七  r-l  r
><  七
      J::  i-l
 o  .  m
 {11  a  r
b n  rlj
r-l
 ><
 o
 o
rn
-1t:
 o
  I
N-I
U  i+
><  t
 o  .
七  +:
m  cn ~-i
><  :-i  m
$$ J:
rn  {n  o
 a  a  0
n b  q-l
430
第1 8章文档：向网络世界阐释代码
┏━━━━┓
┃DocBook ┃
┗━━━━┛
    图18.2  如今的XML-DocBook工具链
    从DocBook生成高质量的XHTML相对容易；事实上XHTML只不过是另外一种
XML DTD，这一点当然有益于转换。对文档施用相当简单的样式单就可以完成HTML
转换，这也是整个过程的结束。按照这种方式，RTF的生成也很简单，而在XHTML或
RTF基础上，必要时生成近似的纯ASCII文本也就是轻而易举的了。
    麻烦的是打印。生成高质量的打印输出一一实际上是Adobe的PDF（Portable
 Document Format，可移植文档格式）――是困难的。需要从算法上重现人工排版中区分
内容和表现精准判断。
    因此，首先，样式单将DcoBook的结构性标记转换成另一种XML方言-FO
（Formatting Objects，带格式对象）。FO标记是完全表示层的；可以认为等同于troff的XML
功能。之后，FO标记会被转换成PostScript，然后包装成PDF。
    在同Red Hat Linux -起发布的工具链中，这项工作由TEX的一个叫做Pas siveTeX
的宏命令包完成。它将xsltproc生成的格式化对象转换成Donald Knuth昀TEX语言。TEX
的输出是熟知的DVI（设备独立）格式，于是便可制成PDF。
    从XML到TEX宏，再到DVI，最后到PDF，这工具链简直就像老牛拉的杂牌老破
车，如果这么认为，确不为过。嘎吱嘎吱，呼哧呼哧，一无是处。字体是个严重的问题，
因为XML、TEX和PDF字体的工作模型都不尽相同：同样，国际化和本地化也是一场
恶梦。按这种方式走到头，真是自寻烦恼。
    FOP（FO-to-PostScript）会优雅得多，这是由Apache项目开发的从FO直接到
PostScript的转换器。在FOP中，国际化问题，如果不算解决的话，至少很好地限制住
了；XML工具总是通过FOP处理Unicode。从Unicode字形到Postscipt字体的映射也绝
www.pdf365.com
18.5  DocBook
431
对是个问题。最麻烦的是这种方法尚无法工作：到2003年中，FOP还处于未完成的alpha
状态――可用，但粗糙不堪且功能不足。
    图18.3展示了FOP工具链的模样
    图18.3  XML-DocBook未来的FOP工具链
    也存在同FOP的竞争者。另一个叫做xmlroff2项目的目标同FOP -样，但以c++
完成（因此速度较Java快也无需依赖Java环境）。在2003年年中，xmlroff也处于未完
成的alpha状态。
18.5.4移植工具
    DocBook第二严重的问题是，需要大量努力将旧风格的表示层标记转换为DocBook
标记。人们通常可以自动地将文本的表示解析成逻辑结构，因为（例如）可以从上下文
中判断一个斜体部分是“强调”还是“外来词”或别的什么。
    无论如何，将文本转换成DocBook的过程中，这种区别需要明确化。有时它们出现
在旧的标记中；有时又不出现，而缺失的结构性信息必须由聪明的算法推演或是人为补
足。
UNIX编翟艺术
  www.pdf365.com
432
第1 8章文档：向网络世界阐释代码
    下面总结了从其它格式到DocBook的转换工具。所有这些工具都不是彻底完美的；
在转换后需要检查，甚至需要人工编辑。
GNU Texinfo
    自由软件基金尝试将DocBook作为交换格式来支持。Texlnfo具有足够的结构标记
来进行良好的自动转换（人T编辑仍然需要，但不会太多），4.x版本的makeinfo有个功
能开关-docbook，可以生成DocBook。更多的信息参见makeinfo项目主页
<http:／/www. gnu. org/directory/texinfo. html>a
POD
    POD::DocBook<ht tp:／/www. cpan. org/mo dule s/by -module/Pod/>将Plain
Old Documentation标记转换为DocBook。它宣称除了L<>斜体标签，可以将所有的POD
标签都转换成DocBook。手册又说“嵌套的=over/=back列表在DocBook中不支持”，
但注意这个模块是经过大量测试的。
LATEX
    一／卜日Lf做TeX4ht<http：／／www - irz -muenchen．de/services/ software/
sonstiges/tex4ht/ mn，html>的项目，按照PassiveTEX作者的说法，可以从LATEX
生成DocBook。
man pages和其它基于troff的标记方式
    这通常被认为是最大最令人厌烦的转换问题。的确，基本troff（1）标记的表示层太
低，自动完成转换的工具简直就是吃力不讨好。然而如果我们考虑从使用man（7）之类宏
命令包编写的文档源进行转换，前景就光明了许多。这些宏具备足够的结构性特征以利
于自动转换。
    我自己编写了～个我称之为doclifer的工具来做troff到DocBook的转换，因为我找不
到什么软件的转换结果可以容忍。<http：／/www- catb. org／―esr／doclifter/>。支
持从，nan（7）、mdoc（7）、ms（7）、以及me（7）宏转换到SGML或者XML DocBook。详情请参
考项目文档。
18.5.5编辑工具
在2003年年中还缺乏的就是～款优秀的开源SGML/XML结构编辑器。
www.pdf365.com
18.5  DocBook
433
    LyX<http: //www．lyx．org/>是个GUJ的字处理器，使用LATEX进行打印并支
持LATEX标记的结构化编辑。有可以生成DocBook的LATEX包，以及描述在LyX界
面中如何撰写SGML和XML的how-to文档<http：//bgu．chez．tiscali．fr/doc/
db4lyx/>。
    GNU TeXMacs  项  目  <http://www.math.u-psud.fr/―anh/TeXmacs/
TeXmac g．html>，其目标是生成一个擅长于技术及数学材料的编辑器，包括公式的显
示。1.0版已经在2002年四月发布。开发者计划在未来加入XML支持，但目前还没有。
    许多人仍然使用Vl或者emacs来手工编写DocBook标签。
18.5.6相关标准和实践
    慢慢地可以凑起许多工具来编辑和格式化DocBook标记。但是DocBook本身只是个
手段，而不是最终目的。除了DocBook本身之外，我们需要其它标准来达成“可搜索文
档数据库”这个目标。这存在两大问题：文档编目和元数据。
    ScroIIKeeper  <ht tp：//scrollkeeper．sourceforge。net／>直接瞄准这种需
求。它提供一套简单的脚本钩子（ script hook），可以使用在软件包的安装和卸载过程中，
以登记和注销它们的文档。
    ScroIIKeeper  使用开放元数据格式  （Open  Metadata  Format）
<http：／/www. ibiblio．org/osrt/omf/>。这是为开源文档制作索引的标准，类似
于图书馆的卡片式目录系统。该创意支持丰富的搜索功能，可通过使用卡片式目录元数
据或是源文本本身。
18.5.7  SGML
    先前，我们有意地忽略了DocBook的历史。在XML之前，还有个标准通用标记语
言（SGML， Standard Generalized Markup Language）。
    直到2002年年中，DocBook的讨论必然深入到SGML中，包括SGML和XML的
不同，包括SGML DocBook工具链的具体描述。现在简单了：存在XML DocBook的开
源工具链，它甚至比SGML工具链工作得还好，也更容易使用。
18.5.8  XML-DocBook参考书籍
学习DocBook比较困难，与之相关的站点总是堆砌长长的W3C标准列表，大量
www.pdf365.com
434
第18章文档：向网络世界阐释代码
SGML理论知识以及一大堆复杂的抽象术语，这往往会吓退初学者。XML in a
NutsheIl（XML技术手册》  [Harold-Means]是本详细的优秀入门书。
    Norman Walsh的DocBook: The Definitive Guide （DocBook权威指南》的印刷版本在
<http：／/www，oreilly．com/caLalog/docbook/>，  电子版本在<http：／/www.
docbook．org/tdg/   en/html/docbook．html>，但它作为入门指导对读者而言简
直就是灾难。我们建议阅读：
    Writing Documents Using DocBook（使用DocBook编写文档）<http：／/xml .web．
cern．ch/XML/goossens/dbatcern/》。这是本优秀的入门指导书。
    同样优秀的DocBook常见问题解答<http：／/www．dpawson．co．uk/docbook/>中，
有许多关于  HTML  输出风格化的资料。  还有一个  DocBook wiki
<ht tp: //docbook. org/wiki/moin. cgi>。
    晟后，The XML Cover Pages<ht t-p：／／xml．coverpages．org/>，将会带你进入
XML标准的世界，如果有此愿望，不妨去看看。
18.6编写Unix文档的最佳实践
    本章早些时候关于阅读Unix文档的建议正好可以反过来。在Unix文化环境中为他
人编写文档时，别自降身价。愚弄读者，就是承认自己也是傻瓜。愚弄读者的文档同真
正易于理解的文档大相径庭；前者偷懒而忽略了重要的东西，后者则要求深思熟虑以及
不留情面的修订。
    数量多不会被认为是质量高。尤其是，决不要因为害怕别人看不懂而省略功能细节，
决不要为了面子而不对存在的问题提出警示。不愿坦露问题才会损害信誉和用户，坦白
了的问题则不会。
    信息密度要适中。过低过高都不好。少用屏幕截图；它们除了界面风格和观感之外
往往很少带有其它信息。它们从来无法代替清晰的文字描述。
    如果项目规模比较大，应该发布三种不同的文档：手册页作为参考资料，教程手册
和常见问题解答列表。应该有个网站，作为发布中心（参考第19章关于交流的指导）。
    没人喜欢庞大的手册；在其中浏览比较困难；如果确有此虞，考虑编写参考手册，
手册页提供快速的摘要，并指向参考手册，以殁程序如何调用的细节。
www.pdf365.com
18.6编写Unix文档的最佳实践
435
    在源码中，需要包含第19章关于开源发布惯例部分阐述的标准维护文件，例如
README。即使是专有代码，也请遵守Unix的约定俗成，具备Unix背景的未来维护者
将会很快上手。
    手册页应该为传统的UfliX用户以传统风格的命令引用形式呈现。考虑非技术用户，
入门手册应该多用全称，少用缩写。而FAQ应该随着软件支持群体对软件常用问题及如
何回答的深入了解而不断改进。
    2003年年中，最前沿的实践中，还有几个重要的习惯应该养成：
    1．使用XML-DocBook维护主文档。即使手册页是DocBook RefEntry文档。关于
    如何编写用户期望看到的手册页来解释内容和组织，这里有个非常有用的
    HOWTO<http:／/www. linuxdoc. org/HOWTO/mini/Man- Page. htrn]>。
    2．发布XML主文档。同时，需要发布troff源码，对主文档运行xmlto man就可
    以得到它，以备用户的系统上没有装载xmlto（1）。软件的安装程序应该以常规方式
    进行，如果有人需要编写或者编辑文档，请引导他们使用XML文件。
    3．让项目的安装包支持ScroIIKeeper，
    4．从主文档生成XHTML（使用命令xmlto xhtml）并放到项目的网页上以供访问。
    无论是否使用XML-DocBook作为主格式，都应该找到某个方法将文档转换为
HTML。无论软件是开源的还是专用的，用户越来越愿意通过网络找到它。将文档放在
网上，其直接效应就是能够让知道软件的潜在用户和消费者更容易阅读，更容易了解软
件。而其间接效应就是软件被网络搜索找到的机会更多。
UNIX编-程艺术
    www.pdf365.com
www.pdf365.com
1 9
开放源码：在Unix新社区
中编程
Open Source: Programming in the
New Unix Community
Software is like sex-it's better when it'sfree.
    软件和性一样――越自由越好。
    -Linus Torvalds
    在第2章，作为总结，我们评述了Unix历史中最大规模的模式；当Unix实践最接
近开放源码时，就欣欣向荣，反之则停滞不前。然后在第16章，我们又断言开源开发工
具往往具备高等级质量。至于本章，我们将以简要说明开源开发怎样工作且为何这样工
作作为开始。实际上，其大多数行为都只不过是Unix传统长期实践的强化而已。
    随后我们将从抽象领域下到具体，转而描述一些Unix从开源社区借鉴而来的最重要
的大众习惯的――特别是由社区发展的、关于如何成为良好源码发布的指导原则。其它
现代操作系统的开发者同样可以沿袭大多数这些习惯并从中受益。
    我们将假设你用开放源码进行开发而描述这些习惯；当然，即使是编写专有软件，
多数习惯仍不失价值。基于开放源码的设想在历史上也是有用的，许多习惯在专有Unix
中都能找到痕迹，像无处不在的工具例如patch （1）、Emacs和GCC筹等都是。
UNIX编程艺术
    www.pdf365.com
438
第1 9章开放源码：在Unix新社区中编程
19.1  Uni×和开放源码
    开源开发利用了这样的事实，甄别和修改bug的任务适合分解成多个并行的子任务
――这和实现某个特殊算法不一样。围绕某个原型设计进行邻域开发，也很适合并行处
理。所以，随着正确技术和社会机制的到位，通过网络松散连接的庞大开发团队可以把
工作做到出色得让你吃惊。
    是的，这会让你吃惊，如果还抱守那种把秘密开发和专有控制视为必然的话。从《人
月神话》[Brooks]直到Linux的兴起，软件工程的正统观念都是关于如何在重量级组织，
例如企业和政府中，构建小型而管理紧密的团队。而实践却是紧密管理的大型团队。
    在AT&T拆分以前的早期Unix社区的运作实际就是开源的典型例子。尽管拆分前
的Unix代码在技术上和法律上是专有的，但在用户和开发者社区中，却被视作共享的。
那些人们的自愿努力，受到解决问题强烈愿望的推动而自觉迸发出来。而在这些努力之
中，优秀者层出不穷。的确，开源开发的方法和技术在Unix社区作为一种无意识的群众
实践而发展，其实在1990后期被分析和标记之前，就已经持续了四分之～个世纪。（参
考《The Cathedral and the Bazaar<大教堂和集市）》[Raymond01]和《Understanding Open
Source Software Development（理解开源软件开发）》[Feller-Fitzgerald]）。
    回顾过去，令人惊讶的是我们对自己的行为意味着什么是多么茫然无知。有些人的
理解却很透彻；Richard Garbiel在文章“差即是好”中表达的思想是其中最著名的，在
Brooks【Brooks] （1975）也可以找到预示，甚至远到Vyssotsky和Corbato在Multics的设
计中的思考（1965）。在1990年代中期被Linux唤醒之前，多达20年的软件开发观察中，
我也没有意识到这～点。这样的经历应该让任何有见解而谦逊的人知道，是不是还有其
它什么重要的统一理念依旧暗含在我们的行为中，潜藏在我们集体的眼皮底下未被发掘，
不是因为复杂而是因为太简单。
    开源开发的规则很简单：
    1．源码公开。别隐藏秘密。公开代码以及产生代码的过程。鼓励第三方的同行复审。
确保其他人能够自由地修改和重新发布代码。尽可能地发展合作开发者。
www.pdf365.com
19.1  Unix和开放源码
439
    2．尽早发布，经常发布。快速的发布节奏意味着反馈迅速而有效。每次递进发布间
隔越小，回应真实世界反馈的修改过程就越容易。
    确保第一次的发布能够编译和运行，所有允诺的功能都可运作。通常，一个开源程
序的启动版本通过至少完成最终目标的某个部分来展示项目的前景，这充分表明发起人
确实可以继续这个项目。例如，字处理器的启动版本应该支持文本的输入以及文本在屏
幕上的显示。
    不能编译或是运行的第一次启动发布会毁掉整个项目（例如大家都知道，这差点就
在Mozilla浏览器身上发生）。不能编译的发布表明项目开发者不能够完成项目，同样地，
不能运行的程序也难以吸引其他开发者的参与，因为任何改动对程序是好是坏都不确定。
    3．给贡献以表扬。如果不能够给合作开发者以物质奖励，就给予精神表扬。即使可
以给予物质的奖励，也不要忘记人们往往是为展示才华而不是为钱努力工作。
    规则2的必然推论就是，单一发布不应该视为重大的事件，无需伴随太多的
  附带许诺和准备。将发布过程无情地精简非常重要，这样就不再为经常发布而感
  到痛苦。在发布准备期，其余工作都必须停止的安排是个可怕的错误（值得一提
  的是，如果使用CVS或者类似酌版本控制，处于准备期的发布应该同主干开发线
  分开，这样就不至于阻塞主线开发过程。）总的来说，不要把发布当作什么特别
  的大事；而应该当作是例行公事。
-Henry Spencer
    牢记：频繁发布的原因是为了缩短和加速同用户和开发者间的反馈循环。因此，精
工细作，等一切完美了才发布的想法是要不得的。不要许太多愿。一步一步地来，承认
和公布现有的bug，并有信心随着时间的推移，一定会达到完美。发布点多一点儿不是
坏事，不必为版本号的增加而烦恼。
    开源开发利用散布在互联网上，而且主要通过email和网络文档交流的大型程序员
团队。典型地，任何项目的多数贡献者都是为了提高软件对自身效用的回报以及声誉激
UN1×编程艺术
  www.pdf365.com
440
第1 9章开放源码：在Unix新社区中编程
励而自愿工作。一般由一个核心开发者或核心开发组来指导项目；其他贡献者可以零星
地加入或离去。为了鼓励志愿者，重要的是避免在他们和核心团队之间产生社会壁垒。
因此需要最小化核心团队的特权，努力模糊界限。
    开源项目遵循Unix传统尽可能自动化的建议。使用patch（l）工具分发递进更改。许
多项目（以及所有大型的）都拥有使用诸如CVS（回顾第15章的讨论）等版本控制系
统的网络访问代码库。Bug和补丁自动追踪系统的使用也很普遍。
    1997年，在黑客文化之外几乎没人能明白，这样管理大型项目并同样获得高质量的
开发结果是完全有可能的。在2003年，这已不再是新闻；诸如Linux、Apache和Mozilla
项目都已经获得了巨大的成功和非常高的公共上镜率。
    抛弃秘密开发的习惯，转而支持过程的透明化和同行复审是炼金术成为化学学科最
关键的一步。同样你也开始发现，开源开发标志着软件开发终于长成为一门学科。
19.2  与开源开发者协同工作的最佳实践
    开源社区最佳开发实践实际上便是对分布式开发自然而然的适应；在本章中可以了
解到许多行为准则，用来同其他开发者进行良好沟通。有些Unix绚定是偶然的（例如文
件的标准命名表达关于发布源的元信息），这常常可以上溯到1980年代早期的Usenet，
或者GNU项目的约定和标准。
19.2.1  良好的修补实践
    多数人在发布自己的项目之前，都是从修补他人的软件而开始接触开源软件开发的。
假定已经为某个基准源代码更改了一些代码，现在需要设身处地去想想，别人该怎样判
断是否可以采纳这个补丁呢？
    代码的质量很难判断，所以开发者往往通过提交的质量来评估补丁，在提交者的风
格和交流行为中寻找线索――该提交者是否设身处地为他们着想，是否知道评估和合并
新的补丁究竟该怎样。
    这是鉴定代码质量相当可靠的方法。在许多年处理来自数以百计陌生人补丁的过程
中，我很少看到一个考虑周全、尊重我的时间的补丁会是技术上的赝品。反过来看，经
www.pdf365.com
19.2与开源开发者协同工作的最佳实践
441
验告诉我们，看起来马马虎虎或是打包很疏懒的补丁往往实际上就是赝品。
    这里有一些怎样让补丁能够被接受的技巧：
19.2.1.1  发送补丁而不是完整档案包或文件
    如果改动包含了一个源代码中并不存在的新文件，当然就必须发送整个新文件。但
如果修改的只是已有文件，无须发送整个文件。只须发送diff就行：运行difi（1）命令，
将基准发布版本与修改版本进行比较，并提交输出。
    dif1）命令及其对偶命令patch（l），是开源开发最基本的工具。差异文件要比整个文件
好，因为自从获得旧拷贝之后，接受补丁的开发者可能已经更改了主干版本。呈送开发
者以一个diff文件，节省了别人将改动从其中分离出来的精力；也表示了对别人时间的
尊重。
19.2.1.2发送针对当前版本代码的补丁
    如果发送给维护者的补丁是针对好几个版本以前的，并期望维护者会判断补丁中哪
些改动已经完成，哪些是新颖独创，这样做既不能达到预期目标也有些粗鲁无礼。
    追踪源码状态以及把主线代码库需要做什么的最小化补丁提交给维护者，是补丁提
交者必须承担的责任。这也意味着应该发送针对当前版本的补丁。
19.2.1.3不要包含可生成文佯的补丁
    在发送补丁之前需通览一遍，对于一旦维护者采用补丁、重新make后就能重新生成
的文件，其补丁段应予删除。犯错的经典例子就是Bison或Flex产生的C文件。
    当今最常见的错误就是，发送的diff文件只包含有巨大的更改段来表明你的
configure脚本和维护者的差异。其实这个文件可以由autoconf产生。
    这是有欠考虑的。它把接收者置于麻烦之中，需要把补丁的真实内容从一大堆乌七
八糟的干扰里分离出来。当然它只是个次要的错误，同我们将要进一步探讨的内容相比，
并非那般严重――但也是不好的。
UNl×编l茬艺术
    www.pdf365.com
442
第1 9章开放源码：在Unix新社区中编程
19.2.1.4不要发送与只是优化RCS或者SCCS $-symbols的补丁段
    有些人喜欢在源码文件中放置一些特殊符号，在登入版本系统时会自动扩展：例如
RCS和CVS使用的$id$构造。
    如果使用自己本地的版本控制系统，更改可能会改变这些符号。这并非真正有害，
因为当接收者在采用补丁而登回代码时，特殊符号可以按照维护者版本控制系统的状态
设置重新扩展。但这些特殊的补丁段是干扰物，会让人分心。不发送它们更能体现考虑
的周全。
    这是另外一个次要的错误。如果别的大事没弄错，这是可以原谅的。但最好避免。
19.2.1.5使用-c或-u格式而不是缺省的（-e）格式
    difj（1）默认的（-e）格式非常脆弱。它不包含任何上下文，因此在得到用来修改的
拷贝之后，如果基准代码中插入或者删除了任何一行，patch工具无法得到正确结果。
    拿到-e格式的diff文件令人恼火，表明发送者如果不是位新手或马大哈，就是个菜
鸟。大多数这种补丁想都不用想便可抛弃掉。
19.2.1.6在补丁中包含文档
    这非常重要。如果补丁增加了用户可见的部分或者改变了软件的功能特征，请在补
丁中包含相应手册页和其宅文档文件。不要期望补丁接收者会乐于为此代码编写文档，
或是在代码中隐藏没有文档说明的功能特征。
    针对改动做好文档体现了一些好习惯。首先，已经为试图说服的维护者设身处地考
虑过了。其次，表明对改动后的效果了如指掌，可以向其余不能查看代码的人解释清楚。
第三，表示了对软件最终用户的关心。
    良好的文档常常是区分“可靠的贡献”和“匆忙而邋遢的改动”最显著的特征。如
果花费了足够的时间和心思来做好文档，最后就会发现让多数开发者接受补丁的道路已
经走完了85%。
www.pdf365.com
1 912与开源开发者协同工作的最佳实践
443
19.2.1.7在补丁中包含解释
    补丁应该包含一份说明，来解释为什么补丁是必须和有用的。这个说明并不直接给
软件用户而是给接受补丁的维护者。
    说明可以很短――实际上，我见过的一些最有效的说明仅仅是“请参看补丁中的文
档更新”。但必须表明正确的态度。
    正确的态度非常有帮助，是对维护者时间的尊重，也是从容而谦逊的自信。表现出
对所修补的代码充分理解，展示对维护者问题的认同，这些都是有益的。对于觉察到的
应用补丁风险预先说明同样大有裨益。下面是一些经验丰富的开发者所发送的各种解释
示例：
    “我已经发现代码中有两个问题，X和Y。我改掉了X，但是我并没有试图去解决
Y问题，因为我对牵涉到的代码还不理解。’’
    “修改了一个当输入过长时的coredump。我在修改的时候，试图寻找另外的溢出错
误。我发现有一个可能在blarg.c中，在第666行附近。你能确定在每个传输中发送端产
生的字节不会多于80?”
    “你是否已经考虑使用  Foonly  算法来解决这个问题？在
<ht tp：／/www．example．com/～j smith/f oonly．htm]>处有个好的实现。”
    “补丁解决了当前的问韪，但我意识到内存分配被不恰当地复杂化了。在我这里可
以工作，但在发布前你应该进行重负荷测试。”
    “这可能太过于花哨，但无论如何我还是提交了。也许你会知道一个实现这种功能
的更简洁的方法。”
19.2.1，8在代码中包含有用的注释
    在合并补丁之前维护者希望能够对更改有准确的理解确。当然，这并不是一成不变
的法则；如果确实同维护者存在很好的合作工作记录，他也许在半自动化地检查前就只
会随意地瞄上～眼。但是任何帮助维护者理解代码和降低不确定性的作为都会提高补丁
被接受的几率。
    代码中良好的注释可以帮助维护者理解代码。糟糕的则不然。
    以下是个糟糕的注释例子：
／★norman newbie fixed this 13 Aug 2001  ★／
UNIX编程艺-荩
  www.pdf365.com
第1 9章开放源码：在Unix新社区中编程
    这没有任何用处。只是在维护者的代码中间，无端地加入了践踏领土的泥泞靴印。
如果维护者接受了补丁（不太可能），他几乎肯定会抛弃这段注释。如果希望获得声望，
应该在工程的News或History文件中包含一个补丁段。这样维护者更可能接受。
    以下是良好的注释例子：
/*
  k This conditional naeds tObe guarded so七hat crunch_data（） never
  * gets passed a NULL pointer  <norman_newbie@foosite.com>
    这样的注释表明，不仅理解了维护者的代码，也理解了维护者对接受你的改动所需
要的信心。这种注释正好给予维护者对于更改的信心。
19.2.1.9如果补丁被拒绝，别往心里去
    存在许多理由，一个补丁可能会遭到拒绝，这并不存在怀疑和责备的意思。记住多
数软件维护者都处于相当沉重的时间压力之下，并很保守地接受补丁，生怕一不小心项
目代码就会崩溃。有时候重新提交改进后的补丁会有所帮助，有时候不会。大家都不容
易。
19.2.2  良好的项目、档案文件命名实践
    随着诸如ibiblio、SourceForge以及CPAN维扩者工作量的增加，一个不断发展的趋
势就是，项目提交部分或整体会由程序来处理（而不是完全由人来处理）。
    对于项目和档案文件的命名而言，更重要的是需要采用更适合计算机程序可以解析
和理解的规则模式。
19.2.2.1  使用GNU风格的命名法：主干加major.minor.patch的编
    三j
    !了．
    如果档案文件都是类似GNU风格的名称，主干前缀全小写且只包含字母和数字，后
接连字号，后再接版本号、扩展和其它后缀，对大家都有帮助。
具备这些部分的名称，其良好的通用形式顺序如下：
1．项目前缀
2．横杠
www.pdf365.com
19.2  与开源开发者协同工作的最佳实践
445
    3．版本号
    4．点
    5．“src”或”bin”（可选）
    6．点号或横线（更倾向点号）
    7．二进制类型和选项（町选）
    8．归档和压缩扩展名
    这种风格的名称主干可以包含连字号或下划线来分隔音节；横线实际上更常用些。
把相关的项目联合成组，给予一个通用的主干名前缀，并以连字符结束，也是个良好的
实践。
    假设正好有个叫做“foobar”的项目，主版本号为1，次版本号或发布号为2，补丁
级别为3。如果只有一个档案部分（假定为源代码），则文件名称看起来应该像这样：
foobar-1.2.3．tar．gz
源文件档案。
foobar．lsm
    LSM文件（假定提交到ibiblio）
    不要使用如下这样的命名方式：
    foobar123．tar．gz
    这让许多程序看起来像一个叫做“foobar123’’没有版本号的项目档案。
    foobarl.2.3．tar．gz
    这对许多程序而言像是“foobarl”项目版本2.3的档案。
    foobar-vl.2.3．tar．gz
    许多程序误认为这是称作“foobar-vl’’的项目。
    foo_bar-l.2.3．tar．gz
    下划线给人们带来发音、打字和记忆的困难。
    FOOBar-1.2.3。tar．gz
    除非喜欢看起来像出售的熏肠，否则不要这样。这也给人们带来发音、打字和记忆
的困难。
UNIX编程艺术
  www.pdf365.com
第1 9章开放源码：在Unix新社区中编程
    如果必须区分源码和二进制档案，或是区分不同的二进制码，或是表达某种文件名
的编译选项，请紧接在版本号之后加上文件扩展名。也就是，像这样做：
foobar-1.2 . 3 . src .tar _gz
源码。
foobar-1 2 _ 3 bin _ tar _ gz
二进制，类型没有指定。
foobar-l. 2 . 3 .bin. i386 _ tar. gz
f386二进制。
    foobar-l.2.3.bin. i386. static. tar. gz
    i386静态链接二进制。
    foobar-l.2.3.bin.SPARC.tar.gz
    SPARC二进制。
    请不要使用像“foobar-i386-1.2.3.tar.gz”之类的名字，因为程序难以从名字主干中识
别出类型的插入词（如“-i386”）。
    区分主要和次要发布的约定很简单：补丁号为修正错误和次要功能：次版本号为兼
容的新功能，而主版本号为不兼容的更改。
19.2.2.2尊重适当的本地约定
    有些项目和社区，对于命名和版本号有良好的约定，并不需要遵从以上的建议。例
如，Apache模块就像mod_foo -样命名，并配有自身的版本号以及协同工作的Apache
版本。同样地，Perl棋块的版本号可以像浮点数～样命名（例如，可能会发现1.303而不
是1.3.3的版本号），Foo::Bar模块的1.303发行版通常命名为Foo-Bar-I.303.tar.gz。（另
一方面，Perl自身，在1 999下半年转换回使用19.2.2.1中描述的约定。）
    查询和尊重特殊社区和开发者的约定；而对于一般的使用，遵守如上19.2.2.1中的
指导。
www.pdf365.com
19.2与开源开发者协同工作的最佳实践
447
19.2.2.3努力选择唯一且容易键入的名称前缀
    主干前缀应该适用于整个项目文件，并且应该容易读写和记忆。所以，不要使用下
划线。没有极特殊的理由，也不要大写或双大写――这会弄乱人眼自然的浏览顺序，并
且看起来像自作聪明的销售小花招。
    如果两个不同的项目存在相同的主干名称会让人们感到迷惑。因此在第一次发布前
就尝试检查是古存在冲突。两个地方可以完成此项检查任务，一个是ibiblio
<http：／/metalab．unc．edu/pub/Linux>的索引文件，  一个是Freshmeat
<http：／/www．freshmeat．net>的应用程序索引。另一个检查的好地方是
SourceForge<h七tp：／/www．sourceforge．net>;做  1个名称搜索。
19.2.3  良好的开发实践
    这里有些作法，可以让项目有别于不起眼而易于湮没的项目，能吸引众多奉献者，
从而成为成功项目。
19.2.3.1  不要依赖专有代码
    不要依赖专有语言、函数库或者其它代码。即使在最有利的情况下这样做都充满风
险；而在开源社区中，这是彻头彻尾的无礼行为。开源开发者不相信他们无法评审酌源
码。
19.2.3.2  使用GNU自动工具
    配置选择应该留到编译期。开源发布的一个巨大优势就是允许软件包适应编译期发
现的环境。这至关重要，因为这可以让软件包运行在连开发者都从未预见的平台上，并
且允许软件社区的用户定制自己的移植。只有最大规模的开发组才买得起所有硬件，以
及雇用足够的员工来支持种类有限的平台。
    因此：使用GNU自动化工具来处理移植性问题，进行系统配置探测，以及量身定制
makefile文件。今天，人们在编译源码时期望能够键入configure; make; make
install就可以得到一个简洁的编译――并且是正确的。关于这些工具的优秀指南可见
<http://seul.org/docs/autotut/>.
    autoconf和autoheader都是成熟的软件。automake如前所述，在2003年年中仍然
脆弱，到处是bug；可能必须维护自己的Makefile．in。幸运的是，它是自动化工具中
重要性最小的一个。
UNl×编程艺．术
    www.pdf365.com
448
第19章开放源码：在Unix．新社区中编程
    无论使用何种配置方法，编译时软件不应向用户咨询系统的信息。安装软件包的用
户并不一定知道问题的答案，这种方法从一开始就注定是失败的。在编译或安装时软件
必须能够自己决定所需的全部信息。
    但是autoconf不应该认为是对一团乱麻式设计的许可。如果可能，编程应遵循POSIX
标准以及尽可能少地向系统询问配置信息。应尽量保持最少的“ifdef" -或者，最好
根本不要有。
19.2.3.3先测试再发布代码
    良好的测试套件使得团队在发布前能够非常容易地执行回归测试。建立强大而便于
使用的测试框架，以便逐步把测试增加到软件之中，测试套件就不那么专用和错综复杂，
开发者也就无需培训了。
    测试套件的发布也使得，社区用户可以在将贡献发转回制作组之前能够测试他们的
代码片段。
    鼓励开发者在他们的桌面和测试机上使用迥异的平台，这样在日常开发中，代码的
移植性就可以不断得到检验。
    代码随着自己使用的测试套件一起发布，并且测试套件可以由make test来运行，
这是非常好的实践，并且可以增强对自己代码的信心。
19_2.3.4发布前对代码进行健全检查
    “健全检查（sanity check）”的意恩是：
类易犯的错误。使用工具捕捉到的错误越多，
使用可以获得的每一款工具来检查每个人
用户和自己需要对付的就越少。
    如果正用GCC编写C/C++，带-Wall选项测试编译，并且在每个发布之前清除掉所
有的警告信息。使用能够找到的每一款编译器编译代码――不同的编译器常常会发现不
同的问题。特别地，在一个真正的64位机器上编译软件。底层的数据类型在64位机器
上可能有所改变，所以常常会发现新的问题。寻找商业Unix系统并且对软件运行lirlt程
序以进行检查。
    使用查找内存泄漏和运行期错误的软件；Electric Fence和Valgrind就是其中两款可
以开源获得的优秀软件。
    对于  Python珂{目，  PyChecker  <http：／／sourceforge．net／projects／
pychecker>是个很有用的检查工具。它常常能捕捉到许多不平凡的错误。
    如果编写Perl程序，可使用perl -c（或是-T，如果可用的话）检查代码。并虔诚
地使用perl -w以激活警告以及“use strict”来限制不安全的结构和语句。  （进一步的讨
论参考Perl文档。）
www.pdf365.com
19.2  与开源开发者协同工作的最佳实践    449
 19.2.3.5发布前对文档和README进行拼写检查
    对软件的文档、README文件和软件中的错误信息进行拼写检查。马虎的代码，编
译时产生警告信息的代码以及README文件或报错信息里的拼写错误，都会让用户认
为软件加工草率、不负责任。
19.2.3.6推荐的C／C++移植性实践
    如果编写C程序，应完全使用ANSI功能特征。特别应使用函数原型，可以帮助发
现跨模块冲突。1日式风格的K&R编译器早就成为历史了。
    不要用编译器的专门特征，例如GCC的-pipe选项或支持嵌套函数的功能。这会导
致其他人在移植到非Linux、非GCC系统时遇到麻烦。
    需要移植的代码应被隔离在一个单独区域的一组源文件（例如，一个Os子目录）中。
涉及不I司编译器、库以及操作系统接口的移植码应该抽象到该目录的文件中。
    移植层是一个库（或者可能仅仅就是头文件中的一套宏），抽象了程序使用到的某
个操作系统的一些API。移植层使软件更容易被移植到新的平台。开发团队中往往没人
了解移植的目标平台（例如，存在成百上千种不同的嵌入式操作系统，没有人知道它们
之间的重要冲突）。通过创造一个分离的移植层，了觯平台的专家就有可能无需理解任
何移植层之外的事情而进行软件移植。
    移植层也简化了应用程序。软件很少需要全功能的、更为复杂的系统调用，例如
mmap（2）和stat（2），并且配置如此复杂的接口也往往让程序员错漏百出。一个具备抽象接
口的移植层（例如，某个叫做一file_exists的stat（2）调用替代物）使你可以从系统
导入有限的、必需的功能，从而简化了应用程序中的代码。
    基于所需功能而不是平台来编写移植层。尝试为每个支持的平台创建单独的移植层
会导致多重更新的维护梦魇。一个“平台”至少总是基于两方面来选择：编译器和库／操
作系统发布版本。在某些情况下，应该是三方面，就像当Linux商家选择一个独立于操
作系统发布版本的C语言库的时候。M个商家、N个编译器以及O个操作系统发布版本，
平台的数目很快就增大到任何最大开发团队都力所不及的地步。另一方面，通过利用语
UNIX编程艺．术
  www.pdf365.com
450
第1 9章开放源码：在Unix新社区中编程
言和系统标准，例如ANSI和POSIX 1003.1，功能特征集总是相对有限的。
    移植性的选择既可以基于代码行数也可以基于编译文件。在同一个平台上，真正的
实现是选择备选代码中的某几行，或是几个不同的文件中的某一个并没有本质区别。经
验原则是，当实现存在重大不同时（例如在Unix和Windows中的共享内存映射），应
把为不同平台的移植代码分离到不同的文件中，而当区别比较微小时（例如，是使用
gettimeofday. clock_gettime、f七ime还是time来获取当前时间），将移植代
码放在单一文件中。
    在移植层之外的任何地方，注意这条建议：
    #ifdef和#if是最后一招，这通常是思路不当、产品过度差异化，无理由
    “优化”或是无用垃圾聚集的先兆。在代码中，它们就是诅咒。GNU的
    /usr/include/   stdio．h就是典型的悲剧。
    ~Doug McIlroy
    在移植层#ifdef和#if的使用是允许的（如果控制得当）。在此之外，应该尽量
限制使用，只用于有条件地触发#include。
    决不要占用系统其它部分的命名空间，包括文件名、错误返回值以及函数名。若育
共享命名空间的地方，应做好文档说明。
    选择一个编码规范。有关规范选择的争论会永无休止地进行下去――但无论如何，
在编写软件过程中支持多重编码规范是太困难太昂贵了，难以达到，所以必须选择某个
通用的规范。严格地坚持编码规范，代码的一致和干净优先级最高；而编码规范自身的
细节倒远在其次。
19.2.4  良好的发行制作实践
    这些指导描述了软件的发行应该如何去做，以供他人更好地下载、获取以及解包。
19.2.4.1  确保打包文件总是解包到单一的新目录下
    初出茅庐的奉献者最要避免的错误就是编制的打包文件，在解包时往往将发行版本
中的文件和目录解包到当前目录中，这很可能会覆盖已经存在的文件。决不要这样做。
www.pdf365.com
19.2与开源开发者协同工作的最佳实践
451
    相反地，应确保所有的档案文件都有一个共同的、以项目名命名的目录部分，如此
一来它们可以解包到一个直接位于当前目录下的顶级目录。为了方便，该目录名应该同
tarball的主干名相同。这样，例如，一个叫做foo-0. 23．tar.gz的文件包，希望能够
解压到一个叫做foo-0. 23的予目录中。
    例19.1展示了一个makefile技巧，假设发行的目录名为“foobar"，而SRC包含一
系列发布文件，可以这样来完成：
例19.1  tar文件包制作过程
foobar-$ {VERS） .targz :
 @ls  $ （SRC）   I  sed  s : ^ : foobar-$ {VERS） / :  >MANIFEST
 @ （cd  . . ;  In -s  foobar  foobar-$ （VERS》
 {cd  . . ;  七ar -czvf foobar/foobar-$（VERS） tar.gz  'cat  foobar/MANIFEST'
 @ （cd  . _ ;  rm foobar-$ （VERS》
19.2.4.2包含README文件
    在源码发行版本中包含一个路标文件README。按照古老的习俗（从1980年以前
发端于Dinnis Ritchie本人，而80年伐早期在Usenet上传播开来），这是勇敢的开拓者
在解包源码之后阅读的第一个文件。
    README文件应该短小精简容易阅读。确保只是一份介绍，而不是长篇累牍。在
README文件中应该包括如下的良好内容：
    1．项目的简短描述。
2．指向项目站点的链接（如果存在）。
3．开发者编译环境的注意事项以及潜在的移植性问题。
4．描述重要文件和子目录的路标。
5．编译及安装的指令或者指向同样内容的文件（通常是INSTALL文件）。
6．维护者光荣榜列表或者指向同样内容的文件（通常是CREDITS文件）。
7．项目的最近新闻或者指向同样内容的文件（通常是NEWS文件）。
8．项目邮件列表地址
UNIX编程艺．术
  www.pdf365.com
452
第1 9章开放源码：在Unix新社区中编程
    曾经有段时问，该文件通常命名为READ .ME，然而这与浏览器存在严重的不兼容问
    题，所有的浏览器往往都假定.ME后缀表示该文件并非文本，只能下载而不能浏览。这
    种做法已被废除。
    19.2.4.3尊重和遵从标准文件命名实践
    甚至在阅读README文件之前，勇敢的开拓者可能已经快速浏览了软件解包后顶级
    目录中的文件名。这些文件名本身也承载了信息。坚持一定标准的命名习惯，可以让开
    拓者得到有价值的线索，以得知接下来该浏览什么样的文件。
    这里是些标准的顶级文件名及其含义。当然，并不是每个发行版本都需要所有文件。
    README
    最先被阅读的路标文件。
    INSTALL
    配置、编译和安装指导。
    AUTHORS
    项目贡献者列表（GNU惯例）。
    NEWS
    最近的项目新闻。
    HISTORY
    项目历史。
    CHANGES
    修订版本之间重大更改的日志。
    COPYING
    项目许可证条款（GNU惯例）。
    LICENSE
    项目许可证条款。
    FAQ
    项目常见问题解答的纯文本文档。
    注意整体上的习惯，文件名一律大写表明是关于软件包的供人阅读的元信息，而不
    是关于编译构件的。README文件源自早期自由软件基金的开发经验。
UNIX缟程艺术
    www.pdf365.com
19.2与开源开发者协同工作的最佳实践
453
    拥有FAQ文件可以让你省很多力气。当关于项目的某个问题经常出现时，就加到
FAQ文件中；然后引导用户在发送问题或者错误报告之前首先阅读FAQ文件。一个发
展良好的FAQ可以减少项目维护者一个数量级的负担，甚至更多。
    为每个发布编写一份标有时间戳的HISTORY或NEWS文件是非常有价值的。别的不
说，这可以帮助确定在专利侵犯诉讼案中的先前证明（虽然还未在任何人身上发生，但
最好先预备着）。
19.2.4.4为可升级性设计
    随着新版本的不断发布，软件也不断变化着。有些更改无法向后兼容。相应地，设
计软件的安装布局时，应认真考虑，以确保多个软件版本能在同一系统中共存。对于库
来说这尤其重要――不能强求所有的客户端程序都同API的更改保持同步的升级速度。
    Emacs、Python以及Qt项目对此有个良好的实践：以版本号来命名目录（另一项被
FSF作为惯例的实践）。Qt库安装后的层次类似这样（$（ver）是版本号）：
# Where you find moc
# Where you find .so
 # Where you find header files
    正是由于这种组织，多重版本才可共存。客户端程摩必须指定其需要的版本，当然，
需要付出点小的开销，不要弄乱相关接口。这个良好实践避免了象Windows臭名昭著的
“DLL地狱’’的失败模式。
19.2.4.5  在Linux  提供RPM
    在Linux下可安装二进制软件包的事实标准格式是Red Hat Package Manager，即
RPM。在多数流行的Linux发行中均得到支持，其它所有的Linux的发行版本实际也有
支持（除了Debian和Slackware；Debian可以从RPM安装软件）。相应地，在项目站点
同时提供可安装的RPM和源码包是个绝佳的主意。
    在源码包文件中包含RPM的spec文件，并设置～个选项可以从makefile生成
RPM，这也是个好主意。spec文件应该具备．spec扩展名；这样才能让rmp一t选项在
压缩包中找到它。
UNIX编l程艺-术
    www.pdf365.com
                           r0
                -rl  -r-l  n
    r  S-l  r  r
    V      r-     r  V
            \-J，L rt rt
          IIII
七  LJ  JJ  _U  U
U q U  q  q
rl  -H  rl  .+  r+
r+  r-l  -l  r+  -l
r  1-1  r  u  s-l
rn  S  S   rn   cn
:j  :j  :j  o  U
454
第1 9章开放源码：在Unix新社区中编程
    额外的风格要点，编写可以自动生成spec文件的shell脚本，自动分析项目的
makef ile或version．h文件而插入正确的版本号。
    注意：如果应用源码RPM，应使用BuildRoot让程序在/tmp或/var／tmp下编译。
如果不这样，在运行make install的过程中，安装过程将会把文件安装到最终的位置。即
使文件有冲突或是并未想要实际安装时，这个过程也会发生。在完成以后，文件已经安
装而系统的RPM数据库却毫不知晓。此类糟糕的SRPM行为，是个雷区，应该远离。
19.2.4.6提供校验和
    提供二进制文件的校验和（压缩包、RPM等等）。这将允许人们验证文件是否损坏
或是否被木马程序侵入。
    尽管有好几个命令来干这个（例如sum以及cksum），但最好还是使用一个密码安
全的哈希函数。GPG软件包的-detach-sign选项提供这种能力：也可以使用GNU命令
md5 sum。
    对于发布的每个二进制文件，项目网页应该列出校验和及其生成命令。
19.2.5  良好的交流实践
    软件和文档，如果除自己之外无人知晓它们的存在，那将毫无益处。要是将项目放
到互联网上，则可以蒂助招揽用户和合作开发者。这里是一些标准的做法。
19.2.5.1  在Freshmeat上发布通告
    可以在Freshmeat<ht tp：／/www．freshmeat．net>上发布通告。这个组织的读者
群众多，也是网络技术新闻的主要提供者。
    不要设想用户从头一直阅读自己的通告。所以在通告中应该一直保留至少一句关于
软件目的的说明。糟糕的说法像这样：“宣告FooEditor最新的发布版，现在速度快了十
倍。”优秀的例子是：“宣告最新的FooEditor发布版，为盲打者设计的文本编辑器，现
在速度快了十倍。”
www.pdf365.com
19.2  与开源开发者协同工作的最佳实践
455
19.2.5.2在相关的主题新闻组上发布通告
    找到～个直接与应用程序相关的Usenet主题组，然后在那儿发布通告。但应该克制，
只在与代码实现功能相关的地方张贴。
    如果（例如）正发布使用Perl语言编写的IMAP服务器查询程序，就一定应该张贴
到cornp．mail．imap。而不应该张贴到comp．lang．perl上，除非程序也同样是Perl
前沿技术的启发实例。
    通告应包含项目网站的URL。
19.2.5.3建立一个网站
    如果试图围绕项目建立坚实的用户和开发者社区，那应该拥有一个项目网站。网站
上需要包含如下一些标准的东西：
●  项目说明（项目存在的理由、项目受众等等）。
●  项目源码的下载链接。
●  如何加入项目邮件列表的指导。
●  常见问题回答列表（FAQ）。
●  项目文档的HTML版本。
●  相关或竞争项目的链接。
优秀项目网站的实例请参考第16章。
    建立网站的一个简单方法就是将项目放到那种专门提供免费主机服务的站点上。在
2003年年中，晟重要的两个站点是SourceForge（这是专有合作工具的展示和测试站点）
以及Savannah（作为一种意识形态的声明，它存放了很多开源顼目）。
19.2.5.4提供项目邮件列表
    私有的开发用途的邮件列表可以让项目合作者以此交流和交换补_J’，这是个标准的
惯例。一些人希望能尽早得到项目进展信息，你应该为他们准备一个通告列表。
    如果正在管理一个名为“foo"的项目，开发者列表应该是foo-dev或
foo- friends;通告列表应该是foo -announce。
    ～个非常重要的决策是“私有”开发列表到底应该有多私有。在设计讨论中更广泛的
参与常常是件好事，但是如果列表相对开放，迟早就会有些用户在其上询问一些初级问
UNIX编茬艺术
  www.pdf365.com
456
第1 9章开放源码：在Unix新社区中编程
题。如何最好地解决这个问题的答案各种各样。仅有文档告知新用户不要在开发列表中
询问初级问题不是个办法；必须以某种方式加以强调。
    通告列表应严格控制。通信量最多一月几条；这个列表的整体目标是，向希望知道
某些重要事情何时发生的人们提供信息，但并不需要知道日常繁冗的细节。如果这个列
表在他们的邮箱中开始带来严重的混乱，许多人会立刻取消订阅。
19.2.5.5发布到主要的档案站点
    关于主要开源存档站点的详细说明参考第16章“何处找”部分。应该将软件包发布
到这些站点上。
    其它重要的站点包括：
O    The Python  Software Activity  <http : / /www . py七hon . org> site （for software
     written in Python）.
O    The CPAN <h七tp : //www . language .perl . com/CPAN>， the Comprehensive
     Perl Archive Network （for software written in Perl）.
o     The Python Software Activity<http : //www _ py七hon . org>  （ Python裎序）   。
O    The CPAN <ht七p : //www. language .perl . com/CPAN>， the Comprehensive
     Perl Archive Network  （ Perl程序）  。
19.3许可证的逻辑：如何挑选
    许可证条款的选择涉及这样的决定，软件作者是否希望对人们怎样处理软件施加某
些限制。
    如果根本就不想做任何限制，应该把软件放到公共域里去。在每个文件头都包含如
下的文本是很恰当的做法：
Placed in public domain by J. Ramdom Hacker， 2003. Share and enjoy!
    这样做就等于放弃了版权。任何人都可以对代码的任何地方做任意改动。再也没有
比这更自由的了。
    但是很少有开源软件是真正像这样发布在公共域的。一些开源开发者希望能够使用
他们对代码的所有权来确保代码可以保持开放的状态（这往往采取GPL）。而另外～些
仅仅期望控制代码的合法公开；所有开源许可证共通的一点就是对软件不作任何担保。
www.pdf365.com
19.5各种开源许可证
457
19.4为什么应使用某个标准许可证
    同开放源码定义保持一致并广泛为人所知的许可证，已经具备长期建立的传统默认
解释。开发者（以及他们关心的用户）知道这些许可证究竟意味着什么，并且理性地承
担所涉及的风险和折衷。因此，如果可能，应使用oSI站点所载的许可证之一。
    如果必须编写自己的许可证，请确保得到OSI的认证。这可以避免许多的争论和额
外开销。除非曾经亲身经历过，不然你无法想象Usenet上许可证谴责战的激烈程度；许
可证被认为是涉及开源社区核心价值近似神圣的盟约，人们的情绪都变得非常激动。
    更进一步，如果许可证在法庭上当作证词，已经确立的传统解释的存在或许就非常
重要。到本书写作时（2003年年中）还没有案例支持或反对任何开源许可证。然而，法
律原则是（至少是在美国，并且或许其它存在习惯法的国家，例如英国和其余的英联邦
国家），法庭应按照产生许可证和契约的社区所能预料的行为和实践来解读许可证和契
约。这样，就有充分的理由相信，当最后不得不由法庭系统来处理的时候，开源社区的
实践将有决定意义。
19.5各种开源许可证
19.5.1  MIT或者×Consortium许可证
    最宽松的自由软件讦可证是这样的，授予无限权利的拷贝、使用、修改和对修改拷
贝的再发行，只要在所有修改的版本中保留版权和许可证条款。接受这种许可证就意味
着放弃控告维护者的权利。
    可  以  在  OSI  站  点  <hL Lp：／/www．opensource．org／licenses／mit
-license．htrnl>找到标准X Consortium许可证的模板。
19.5.2  经典BSD许可证
    比上面稍严一点的许可证，授予无限权利的拷贝、使用、修改，以及对修改拷贝的
再发行，只要在所有修改的版本中保留版权和许可证条款，并且在广告和软件包相关的
文档中包含致谢。受让者也必须放弃控告维护者的权利。
UNIX编程艺_术
  www.pdf365.com
458
第1 9章开放源码：在Unix新社区中编程
    最初的BSD许可证是这类许可证最著名的。在血统上可以追溯回BSD Unix的自由
软件文化中，这个许可证甚至使用在离伯克利数千英里之外的地方编写的自由软件上。
    BSD许可证的次要变种更改了版权所有人和删除了对广告的要求（实际上等价于
MIT许可证），也并非不常见。注意在1999年年中，加州大学技术转让办公室（Office of
Technology Transfer of the University of California）废除了BSD许可证中的广告条款。所以
BSD软件中的许可证的限制已经更宽松了。如果选择BSD方式，我们强烈推荐使用新式
（没有广告条款的）而非1日式许可证。广告条款被废除了，因为这导致了确定授权广告
构成时，在法律和过程上的极端复杂性。
    可以召E OSI站点<http：／/www．opens ource．org/licenses/bsd  -license．html>
找到BSD许可证的模板。
19.5.3 Artistic许可证
    下一个稍严点的许可证授予无限的拷贝、使用和本地修改的权利。允许再发行修改
后的=I进制版本，但是限制修改源码的再发行以保护作者和自由轶件社区的利益。
    Artistic许可证为Perl而设计，广泛使用在Perl开发者社区，它就是此类许可证。它
要求被修改的文件包含“显著声明”，表示已经被修改过。也要求发布更改者让更改可
以自由获取，并努力将其传播回自由软件社区。
    可以在  OSI  站点<http：／／WWW，opensource．org／licenses／artistic
-license．html>找到Artistic许可证的拷贝。
19.5.4通用公共许可证
    GNU通用公共许可证（及其派生，Library或“Less”GPL）是最广泛使用的单一自
由软件许可证。如同Artistic许可证～样，若修改后的文件带有“显著声明（ prominent
notice）’’则允许修改源码再发布。
    GPL要求，如果程序包含了任何处于GPL涵盖下的部分，则整个程序都处于GPL
涵盖之下。  （触发这项要求的确切情况并不会让每个人都能清晰理解）。
    实际上这些特殊的要求使得GPL比其它常用的许可证都要严格。（在针对同样的目
标问题时，Larry Wall编写的Artistic许可证回避了这个问题。）
www.pdf365.com
19.5各种开源许可证
459
    可以在FSF的copyleft站点<ht tp：／/www．gnu．org/copyleft．html>找到指向
GPL的链接以及如何应用的指导。
19.5.5  Mozilla公共许可证
    Mozilla公共许可证支持开源软件，但是可以链接闭源的模块和扩展。它要求发行的
软件（被涵盖代码，Covered Code）仍然保持开源，但附加软件，如果通过良好定义的API
来调用，允许保持闭源。
    可以在  OSI  站点<http：／／www，opensource．org／licenses／MPL-I. 1.
html>找到MPL许可证的模板。
UNIX编腥艺-术
  www.pdf365.com
www.pdf365.com
函
  来：  【机与机遇
Futures:
Dangers and Opportunities
The best way to predict thefuture is to invent以，
    预测未来最好的方法就是去创造未来。
    /97/年XEROX PARC会议上的发言
    -Alan Kay
    历史远未结束。Unix将继续成长变化。围绕Unix的社区和传统也将继续演进。试
图预见未来有些投机，但我们也许可以从两个方面预测：首先，看看Unix是如何应对过
去的设计挑战的：其次，确定需要解决的问题和有待开拓的机会。
20.1  Uni×传统中的平质和偶然
    为了理解Unix的设计在未来会如何变革，我们可以先看看Unix编程风格在过去的
日子里是如何随时间而变化的。这种努力将我们直接引领到理解Unix风格的一个挑战面
前――区分平质属性和偶然属性。也就是说，分辨出哪些特征是从暂时的技术中发展而
来的，而哪些又是紧密联系于核心的Unix设计挑战――如何正确地模块化和抽象化的同
时而保持系统的透明和简洁的。
    这种区分可能是困难的，因为那些偶然发展而来的特征有时会变成平质功用。作为
UNIX编程艺术
  www.pdf365.com
462
第20章未来：危机与机遇
实例，考虑我们在第1 1章讨论过的“沉默是金”的Unix接口设计原则；该原则最初是
为了适应缓慢的电传打字机，但因为输出简明扼要的程序更容易跟脚本组合而流传至今。
今天，在大多数程序都通过GUI可视运行的普遍环境下，又有了第三个用处：寡言的程
序不会分散或浪费用户的注意力。
    另一方面，一些曾经是Unix本质的特征由于特定成本比例的变化而成为了偶然属
性。例如，旧学派Unix偏爱的程序设计．（以及像awk （1）的微型语言），逐行处理输
入流或者逐条记录地处理二进制文件，并需要在块与块之间维护上下文，由精心制作的
状态机代码实现。另一方面，新学派Unix的设计就幸福多了，可以假定程序把全部输入
读进内存而可以在需要时随机访问。实际上，现代各种Unix提供mmap （2）操作允许
程序员将整个文件映射到虚拟内存中，而J/O序列化操作的读盘写盘操作则完全被隐藏
了。
    这种变革以存储操作的经济性换取更简单透明的代码。这是出于内存成本比程序员
时间廉价的调整。1970-1980年代旧学派Unix设计同1990年后新学派Unix设计之间
的许多差别都可以回溯到相对成本的巨大转变上，今天，所有的机器赘源相对于程序员
时间来说，比起1969年要廉价好几个数量级。
    回顾过去，我们可以甄别出三个特殊的技术变化驱动了Unix设计风格中的重大变
革：网络互联、位图图形显示以及个人计算机。在每场革新中，Unix传统都通过抛弃不
再合适的偶然属性、寻找新方法来适应新技术的核心观念，从而成功战胜了挑战。生物
进化也以同样的方式。进化生物学家有个法则：  “不要以为历史起源确定了当前效用，
反之亦然”。概要地看看Unix是如何适应这些变化的，或许会提供一些线索，让我们认
识到Unix将如何适应未来我们预测不到的技术变迁。
    第2章描述了第一个变化：互联网的兴起，并从历史文化的角度，讲述了在1980年
后TCP，IP如何将最初的Unix和ARPANET文化融合为一体。在第7章，有关诸如System
V STREAMS之类的过时IPC和网络互连方法的材料，表明在接下来的十年里，许多错
误的开始、失足以及死胡同迷惑了Unix开发者。关于协议、关于不同机器间的网络互连
与同一机器上不同进程的通讯之间到底是什么样的关系，那时有太多混乱。t
1有好几年似乎ISO的七层互联网标准可能战胜TCP/IPo ISO标准由欧洲标准委员会提出，他们在政
治上言怕采用任何诞生自五角大楼的技术。唉，意气用事盖过了技术的敏锐。结果证明是过度复杂
和十分无用的，请细节有关参考[Padlipsky]。
UNIX编鹱；艺术
    www.pdf365.com
20.1  Unix传统中的平质和偶然
463
    最后当TCP/IP胜出以及BSD套接字重申Unix本质上～切都是字节流的隐喻时，迷
惑便～扫而空。IPC和网络互联都普遍使用BSD套接字，而两者的老方法大部分弃而不
用，同时，通信双方是否位于同一主机对Unix软件来说也就更无关紧要了。1990～1991
年间万维网的发明便是合乎逻辑的结果。
    1984年，TCPfIP出现的几年之后，位图图形以及Macintosh机登场时，带来了～个
更加困难的挑战。最初来自Xerox PARC和苹果公司的GUI非常漂亮，但是系统的太多
层次都捆绑在一起，让Unix程序员对这种设计感到很不舒服。Unix程序员当下的反应
就是让分离机制与策略成为一个明确准则；到1988年，X窗口系统将其确立下来。通
过将X窗口构件与完成底层图形操作的显示管理器分离，他们创造了一种架构，按Unix
的标准是模块化的、清晰的，并且随着时间，可以很容易在此基础上发展出更好的策略
来。
    但那只是问题较为容易的部分。困难部分在于决定Unix是否应该拥有统一的界面策
略；而如果是，又是什么。通过专有工具包（例如Motif）来建立统一界面策略的几个不
同努力已经宣告失败。知今，在2003年里，GTK和Qt彼此争当这个角色。而在2003
年这个问题的争论也还没有结束，我们在第II章讨论过的各种UI风格同时并存的持续
状态似乎很明显。新学派Unix设计保留命令行方式，并通过编写许多在两种风格都可以
使用的CLI引擎+GUI界面组合，来解决GUI和CLI方式之间的冲突。
    个人计算机作为技术本身并没有带来什么主要的设计挑战。386以及后来的芯片，
性能足够强大，所以围绕其设计的系统在成本比例上同Unix非常成熟的小型机、工作站
和服务器相似。真正的挑战是Unix潜在市场的变化：硬件价格的全面走低，让个人计算
机吸引了更广泛的、不太懂技术的用户群。
    专有Unix软件商习惯了把更强大系统卖给高深技术买家的丰厚利润，从未对这个实
际上更广泛的市场表示出兴趣。理所当然，朝终端用户桌面系统努力的第一次重大启动
产生于开源社区，并由于本质的意识形态原因而不断增加。到了2003年年中，市场调查
显示Linux已经占到大约40-/0～5%的份额，接近了苹果分司的Macintosh。
    无论Linux是否会充分地做得更好，Unix社区反应的本质已经很清楚。我们在第
三章Linux的分析中检视了这一点。这包捂采取一些取自别处的新技术（例如XML），
并且付出了许多努力将GUI移植到Unix世界。但是在主题GUI和安装包之下，主要
www.pdf365.com
第20章未来：危机与机遇
的重心依然是模块化和清晰的代码一一为严肃、高度可靠的计算和通信提供正确的基
础设施。
    诸如Mozilla和OpenOffice.org的大规模桌面开发始于1990年代末，其发展历史很
好地展示了我们所说的重点。在上述两个开发例子中，社区反馈中最重要的议题并不是
要求增加新特征，也不是安排发布日期――而是对巨大的单体程序的厌恶以及一致感觉
在那些巨大程序成为障碍之前，必须瘦身、重构、分解成块。
    尽管伴随着许多创新，但所有对这三个技术的响应都保持着Unix的设计准则――模
块化、透明性、机制同策略分离及其它我们在本书早前描绘的品质。Unix程序员在30
年风雨中学到最有经验的回应，就是回到最初的准则――优先从流、命名空间、进程等
Unix基本抽象中得到更多效用，而不是增加新的东西。
20.2  Plan 9：未来之路
    我们知道Unix的未来看起来会怎样。
在贝尔实验室编制了Unix的研究组设计。
它被称作“来自贝尔实验室的Plan 9”2，由
Plan 9尝试重做Unix，做更好的Unix。
    设计者在Plan 9中尝试应对的核心设计挑战是整合图形和无处不在的网络互联，使
它们成为好用的Unix式框架。他们保曰了Unix的选择，尽可能多地通过单一大型文件
层次命名空间来访问系统服务。实际上，他们是在此基础上改进；许多在Unix中需要通
过不同专用接口的功能，比如BSD套接字、fcntl （2）以及ioctl（2），在Plan 9中都可通
过在类似设备的专用文件上使用最普通的读写操作来完成。为了可移植性和易访问性，
几乎所有设备接口都是文本的而非二进制的。许多系统服务（包括视窗系统在内）都是
文件服务器，以特殊文件或目录树来表示服务资源。通过将所有的资源都表示成文件，
Plan 9把访问不同服务器资源的问题转变成访问不同服务器文件的问题。
2名字来源于1958年的电影，《Plan 9from Outer Space））（外层空间第九计划），该片被当作“最糟
糕的”而写进历史。（不幸的是，榜单似乎并不正确，1966年有部甚至更糟的影片叫做《Manos: The
Hands of Fate》（Manos:命运之手），少数看过的人可以作证）。文档，包括描述架构的技术文件，
以及可以安装在PC机上的完整源码和发布包，都可以通过搜索短语“Plan 9 from Bell Labs”得到。
UNI×编程艺术
www.pdf365.com
20.2  Ptan 9：未来之路
465
    Plan 9将这种“比Unix更Unix’’的文件模式和一个全新的概念整合在一起：私有命
名空间（ private namespace）。每个用户（实际上，每个进程）都可以拥有自己的系统服
务视图，通过创建自己的文件服务器装配树（ mount tree）。有些文件服务器的装配树将
由用户手动设置，其它的在登录时自动建立。这样（如同Plan 9from Bell Labs的技术资
料指出的一样）“/dev/cons总是指终端设备，而/bin/date则指date命令正确的运
行版本，但是这些名字代表的文件依赖于环境，例如执行date机器的架构等等”。
    Plan 9最重要的特征是，无论何种实现，所有挂载的文件服务器都具备相同的类文
件系统接口。有些可能相对于本地文件系统，有些相对于通过网络访问的远程文件系统，
有些相对于在用户空间运行的系统服务器实例（比如窗口系统或另～种网络栈），还有
些相对于内核接口。对于用户和客户端程序而言，它们没有区别。
    Plan 9技术资料中的有个例子就是实现FTP访问远程站点。在Plan 9下并没有ftp（l）
命令，而存在一个ftpfs文件服务器，每个FTP连接看起来兢像是挂载一个文件系统。在
挂载点下，对于文件和目录的open、read以及write命令，都由ftpfs自动地转换为FTP
协议事务。这样，所有普通的文件处理工具，例如/s（1）、  mv（l）以及cp（l）都可以正常
工作：无论是在vrP装配点下，还是跨越到其它用户眼中的命名空间。用户（或是脚本
和程序）能够注意到的唯一不同就是不尽一致的检索速度。
    PJan 9还有许多其它值得推荐的地方，包括一些问题重重Unix系统调用接口的再造、
摒弃了超级用户概念的，以及许多其它有趣的再思考。它的血统没有污点，设计优雅，
而且揭露了Unix设计中的一些严重错误。
    同大多数二次系统不同，在许多地方Plan 9都创造了比其前身更简洁更优美的体系。
但它为什么没有统治世界呢？
    有人会提出许多特殊的理由――缺乏重大的市场努力、文档的稀少、许可证和费用
的困惑和阻碍。对于那些不熟悉Plan 9的人，似乎它的主要功能就是作为关于操作系统
研究有趣论文的题材。但在先前，Unix自身已经就超越了各种障碍吸引了无数为之献身
的追随者，最后遍布全球。但为什么P1an 9没有昵？
    深入到历史长河的调查也许会揭开一个不同的故事，但是在2003年，看起来Plan
9昀失败仅仅是它的改进尚不足以取代它的前任。对比Plan 9，Unix似乎明显嘎吱作
响，锈迹斑斑，但是Unix的工作完成得很棒足以保持它的地位。这是个教训，提示
UNIX编程艺_术
  www.pdf365.com
466
第20章未来：危机与机遇
雄心勃勃的系统架构师：更优秀解决方案的最危险敌人，就是一个现存的、足够优秀
的代码库。
    一些Plan 9的思想已被吸收进现代的Unix，尤其是在更革新的开源版本中。FreeBSD
具备―个/proc文件系统，几乎完全借Plan 9的模型，可以用来查询或控制运行的进程。
FreeBSD的rfork（2）以及Linux的clone（2）系统调用也借自Plan 9的ork（2）。Linux的
/proc文件系统，除了当前进程信息，也附加保存了许多类Plan 9设备文件的综合信息，
几乎全部使用文本接口来查询和控制内核。Linux 2003年的实验性版本也实现了逐进程
的装配点，这是迈向Plan 9私有命名空间的一大步。不同的开源Unix版本现在朝着系统
范围内支持UTF-8的方向努力，而UTF-8正是一种实际上为Plan 9而发明的编码。3
    随着时间的推移，可能就会那样，随着Unix内部架构某些部分的渐渐老化，越来越
多的Plan 9思想将整合进Unix中。这是Unix未来一个可能的发展路线。
20.3 Unix设计中的问题
    Plan 9洗涤了Unix;但在Unix的基础设计概念集上真正所加的全新的概念足有一
个（私有命名空间）。但是还有别的基本设计概念存在严重问题吗？在第1章，我们接
触了几个Unix存在争论的失败之处。既然开源运动已经将Unix的未来设计交回到程序
员和技术员手中，那些问题就不再是我们必须永远忍受的定局了。我们将重新检视它们
以更好应对Unix未来应该如何发展的问题。
20.3.1  Uni×文件就是一大袋字节
    Unix文件仅仅是个字节大袋子，而没有其它文件属性。特别是没有能力存储有关文
件类型的信息，以及指向文件实际数据之外相关应用程序的指针。
    更普遍地，一切都是字节流，甚至包括硬件设备也是字节流。这种隐喻在早期的Unix
中取得了巨大的成功，而且，在某些地方，例如，被编译的程序不能够产生传递回编译
器的输出，的的确确是个真正的进步。管道和shell编程也正是从这个隐喻上发轫的。
3 UTF_8如何诞生的传说涉及Ken Thompson.  Rob Pike、一次新泽西的午餐以及彻夜疯狂的编程
<ht t_p：／／www.cl.cam.ac.uk／-mgk2 5/ucs／utf -8-history.txt>.
www.pdf365.com
20.3 Unix设计中的问题
467
    但是Unix的字节流隐喻太过重要，以至于如果软件对象的某些操作不是特别适合字
节流或是文件操作（创建、打开、读写删除）的话，那么Unix就存在整合的困难。GUI
对象尤其是个问题，例如图标，窗口，以及正在操作的文档。在Unix世界经典的模型中，
“一切都是字节流’’这个隐喻的唯一扩展方式就是ioctl调用，使用内核空间声名狼藉
的后门。
    Macintosh系列操作系统的发烧友往往对此咆哮不已。他们提倡～种模型，其中，单
一文件名可以既有数据“分支”又有资源“分支”。数据分支对应于Unix的字节流，而
资源分支则是名／值对的集合。而Unix支持者更喜欢文件数据自描述的方式，这样，同
种类的元数据都有效地存放在该文件中。
    Unix方法的问题在于写文件的每个程序都必须清楚自描述的方式。这样，例如，如
果我们需要文件携带类型信息在其中，涉及该文件的每个工具都得小心，要么原封不动
地保留该类型域，要么解析之后重写。尽管这在理论上可以实现，但在实践中太脆弱了。
    另一方面，支持文件属性会产生难以应付的问题，什么样的文件操作应该保留文件
属性。很明显，具名文件的复制应该拷贝源文件的数据及属性．但是如果我们cat（1）文件，
将其输出重定向到一个新的名字又该如何？
    答案依赖于属性实际上是否真是文件特性，还是以某种特殊方式作为不可见的前编
码或后编码与文件数据捆绑在一起。这样问题又变为：属性对何种操作可见？
    远在七十年代，Xerox PARC文件系统设计就在这个问题中不断挣扎。它们创造了一
个序列化打开（open serialized）调用，返回同时包含内容和属性的字节流。如果应用在目
录上，就返回目录属性和目录中所有文件的序列化结果。这种方法是不是一直都有改善，
并不清楚。
    Linux 2.5已经支持附带任意名／值对来作为文件特性，但在写作本书时，并没有为太
多的应用程序所用。Solaris最近的版本也有几乎等价的特征。
20.3.2  Unix对GUI的支持孱弱
    Unix的经历证明了使用众多隐喻作为框架的基础是个威力巨大的策略（回忆我们在
第13章关于框架和共享上下文的讨论）。现代GUI核心的可视隐喻（文件由图标表示，
打开靠点击，点击会激发某个设计好的处理程序，通常能够创建和编辑这些文件）也证
UNIX编程艺求
  www.pdf365.com
468
第20章未来：危机与机遇
明了是成功而持久的。自从Xerox PARC在七十年代先驱性开拓以来，这些就紧紧地抓
住了用户和界面设计者。
    尽管最近做出了相当多的努力，在2003年，Unix仍然只是蹩脚地、勉强地支持这
种隐喻――层次太多，约定太少，构建程序太过于简陋。Unix老手典型的反应就是怀疑
这折射出GUI隐喻本身更深层次的问题。
    我认为产生这样的问题部分是由于我们仍未正确理解隐喻。例如，在Mac上，
  把一个文件拖到垃圾桶去是删除，但把文件拖到某个磁盘上却又是复制，而打印
  时却又不能把文件拖到打印机的图标上去，那需要通过菜单才能完成。我还能够
  继续举例下去。它像OS/360上的文件操作，那会儿还没有Unix简单（但不简陋）
  的文件思想。
-Steve Johnson
    对于类似的效应，在第Il章我们引用了Brain Kernighan和Mike Lesk的话。但是这
个疑问并不能简单归罪于GUI就停止了，因为尽管GUI存在许多缺点，但终端用户却有
巨大的需要。设想，如果我们能够在设计用户交互层面上，把隐喻弄正确明白，Unix就
能够优雅地支持它了？
    答案是：也许不能。我们在思考字节袋子模型是否先天不足时就接触到这个间题。
Macintosh风格的文件属性或许可以帮助提供一种机制，支持更为丰富的GUI。然而这
似乎并不是完整的答案。我们需要仔细思考，才能得出结论，一个真正强大的GUI框
架究竟是什么样的一一而且，同样重要地，又如何同现存的Unix框架整合在一起。这
是个难题，需要基础性的顿悟，但在喧闹而令人困惑的大众软件工程或学术研究巾还
未出现。
20.3.3文件删除不可撤销
    有过VMS经验的人，或是还记得TOPS-20的人，往往怀念这些系统的文件版本功
能。删除或打开并修改现存文件，实际上只是以一种包含版本号的可预知方式重命名文
件，只有对版本文件明确的删除操作才会真正地删除数据。
    Unix没有这种功能，其小小代价是，在因打字疏忽或shell通配符结果不符而错误删
除文件，把用户惹怒。
    这个问题好像并没什么可预见的前景，会在操作系统级别上得到更改。Unix开发者
www.pdf365.com
20.3 Unix设计中的问题
469
喜欢清晰、简单的操作，用户告诉什么他们就做什么，即使用户指令等于“向我开枪”
的命令。Unix开发者本能的辩解就是重申：保护用户免受自我损害，应该是GUI或应用
程序级别的事，而非操作系统。
20.3.4 Unix假定文件系统是静态的
    某种角度上，Unix世界的模型完全是静态的。程序的运行总被设想为暂时的，所以
文件和目录环境在整个执行中都可以当成静态的。如果某个指定的文件或目录发生了改
变，没有标准的、良好的方式来让系统通知应用程序。当编写长期运行的用户界面软件，
如果又希望知道环境的改变时，这就会成为重大的问题。
    Linux具有文件和目录更改通知功能4，有些BSD的版本也复制了这个功能，但尚无
法移植到其它Unix。
20.3.5作业控制设计拙劣
    除了挂起进程（在本身，微不足道地增加了调度程序负担，并不是那么令人讨厌）
的能力之外，作业控制就是在多重进程中切换终端。不幸地，操作系统只做了最简单的
部分――确定触发了哪个键――而把所有难题当皮球似地踢给了应用程序，例如保存和
恢复屏幕的状态。
    该功能真正良好的实现对于用户进程应该完全不可见：没有专用的信号，不需要保
存和恢复终端模式．不需要应用程序定时重绘屏幕。其模型应该是，虚拟的键盘必要时
连接到真正的键盘（如果没有连接，在请求输入时会遭到阻塞），以及一个虚拟屏幕，
必要时可以显示在真正的屏幕上（当没有显示时，无所谓阻塞不阻塞输出）：而以同样
的多路复用方式，系统应该可以多路复用磁盘、处理器等等，而用户程序根本就不受影
响。5
    正确的做法要求Unix tty驱动跟踪整个当前屏幕的状态，而不仅仅只是支持行缓存
区，并且当一个挂起的进程恢复到前台运行时，需要在内核级知道终端的类型（可以求
4在fcntl（2）下查找F―NOTIFY。
5本段基于Henry Spencer在1984年的分析。他继续注意到作业控制对于POSIX及后来的Unix标准
是需要和适合认真考虑的，因为它渗透到了每个程序，所以在任何应用程序到系统的接口都必须考
虑。因此，POSIX认可了这个错误设计，而正确的解决方案却因“不在讨论范围”而甚至没有考虑
过。
UNIX编程艺术
  www.pdf365.com
470
助于一个后台进程）才可以正确地恢复。
离某个对话，例如xterm或Emacs作业，
型的）。
如果没有做好，Unix内核不能够从一个终端分
然后又将其配接到另一个终端（可能是不同类
    随着Unix的使用已经转向X显示和终端模拟器，作业控制就变得相对不那么重要
了，而也就没有曾经那样的破坏力了。然而，仍然讨厌的是没有suspend/attach/detach等
操作，这种功能对于在不同登录中保留终端对话的状态非常有用。
    叫做screen（1）的通用开源程序解决了这些问题中的好几个6。然而，必须显式地
由用户调用，既然这样，就不能保证在每个终端对话都拥有其功能；同时，在功能上与
之重叠的内核级代码也还没有移除掉。
20.3.6  Unix API没有使用异常
    C语言缺乏抛出附带数据的命名异常的机制。因此，Unix API中的C函数用与众不
同的的返回值（通常是。l或NULL）并设置全局变量ermo来报告错误。7
    回顾过去，这的确是许多微妙错误的发源之地。匆匆忙忙的程序员常常忽略返回值
检查。因为没有异常抛出，补救原则也被破坏了；程序流程继续进行，直到错误情形在
后来的执行中表征出某种失败或数据损失。
    异常的缺失也意味着某些理虚简单的任务――例如在具备Berkelev风格信号的Unix
版本上，从信号处理程序中退出――不得不由复杂的代码来实现，从而成为移植的障碍，
和众多错误的渊薮。
    这个问题也可能（且通常是）隐藏在Unix API对诸如Python和Java之类具备异常
的语言的接口中。
    异常机制的缺乏实际上也牵连出一个更大的问题：由于C语言是弱类型语言，所以
使用C语言实现的高级语言之间，其通信也是问题多多。多数现代的语言都将诸如链表
和字典作为基本数据类型――但是，因为这些在通用C语言中没有规范的表示，所以在
类似Perl和Python之间尝试传递链表就是一个非自然的行为，需要许多胶合代码。
存在解决更大规模问题的技术，例如CORBA，但是却往往涉及运行期的转换，并且
6 <http：／／www - math．fu-berlin．de／～guckes/screen/>是screen（1）的项目站点。
7对于非程序员，异常抛出是程序从函数过程中间跳出的一种方法。它并不是真正的退出，因为在某
个封装的过程中，抛出的异常可以被捕获代码中途拦截。异常往往用来表示错误或是不希望的情
形，意味着试图继续正常处理逻辑是毫无意义的。
www.pdf365.com
20.3  Unix设计中的问题
471
太过重量级，令人不舒服。
20.3.7  ioctl（2）和纪几t/（2）是个尴尬
    ioctl（2）和fcntl（2）机制提供一种在设备驱动中插入钩子的方法。原始的、历史的ioctl（2）
用法，就是设置波特率以及设置串行通信驱动中的帧比特，所以就产生了这个名字（“I/O
控制”）。后来，其它驱动函数可以使用ioctl调用，而fcntl（2）作为一个钩子函数增加到
了文件系统中。
    年复一年，ioctl和fc:ntl调用不断增加新的用法。但常常缺乏文档，也常常产
生移植性问题。每一个都带来一大堆繁杂的宏定义来描述操作类型和特殊的参数值。
    根本的问题同“字节大袋子”一样；Unix的对象模型孱弱不堪，没有留下自然的空
间放置太多增加的辅助操作。设计者不得不在不满意的解决方案中胡乱选择：
fcntl／ioctl在／dev中检查设备、新的专用系统调用、或是通过特殊用途虚拟文件系
统钩子加载进内核里去（例如，在Linux以及别的地方的／proc）。
    还不清楚在未来，Unix的对象模型是否会得到加强或如何加强。如果类MacOS的
文件属性成为Unix的通用特征，在设备驱动上调节各式具名属性就可卧接替
ioctl／fcntl现在的作用（这样至少不需要在接口可以使用前定义一堆宏）。我们已
经看到Plan 9使用具名文件服务器或文件系统作为基础对象，而不是文件／字节流，这提
供了另外的可能方法。
20.3.8  Unix安全模型可能太过原始
    或许root用户权限太大，对于系统管理功能，Unix应该具备粒度更细的能力或是
ACL（Access Control Lists，访问控制列表），而不是只有一个什么都能做的超级用户。
站在这一边的人们或许会辩解，许多系统程序通过set-user-ID就会拥有永久的root用户
权限；一处被攻破，就意味着全面沦陷。
    然而论据是小充分的。现代Unix允许指定用户帐户分属多个安全权限组。通过使用
执行许可以及在程序可执行时set-group-ID，每个组的作用就可以像文件程序的ACL。
UNIX编程艺-术
  www.pdf365.com
472
理论可行，却很少使用，可以这样认为，对ACL的需求在实践上远比理论少。
20.3.9  Unix名字种类太多
    Unix统一了文件和本地设备――都是字节流。但是通过套接字访问的网络设备在不
同的命名空间却具有不同的语义。而Plan 9展示了文件同本地及远程（网络）设备可以
平滑地统一在一起，并且所有这些事情都可以通过一个命名空间来管理，当然，命名空
间可以根据每个用户甚至是每个程序动态地调整。
20.3.10文件系统可能有害论
    拥有文件系统根本就是个错误？自从1970年代晚期起就一直存在有趣的研究，研究
持续对象存储，研究根本没有全局共享文件系统，而将磁盘存储当作巨大交换区，做任
何事情都通过虚拟对象指针来完成的操作系统。
    这条阵线上现代的努力（例如EROS8）提示这样的设计可以提供大量的好处，包括
被证实的安全策略一致性以及更高的性能。然而必须注意到，如果Unix是个失败，它所
有的竞争者都同样是失败；没有作为主要产品的操作系统都跟随EROS的领导。9
20.3.11  朝向全局互联网地址空间
也许URL扬名得还不够。关于Unix未来的方向，我们把最后的话留给Unix的发明者；
    我未来的理想就是开发一个文件系统的远程按口（也就是Plan 9），然后使
其在互联网成为标准实现，取代现在的HTML。那实在是酷毙了。
-Ken Thompson
8 http：／／www - eros-.s .org／
9 Apple Newton、AS/400小型机以及Palm手持设备上的操作系统可以认为是例外。
www.pdf365.com
20.4 Unix的环境问题
473
20.4  Unix的环境问题
    Unix旧有的文化在开源运动中大部分进行了自我再造，在灭亡的边缘挽救了我们，
但这也意味着开放源码的问题现在就是我们自己的问题。
    问题之一就是如何让开源开发获得持续的经济支持。我们重新植根于Unix早期的
合作开放进程。我们已经在很大程度上，在抛弃私用专有系统的技术争论上取得胜利。
我们已经想出了许多方法，在比1970～1980年代更平等的地位上，同市场和管理人员
合作，并且在许多地方我们的革新都获得了成功。在2003年，开源Unix和它的核心
开发组，达到了如大型机般受人尊敬和权威的地位，这在1990年代中期是不敢想象的。
    我们已经走过了很长的路，但是我们还有更长的路要走。我们知道哪种商业模式
在理论上管用，而且我们现在甚至可以指出一些零星的成功，展示了那些商业模式在
实践中也确实运营良好；当然，现在我们必须显示那种模式可以可靠地运营更长的时
间。
    这并不一定是个容易的转变。开放源码将软件业转变成服务业。服务提供商（想
想医疗和法律行业）并不会注入更多资本的比例来扩张；那些仅仅尝试追加固定成本，
就期望得到高产出的做法，注定会被饿死。合理的选择可以归纬为卖唱（通过小费或
捐款），经营街角小店（一种小型的、低开销的服务商务），或是找到一个富有的赞
助人（某些大商家为其商业目的而需要使用及修改开源软件）。
    总而言之，技工的小时工资随着汽车的降价而上升10，同样的原因，雇用软件开发
者的费用也会如预料中地提高。而个人和商家也越来越难以获得投资。会有许多程序
员富裕起来，但是仅有少数几个能成为百万富翁。这实际上是进步的标志，无能的就
被竞争出局。但这也将表示整个软件环境气候的一大变化，可能意味着投资者将失去
他们仅存的、在赞助软件启动中很少的利益。
io~-完整的讨论，参见《The Magic Cauldron》 [Raymond01]。
UNIX编程艺术
  www.pdf365.com
474
第20章未来：危机与机遇
    一个有关真正大型软件商维护越来越困难的子问题是如何组织终端用户测试。历
史上，Unix文化首要关注内部架构，这意味着，能够提供最终用户舒适界面的价值，
从未被我们当作程序构建的基础。如今，尤其是把在目标瞄准同微软和Apple竞争的
开源Unix中，这一点正在改变。但是最终用户界面需要实际用户系统地测试一一这存
在～些挑战。
    实际最终用户测试需要机构、专家以及一定水准的管理，然而以分布自愿团体为
特征的开源开发却难以部署这些。也许因此，开源的字处理器、电子表格以及其它生
产型应用程序不得不留在由大商家赞助的研究计划手中，例如OpenOffice.org，只有它
们才能提供那种开销。开源开发者往往认为单…商家就意味着单点失败，并且非常担
心这种依赖，但更好的解决方案还没有发展出来。
    这些是经济问题。我们还有其它更政治化的问题，因为成功招徕敌人。
    有些是老对头啦。微软要成为计算机世界不可动摇垄断者的野心，使得在我们知
道我们卷入战争的五年前，就把打败Unix作1980年代中期该公司的战略目标。在2003
年年中，尽管好几个成长性市场遭到Linux大范围的侵占，微软仍然是世界上最富有
和最疆大的软件公司。微软很清楚地知道必须打败新学派的开源Unix以求生存。而为
了获胜，必须毁灭或是羞辱产生它的文化。
    Unix借开源社区之手回来了，而同互联网自由文化的结合，也带来了新的敌人。
  好莱坞和媒体巨头感到了互联网深深的威胁，对不受控制的软件开发发起了多重攻击。
’  现存的法案，例如Digital Millennium Copyright Act已经被用来起诉那些为媒体权势不
  喜的软件开发者（最臭名昭著的案件就是针对能够复制加密DVD的DeCSS软件）。
  预期的计划例如所谓的可信计算甲台联盟（ Trusted Computlng Platform Alliance）和微
  软的Palladium威胁11要让开源开发成为非法活动一一而如果开放源码消亡了，Unix也
  很可能随之消亡．
    Unix、黑客以及互联网～起反对微软和好莱坞及媒体巨头。这是我们需要获胜的
斗争，不仅是出于我们传统的专业主义、我们对技艺的热爱，以及共有的部族忠贞，
还有更重要的原因使这个斗争如此重要。政治可能性渐渐成形于通信技术一一谁可以
使用、谁应该检查以及谁可以控制。政府和法人对网络内容的控制，对什么人可以利
用计算机的控制，都是对政治自由一个长期严重的咸胁。恶梦般的场景就是这样，垄
断商家和中央独裁，永远的自然同盟者，相互勾结并炮制理论，越来越多地制订规章、
2 1参考TCPA FAQ<http：／／WWW - cl．cam. ac．uk／～rj aj 4/tcpa- faq．html>，由一个著名安全
专家所做的一个相当毛骨悚然的可能性分析摘要。
www.pdf365.com
20.5 Unix文化中的问题
475
无情镇压以及罗织电子言论罪名。在反对这一切的斗争中，我们是自由的战士一一不
仅仅是为了我们自己的自由，也同样是为了所有人的自由。
20.5  Uni×文化中的问题
    围绕在Unix社区的文化问题，同Unix自身的技术问题以及伴随成功而来的挑战
同样重要。至少存在两个重大的问题：小挑战是内部转型，大挑战是我们要克服历史
上的优越感。
    小挑战是老学究与新派开源大众之间的摩擦。Linux的成功，特别地，对许多老一
辈的Unix程序员来说并不完全舒服。部分是由于代沟的问题。Linux小子们吵闹活泼
天真愉悦的狂热行为激怒了老一辈，他们自从七十年代就接触Unix了，而且（常常公
正地）认为自己更有智慧。而小子们在老一辈失败的地方不断取得成功的事实更激化
了这种现象。
    在2000年，当花了三天时间参加了一个Macintosh开发者会议之后，我愈发清晰
地意识到了更大的心理问题。沉浸在一个同Unix世界假设基础完全相反的编程环境中
真是个给人启迪的经历。
    Macintosh程序员最为关心用户体验。他们是建筑设计师和装饰家。他们由外而内
进行设计，首先就问“我们需要支持哪种交互？”，然后构建隐藏其后的狸序逻辑来
满足用户界面设计的需求。这就会导致程序外观非常漂亮而内部结构脆弱摇摆。一个
声名狼藉的例子，在MacOs 9以前的发布版本中，内存管理器有时对于那些退出但仍
占用内存的程序，竟然要求用户手动回收内存。Unix支持者本能地反感这类病态设计：
他们不能理解Macintosh的人怎么能够忍受这些。
    比起来，Unix程序员先考虑基础设施。我们是水管工和砖瓦匠。我们的设计由里
而外，构建强大的引擎以解决抽象定义问题（例如“我们如何通过不可靠的链接和硬
件而获得从A点到B点的可靠信息包流交换”）。然而引擎外，我们的包装难看，甚
至接口常常相当丑陋。date（l）. find（l）和ed（l）就是臭名昭著的例子，但还有其它成百上
千的程序也是这样。Macintosh人也本能地反感这种病态设计；他们也不能理解Unix的
人怎么能够忍受这些。
    两种设计哲学都有正确的一面，但是两个阵营却难以理解彼此的立场。Unix开发者
典型的反应就是把Macintosh软件当作是给无知人的绣花枕头而抛弃，然后继续构建能
UNIX编}翟艺_术
  www.pdf365.com
476
第20章未来：危机与机遇
够吸引其它Unix开发者的软件。如果终端用户并不喜欢，那是终端用户的不对：他们了
解多了之后，会回来的。
    在许多地方，这种狭隘思想已经为我们工作得很好。我们是互联网和万维网的守护
者。我们的软件和我们的传统统治了重大计算，统治了必须是全天候可靠的、宕机时间
最少的应用程序。我们真正极端擅长构建坚实的内部结构；虽非完美，但无论如何没有
其它的软件技术文化能够在任何地方接近我们的纪录，这是非常值得骄傲的。
    问题是我们愈发必须直面的挑战，是需要更多丰富视图的挑战。世界上大多数的计
算机都不是放在服务器机房里，而是在那些终端用户手中。在Unix早期的日子里，在个
人计算机之前，我们的文化把自身部分定位为大型机神父，那个大铁玩意管家的反叛者。
后来，我们吸收了早期小型机狂热者给人们以力量的理想。但是今天，我们成为了神父；
成为了网络和大铁块的守护者。我们潜在的要求是，如果想使用我们的软件，就必须
学会像我们一样思考。
    在2003年，在我们的态度中存在深深的矛盾一一精英和大众之间的摩擦。我们希
望影响和改变这世界92%的人，对他们来说，计算机就意味着游戏、多媒体、漂亮的
GUI界面、  （对他们来谠最技术的）邮件软件、字处理器以及电子数据表。我们正花
费主要努力在诸如GNOME以及KDE等设计来给予Unix美妙外观的项目。但在内心
深处，我们仍旧认为自己是精英，不能或不想去甄别或是倾听以王大婶为代表的普通
用户需求。
    对于非技术最终用户，我们构建的软件往往不是令人迷惑无法理解，就是样子难
看故意屈尊似的，又或两者兼有。即使我们怀着尽可能高的热情尝试去做对用户友好
的事，却可悲地前后矛盾。对于完成这份工作，我们从旧学派Unix继承的许多态度和
反应都是不恰当的。即使我们想要倾听或帮助王大婶，我们也不知道如何去做一一我
们设计了我们的服务类目、关心她并提供“解决方案”，但她却发现这同她存在的问
题一样可怕。
    我们在文化上面临的巨大挑战是，我们是否能够不再过分依赖那些已经很好地为
我们工作过的设想――我们是否能够承认，不仅是在思想上，也是在日常实践的施行上，
承认Macintosh支持者也抓住了要点。他们的要点也是基于普遍实际，而非Mac专用方
式，在“The Inmates Are Running the Asylum[CooperJ”，一部具有深刻见解和充分论证
的书籍中，其作者称（别管偶尔的一些奇谈怪论），交互设计乜包含了大量坚实的真理，
需要为每个Unix程序员所知道。
    我们可以避开这～点：我们可以保留教父地位，祈求碰到最好最聪明的少数人――
一小撮关注我们历史作用的知识精英――作为软件内部架构和网络的守护者。但如果我
www.pdf365.com
20.6信任的理由
477
们这样做，就很可能走向衰落，直到最后失去几十年来一直支持我们的动力。自有别
的东西去服务人们；自有别的东西会赢得动力和金钱并拥有未来92%比例的软件。而
这个可能成功的机会，无论是不是属于微软，都将使用我们所不喜欢的软件和实践来
完成。
    或者我们真正接受这个挑战。开源运动正努力这样去做。但在过去用来解决其它问
题的相同工作和思想是不够的。我们的态度必须在根本上有所转变，虽然困难。
    在第4章，我们讨论了抛弃设想限制以及在解决技术问题上“抛弃过去”的重要性，
建议同禅宗思想类似的超然和“初衷”。我们拥有～个需要更多种类的分离工作。我们
必须学会在王大婶面前虚心，并且放弃某些我们长期坚持的、曾使我们如此成功的偏见。
    明显地，Macintosh文化已经开始同我们的文化相融合-MacOS X拥有Unix的底
层架构，并且在2004年Mac开发者（虽然在某些方面有所斗争）进行了思想上的调整
来学习注重内部架构的Unix美德。我们的挑战将是，相互地，吸纳Macintosh以用户为
中心的美德。
    还有几个表明Unix文化摆脱其狭隘性的迹象。其中之一就是Unix开源社区似乎开
始融入被称为“敏捷编程”12的远动。我们在第4章注意到，Unix程序员已经愉快地抓
住了重构的概念，那就是敏捷编程思想的重点之一。
    重构，以及其它的敏捷编程概念，例如单元测试和围绕情景设计，似乎清晰地说明
和突出了那些迄今已经在Unix传统广泛但隐性流传的实践。另一方面，Unix传统可以
给敏捷编程带来长期经验的积累和教训。随着开源软件不断获得市场份额，可以想象这
些文化将会融合在一起，如同过去互联网和早期Unix文化在1980年后的融合一样。
20.6信任的理由
    Unix的未来充满难题。我们确实想让它走好吗？
    三十多年来，我们在应对挑战中兴盛起来。我们开拓了软件工程中最好的实践。我
们创造了今天的互联网和万维网。我们编制了有史以来最庞大、最复杂、最可靠的软件
系统。我们打破了IBM的垄断，我们正在开展反对微软霸权的运动，并且已经深深地震
慑了它。
12更详细的敏捷编程介绍，参考《Agile Manif est。》（敏捷宣言）<http：／／agilemanifest。，。rg／>
    UNI×编rkc:艺术
    www.pdf365.com
478
第20章未来：危机与机遇
    而无论如何，胜利并不是全面的。在1980年代，我们同意专有权对Unix的占领，
这几乎毁了我们自己。长期以来，我们忽视了低端市场，忽视了非技术的终端用户，因
此让微软钻了空子，大幅度地降低了软件的质量标准。甚至精明的观察家多次断言我们
的技术、我们的社区、我们的价值死亡了。
    但我们总是可以重振旗鼓地王者归来。我们犯了错，但我们从错误中汲取了教训。
我们的文化薪火相传：我们已经从早期的学院黑客、ARPANET实验者、微机狂热者以
及其它许多文化中汲取了精华。而开源运动已经复兴了我们早年的激情和理想，今天，
我们的力量，我们的规模将远胜过去。
    迄今为止，打赌Unix玩家会输的人总是聪明一时糊涂一世。我们能赢――只要我们
想赢。
www.pdf365.com
附录A
缩写词表
Glossary of Abbreviations
API
The most important abbreviations and acronyms Uksed in the main text are defined here.
本书中最重要的简称和缩写定义如下。
Application Programming Interface（应用编程接口）。同可链接程序库或操作系统内
核或两者通信的过程调用集。
BSD
    Berkeley System Distribution;也作Berkeley Software Distribution;名字具体来源已不
可考。在1976到1994年之间，由加利福尼亚大学伯克利分校计算机科学研究组发布的
Unix版本统称为此，许多开源Unix都从此继承而来。
CLI
    Command Line Interface（命令行界面）。有些人认为太陈1日了，但在Unix世界仍然
很有用。
CPAN
    Comprehensive Perl Archive Network。<http：//cpan．org/>，Perl模块和扩展的
网络中心库。
GNU
    GNU's Not Unix （GNU不是Unix）!自由软件基金的项目，原意是开发一个Unix昀
克隆版本，但完全自由的软件；GNU是其递归的缩写名。这个项目并没有取得完全成功，
但是产生了许多现代Unix开发的基本工具，包括Emacs和GNU编译器集（GNU Compiler
Collection，GCC）。
www.pdf365.com
480
附录A缩写词表
GUI
    Graphical User Interface（图形用户界面）。应用程序界面的现代风格，与老式CLI
或roguelike风格不同，使用鼠标、窗口及图标，由Xerox PARC中心在1970年代创造。
IDE
    Integrated Development Environment（集成开发环境）。代码开发的GUI工作台，功
能包括符号调试器、版本控制以及数据结构浏览。在Unix下通常并不使用，原因在第
15章讨论过。
IETF
    Intemet Engineering Task Force（互联网工程任务组）。负责定义诸如TCP/IP之类互
联网协议的实体。一个松散平等的组织，主要由技术人员构成。
IPC
    Inter-Process Communication（进程间通信）。独立地址空间运行进程的数据传输方
法。
MIME
    Multipurpose Internet Mail Extensions（多用途互联网邮件扩展）。一系列的RFC，描
述了在RFC-822邮件中内嵌二进制和multipart信息的标准。除了使用在邮件传输之外，
MIME也被一些重要的应用协议（如HTTP和BEEP）作为基础使用。
00
    Object Oriented<面向对象）。一种编程风格，将处理的数据和处理数据的代码封装
在一种称作对象的闭合容器内。相比之下，非面向对象编程更容易暴露内部的数据结构
和代码。
OS
    Operating System（操作系统）。机器的基础软件；完成任务调度、分配存储空间以
及在应用程序之间提供默认的用户界面。操作系统提供的功能及其一般性的设计哲学，
强烈影响着围绕其宿主机而成长起来的编程风格和技术文化。
PDF
    Portable Document Format（可移植文档格式）。控制打印机和其它成像设备的
PostScript语言，设计来将数据流输出给打印机。而PDF是一系列的PostScript页，并包
入标记描述，可以方便作为显示格式使用。
www.pdf365.com
附录A缩写词表
481
PDP-11
    Programmable Data Processor l l（可编程数据处理器11）。可能是历史上最成功的单一
大型机设计；于1970年首次发布，1990年结束发布，并且是VAX的直接祖先。PDP-lI
是第一款主要的Unix平台。
PNG
    Portab】e Network Graphics（可移植网络图形）。万维网联盟（The World Wide Web
Consortium）的位图图形图像标准和推荐格式。这是二进制图像格式的一个优雅设计，
曾在第5章讨论。
RFC
    Request For Comment（请求评注）。一个互联网标准。当其文档作为提议被提交、
处于某种目前虽不存在但期望的正式承认过程时，就称为RFC。而正式的承认过程从未
实体化。
RPC
    Remote Procedure Call（远程过程调用）。使用IPC方法，试图创造～种错觉，进程
间互相交换数据就像是在同一地址空间，这样可以方便地（a）共享复杂的数据结构，和（b）
就像函数库互相调用一样，忽略时延和其它的性能考虑。想维持这种错觉异常困难。
TCP/IP
    Transmission Controj Protocol/lnternet Protocol（侍输控制协议／互联网协议）。自1983
年从NCP（网络控制协议）转变而来的互联网基本协议。提供可靠的数据流传输。
UDP/IP
    Universal Datagram Protocol/lnternet Protocol（通用数据报协议／互联网协议）。提供小
型数据包的不可靠低迟延传输。
UI
    用户接口（界面）。
VAX
    正式名称Virtual Address Extension（虚拟地址扩展）：由DEC（后来同Compaq合
并，再后来又与HP合并）开发的经典大型机设计。VAX第一次发布是在1977年。1980～
1990年间，VAX是最重要的Unix平台之一。针对微处理器的再实现正在开发中。
UNIX编程艺术
  www.pdf365.com
www.pdf365.com
附录B
参考文献
References
Event  timelines  of  the   Unix  Industry  <http : //snap . nlc . dcccd _ edu/
learn/drkelly/hst-hand . htm> and of GNU/Linux and Unix <http : //
WWW . robotwisdom _ com/ linux ! timeline . html>   are   available   on   the
Web. A timeline tree of Unix releases <http : / /www . levenez _ com/unix/>
is also available.
[Appleton] Randy Appleton. Improving Contexr Switching Performance ofldle Tasks
 under Linux. 200 I . Cited on:  158.
Available    on    the    Web    <http: //cs . runu _ edu/～randy/Research/
Papers/ Scheduler/>.
fBaldwin-Clarkl Carliss Baldwin and Kim Clark. Design Rules， Vol l: The Power of
  Modularitv. MIT Press. 2000. ISBN 0-262-024667+ Cited on: 83.
（Bentley] Jon Bentley. Programming Pearls
  ISBN 0-201-65788-0. Cited on: 2/5.
（2nd Edition）. Addison-Wesley. 2000.
The third essay in this book.”Data Structures Programs"， argues a case similar to
that of Chapter 9 with Bentley's characteristic eloquence. Some of the book
is available on the Web <http://wwwcs.bell-labs.com/cm/cs/
pearls />.
[BlaauwBrooks] Gerrit A. Blaauw and Frederick P. Brooks. ComputerArchitecture:
  Concepts and Evolution. Addison-Wesley.  1 997. ISBN 0-201-10557-8. Cited on:
  98， 394+
www.pdf365.com
484
附录B参考文献
[Bolinger-Bronson] Dan Bojinger and Tan Bronson. Applying RCS and SCCS.
  0' Reilly & Associates.  1995.  ISBN  l-56592-1 17-8. Cited on: 367.
Not just a cookbook. this also surveys the design issues in version-control systems.
[Brokken] Frank Brokken. C++ Annorations Version. 2002. Cited on: 329.
Available    on    the    Web    <h七tp : / /www .1cce . rug . nl/documents/
cplusplus/cplusplus . html>.
[BrooksD] David Brooks. Converting a UNIX .COM Site to Windows. 2000. Cited
  on: 59.
Available on the Web <http : / /.^rww . securityof f ice . net/mssecrets
/hotmail . htmI#_Toc4 916 01819>.
[Brooks] Frederick P. Brooks. The Mvr向融以l Man-Month （20th Anniversary Edition）.
  Addison-Wesley. 1995. ISBN 0-201-83595-9. Cited on: /2， /4， 300， 438.
[Boehm] Hans Boehm. Adr'antages urzd Disadvantages of Conservative Garbage
  Collection. Cited on: 323.
Thorough discussion of tradeoffs between garbage-collected and non-garbage-
collected environments. Available on the Web <http : //www . hpl . hp _ com/
personal/Hans_Boelun/gc/ issues . html>.
fCameron] Debra Cameron， Bill Rosenblatt， and Eric Raymond. Learning GNU
  Emacs （2nd Edition）. O'Reilly & Associates. 1996. ISBN l-56592-152-6. Cited
  on: 352.
[Cannon] L. W. Cannon， R. A. Elliot， L. W. Kirchhoff， J. A. Miller. J. M. Milner，
  R. W. Mitzw， E. P. Schan. N. 0. Whittington， Henry Spencer， David Keppel， and
  Mark Brader. Recommended C SO，le and Coding Standards. 1990. Cited on: 410.
 An updated version of the Indian Hill C Style and Coding Standards paper， with
  modifications by the last three authors. It describes a recommended coding standard
 for C  programs. Available  on  the Web  <http: //www . apocalypse .org/
 pub/u/paul/docs /cstyle/cs tyle . htrn>.
[Christensen] Clayion Christensen.  The Innovator 's Dilemma. HarperBusiness. 2000.
  ISBN 0-066-62069-4. Cited on: 52.
www.pdf365.com
m蹦
k h
抓吨
噌哩
．u m
一一眦
H．嶝珧
b曲m
 C S e
词恤叫
蛐笨
篡
一裂
她¨．要
丑帕5
篡
岫8"
誊
附录B参考文献
485
[ComerJ Douglas Comer.“Pervasive Unix: Cause for Celebration". Unix Review，
  October 1985， p. 42. Cited on: 34.
[Cooper] Alan Cooper. The Inmotes Are Running the Asylum Sams. 1999. ISBN
  0-672-3 1649-8. Cited on: 476.
Despite some occasional quirks and crotchets， this book i.s a trenchant and brilliant
analysis of what's wrong with software interface designs， and how to put it right.
[Coram-Lee] Tod Coram and Ji Lee. Experiences-A Pattern Language for User
 Interface Design.  1 996. Cited on: 266'.
Available on the Web <http://www.maplefish.com/todd/papers/
Experiences . html>.
[DuBois] Paul DuBois. Sofnvare Portability with Imake. O' Reilly & Associates.  1 993.
  ISBN l-56592-055-4. Cited on: 363.
[Eckel] Bruce Eckel. Thinking in Java （3rd Edition）. Prentice-Hall. 2003. ISBN
  0-13-100287-2. Cited on: 341.
Available  on the Web <ht tp :  / /w\^n^i . mindview . net /Books/TIJ/>.
[Feller-Fitzgerajd] Joseph Feller and Brian Fitzgerald. Understanding Ope.n Source.
 Software. Addison-Wesley. 2002. ISBN 0-201-73496-6. Cited on: 438.
[Flanaganjava] David Flanagan. Java in a Nutshell. O'Reilly & Associates. 1997.
  ISBN l-56592-262-X. Cited on: 341.
[FlanaganjavaScript] David FJanagan. JavaScripr: Ihe Definitive Guide （4th Edition）.
 O'Reilly & Associates. 2002. ISBN l-596-00048-0. Cited on: 206.
[Fowler] Martin Fowler. Refactoring. Addison-Wesley. 1999. ISBN 0-201-48567-2.
  Cited on: 90.
[Friedl] Jeffrey Friedl. Mastering Regular Expressions （2nd Edition）. O'Reilly &
  Associates. 2002. ISBN 0-596-00289-0. Cited on: 188.
[Fuzz] Barton Mifler. David Koski， Cjin Pheow Lee. Vivekananda Maganty，
  Ravi  Murthy，  Aj itkumar Nataraj an，  and Jeff Steidl.  Fuzz Revisited: A  Re-examination
 of the Reliability of Unix Utilities and Services. 2000. Cited on: 9.
Available on the Web <http:
fuz z -revisited . pdf>.
/ /WWW . opensource _ org/advocacy/
www.pdf365.com
486
附录B参考文献
[Gabriel] Richard Gabriel. Good News， Bad News. and How to Win Big. 1990. Cited
  on: 298， 438.
Available     on      the     Web     <ht tp : / /www . dreams ongs . com/Worsels -
Better . html>.
[Gancalrz] Mike Gancarz. The Unix Philosophy. Digital Press. 1995. ISBN
  l-55558-123-4. Cited on: xxviii.
[GangOfFourJ Erich Gamma， Richard Helm， Ralph Johnson， and John Vlissides.
 Design Patterns: E瞎me九坫 of Reusable  Object-Oriented Software.  Addison-Wesley.
  1997. ISBN 0-201-63361-2. Cited on: xxxii.
[Garfinkej] Simson Ga埔nkel， Daniel Weise， and Steve Strassman. The Unix Hater 's
  Handbook. IDG Books. 1994. ISBN l-56884-203-1. Cited on: 5.
Available  on  the  Web  <http :  / /research . microsof t . com/一daniel/
unix-haters . html>.
[Gentner-Nielsen] Don Gentner and Jacob Nielsen. "The Anti-Mac Interface". Com-
  munications of the ACM， Association for Computing Machinery. August 1996.
  Cited on: 26/.
Available           on           the          Web          <ht tp :  l  /\^n^n^i _  acm _  org/cacm/AUG9 6 /
an七imac . htm>.
[Gettys] Jim Gettys. The Two-Edged Sword. 1998. Cited on: 7.
Available on the Web <ht tp :  / / freshmeat . net/articles /view/12 2 1>.
[Glickstein] Bob Glickstein.  Writing GNU Emacs Extensions 0' Reijly & Associates.
  1997. ISBN J -56592-261-1. Cited on: 343.
[Graham]  Paul Graham. A  Plan for Spam.  Cited on:  218.
Available on the Web <ht tp : / /www . paulgraham _ com/spam . html>.
[Harold-MeansJ Elliotte Rusty Harold and W. Scott Means. XML in a Nutshetl （2nd
 Edition）.  O'ReiIJy & Associates.  2002.  ISBN 0-596-00292-0. Cited on:  11 7.  434.
[Hatton97] Les Hatton. ';Re-examining the Defect-Density versus Component Size
  Distribution". IEEE Software， March/April 1997. Cited on: 86.
  Available  on  the  Web  <http : / /www .cs .ukc . ac .uk/people/staff/
  lh8 /pubs /pubis 69 7/Ubend_IS697 . pdf . gz>.
www.pdf365.com
附录B参考文献
487
[Hatton98J Les Hatton. "Does 00 Sync with the Way We Think?" IEEE Software，
  15（3）. Cited on: 328.
Available   on   the  Web  <ht tp : / /www . cs . ukc _ ac . uk/people/s taff/
th8/pubs/pubis69 8/OO_IS698 . pdf . gz>.
[Hauben] Ronda Hauben. History of UNIX+ Cited on: 34.
Available      on      the      Web      <ht tp : / /www . dei _ isep . ipp . pt/docs/
unix . html>.
[Heller] Steve Heller. C+ +: A Diatog: Programming with the C+ + Standard Li'brar），.
  Prentice-Hall. 2003. ISBN 0-13-009402-1. Cited on: 329.
[Hunt-Thomas] Andrew Hunt and David Thomas. The Pragmatic Programmer: From
 Journeyman to Master. Addison-Wesley. 2000. ISBN 0-201-61622-X. Cited on:
  xxix， 90.
[Kemighan95] Brian Kernighan Experience with 7W/Tkfor Scientific and Engineering
  Visualization. USENIX Association Tcl/Tk Workshop Proceedings. 1995. Cited
  on: 335.
Available on the Web <http://www.usenix.org/publications/
library/proceedings/tcl9 5 / full_papers /kernighan . txt>.
[Kernighan-Pike84] Brian Kemighan and Rob Pike. The Unix Programming
 Environment. Prentice-Hall. 1984. ISBN 0-13-937681-X. Cited on: xxviii， 325，
  331， 356.
[Kernighan-Pike99] Bnan Kemighan and Rob Pike.  The Practice of Programming.
  Addison-Wesley. 1999. ISBN 0-201-61586-X. Cited on: xxvii， xxix， 410.
An excejlent treatise on writing high-quality programs， surely destined to become
a cjassic of the fiejd.
[Kemighan-Plauger] Brian Kernighan and P. J. Plauger. Software Tools. Addison-
 Wesley. 1976. ISBN 201-03669-X. Cited on: /4.
[Kernighan-Ritchie] Brian Kernighan and Dennis Ritchie. The C Programming Lan-
  guage （2nd Edition）. Prentice-Hall Software Series. 1988. ISBN 0-13-110362-8.
  Cited on: 94， 326， 395. 397.
www.pdf365.com
488
附录B参考文献
[Lampson] Butler Lampson ';Hints for Computer System Design". ACM Operating
  Systems Review， Association for Computing Machinery. October 1983. Cited on: 26.
Available on the Web <http : / /research . microsof t . com/～lampson/
3 3 -Hints /WebPage . html>.
[Lapin] J. E. Lapin. Portable C and Unix Systems Programming. Prentice-Hall. 1 987.
  ISBN 0-13-686494-5. Cited on: 397.
[Leonard] Andrew Leonard. BSD Unix: Power to the People， from the Code. 2000.
  Cited on: 35.
Available on the Web <http : //dir . salon _ com/tech/fsp/2000/05/
16 /chapter_2 _part_one/index _ html>.
[Levy） Sreven Levy. Haclcers: Heroes of the Computer Revolution. Anchor/Doubleday.
  1984. ISBN 0-385-19195-2. Cited on: 44.
Available on the Web <http://www.stanford.edu/group/mmdd/
SiliconValley/Levy/Hackers _ 1984 . book/con t ents . h仁ml>.
[Lewine] Donajd Lewine. POSIX Programmer's Guide: Writing Portable Unix
 Programs. O'Reilly & Associates. 1992. ISBN 0-937175-73-0. Cited on: 400.
[Libes-Ressler] Don Libes and Sandy Ressler. Life with Unix. Prentice-Hall. 1989.
  ISBN 0-13-536657-7. Cited on: 35.
This book gives a more detailed version of Unix's early history. It's particulauiy
strong for the period 1979-1986.
[Lions] John Lions. Lions 's Commentary on Unix 6th Edition. Peer-To-Peer Commu-
  nications. 1996. l-57398-OJ3-7. Cited on: 34.
PostScript rendering of Lions's original floats around the Web. This URL may be
unstable <http :  / /\^ri^rw . upl . cs . wisc . edu/ ~ epaulson/ lionc . ps>.
[Loukides-Oram] Mike Loukides and Andy Oram Programming with GNU Software.
 O'Reilly & Associates. 1996. ISBN l-56592-112-7. Cited on: 350， 357.
[Lutz] Mark Lutz. Programming Python. O'Reilly & Associates. 1996， ISBN
  1-56592-197-6. Cited on: 337.
fMcltroy78] M. D+ Mcllroy， E+ N. Pinson， and B. A. Tague.”Unix Time-Sharing
 System Forward". The Bell System Technical Journal， Bell Laboratories. 57
  （6， part 2）， 1978， p. 1902. Cited on: //.
www.pdf365.com
489
[Mcllroy9 I ] M. D. Mcllroy. "Unix on My Mind". In: Proc. Virginia Computer Users
 Conference， Volume 21， p. l-6. Cited on: 32.
[Miller] George Miller. "The Magical Number Seven， Plus or Minus Two". The
  Psychological Review， 63， 1956， pp. 81-97. Cited on: 88.
Available      on      the     Web      <http : / /www . well . com/user/s<nalin/
miller . html>.
[Mumon] Mumon. The Gateless Gare. Cited on: 149.
A good modem translation is available on the Web <ht tp : / /www . ibiblio .
org/zen/cgi-bin/koan - index . pl>.
[OpenSources] Sam Ockman and Chr:is DiBona， eds+ Open Sources: Voicesfrom the
 Open Source Revolution. O'Reilly & Associates. 1999. ISBN l-56592-582-3. Cited
  on: 6/.
Available        on        the        Web        <ht tp :  / /wwx^i - oreilly . c om/catalog/
opensources/book/toc . html>.
[Oram-Talbot] Andrew Oram and Steve Talbot. Managing Projects with Make.
 O'Reilly & Associates. 1991. ISBN 0-937175-90-0. Cited on: 357.
[Ousterhout94J John Ousterhout. Tcl and the Tk Toolkir. Addison-Wesley. 1994.
  ISBN 0-201-63337-X.
[Ousterhout96] John Ousterhout. Wh缈 Threads Are a Bad Idea （for most purposes）.
  1996.
An invited talk at USENIX 1996. There is no written paper that corresponds
to it， but the slide presentation is available on the Web <http://home.
pacbell . net/ouster/threads .pdf>.
[PadlipskyJ Michael Padlipsky. 7he Elements of Nerrworking Sryle. iUniverse.com.
  2000. ISBN 0-595-08879-1. Cited on: 103， 462.
[Pamas] Pamas L. David. **On the Criteria to Be Used in Decomposing Systems into
  Modules". Communications of the ACM. Cited on: 85.
Available on the Web at the ACM Classics page <http : / /www.acm.org/
classics/may9 6/>.
www.pdf365.com
490
附录B参考文献
[Pikel Rob Pike. Nores on Programming in C. Cited on: /2.
This document is popular on the Web; a title search is sure to find severaJ copies.
Here is one <ht tp : / /www . lysa七or . liu . se/c/pikestyle . html>.
[Prechelt] Lutz Prechelt. An Empirical Comparison of C， C++， Jczva， Perl， Python，
  Rexx，  and Tcl for a  SearcWString-Processing Program<h t tp : //www . ubka .
  uni -karl sruhe . de/cgi -bi n /psvi ew?documen t =i ra /2 0 00/5>.
  Cited on: 324.
[RaskinJ Jef Raskin. The Humane Interfoce. Addison-Wesley. 2000. ISBN
  0-201-37937-6. Cited on: 254.
A summary is available on the Web <http : //humane . sourcef orge _ net/
humane_inter f ace/summary_o f_thi . html>.
[Ravenbrook] The Memory Management Reference. Cited on: 22.
  Availabje on  the Web <h t tp : / /www . memorymanagement . org/>.
[Raymond96] The NeHr Hacker's Dictionary （3rd Edition）. MIT Press. 1996. ISBN
  0-262-68092-0. Cited on: 45， 298.
Available on the Web at Jargon File Resource Page <http : / /www _ catb . org/
～esr/j argon>.
[Raymond01] Eric S. Raymond. The Cathedral and the Bazaar （2nd Edition）.
 O'Reilly & Associates. 1999. ISBN 0-596-00131-2. Cited on: 49， 438， 473.
[Reps-Senzaki] Paul Reps and Nyogen Senzaki， eds. Zen Flesh， Zen Bones. Shamb-
 hala Publications. 1994. ISBN l-570-62063-6. Cited on: xxix.
A superb anthology of Zen primary sources， presented just as they are+
[Ritchie79] Dennis M. Ritchie. The. Evolution of the Unix Time-Sharing System  1979.
  Cited on: 30.
Available  on  the  Web  <ht tp :  / /cm _ bell-labs _ com/ cm/cs /who/chnr/
hist . html>.
[Ritchie93] Dennis M. Ritchie. The Development of the C Lnnguage. 1993. Cited
  on: 396.
Available  on  the  Web  <ht tp :  / /cm _ bell-labs . com/ cm/cs /who/clmr/
chist . html>.
www.pdf365.com
附录B参考文献
491
【RitchieQEDI Dennis M. Ritchie. An Incomplere History of the QED Text Editor.
  2003. Cited on: 304．
Available  on  the  Web  <http :  / /cm . bell-labs  . com/ cm/ c s /who / chnr/
qed . html>.
[Ritchie-Thompson] Dennis M. Ritchie
  Svstem. Cited on: 33.
and Ken Thompson. The Unix Time-Sharing
Available  on  the  Web  <http : //cm . bell-labs . com/cm/cs/who/dmr/
cacm . html>.
[Saltzer] James. H. Saltzer， David P. Reed， and David D. Clark. "End_to_End Argu-
  ments in System Design". ACM Transactions on Computer Systems， Association
  for Computing Machinery. November 1984. Cited on: /23.
Available      on      the     Web      <http : / /web .mit . edu/Saltzer/www/
publications /endtoend/endt oend . pdf>.
[Salus] Peter H. Salus. A Quarter-Century of Unix. Addison-Wesley. 1994. ISBN
  0-201-54777-5. Cited on: /2.
An excellent overview of Unix history， explaining many of the design decisions in
the words of the people who made them.
[Schaffer-Wolf] Evan Schaffer and Mike Wolf. The Unix Shell as a Fourth-Generation
 Language.  199 I . Cited on:  162.
Available on the Web <http : / /www . rdb . com/lib/4gl .pdf>. An open-
source implementation， NoSQL， is available and readily turned up by a Web search.
[Schwartz-Christiansen] Randal Schwartz and Tom Phoenix. Learning Perl （3rd
  Edition）. O'Reilly & Associates. 2001. ISBN 0-596-00132-0. Cited on: 333.
[Spinellis] Diomidis Spinellis. "Notable Design Pattems for Domain-Specific Lan-
 guages". Journal of Systems and Software，  56（ 1 ），  February  2001 ，  p.  9 I -99.  Cited
  on: 207.
Available  on  the Web  <http : / /www . cbnst . aueb . gr/dds/pubs/ j rnl/
2 0 0 0 -JSS-DSLPat terns/html/dslpat . html>.
[StallmanJ Richard M. Stallman. The GNU Manifesto+ Cited on: 39.
Available on the Web<http : / /www . gnu . org/gnu/manif esto . html>.
www.pdf365.com
492
附录B参考文献
[Stephenson] Neal Stephenson. In the Beginning Was the Command Line. 1999. Cited
  on: 262.
Available        on        the        Web        <http : //www . cryptonomicon _ com/
beginning . html>， and also as a trade paperback from Avon Books.
[Stevens90] W. Richard Stevens. Unix Network Programming. Prentice-Hall. 1990.
  ISBN 0- 13-949876-1 . Cited on:  /77.
The classic on this topic_ Note; Some later editions of this book omit coverage of
the Version 6 networking facilities like mx （ ） .
[Stevens92] W. Richard Stevens. Adv乜nced Programming in the Unix Environment.
 Addison-Wesley. 1992. ISBN 0-201-56317-7. Cited on: l:xv.
Stevens's comprehensive guide to the Unix API. A feast for the experienced pro-
grammer or the bright novice， and a worthy companion to Unix Network
Programming .
[Stroustrup] Bjarne Stroustrup. The C++ Programming Language. Addison-Wesley.
  1991. ISBN 0-201-53992-6. Cited on: 329.
rTidweIIJ Doug Tidwell. XSLT: Mastering XML Transformations. O'Reilly & Asso-
  ciates. 2001. ISBN l-596-00053-7. Cited on: /94.
[Torvalds] Linus Torvalds and David Diamond. Just for Fun: The Story of an
  Accidental Revolutionary. HarperBusiness. 2001. ISBN 0-06-662072-4. Cited on:
  394， 402.
[Vaughan] Gary V Vaughan， Tom Tromey， and Ian Lance Taylor. GNU Autoconf.
  Automake， and Libtool. New Riders Publishing. 2000. ISBN l-578-70190-2. Cited
  on: 364.
A user's guide to the GNU autoconfiguration tools. Available on the Web
<http : //sources . redhat _ com/autobook/> .
[Vo] Kiem-Phong Vo. 16The Discipline and Method Arrhitecture for Reusable
 Libraries". Software Practice & Experience， 30， 2000， p. 107-128. Cited on: 100.
Available on the Web <http://www.research.attcom/sw/tools/
vcodex/ctn- spe . ps>.
www.pdf365.com
舭吣
“雕
e嘣
月m
她P
一峪
一一
灿鼯
州唧
黼附
啪彬
n僦
吣砌
妇删殄
豪
Ⅶ眦阻
～胁棚
嚣
附录B参考文献
493
[Wal12000] Larry Wall， Tom Christiansen， and Jon Orwant. Programming Perl （3rd
  Edition）. O'Reilly & Associates. 2000. ISBN 0-596-00027-8. Cited on: 333.
[Welch] Brent Welch. PracticalP加g懈们ming in Tcl and Tk. Prentice-Hall 1999.
  ISBN 0- 1 3-022028-0+ Cited on:  335.
[Williams] Sam Williams. Free as in Freedom. O'Reilly & Associates. 2002. ISBN
  0-596-00287-4.  Cited on : 46.
Available on the Web <http :  / /www . oreilly . c om/openbook/f reedom/
index . html>.
[Yourdon] Edward Yourdon Death March: The Complete Soflware Developer's
  Guide to Surviving "Mission Impossible" Projects. Prentice-Hall. 1997. ISBN
  0- 137-483 10-4.  Cited on: 377.
www.pdf365.com
www.pdf365.com
附录
贡献
Contributors
     Anyone who has attended a USENIX conference in a fancy hotel can tell you that a
sentence like "You're one of those computer people， aren't youl" is roughly equivalent to
"Look， another amazingly mobile form of slime mold.t" in the mouth of a hotel cocktail
waitress.
    只要在大饭店参加过会议的人就会跟你说这么一句：  “你是搞计算机的，不是吗？”
基本上等同于酒店鸡尾酒会女招待嘴里的“瞧，粘土人还能动呢！’’
- Elizabeth Zwicky
Ken Arnold是创造4BSD Unix发布版的成员之一。他编写了最初的curses（3）库，也
是最初的rogue（6）游戏作者之一。他也是Java Reference Manual （Java参考手册）的合作作
者之一，是Java和00技术的头牌专家之一。
Steven M. Bellovin于1979年在北卡罗莱纳大学创造了Usenet（]司Tom Truscott祁Jim
Ellis）。在1982年加入AT＆T贝尔实验室，在那里，他完成了安全领域、密码系统、以
及Unix系统和其它操作系统网络的前沿研究。他是互联网工程任务组的积极成员，以及
美国国家T程院（ National Academy of Engineering）的成员。
    Stuart Feldman是Bell实验室Unix开发组的成员之一。他编写了rnake（1）和f77（1），
他现在是IBM负责计算研究的副总裁。
Jim Gettys laJ Bob Scheifler、Keith Packard -起，是1 980年代晚期X窗口系统的主
要架构者之一。他编写了X库的相当部分，编写了X许可证，以及清晰地指出了“机制
而不是策略“的X设计中心信条。
www.pdf365.com
O  者
496
附录C贡献者
    Steve Johnson编写了yacc（1），并用它编写可移植C编译器（Portable C Compiler，
PCC），从而取代了最初的DMR C编译器，成为后来Unix C编译器的鼻祖。
    Brain Kernighan已经是Unix社区良好风格的最好诠释者。他已经编著或合著了好
几本不可或缺的、关于Unix传统的经典作品，包括《The Practice of Programming（编程
实践）》、《The C Programming Language （C编程语言）》、《The Unix Programming
Environment （Unix编程环境）》。在Bell实验室时，他合作开发了awk（l）语言，并在troff
系列工具的开发中发挥了主要的作用，包括eqn（l）（同Lorinda Cherry合编），pic（l），
以及grap（l） （Jon Bentlev）。
    David Kom编写了Korn shell，在风格上，是几乎所有现代Unix shell设计的先驱。
他创造了UWIN，为被迫使用Windows者设计的Unix模拟器。David也在文件系统和移
植工具的设计研究中有相当成就。
    Mike Lesk是Bell突验室最初Unix研究组的成员之一。除了许多其它的贡献以外，
他还编写了ms宏命令包，tbl（）和refer（l）字处理工具，lex（I）词法分析生成器，以及
UUCP  （Unix-to-Unix copy program）。
    Doug Mcllroy在贝尔实验室领导创造了Unix的研究组，发明了Unix管道。他编写
了spell（1）、diff/l）、sort（】）、join（1）、tr（1）以及其它经典的Unix工具，同时帮助定义了
Unix文档的传统风格。他也在存储分配算法、计算机安全以及数学定理自动证明方面做
出了开拓性的工作。
    Marshall Kirk McKusick实现了4.2BSD快速文件系统，并且是Berkeley Computer
Systems Research Group （CSRG）的计算机机研究科学家，亲历了4.3BSD和4.4BSD的开
发和发布。
    Keith Packard是最初XII代码的主要贡献者。在1999年开始的第二阶段开发中，
Keith重写了X的渲染代码，使其性能更强而体积大幅减少，从而可用于手持电脑和PDA
中。
    Eric S．Raymond自从1982年就一直在编写Unix软件；在1991年，编辑了《The New
Hacker's Dictionary（新黑客字典）》，并一直从历史和人类学角度研究Unix社区和互联网
黑客文化。在1997年，这个研究产生了《The Cathedral and the Bazaar（大教堂和集市）》，
帮助定义（或重新定义）和激发了开源运动。他现在维护着三十多个开源软件项目以及
十几个关键的FAQ文档。
www.pdf365.com
附录C贡献者
497
    Henry Spencer是1970年代Unix走出Bell实验室时第一次拥抱Unix浪潮中程序员
的领袖。他的贡献包括公共域的getopt（3），第一款开源的字符串处理函数库，以及使用
在4.4BSD、后来作为POSIX标准参考的开源正则表达式引擎。他也是著名的C语言专
家。他是C News的合作者，而且多年来都一直是Usenet的理性之声以及最受尊敬的老
常客。
Ken Thompson发明了Unix。
UNIX编程艺：术
  www.pdf365.com
www.pdf365.com
附录D
无根的根：无名师的Unix心传
Rootless Root: The Unix Koans of
Master Foo
编者导言
    《无根的根》这部心传的收录集在西山纯净的空气中得以保存数十年，它的发现在
学术圈中掀起轩然大波。这些出土文稿是否为早期Unix教义的新发现？抑或仅是后世高
明的赝品？那些半神秘的人物，像尊者Thompson、Ritchie和Mcllroy，是否以此发展出
我们所处时代的教义？
    答案无法确知。各方争论均被收入那本经典之作，  《编程之道》（The Tao of
Programming）.1但是《无根的根》在论调风格上都与那本James松散诗化的逸闻译作有显
著差异，所有一切都围绕着卓越而谜…般的无名师。
1  The Tao of Programming可查看网页<http：／/www．canonical．org/-kragen/tao-of -
programming．ht ml>.
UNIX编程艺：术
  www.pdf365.com
500
附录D无根的根：无名师的Unix心传
    把AI Koans（AI心传）与之相提并论颇为恰当；2在AI Koans中也可发现《无根的根》
作者的着笔痕迹。它和Loginataka（箴言剧）也有密切关联：3实际上，  《无根的根》和
Loginataka大有可能是出自一人之手笔，此人正是无名师。
    Tales of Zen Master Greg（禅祖Greg传说）也值得～说，4对“九寸钉”的引用已经使
人对其古老程度产生怀疑，它对《无根的根》影响微乎其微。
    毫无疑问，可以认为标题借鉴了Mumon的禅宗经典读物5《无门之门》（The Gateless
Gate）。数个心传都可看作是对Mumon的回应。
    无名师应该归于东派（New Jersey）还是西派（尊者Thompson往Berkeley的划时代之
旅）。如果不能回答这个问题，我们甚至也许无法宣称无名师确实存在。它也许只是一群
教师，也许是一批达摩尊者。
    即使把无名师的传说附会在单独的人身上，那他最看重的学生Nubi怎么办？Nubi
是个有血有肉的形象，是个完美的门徒。也许有人会想起佛祖最喜爱的追随者阿难达的
传说，但他的性格特质在神话传说中并没留下痕迹，而佛祖也是永恒的谜。
    最络，我们可做的便是讲述故事的本原，抽丝剥茧，挖掘其中真意。
    《无根的根》还在编写之中，素材的整理和解释都是难题。难题解开后，将被收录
到未来版本中。
2  AIKoans  可  查  看  网  页  <ht tp：／／www．catb. org/-esr/j argon/html/Some-AI
-Koans．html>.
3 The Loginataka可查看网页<http：／/www．catb. org/-esr/faqs/loginataka．html>.
4 Tales of Zen Master Greg可查看网页<http：／／www - gu．uwa．edu．au/users/greg/>．
5'IheGateless  Gate  可查看网页<hLtp：／／www．ibibli。，。rg/ zen/cgi-bin/koan
-index．pl>.
www.pdf365.com
附录D无根的根：无名师的Unix心传
501
无名师与万行码
无名师曾对来访的程序员说：“Unix传统上认为，一行shell脚本胜过万行C程序。”
这个程序员自以为对C极其精通，说：  “这不可能。Unix内核正是用C实现的。”
    无名师回道：  “确是如此。不过，Unix传统上认为，一行shell脚本胜过万行C程
序。”
    程序员颇为沮丧：“但是在C中我们可领会到尊者Ritchie的智慧。我们与操作系统
和机器合而为一，可以获取无与伦比的性能。”
    无名师回道：  “诚如你言。不过，Unix传统上认为，一行shell脚本胜过万行C程
序。”
    程序员冷笑着想愤然离去。无名师向学生Nubi颔首示意，Nubi在黑板上写下一行
shell脚本，问道：“尊敬的程序员，看看这行管道。用纯C实现，是不是要一万行C代
码？”
    程序员沉吟念诵。最终他承认如此。
    “你需要多长时间来实现和调试那个C程序？”Nubi问道。
    “很长”，来访程序员承认。“但傻子才会干这个而不去完成更有价值的任务。”
    “那么谁更了解Unix传统？”无名师问道。“是写一万行代码的，还是看到任务的
无谓而不去编码的？’’
    听到此，程序员眼中一亮。
UNIX编程艺术
  www.pdf365.com
502
附录D无根的根：无名师的Unix心传
无名师与脚本狂
    无名师和学生吃早饭时，从黑客大陆来了个陌生访客。
    “I hear y00 are very l33t，”他说。“PI33z teach m3 all y00 know”。（我听说你很牛，
请把你会的都教给我。）
    无名师的学生面面相觑，都没听懂这类粗鄙言语。无名师微笑道：“你想弄懂Unix?”
    “1 want to b3 a wizard haxOr"，陌生人回答，  ‘‘and Own ever30ne's bOxen。”（我想
当个顶尖黑客，能掌握所有人的机器。）
    “我不教这个’’，无名师答道。
    陌生人很激动。“DOOd，y00 r nothing but a pOser”，他说。“If y00 n00 anything，y00
wud t33ch m3。”（哥们儿，敢情你没真本事啊，你要知道点儿东西就教给我了。）
    “有条路，”无名师说，  “可以将你带入真知。’’他在纸上写了个IP地址。“黑掉
这台机器，这对你来说应该不费什么力气，它的管理员不称职。回来后告诉我你发现了
什么。”
    陌生人鞠了一躬就离开了。无名师把他的早饭吃完。
    几天过去了，几个月过去了。没人再想起陌生人。
    数年过去了，黑客大陆来的陌生人回来了。
    “你混蟹！”他说，  “我黑掉了那台机器，你说的没错，太容易了。但是我被FBI
抓起来扔进监狱了。”
    “好”，无名师说，“你可以继续下一课了。”他在另一张纸上写了个IP地址交给
陌生人。
    “你疯了？”陌生人喊道。  “经过这事，我再也不黑别人的机器了。”
    无名师脸现微笑。“这里就是”，他说，  “真知的开始。”
    听到此，陌生人眼中一亮。
www.pdf365.com
附录D无根的根：无名师的Unix心传
503
无名师的双路论
    无名师如是教导学生：
    “达摩教义有条准线，这在尊者Mcllroy的符咒“做一件事并做好”中得到体现。
它强调软件应当具有简单一致的行为，这符合Unix惯例，人和其它程序便都很容易想象
其心理模型。
    “但达摩教义还有另一条准线，体现在尊者Thompson的符咒“有怀疑，用穷举’’
中，很多经文都教导我们现在得到的90%，比等不来的100%更有价值。它强调实现的健
壮性和简单性。
    “现在告诉我：什么程序符合Unix传统？”
    想了一会儿后，Nubi沉思道：
    “老师，这些教义有冲突。”
    “简单的实现往往对边缘情况有欠考虑，比如资源耗竭、无法关闭竞争窗口以及在
未完成事务中超时等等。”
    “发生边缘情况时，软件行为往往不规律、难以猜测。这当然不是Unix传统。”
    无名师颔首同意。
    “另一方面，大家都知道精巧的程序很脆弱。更进一步说，每个对边缘情况的修正
往往牵扯到程序的核心算法，还牵扯处理其它边缘情况的代码。”
    “于是，对边缘情况防患于未然、确保描述的简单性，反而会使得代码过分复杂、
bug成堆、根本无法发售。这当然不是Unix传统。”
    无名师颔首同意。
    “那么，什么是正确的达库道？”Nubi问道。
UNI×编程艺．术
  www.pdf365.com
504
附录D无根的根：无名师的Unix心传
    无名师说：
    “当鹰飞翔时，它忘记爪子与地面相触？当虎捕食时，它忘记腾空的一刻？VAX只
重三斤！”
    听到此，Nubi眼中一亮。
www.pdf365.com
附录D无根的根：无名师的Unix心传
505
无名师与方法论
道。
无名师和学生Nubi在圣地行走，无名师习惯在晚间为城市和乡村的Unix新门徒布
一次，聆听者中混入了一名方法论者。
    “优化程序时不对热点进行反复衡量，就像渔夫把网撒入空湖中。”无名师说。
    “那么，”方法论者说，  “管理资源时不持续地衡量你的产能，不也像渔夫将网撒
入空湖中么？”
    “我一次碰到一个渔夫时，他正将网撒入船下的湖中，”无名师说，  “他摸了好一
会儿船底，像在寻找他的船。”
    “但是，’’方法论者说，  “如果他把网撒入湖中，为什么还要找船呢？”
    “因为他不会游泳。”无名师答道。
    听到此，方法论者眼中一亮。
UNIX编I程艺．术
www.pdf365.com
506
附录D无根的根：无名师的Unix心传
无名师的GUI论
    一晚，无名师和Nubi参加一个程序员的探讨会。有个程序员问Nubi和他的老师来
自哪所学校。当得知他们是Unix大道的追随者时，程序员颇为不屑。
    “Unix命令行工具太粗糙太落后”，他讥讽道。“现代的、设计得当的操作系统可
以在图形用户界面中做任何事情。”
    无名师一言不发，只是指着月亮。旁边的一条狗对着他的手狂吠。
    “我不明白。”程序员说。
  无名师依然缄默，指着一幅佛祖像，然后又指着一扇窗。
  “你想说什么？”程序员问。
  无名师指着程序员的头，接着指着一块大石。
  “请把话说清楚！’’程序员要求道。
  无名师深深蹙眉，轻拍程序员的鼻子两下，把他扔到旁边的垃圾箱中。
  程序员试图从垃圾堆挣扎出来之时，那条狗跑过来在他身上便溺。
  此时，程序员H艮中一亮。
www.pdf365.com
附录D无根的根：无名师的Unix心传
507
无名师与Unix狂
…个Unix狂热者听说无名师掌握Unix大道真知，便跑来求教。无名师对他说：
    “当尊者Thompson发明Unix时，他并不理解它。随后他理解了，受益了，不再发
明了。”
    “当尊者Mcllroy发明管道时，他只知道它将传递软件，并不知道它能传播思想。”
    “当尊者Ritchie发明C时，他将程序员放到缓冲溢出、堆损坏和烂指针bug的地域
中惩罚。”
    “说实话，这些尊者既瞎又蠢！”
    狂热者对无名师的用词极为愤怒。
    “这些智者”，他抗议道，“给了我们Uriix的大道。我们嘲笑他们，就是混淆是非，
比转世为牲畜和MCSE还不如。”
    “你的代码全无污点和缺陷？”无名师问。
    “不，”狂热者承认，  “没人不犯错。”
    “这些尊者之智，’’无名师说，  “就是J，解自身之愚。”
    听到此，狂热者眼中一亮。
UNIX编}程艺术
  www.pdf365.com
508
附录D无根的根：无名师的Unix心传
无名师的Unix传统论
一学生对无名师说：  “我们听说SCO公司把握着纯正的Unix。”
无名师领首。
学生继续说，  “我们还听说OpenGroup公司也把握着纯正的Unix。
无名师颔首。
“这怎么可能？”学生问。
无名师答道：
    “SCO确实把握着Unix源码，但是Unix的源码不是Unix。OpenGroup确实把握着
Unix的名称，但Unix的名称不是Unix。’’
“那么，什么是Unix传统？”学生问。
无名师答道：
“非源码。非名称。非思想。非实物。恒变，不变。”
“Unix传统是简单和空。正是简单，正是空，才使得它更强胜飓风。
    “以自然法则前行，‘在程序员手中，吸纳各种优良设计。与之竞争的软件最终必与
之相像；空，空，真空，虚无，万岁！’’
    听到此，学生眼中一亮。
www.pdf365.com
附录D无根的根：无名师的Unix心传
509
无名师与最终用户
    无名师又一次布道时，一个最终用户听说了他的智慧，跑来求教。
    他对无名师三鞠躬。“我欲学习Unix大道，”他说，  “但是弄不懂命令行。”
    一个旁观的新门徒开始嘲讽最终用户，说他脑子一锅粥，说只有经训练者、有智慧
者才配使用Unix。
    无名师抚手不语，命这个嘲笑最终用户的新门徒前坐，坐到最终用户身边。
    “告诉我，”他对新门徒说，  “你写过什么代码，有过什么突出设计。”
    新门徒嗫嚅了两句，然后沉默了。
    无名师转向最终用户。“告诉我”，他问，  “为何你要寻求大道？”
    “我用的软件并不能令我满意”，最终用户答，  “既不稳定，也不美观。听说Unix
之道尽管艰难，但超越一切，我愿抛去～切诱饵和虚像。”
    “那么，”无名师问，  “你为何想尽办法让软件帮你做事？”
    “我是个建筑工”，最终用户答道，  “这座城里的很多房屋都出自我手。”
    无名师转向新门徒。“家猫也能欺负老虎”，无名师说，  “但是猫叫永远比不过虎
吼。”
    听到此，新门徒眼中一亮。


    大多数译序是给作者说好话，顺便带动一下译本销量的，本篇是一个例外。
    《The  Art of UNIX Programming》，简称TAOUP，作者Eric S．Raymond，简称ESR。
这大概是计算机类书籍中很少见的一本课外读物。TCP/IP编程之类典型Unix编程书中
讲到的东西在这本书里面找不到，所以书里讲到的当然就是别的书里找不到的东西。读
者也许需要有相当的Unix背景、或者长期钻研某个专题，才能体会到作者的弦外之音。
ESR作为老牌黑客信手拈来的典故，如果不是在Unix里面长期浸淫，大概很难有所共鸣，
所以把这当作Unix的一部坊问史话倒也合适。
    本书总结了历史上Unix众多成功的经验和失败的教训、经时问考验和临时搭救的编
码策略、大众喜爱和小众受用的实用工具：一些被跨国界信仰地广泛接受，一些则在不
rIIJ环境中各有见地。被TAOUP总结为失败的，也许恰恰是某些工程的保命神药：总结
为成功的，也许正好是压垮另一些工程的最后一根稻草。情景各异而已。书是写给程序
员看的，因此很多观点都太过技术昧儿，比如所见即所得的编辑器不如手写标记的纯文
本更直接-90%的人会想：这怎么可能？！
    这本书是给读者增长见讽的，很多案例分析不管结论如何，读者都可以从中见到红
蓝两方的思维方式和行事方法，以及各方高手看待问题的角度。无论成功还是失败，都
只是一念之间，而读者只需要体味出这些对自己过去的、手头的、未来的项目可以有何
种借鉴，便已得其中三昧。
    网络上关于TAOUP的书评甚多，正负反响各有不少，负面评价大体集中在认为作
者视角较窄、对商业公司有偏见以及过分抬爱自己的fetchmail几方面。我个人的感觉，
Unix、尤其是开源Unix上有太多好用的丁具极欠雕琢，目标受众太过技术。ESR并未回
避这些，读者不妨多留意为数不多的痛切之笔。
UNIX编程艺_术
  www.pdf365.com
译序
    本书翻译经历～年多的时间，之前我曾经约略翻过纸版，偶尔见到一些合我胃口的
言论，于是心有灵犀认为这书不错；然而等到译到中途，便发现ESR实在是个美国愤青，
这便是课外读物和工本教程给读者的不同感受了。翻译的过程对译者是精读的过程，但
希望读者能用它打发堵车、候机、等人时的无聊时间，这书适合从任何一篇翻起。
    翻译过程颇为艰辛：何蔡两位初译，由我统稿。书中寻章摘句之处，我们尽力将其
还原。书名保持原文并给出译名，人名不译，专有名词给出原文，特意不加入任何译注。
相关背景常识、翻译感受以及付梓后的任何问题，可以在中译版网页上与我们交流。这
一年间，侯捷老师的推荐，周筠老师、方舟和兴璐两位编辑、何蔡二位给我的莫大帮助
和宽容使得本书最终面世；身边诸位好友同事也不同程度地在各个技术方面给予指导和
支持，尤其感谢bz、主任、delphij、kola几位。我的爱人王冰陪我加班，容忍我对程序
的沉迷，给我心灵的温暖，是我翻译这本书的力量源泉。
    KISS。
    姜  宏
2005年12月于北京
www.pdf365.com
序
Preface
Unix is not so much an operating system as an oral history.
与其说Unix是个操作系统，不如说是一部口述历史。
    -NeaJ Stephenson
    知识和专能差异巨大，凭借知识可以推断出该做什么，而专能让你甚至在无意之间，
条件反射似的把事情做好。
    这本书确实有关“知识”，但更着眼于“专能’’。你将学到那些Unix专家们都不自
知的Unix开发知识。少一点技术，多一些共享文化：显见和隐微的，直观和潜流的――
这是本书和大多数Unix书籍不同的地方――不止于方法，更重乎理念。
    理念于实用大有裨益，有太多设计不良的软件：体积臃肿，难于维护、移植和扩展
――这些都是蹩脚设计的症候。我们希望本书的读者能品出什么是Unix所教示的良好设
计。
    本书分为四部分：场景、设计、工具和社群。第一部分（场景）涉及哲学和历史，
为后续内容埋下伏笔。第二部分（设计）将Unix哲学的原理细分为有关设计与实现的、
更专门的建议。第三部分（工具）着眼于Unix所提供的工具，可助你解决问题。第四部
分（社群）则讲述人与人之间的事务与约定，而这正是Unix文化拥有高效能的原因。
    这本书是关于共享文他的，我从未想像过独自完成它。你会发现正剧中包含数位Unix
资深专家的客串演出，正是这些人塑造了Unix的习俗。本书曾有过公开大范围的审阅过
UNIX编腥艺．术
  www.pdf365.com
序
程，这期间我邀请这些明星人士对书稿进行评审与研论。这些意见没有湮没在本书定稿
中，而你可以在书中聆听到他们的真实声音：无论是为本书呐喊助阵、还是摇头反对。
    本书中用到人称“我们”时，我并不是虚张声势，仅以此说明这是整个社群都清楚
明了的事实。
    因为本书着力传递文化，因此加入了很多野史和坊间传说，这在技术书中并不多见。
希望你喜欢，这些东西其实是Unix程序员的教养。须弥不重，芥子不轻。我们希望以这
种方式更好地讲述故事。了解Unix的由来和变迁，会培养你对Unix风格的直觉。
    同样地，基于此，我们不打算使用回述历史的腔调。你会发现本书参考了众多时下
信息。我们不希望给你一种错觉：书里说的都是亘古不变的终极真理。参考时下的信息
这一做法，也提醒读者，三十年河东，三十年河西，眼前所见，也许过不了多久就会过
时，而需要重新检省。
    另外，本书不是C教程，不是Unix命令和API的手册，不是sed/yacc/Perl/Python
的语言参考，也不是网络编程入门，更不是巨细靡遗的令人费解的X指南。本书也不打
算带你巡游Unix内幕和体系。有很多其它的好书涵盖这些领域，本书会在适当的时候告
诉你该看哪些。
    在这些技术细节外．Unix文化有一个未见诸笔端的行工传统，以熟练工的考量，它
已经有几百万人年的发展1。本书即立足于这样一个信念：领会此传统，并将它的设计手
法应用到手边，你将成为更好的程序员和设计师。
    构成文化的是人，一直以来，获知文化的方式大约是口口相传、潜移默化。本书不
打算取代人际的文化传播，但可以促进这一过程，使你能俯耳倾听他人的心声。
1从1969到2003年，35年时间可不算短。以这期间Unix站点数量的年度曲线计算，人们在Unix
上耕作了约有5000万人年。
www.pdf365.com
序
谁应该看这本书
    如果你是个Unix编程老手，经常教导菜鸟，或者与人进行操作系统论战时无法阐明
使用Unix方案所带来的好处时，可以看看这本书。
    如果你是个C、C++或者Java程序员，有其它操作系统的开发经验，现在轮到你开
展一个Unix项目时，可以看看这本书。
    如果你是个初级或者中级水平的Unix用户，但是没什么开发经验，想学习在Unix
下如何高效地设计软件时，可以看看这本书。
    如果你不在Unix下编程却发觉Unix的传统给你带来某种启迪，那你就对了，Unix
哲学适用于其它的操作系统。因此我们会花比其它Unix书籍更多的篇幅关注非Unix环
境（特别是微软的操作系统）；当所用到工具或者案例可用于其它操作系统时，我们会
告诉你。
    如果你是一个系统架构师，正为通用市场或垂直应用准备平台方案或实现策略时可
以看看这本书。本书将帮助你了解Unix作为开发平台的强大功能，以及开放源码这个
Unix的传统所带来的开发方式。
    如果你想学到C编程的细节或者想知道怎么用Unix内核API，本书可能不适合你。
Advanced Programming in theUnix Envirortment[Stevens921是探究Unix API妁经典名著；
The Practice of Programming [Kernighan-Pike99]是每个C程序员的必读书目（任何语言的
程序员都该看看这本书）。
    这本书既重实践，更富理念：既包含警世格言，又不忘检点Unix开发中的特殊案例。
在每个警句前后，都有生动实例阐明其由来，这些例子绝不来自小儿科式的示例程序，
而均出自真实世界满眼所见的运行代码。
    我们着力避免以大量代码或者规范文件来胡乱凑数，当然这么做会让本书的写作轻
松许多（某些地方或许读起来也更轻松）。绝大多数编程书籍只授你以鱼，而本书避免
这种做法，力求培养读者“探求事情何以如此，，的感知力。
UN/X编腥艺：术
  www.pdf365.com
l∈j
坐咀
    正由于此，本书会时常请你阅读代码与规范文档，它们中极少量的内容会附在书中，
其余部分我们会在举例时告诉你如何从网上获取。
    从这些范例中汲取养分，将有助你将所学原则消化变为疱丁之技。如果你能就着一
部跑在Unix系统上的网页浏览器来读书，是再理想不过的了。任何Unix系统都适合，
但是我们将要研究的案例大多都会预装在、或者可以从Linux系统上获得，书中会提示
请你浏览或亲身感受它们。这些提示通常是按部就班的，跑开玩一会儿并不会打散整个
讲述过程的连续性。
    注意：我们虽力求，但无法给你打保票，声称我们所引用的URLs稳定可用。如果
你发现某个引用连接已陈旧过时，来点常识，用你喜爱的搜索引擎来个短语搜索。如有
可能，我们会在所引用的URLs附近给出如何搜索的提示。
    大多数缩写形式会在首次出现时伴随其全称。为方便起见，我们在附录中提供了名
词对照表。
    交叉索引通常以作者名字为主导词。带编号的脚注是那些可能会扰乱你阅读正文，
或者是易变的URLs;也可能是旁征博引的战争故事或者笑话2。
    为了使这本书不至于让非技术人员太过难读，我们邀请了一些非程序员试读，并指
出一些晦涩但起贯穿作用的词汇。我们把那些编程老手不太舍需要的名词解释也放在脚
注中。
相关引文
    一些Unix早期拓荒者的著名论文和书籍，比如Kernighan和Pike的《The Unix
Programming Environment》[Kemighan-Pike84]就是其中佼佼者，被世人尊为圭臬。而今
看来此书廉颇老矣，它没提到Intemet、万维网以及诸如Perl、Tcl和Python这些解释型
语言的新秀。
    写作本书的中途我们借鉴了Mike Gancarz的《The Unix Philosophy》 [Gancarz]。这
本书在它的覆盖范围内极其优秀，但是我们觉得需要更多内容才能反映出事情的全貌。
尽管如此我们仍对此书作者心存感激，他愈发使我们知道最简单的Unix设计手法就是最
持久耐用的。
2这个特别的脚注献给Terry Pratchett，他对脚注的用法简直是……绝了。
www.pdf365.com
l同
坐咀
《The Pragmatic Programmer》fHunt-Thomas]是一本关于良好设计的书，文风机智诙
谐，它与本书相比，倾向于软件设计工艺的另一个层面（更注重编码，而少着墨于高层
面的问题划分）。作者的哲学是其Unix领域耕耘的成果，也是本书内容极好的补充。
《The Practice of Programming》[Kernighan-Pike99]包含了一些与《The Pragmatic
Programmer》共通的内容，但更钻入Unix传统的深处。
    最后（明知道会激怒你），我们推荐《Zen Flesh，Zen Bones》 [Reps-Senzaki]，一部
重要的佛教禅宗本源的合集。对禅的引用书目遍布全书。我们将这些书目包含进来，是
因为禅为表达某种想法提供了丰富的语汇，而在软件设计中却很难烂熟于心。信奉宗教
的读者，请您不要把禅当成宗教，它是一种心灵鸡汤似的东西，纯净而没有神灵的干扰
――此即是禅。
本书的习俗约定
    术语“UNIX’’技术上和法律上讲，是The Open Group的商标，并且应该仅限于那
些通过The Open Group严格的“符合标准”认证的操作系统。奉书中我们使用其较宽松
的定义，印大多数程序员所指的，Bell实验室Unix代码的后裔或旁支。在这个意义下，
Linux（大多数例子都举自它）也算是一种Unix。
    本书也使用了Unix手册页（manual page）的传统，即以括号括起来的手册节号来标
记Unix设施。通常用于强调一个Unix命令首次出现。比如“munger（l）”可解读为“munger
程序加入存在于你的系统中，其文档位于Unix手册页的第1节”。第2节是C的系统调
用，第3节是c的库函数调用，第5节是文件格式与协议，第8节是系统管理工具。其
它节号本书未曾用到，其定义在各个Unix系统各有不同。在你的Unix外壳提示符下输
入man l man（老式的System VUnix系统可能要输入man -s l man）以获得更多信
息。
    有时我们会提及某个Unix程序（比如Emacs），后面没有手册节号而且首字母大写。
这意味这个名字代表一族Unix程序，其基本功能相同，而我们将讨论其通用特性。比如
Emacs，就包含了xemacs。
    本书很多地方我们同时给出了老式（old school）和新式（new school）解法。new-school
和rap音乐～样，开始于1990年前后。在这个含叉下，我们往往把它与脚本语言、图形
UNIX编喱；艺术
    www.pdf365.com
序
用户界面、开放源码的Unix和万维网联系起来。Old-school指代1990年以前（特别是
1985年以前）的世界：昂贵的共用计算机、专属的Unix，shell脚本和无所不在的C。值
得指出这些差异，机器越来越便宜，内存多了起来，这些有如暗流，渐渐影响着Unix编
程的风格。
所用案例
    很多编程书籍为证明某一观点而特地造出一个范例，你手中这本书不这么干。我们
的案例研究均来自真实世界，在生产环境中工作已久。下面是一些主要案例：
cdrtools/xcdroast
    这两个独立的项目通常被～并使用。cdrtools是一组刻盘工具（用关键字“cdrtools”
可以在网上找到）。xcdroast是cdrtools的图型界面前端，其项目网站为
<ht tp:／/www. xcdroast. org/>。
f etclunail
  fetchmail用于从远程邮件服务器上收信，支持POP3和IMAP邮箱协议。其主页为
<ht tp：／／www．catb．org/-esr/fetchmail>，也可以用关键字“fetchmail从网上
找到。
G工MP
    GIMP（GNU Image Manipulation Program，GNU图像处理程庠）是一个全特性的绘
画和图像处理程序，可对多种图像格式进行复杂处理。其源码可从GIMP主页
<http：／/www．gimp．org/>获得（也可以通过关键字“GIMP"从网上搜到）。
mutt
    mutt邮件客户端是目前各类基于文本的邮件客户端程序中的翘楚，提供对MIME
（Multipurpose Intemet Mail Extensions）、个人隐私辅助程序，如PGP（ Pretty Good Privacy）
和GPG （GNU Privacy Guard）等特性的绝佳支持。其源码和二进制可执行文件可以从
Mutt项目主页<http：／/www．mut七．org>获得。
xmlto
xmlto可将DocBook和其它XML文档以多种格式渲染输出，包括HTML、纯文本
www.pdf365.com
序
和PostScript。其源码和文档可在xmlto主页<http：／／cyberelk．net／tim/xmlto／>获得。
    为了将读者理解本书例子所要阅读的代码量降低到最小程度，我们尽量挑选那些可
重复使用、并能体现多种不同设计原理和设计实践的案例。出于同样原因，很多示例来
自于我本人的项目。我没想说这些例子最为恰当，只是我觉得它们对阐述我的观点非常
有用。
作者致谢
    各位客串贡献者（Ken Amold，Sreven M. Bellovin，Stuari Feldman，Jim Gettys，Steve
Johnson， Brian Kernighan， David Korn， Mike Lesk， Doug Mcllroy， Marshall Kirk McKusick，
Keith Packard， Henry Spencer，和Ken Thompson）为本书增添极大价值。特别是Doug
Mcllroy，给予本书恪尽职责、鞭辟入里的评注的同时，也展现了他早在30年前管理最
原始的Unix研究组时鞠躬尽瘁的高风亮节。
    我要对Rob Landley和我的妻子Catherine Raymond致以特别感谢，他们都不厌其烦
地逐行对本书手稿进行审阅，Rob的深富洞察力的细致评述激励我在最终稿中加入了一
整章内容，他为本书的组织结构与取材范围奉献极多。如果把他所给予的改进意见落在
笔端，那他无愧于本书的合著者。Cathy代表读者中非技术人员的一群，如果那些非程序
员读者觉得本书并不难读，那全是她的功劳。
    写作的五年间，本书从不少人的讨论意见中获益良多。Mark M. Miller使我对线程有
了更深的认识o  John Cowan教给我不少接口设计方式，并起草了wily和VNVCMS的学
习案例o Jef Raskin告诉我Rule of Least Surprise的由来。UIUC System Architecture Group
对前几章给出的反馈弥足珍贵，What Unix Gets Wrong和Flexibility in Depth两节是他们
直接激励的结果。Russell J．Nelson提供了Bemstein chaining的素材。第3章中MVS学
习案例大部分的材料来自Jay Maynard。Les Hatton对语言一章给出很多有益建议，并促
使我写成第4章中Optimal Module Size的部分内容。David A．Wheeler贡献了很多发人深
省的批评，以及一些学习案倒（特别是在设计部分中）的素材。Russ Cox帮助我进行了
Plan 9的调查。Dennis Ritchie纠正了我的一些错误的C历史观念。
UNIX编罹艺术
  www.pdf365.com
序
    成百上千的Unix程序员，人数太多以至于无法在此列出他们的名字，在2003年1
月到6月间的公开审阅过程间给了我建议和评论。开放的同级复审这一过程让我觉得紧
张刺激而回报极多。当然，任何最终书稿中残留的错误都是我自己的责任。
    “把事情说透”的风格，以及其它一些考虑因素，是受到了“设计模式运动’’的影
响；说实话，我对到处堆砌Unix设计模式这种做法深不以为然。我对此运动的中心教条
不敢苟同，并且没觉得把设计模式严格付诸实用有什么必要，也不想背上这种思想的包
袱。尽管如此，我的行事方法仍然受到Christopher Alexander成果3（特别是《Timeless Way
of Building》和《A Pattern Language》两文）的影响。Gang of Four和他们的信徒为我展
示了如何用Alexander的思想，站在较高层面上，抛去含混不清的对设计通则的空话，来
谈论软件设计，这一点我心存感激，永志不忘。对设计模式有兴趣的读者可以看看这本
书《Design Pattems:  Elements of Reusable Object-Oriented Software[GangOfFour]》。
    本书标题毫无疑问是偌鉴了Donald Knuth的《The Art of Computer Programming》 -
书的书名。Knuth和Unix传统文化没什么联系，但他影响了我们每一个人。
    有先见之明和丰富想象力的编辑并不多，好在Mark Taub就是一个，他从并不看好
的项目中发现了闪光点，并极富技巧地促成了这奉书的写作。文字编辑中，文笔好而又
能帮助别人提高文笔的就更少了，所幸Mary Lou Nohr是其中之一。Jerry Votta的封面设
计领会了我的意图，而且做得比我的想像还要漂亮。Addison-Wesley的编辑们让审稿和
出版这一过程不再枯燥无味，我天生怕被人管，但是他们仍然极力配合我，使得文字、
版面、图片和市场工作都达到极高水准。
3一篇对Alexander工作成果的肯定文章，包含其部分重要成果的在线连接，可以参考Some Notes

